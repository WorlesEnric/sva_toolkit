[
    {
        "sva": "property p_o_wb_dat_assignment;\n    @(posedge i_clk)\n        start_access == 1 |-> ##1 o_wb_dat == $past(i_write_data);\nendproperty\nassert_p_o_wb_dat_assignment: assert property (p_o_wb_dat_assignment) else $error(\"Assertion failed: o_wb_dat does not match the past value of i_write_data after one clock cycle when start_access is asserted.\");",
        "sva_id": "174_9_1_1"
    },
    {
        "sva": "property p_wbuf_addr_r_assignment;\n    @(posedge i_clk)\n        (wb_wait == 1 && wbuf_busy_r == 0 && (core_write_request == 1 || cache_write_request == 1)) |-> ##1 wbuf_addr_r == $past(i_address);\nendproperty\nassert_p_wbuf_addr_r_assignment: assert property (p_wbuf_addr_r_assignment) else $error(\"Assertion failed: wbuf_addr_r does not match the previous i_address when wb_wait is high, wbuf_busy_r is low, and either core_write_request or cache_write_request is high.\");",
        "sva_id": "174_1_1_1"
    },
    {
        "sva": "property p_read_ack_assignment;\n    @(posedge i_clk)\n        (o_wb_we == 0 && i_wb_ack == 1) |-> (read_ack == (~o_wb_we & i_wb_ack));\nendproperty\nassert_p_read_ack_assignment: assert property (p_read_ack_assignment) else $error(\"Assertion failed: read_ack signal does not reflect the correct state when o_wb_we is 0 and i_wb_ack is 1\");",
        "sva_id": "174_13_1_1"
    },
    {
        "sva": "property p_core_read_request_assignment;\n    @(posedge i_clk)\n        (i_select == 1 && i_write_enable == 0) |-> core_read_request == (i_select == 1 && i_write_enable == 0);\nendproperty\nassert_p_core_read_request_assignment: assert property (p_core_read_request_assignment) else $error(\"Assertion failed: core_read_request does not reflect the correct state when i_select is 1 and i_write_enable is 0\");",
        "sva_id": "174_2_1_1"
    },
    {
        "sva": "property p_cache_read_request_assignment;\n    @(posedge i_clk)\n        (i_cache_req == 1 && i_write_enable == 0) |-> (cache_read_request == 1);\nendproperty\nassert_p_cache_read_request_assignment: assert property (p_cache_read_request_assignment) else $error(\"Assertion failed: cache_read_request signal is not set correctly when i_cache_req is high and i_write_enable is low\");",
        "sva_id": "174_22_1_1"
    },
    {
        "sva": "property p_core_read_request_assignment;\n    @(posedge i_clk)\n        (i_select == 1 && i_write_enable == 0) |-> core_read_request == (i_select == 1 && i_write_enable == 0);\nendproperty\nassert_p_core_read_request_assignment: assert property (p_core_read_request_assignment) else $error(\"Assertion failed: core_read_request does not match the expected condition when i_select is 1 and i_write_enable is 0\");",
        "sva_id": "174_20_1_1"
    },
    {
        "sva": "property p_cache_write_request;\n    @(posedge i_clk)\n        (i_cache_req == 1 && i_write_enable == 1) |-> cache_write_request == (i_cache_req == 1 && i_write_enable == 1);\nendproperty\nassert_p_cache_write_request: assert property (p_cache_write_request) else $error(\"Assertion failed: cache_write_request does not correctly reflect the state of i_cache_req and i_write_enable\");",
        "sva_id": "174_23_1_1"
    },
    {
        "sva": "property p_core_write_request_assignment;\n    @(posedge i_clk)\n        (i_select == 1 && i_write_enable == 1) |-> core_write_request == (i_select == 1 && i_write_enable == 1);\nendproperty\nassert_p_core_write_request_assignment: assert property (p_core_write_request_assignment) else $error(\"Assertion failed: core_write_request does not correctly reflect the state of i_select and i_write_enable\");",
        "sva_id": "174_21_1_1"
    },
    {
        "sva": "property p_shift_counter_initialization;\n    @(posedge clk2M) disable iff (reset==0)\n        reset == 1 |-> ##1 shift_counter == 5'b0;\nendproperty\nassert_p_shift_counter_initialization: assert property (p_shift_counter_initialization) else $error(\"Assertion failed: shift_counter is not initialized to 5'b0 one cycle after reset is asserted\");",
        "sva_id": "51_11_1_1"
    },
    {
        "sva": "property p_byte_enable_assignment;\n    @(posedge i_clk)\n        wbuf_busy_r == 1 |-> byte_enable == wbuf_sel_r;\nendproperty\nassert_p_byte_enable_assignment: assert property (p_byte_enable_assignment) else $error(\"Assertion failed: byte_enable does not match wbuf_sel_r when wbuf_busy_r is asserted\");",
        "sva_id": "174_25_1_1"
    },
    {
        "sva": "property p_o_stall_assignment;\n    @(posedge i_clk)\n        (core_read_request == 1 && read_ack == 0) |-> (o_stall == 1);\nendproperty\nassert_p_o_stall_assignment: assert property (p_o_stall_assignment) else $error(\"Assertion failed: o_stall should be 1 when core_read_request is 1 and read_ack is 0\");",
        "sva_id": "174_15_1_1"
    },
    {
        "sva": "property p_gap_sc_value_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        speed[0] == 1 |-> gap_sc_value == 9'd59;\nendproperty\nassert_p_gap_sc_value_assignment: assert property (p_gap_sc_value_assignment) else $error(\"Assertion failed: gap_sc_value is not assigned the value 59 when speed[0] is 1 at the rising edge of clk2M\");",
        "sva_id": "51_16_1_1"
    },
    {
        "sva": "property p_read_ack_assignment;\n    @(posedge i_clk)\n        (o_wb_we == 0 && i_wb_ack == 1) |-> (read_ack == (~o_wb_we & i_wb_ack));\nendproperty\nassert_p_read_ack_assignment: assert property (p_read_ack_assignment) else $error(\"Assertion failed: read_ack signal does not reflect the correct state when o_wb_we is 0 and i_wb_ack is 1\");",
        "sva_id": "174_19_1_1"
    },
    {
        "sva": "property p_aandb_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        (a429_in_a == 1 && a429_in_b == 1) |-> (aandb == (a429_in_a & a429_in_b));\nendproperty\nassert_p_aandb_assignment: assert property (p_aandb_assignment) else $error(\"Assertion failed: aandb signal does not reflect the correct state when both a429_in_a and a429_in_b are 1\");",
        "sva_id": "51_5_1_1"
    },
    {
        "sva": "property p_data_reset_assignment;\n    @(posedge clk2M) disable iff (reset == 0)\n        reset == 1 |-> ##1 data == 32'b0;\nendproperty\nassert_p_data_reset_assignment: assert property (p_data_reset_assignment) else $error(\"Assertion failed: data is not assigned to 32'b0 one cycle after reset is asserted\");",
        "sva_id": "51_12_1_1"
    },
    {
        "sva": "property p_o_wb_we_assignment;\n    @(posedge i_clk)\n        (wishbone_st == WB_IDLE && start_access == 1 && wbuf_busy_r == 1) |-> ##1 (o_wb_we == 1);\nendproperty\nassert_p_o_wb_we_assignment: assert property (p_o_wb_we_assignment) else $error(\"Assertion failed: o_wb_we signal is not assigned correctly one cycle after the specified conditions are met.\");",
        "sva_id": "174_8_1_1"
    },
    {
        "sva": "property p_aandb_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        (a429_in_a == 1 && a429_in_b == 1) |-> (aandb == (a429_in_a & a429_in_b));\nendproperty\nassert_p_aandb_assignment: assert property (p_aandb_assignment) else $error(\"Assertion failed: aandb signal does not reflect the correct state when both a429_in_a and a429_in_b are 1\");",
        "sva_id": "51_17_1_1"
    },
    {
        "sva": "property p_aorb_prev_reset;\n    @(posedge clk2M) disable iff (reset == 0)\n        (reset == 1) |-> ##1 (aorb_prev == 0);\nendproperty\nassert_p_aorb_prev_reset: assert property (p_aorb_prev_reset) else $error(\"Assertion failed: aorb_prev signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "51_1_1_1"
    },
    {
        "sva": "property p_aorb_prev_reset;\n    @(posedge clk2M) disable iff (reset == 0)\n        reset == 1 |-> ##1 aorb_prev == 0;\nendproperty\nassert_p_aorb_prev_reset: assert property (p_aorb_prev_reset) else $error(\"Assertion failed: aorb_prev is not 0 one cycle after reset is asserted\");",
        "sva_id": "51_13_1_1"
    },
    {
        "sva": "property p_other_sc_value_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        speed[0] == 1 |-> other_sc_value == 9'd19;\nendproperty\nassert_p_other_sc_value_assignment: assert property (p_other_sc_value_assignment) else $error(\"Assertion failed: other_sc_value is not equal to 9'd19 when speed[0] is 1 at the rising edge of clk2M\");",
        "sva_id": "51_15_1_1"
    },
    {
        "sva": "property p_aorb_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        (a429_in_a == 1 && a429_in_b == 0) |-> aorb == 1;\nendproperty\nassert_p_aorb_assignment: assert property (p_aorb_assignment) else $error(\"Assertion failed: aorb signal is not 1 when a429_in_a is 1 and a429_in_b is 0\");",
        "sva_id": "51_18_1_1"
    },
    {
        "sva": "property p_wishbone_st_transition;\n    @(posedge i_clk)\n        (wishbone_st == WB_IDLE && wait_write_ack == 1) |-> ##1 (wishbone_st == WB_WAIT_ACK);\nendproperty\nassert_p_wishbone_st_transition: assert property (p_wishbone_st_transition) else $error(\"Assertion failed: wishbone_st did not transition to WB_WAIT_ACK after WB_IDLE and wait_write_ack == 1\");",
        "sva_id": "174_16_1_1"
    },
    {
        "sva": "property p_wRTD_opc_of;\n    @(posedge gclk) disable iff (grst == 1)\n        opc_of == 6'o55 |-> wRTD == 1;\nendproperty\nassert_p_wRTD_opc_of: assert property (p_wRTD_opc_of) else $error(\"Assertion failed: When opc_of is 6'o55, wRTD should be 1\");",
        "sva_id": "64_1_1_1"
    },
    {
        "sva": "property p_addr_assignment_logic;\n    @(posedge ckmb) disable iff (reset == 1)\n        IO_Addr_Strobe == 1 |-> ##1 addr == { $past(page[3:0]), $past(IO_Address[29:2]) };\nendproperty\nassert_p_addr_assignment_logic: assert property (p_addr_assignment_logic) else $error(\"Assertion failed: addr signal does not reflect the correct state based on the past values of page and IO_Address\");",
        "sva_id": "393_14_1_1"
    },
    {
        "sva": "property p_IO_Ready_rdy2;\n    @(posedge ckmb) disable iff (reset == 1)\n        rdy2 == 1 |-> IO_Ready == (rdy2 == 1);\nendproperty\nassert_p_IO_Ready_rdy2: assert property (p_IO_Ready_rdy2) else $error(\"Assertion failed: IO_Ready signal does not match the state of rdy2 when rdy2 is 1\");",
        "sva_id": "393_12_1_1"
    },
    {
        "sva": "property p_wBNE_not_wBEQ;\n    @(posedge gclk) disable iff (grst == 1)\n        wBEQ == 0 |-> wBNE == 1;\nendproperty\nassert_p_wBNE_not_wBEQ: assert property (p_wBNE_not_wBEQ) else $error(\"Assertion failed: wBNE should be 1 when wBEQ is 0\");",
        "sva_id": "64_7_1_1"
    },
    {
        "sva": "property p_data_reset_logic;\n    @(posedge clk2M) disable iff (reset == 0)\n        reset == 1 |-> ##1 data == 32'b0;\nendproperty\nassert_p_data_reset_logic: assert property (p_data_reset_logic) else $error(\"Assertion failed: data signal is not 32'b0 one cycle after reset is asserted\");",
        "sva_id": "51_7_1_1"
    },
    {
        "sva": "property p_o_wb_cyc_assignment;\n    @(posedge i_clk)\n        (wishbone_st == WB_IDLE && start_access == 1) |-> ##1 (o_wb_cyc == 1);\nendproperty\nassert_p_o_wb_cyc_assignment: assert property (p_o_wb_cyc_assignment) else $error(\"Assertion failed: o_wb_cyc signal is not assigned correctly after starting access in WB_IDLE state\");",
        "sva_id": "174_11_1_1"
    },
    {
        "sva": "property p_wait_write_ack_assignment;\n    @(posedge i_clk)\n        (o_wb_stb == 1 && o_wb_we == 1 && i_wb_ack == 0) |-> (wait_write_ack == (o_wb_stb && o_wb_we && ~i_wb_ack));\nendproperty\nassert_p_wait_write_ack_assignment: assert property (p_wait_write_ack_assignment) else $error(\"Assertion failed: wait_write_ack does not reflect the correct state when o_wb_stb, o_wb_we are high and i_wb_ack is low\");",
        "sva_id": "174_26_1_1"
    },
    {
        "sva": "property p_o_wb_adr_increment;\n    @(posedge i_clk)\n        (wishbone_st == WB_BURST1 && i_wb_ack == 1 && o_wb_adr[3:2] < 1) |-> ##1 o_wb_adr[3:2] == $past(o_wb_adr[3:2]) + 1'd1;\nendproperty\nassert_p_o_wb_adr_increment: assert property (p_o_wb_adr_increment) else $error(\"Assertion failed: o_wb_adr[3:2] did not increment correctly after wishbone_st == WB_BURST1 and i_wb_ack == 1\");",
        "sva_id": "174_6_1_1"
    },
    {
        "sva": "property p_srd_read;\n    @(posedge ckmb) disable iff (reset == 1)\n        read == 1 |-> srd == (read == 1);\nendproperty\nassert_p_srd_read: assert property (p_srd_read) else $error(\"Assertion failed: srd signal does not reflect the correct state when read is asserted\");",
        "sva_id": "393_22_1_1"
    },
    {
        "sva": "property p_IO_Read_Data_rdat;\n    @(posedge ckmb) disable iff (reset == 1)\n        rdat == 8'hA5 |-> IO_Read_Data == rdat;\nendproperty\nassert_p_IO_Read_Data_rdat: assert property (p_IO_Read_Data_rdat) else $error(\"Assertion failed: IO_Read_Data does not match rdat when rdat is 8'hA5\");",
        "sva_id": "393_20_1_1"
    },
    {
        "sva": "property p_wBGE_not_wBLT;\n    @(posedge gclk) disable iff (grst == 1)\n        wBLT == 0 |-> wBGE == 1;\nendproperty\nassert_p_wBGE_not_wBLT: assert property (p_wBGE_not_wBLT) else $error(\"Assertion failed: wBGE should be 1 when wBLT is 0\");",
        "sva_id": "64_8_1_1"
    },
    {
        "sva": "property p_first_sc_value_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        speed[0] == 1 |-> first_sc_value == 9'd4;\nendproperty\nassert_p_first_sc_value_assignment: assert property (p_first_sc_value_assignment) else $error(\"Assertion failed: first_sc_value is not equal to 9'd4 when speed[0] is 1 at the rising edge of clk2M\");",
        "sva_id": "51_14_1_1"
    },
    {
        "sva": "property p_swr_write;\n    @(posedge ckmb) disable iff (reset == 1)\n        write == 1 |-> swr == (write == 1);\nendproperty\nassert_p_swr_write: assert property (p_swr_write) else $error(\"Assertion failed: swr signal does not match the write condition when write is asserted\");",
        "sva_id": "393_23_1_1"
    },
    {
        "sva": "property p_wBLT_opd_of;\n    @(posedge gclk) disable iff (grst == 1)\n        opd_of[31] == 1 |-> wBLT == opd_of[31];\nendproperty\nassert_p_wBLT_opd_of: assert property (p_wBLT_opd_of) else $error(\"Assertion failed: wBLT signal does not match opd_of[31] when opd_of[31] is 1\");",
        "sva_id": "64_5_1_1"
    },
    {
        "sva": "property p_bra_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 bra_ex == 2'h0;\nendproperty\nassert_p_bra_ex_assignment_on_grst: assert property (p_bra_ex_assignment_on_grst) else $error(\"Assertion failed: bra_ex is not assigned to 2'h0 one cycle after grst is asserted\");",
        "sva_id": "64_11_1_1"
    },
    {
        "sva": "property p_o_wdata_assignment_logic;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_wdata == wbuf_wdata_r[wbuf_rp_r];\nendproperty\nassert_p_o_wdata_assignment_logic: assert property (p_o_wdata_assignment_logic) else $error(\"Assertion failed: o_wdata does not match wbuf_wdata_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_12_1_1"
    },
    {
        "sva": "property p_read_assignment_on_reset;\n    @(posedge ckmb) disable iff (reset == 0)\n        reset == 1 |-> ##1 read == 0;\nendproperty\nassert_p_read_assignment_on_reset: assert property (p_read_assignment_on_reset) else $error(\"Assertion failed: read signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_15_1_1"
    },
    {
        "sva": "property p_state_reset_logic;\n    @(posedge clk2M) disable iff (reset == 0)\n        reset == 1 |-> ##1 state == $past(WAITFORGAP);\nendproperty\nassert_p_state_reset_logic: assert property (p_state_reset_logic) else $error(\"Assertion failed: state does not equal the previous value of WAITFORGAP after one cycle when reset is active\");",
        "sva_id": "51_8_1_1"
    },
    {
        "sva": "property p_wBCC_assignment;\n    @(posedge gclk) disable iff (grst)\n        opc_of == 6'o47 |-> wBCC == 1;\nendproperty\nassert_p_wBCC_assignment: assert property (p_wBCC_assignment) else $error(\"Assertion failed: wBCC is not assigned correctly when opc_of is 6'o47\");",
        "sva_id": "64_2_1_1"
    },
    {
        "sva": "property p_wbuf_busy_r_assignment;\n    @(posedge i_clk)\n        (wb_wait == 1 && wbuf_busy_r == 0 && (core_write_request == 1 || cache_write_request == 1)) |-> ##1 wbuf_busy_r == 1;\nendproperty\nassert_p_wbuf_busy_r_assignment: assert property (p_wbuf_busy_r_assignment) else $error(\"Assertion failed: wbuf_busy_r should be assigned to 1 one cycle after wb_wait is 1, wbuf_busy_r is 0, and either core_write_request or cache_write_request is 1\");",
        "sva_id": "174_17_1_1"
    },
    {
        "sva": "property p_wBLE_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (wBLT == 1 && wBEQ == 0) |-> (wBLE == 1);\nendproperty\nassert_p_wBLE_assignment: assert property (p_wBLE_assignment) else $error(\"Assertion failed: wBLE should be 1 when wBLT is 1 and wBEQ is 0\");",
        "sva_id": "64_6_1_1"
    },
    {
        "sva": "property p_start_access_assignment_logic;\n    @(posedge i_clk)\n        (core_read_request == 1 && core_write_request == 0 && i_cache_req == 0 && wb_wait == 0) |-> start_access == 1;\nendproperty\nassert_p_start_access_assignment_logic: assert property (p_start_access_assignment_logic) else $error(\"Assertion failed: start_access signal is not set correctly when core_read_request is 1, core_write_request is 0, i_cache_req is 0, and wb_wait is 0\");",
        "sva_id": "174_18_1_1"
    },
    {
        "sva": "property p_o_be_assignment;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_be == wbuf_be_r[wbuf_rp_r];\nendproperty\nassert_p_o_be_assignment: assert property (p_o_be_assignment) else $error(\"Assertion failed: o_be does not match the expected value from wbuf_be_r at the current read pointer wbuf_rp_r when wbuf_used_r is not zero.\");",
        "sva_id": "175_5_1_1"
    },
    {
        "sva": "property p_bra_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 bra_ex == 2'h0;\nendproperty\nassert_p_bra_ex_reset: assert property (p_bra_ex_reset) else $error(\"Assertion failed: bra_ex signal is not 2'h0 one cycle after grst is 1\");",
        "sva_id": "64_15_1_1"
    },
    {
        "sva": "property p_wBRU_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        opc_of == 6'o46 |-> wBRU == 1;\nendproperty\nassert_p_wBRU_assignment_logic: assert property (p_wBRU_assignment_logic) else $error(\"Assertion failed: When opc_of is 6'o46, wBRU should be 1\");",
        "sva_id": "64_3_1_1"
    },
    {
        "sva": "property p_wbuf_rp_r_pop_operation;\n    @(posedge i_clk)\n        pop == 1 |-> ##1 wbuf_rp_r == !$past(wbuf_rp_r);\nendproperty\nassert_p_wbuf_rp_r_pop_operation: assert property (p_wbuf_rp_r_pop_operation) else $error(\"Assertion failed: wbuf_rp_r signal does not toggle correctly after pop operation\");",
        "sva_id": "175_19_1_1"
    },
    {
        "sva": "property p_o_write_assignment;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_write == wbuf_write_r[wbuf_rp_r];\nendproperty\nassert_p_o_write_assignment: assert property (p_o_write_assignment) else $error(\"Assertion failed: o_write does not match wbuf_write_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_11_1_1"
    },
    {
        "sva": "property p_o_be_assignment_logic;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_be == wbuf_be_r[wbuf_rp_r];\nendproperty\nassert_p_o_be_assignment_logic: assert property (p_o_be_assignment_logic) else $error(\"Assertion failed: o_be does not match wbuf_be_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_13_1_1"
    },
    {
        "sva": "property p_o_rdata_assignment;\n    @(posedge i_clk)\n        i_rdata == 8'hA5 |-> o_rdata == 8'hA5;\nendproperty\nassert_p_o_rdata_assignment: assert property (p_o_rdata_assignment) else $error(\"Assertion failed: o_rdata does not equal 8'hA5 when i_rdata is 8'hA5 at the rising edge of i_clk\");",
        "sva_id": "175_7_1_1"
    },
    {
        "sva": "property p_o_addr_assignment_logic;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_addr == wbuf_addr_r[wbuf_rp_r];\nendproperty\nassert_p_o_addr_assignment_logic: assert property (p_o_addr_assignment_logic) else $error(\"Assertion failed: o_addr does not match the expected value from wbuf_addr_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_14_1_1"
    },
    {
        "sva": "property p_o_ack_assignment;\n    @(posedge i_clk)\n        (in_wreq == 1 && wbuf_used_r == 2'd0) |-> (o_ack == 1);\nendproperty\nassert_p_o_ack_assignment: assert property (p_o_ack_assignment) else $error(\"Assertion failed: o_ack signal is not 1 when in_wreq is 1 and wbuf_used_r is 0\");",
        "sva_id": "175_8_1_1"
    },
    {
        "sva": "property p_o_rdata_i_rdata;\n    @(posedge i_clk)\n        i_rdata == 8'b10101010 |-> o_rdata == 8'b10101010;\nendproperty\nassert_p_o_rdata_i_rdata: assert property (p_o_rdata_i_rdata) else $error(\"Assertion failed: o_rdata does not match the expected value 8'b10101010 when i_rdata is 8'b10101010\");",
        "sva_id": "175_15_1_1"
    },
    {
        "sva": "property p_mask_assignment_logic;\n    @(posedge ckmb) disable iff (reset)\n        IO_Byte_Enable == 4'b1010 |-> mask == ~IO_Byte_Enable;\nendproperty\nassert_p_mask_assignment_logic: assert property (p_mask_assignment_logic) else $error(\"Assertion failed: mask does not correctly reflect the negation of IO_Byte_Enable when IO_Byte_Enable is 4'b1010\");",
        "sva_id": "393_6_1_1"
    },
    {
        "sva": "property p_bra_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 bra_ex == 2'h0;\nendproperty\nassert_p_bra_ex_assignment_on_grst: assert property (p_bra_ex_assignment_on_grst) else $error(\"Assertion failed: bra_ex is not assigned to 2'h0 one cycle after grst is asserted.\");",
        "sva_id": "64_16_1_1"
    },
    {
        "sva": "property p_busy_reading_r_assignment;\n    @(posedge i_clk)\n        (o_valid == 0 && i_rdata_valid == 1) |-> ##1 (busy_reading_r == 0);\nendproperty\nassert_p_busy_reading_r_assignment: assert property (p_busy_reading_r_assignment) else $error(\"Assertion failed: busy_reading_r should be 0 one cycle after o_valid is 0 and i_rdata_valid is 1\");",
        "sva_id": "175_16_1_1"
    },
    {
        "sva": "property p_wbuf_addr_r_assignment;\n    @(posedge i_clk)\n        push == 1 |-> ##1 wbuf_addr_r[$past(wbuf_wp_r)] == $past(i_addr);\nendproperty\nassert_p_wbuf_addr_r_assignment: assert property (p_wbuf_addr_r_assignment) else $error(\"Assertion failed: wbuf_addr_r assignment does not match the expected value based on i_addr\");",
        "sva_id": "175_6_1_1"
    },
    {
        "sva": "property p_wBGT_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        wBLE == 0 |-> wBGT == 1;\nendproperty\nassert_p_wBGT_assignment_logic: assert property (p_wBGT_assignment_logic) else $error(\"Assertion failed: wBGT should be 1 when wBLE is 0 at the rising edge of gclk\");",
        "sva_id": "64_9_1_1"
    },
    {
        "sva": "property p_bra_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 bra_ex == 2'h0;\nendproperty\nassert_p_bra_ex_assignment_on_grst: assert property (p_bra_ex_assignment_on_grst) else $error(\"Assertion failed: bra_ex is not assigned to 2'h0 one cycle after grst is asserted\");",
        "sva_id": "64_14_1_1"
    },
    {
        "sva": "property p_in_wreq_assignment;\n    @(posedge i_clk)\n        (i_req == 1 && i_write == 1) |-> (in_wreq == 1);\nendproperty\nassert_p_in_wreq_assignment: assert property (p_in_wreq_assignment) else $error(\"Assertion failed: in_wreq signal should be 1 when i_req and i_write are both 1 at the rising edge of i_clk\");",
        "sva_id": "175_3_1_1"
    },
    {
        "sva": "property p_o_valid_assignment;\n    @(posedge i_clk)\n        (wbuf_used_r != 2'd0 && wait_rdata_valid_r == 0) |-> (o_valid == 1);\nendproperty\nassert_p_o_valid_assignment: assert property (p_o_valid_assignment) else $error(\"Assertion failed: o_valid signal is not set to 1 when wbuf_used_r is not zero and wait_rdata_valid_r is zero\");",
        "sva_id": "175_9_1_1"
    },
    {
        "sva": "property p_rdy1_reset;\n    @(posedge ckdr) disable iff (reset == 0)\n        reset == 1 |-> ##1 rdy1 == 0;\nendproperty\nassert_p_rdy1_reset: assert property (p_rdy1_reset) else $error(\"Assertion failed: rdy1 signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_3_1_1"
    },
    {
        "sva": "property p_swdat_wdat_assignment;\n    @(posedge ckmb) disable iff (reset == 1)\n        (wdat == 8'hA5) |-> (swdat == 8'hA5);\nendproperty\nassert_p_swdat_wdat_assignment: assert property (p_swdat_wdat_assignment) else $error(\"Assertion failed: swdat signal does not match wdat signal when wdat is 8'hA5\");",
        "sva_id": "393_24_1_1"
    },
    {
        "sva": "property p_wait_rdata_valid_r_assignment;\n    @(posedge i_clk)\n        (o_valid == 1 && o_write == 0 && i_accepted == 1) |-> ##1 (wait_rdata_valid_r == 1);\nendproperty\nassert_p_wait_rdata_valid_r_assignment: assert property (p_wait_rdata_valid_r_assignment) else $error(\"Assertion failed: wait_rdata_valid_r is not set to 1 one cycle after o_valid is 1, o_write is 0, and i_accepted is 1\");",
        "sva_id": "175_10_1_1"
    },
    {
        "sva": "property p_rdat_assignment;\n    @(posedge ckdr) disable iff (reset == 1)\n        (reset == 0 && srdy == 1 && addr[4:2] == 3'b000) |-> ##1 rdat == $past(srdat[31:0]);\nendproperty\nassert_p_rdat_assignment: assert property (p_rdat_assignment) else $error(\"Assertion failed: rdat does not match the past value of srdat[31:0] under the specified conditions\");",
        "sva_id": "393_17_1_1"
    },
    {
        "sva": "property p_o_wb_sel_assignment;\n    @(posedge i_clk)\n        (wishbone_st == WB_IDLE && start_access == 1) |-> ##1 o_wb_sel == $past(byte_enable);\nendproperty\nassert_p_o_wb_sel_assignment: assert property (p_o_wb_sel_assignment) else $error(\"Assertion failed: o_wb_sel does not match the previous cycle's byte_enable when wishbone_st is WB_IDLE and start_access is 1\");",
        "sva_id": "174_7_1_1"
    },
    {
        "sva": "property p_bra_ex_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && wRTD == 1 && wBRU == 0 && wBCC == 0 && xcc == 0) |-> ##1 (bra_ex[1] == 1);\nendproperty\nassert_p_bra_ex_assignment: assert property (p_bra_ex_assignment) else $error(\"Assertion failed: bra_ex[1] is not assigned correctly one cycle after the specified conditions are met\");",
        "sva_id": "64_12_1_1"
    },
    {
        "sva": "property p_wishbone_st_assignment;\n    @(posedge i_clk)\n        (wishbone_st == WB_WAIT_ACK && i_wb_ack == 1) |-> ##1 (wishbone_st == WB_IDLE);\nendproperty\nassert_p_wishbone_st_assignment: assert property (p_wishbone_st_assignment) else $error(\"Assertion failed: wishbone_st did not transition to WB_IDLE one cycle after WB_WAIT_ACK and i_wb_ack == 1\");",
        "sva_id": "174_14_1_1"
    },
    {
        "sva": "property p_first_sc_value_assignment;\n    @(posedge clk2M) disable iff (reset == 1)\n        speed[0] == 1 |-> first_sc_value == 9'd4;\nendproperty\nassert_p_first_sc_value_assignment: assert property (p_first_sc_value_assignment) else $error(\"Assertion failed: first_sc_value is not assigned to 9'd4 when speed[0] is 1 at the rising edge of clk2M\");",
        "sva_id": "51_4_1_1"
    },
    {
        "sva": "property p_in_wreq_assignment;\n    @(posedge i_clk)\n        (i_req == 1 && i_write == 1) |-> in_wreq == (i_req == 1 && i_write == 1);\nendproperty\nassert_p_in_wreq_assignment: assert property (p_in_wreq_assignment) else $error(\"Assertion failed: in_wreq signal does not reflect the correct state when i_req and i_write are both asserted\");",
        "sva_id": "175_22_1_1"
    },
    {
        "sva": "property p_read_reset_logic;\n    @(posedge ckmb) disable iff (reset == 0)\n        reset == 1 |-> ##1 read == 0;\nendproperty\nassert_p_read_reset_logic: assert property (p_read_reset_logic) else $error(\"Assertion failed: read signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_1_1_1"
    },
    {
        "sva": "property p_o_wb_stb_assignment;\n    @(posedge i_clk)\n        (wishbone_st == WB_IDLE && start_access == 1) |-> ##1 (o_wb_stb == 1);\nendproperty\nassert_p_o_wb_stb_assignment: assert property (p_o_wb_stb_assignment) else $error(\"Assertion failed: o_wb_stb is not assigned correctly one cycle after wishbone_st is WB_IDLE and start_access is 1\");",
        "sva_id": "174_12_1_1"
    },
    {
        "sva": "property p_bra_ex_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && wBRU == 1) |-> ##1 bra_ex[0] == $past(ra_of[4]);\nendproperty\nassert_p_bra_ex_assignment: assert property (p_bra_ex_assignment) else $error(\"Assertion failed: bra_ex[0] does not match the past value of ra_of[4] under the specified conditions.\");",
        "sva_id": "64_13_1_1"
    },
    {
        "sva": "property p_wbuf_used_r_retention;\n    @(posedge i_clk)\n        (push == 1 && pop == 1) |-> ##1 wbuf_used_r == $past(wbuf_used_r);\nendproperty\nassert_p_wbuf_used_r_retention: assert property (p_wbuf_used_r_retention) else $error(\"Assertion failed: wbuf_used_r does not retain its value when both push and pop are asserted\");",
        "sva_id": "175_1_1_1"
    },
    {
        "sva": "property p_read_reset_logic;\n    @(posedge ckmb) disable iff (reset == 0)\n        reset == 1 |-> ##1 read == 0;\nendproperty\nassert_p_read_reset_logic: assert property (p_read_reset_logic) else $error(\"Assertion failed: read signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_11_1_1"
    },
    {
        "sva": "property p_xcc_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (rd_of[2:0] == 3'b000 && wBEQ == 1) |-> xcc == 1;\nendproperty\nassert_p_xcc_assignment_logic: assert property (p_xcc_assignment_logic) else $error(\"Assertion failed: xcc signal is not assigned correctly when rd_of[2:0] == 3'b000 and wBEQ == 1\");",
        "sva_id": "64_10_1_1"
    },
    {
        "sva": "property p_read_assignment_on_reset;\n    @(posedge ckmb) disable iff (reset == 0)\n        reset == 1 |-> ##1 read == 0;\nendproperty\nassert_p_read_assignment_on_reset: assert property (p_read_assignment_on_reset) else $error(\"Assertion failed: read signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_2_1_1"
    },
    {
        "sva": "property p_o_write_assignment_logic;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_write == wbuf_write_r[wbuf_rp_r];\nendproperty\nassert_p_o_write_assignment_logic: assert property (p_o_write_assignment_logic) else $error(\"Assertion failed: o_write does not match wbuf_write_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_26_1_1"
    },
    {
        "sva": "property p_in_wreq_assignment;\n    @(posedge i_clk)\n        (i_req == 1 && i_write == 1) |-> (in_wreq == 1);\nendproperty\nassert_p_in_wreq_assignment: assert property (p_in_wreq_assignment) else $error(\"Assertion failed: in_wreq signal is not set to 1 when both i_req and i_write are 1\");",
        "sva_id": "175_2_1_1"
    },
    {
        "sva": "property p_wbuf_wdata_r_assignment;\n    @(posedge i_clk)\n        push == 1 |-> ##1 wbuf_wdata_r[$past(wbuf_wp_r)] == $past(i_wdata);\nendproperty\nassert_p_wbuf_wdata_r_assignment: assert property (p_wbuf_wdata_r_assignment) else $error(\"Assertion failed: wbuf_wdata_r assignment does not match the expected value based on i_wdata\");",
        "sva_id": "175_4_1_1"
    },
    {
        "sva": "property p_imm_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 imm_ex == 0;\nendproperty\nassert_p_imm_ex_assignment_on_grst: assert property (p_imm_ex_assignment_on_grst) else $error(\"Assertion failed: imm_ex signal is not 0 one cycle after grst is asserted.\");",
        "sva_id": "65_7_1_1"
    },
    {
        "sva": "property p_rdy1_reset_logic;\n    @(posedge ckdr) disable iff (reset == 0)\n        reset == 1 |-> ##1 rdy1 == 0;\nendproperty\nassert_p_rdy1_reset_logic: assert property (p_rdy1_reset_logic) else $error(\"Assertion failed: rdy1 signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "393_8_1_1"
    },
    {
        "sva": "property p_bsf_mx_assignment;\n    @(posedge gclk) disable iff (grst)\n        AEMB_BSF[0] == 1 |-> bsf_mx == rBSR;\nendproperty\nassert_p_bsf_mx_assignment: assert property (p_bsf_mx_assignment) else $error(\"Assertion failed: bsf_mx does not equal rBSR when AEMB_BSF[0] is 1\");",
        "sva_id": "65_5_1_1"
    },
    {
        "sva": "property p_rBSRL_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rBSRL == 32'h0;\nendproperty\nassert_p_rBSRL_assignment_on_grst: assert property (p_rBSRL_assignment_on_grst) else $error(\"Assertion failed: rBSRL is not assigned to 32'h0 one cycle after grst is asserted.\");",
        "sva_id": "65_2_1_1"
    },
    {
        "sva": "property p_wdat_msk_assignment_logic;\n    @(posedge ckmb) disable iff (reset == 1)\n        (reset == 0 && IO_Addr_Strobe == 1 && IO_Write_Strobe == 1 && IO_Address[4:2] == 3'b000) |-> \n        ##1 (wdat[31:0] == $past(iowd) && msk == {28'hFFFFFFF, $past(mask)});\nendproperty\nassert_p_wdat_msk_assignment_logic: assert property (p_wdat_msk_assignment_logic) else $error(\"Assertion failed: wdat and msk signals do not reflect the correct state based on the past values of iowd and mask\");",
        "sva_id": "393_13_1_1"
    },
    {
        "sva": "property p_wOPB_opb_of;\n    @(posedge gclk) disable iff (grst == 1)\n        opb_of == 8'hA5 |-> wOPB == opb_of;\nendproperty\nassert_p_wOPB_opb_of: assert property (p_wOPB_opb_of) else $error(\"Assertion failed: wOPB signal does not match opb_of value when opb_of is 8'hA5\");",
        "sva_id": "65_8_1_1"
    },
    {
        "sva": "property p_o_wdata_assignment;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_wdata == wbuf_wdata_r[wbuf_rp_r];\nendproperty\nassert_p_o_wdata_assignment: assert property (p_o_wdata_assignment) else $error(\"Assertion failed: o_wdata does not match the expected value from wbuf_wdata_r at the position indicated by wbuf_rp_r when wbuf_used_r is not zero\");",
        "sva_id": "175_25_1_1"
    },
    {
        "sva": "property p_busy_reading_r_assignment;\n    @(posedge i_clk)\n        (o_valid == 1 && o_write == 0) |-> ##1 (busy_reading_r == 1);\nendproperty\nassert_p_busy_reading_r_assignment: assert property (p_busy_reading_r_assignment) else $error(\"Assertion failed: When o_valid is 1 and o_write is 0, busy_reading_r should be 1 after 1 clock cycle\");",
        "sva_id": "175_20_1_1"
    },
    {
        "sva": "property p_o_ack_assignment;\n    @(posedge i_clk)\n        (in_wreq == 1 && wbuf_used_r == 2'd0) |-> (o_ack == 1);\nendproperty\nassert_p_o_ack_assignment: assert property (p_o_ack_assignment) else $error(\"Assertion failed: o_ack signal is not set to 1 when in_wreq is 1 and wbuf_used_r is 0\");",
        "sva_id": "175_29_1_1"
    },
    {
        "sva": "property p_o_be_assignment_logic;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_be == wbuf_be_r[wbuf_rp_r];\nendproperty\nassert_p_o_be_assignment_logic: assert property (p_o_be_assignment_logic) else $error(\"Assertion failed: o_be does not match the expected value from wbuf_be_r at index wbuf_rp_r when wbuf_used_r is not zero\");",
        "sva_id": "175_28_1_1"
    },
    {
        "sva": "property p_wbuf_used_r_retention;\n    @(posedge i_clk)\n        (push == 1 && pop == 1) |-> ##1 (wbuf_used_r == $past(wbuf_used_r));\nendproperty\nassert_p_wbuf_used_r_retention: assert property (p_wbuf_used_r_retention) else $error(\"Assertion failed: wbuf_used_r does not retain its value when both push and pop are asserted.\");",
        "sva_id": "175_17_1_1"
    },
    {
        "sva": "property p_wdat_assignment_logic;\n    @(posedge ckmb) disable iff (reset == 1)\n        (reset == 0 && IO_Addr_Strobe == 1 && IO_Write_Strobe == 1 && IO_Address[4:2] == 3'b000) |-> ##1 wdat[31:0] == $past(iowd);\nendproperty\nassert_p_wdat_assignment_logic: assert property (p_wdat_assignment_logic) else $error(\"Assertion failed: wdat[31:0] does not match the past value of iowd under the specified conditions\");",
        "sva_id": "393_7_1_1"
    },
    {
        "sva": "property p_o_valid_assignment;\n    @(posedge i_clk)\n        (wbuf_used_r != 2'd0 && i_req == 1 && wait_rdata_valid_r == 0) |-> (o_valid == 1);\nendproperty\nassert_p_o_valid_assignment: assert property (p_o_valid_assignment) else $error(\"Assertion failed: o_valid signal is not set to 1 when wbuf_used_r is not zero, i_req is 1, and wait_rdata_valid_r is 0\");",
        "sva_id": "175_30_1_1"
    },
    {
        "sva": "property p_rBSLL_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rBSLL == 32'h0;\nendproperty\nassert_p_rBSLL_assignment_on_grst: assert property (p_rBSLL_assignment_on_grst) else $error(\"Assertion failed: rBSLL is not assigned to 32'h0 one cycle after grst is asserted\");",
        "sva_id": "65_6_1_1"
    },
    {
        "sva": "property p_push_assignment_logic;\n    @(posedge i_clk)\n        (i_req == 1 && busy_reading_r == 0 && wbuf_used_r == 2'd1) |-> (push == 1);\nendproperty\nassert_p_push_assignment_logic: assert property (p_push_assignment_logic) else $error(\"Assertion failed: push signal is not asserted when i_req is 1, busy_reading_r is 0, and wbuf_used_r is 2'd1\");",
        "sva_id": "175_23_1_1"
    },
    {
        "sva": "property p_pop_assignment;\n    @(posedge i_clk)\n        (o_valid == 1 && i_accepted == 1 && wbuf_used_r != 2'd0) |-> \n        (pop == (o_valid == 1 && i_accepted == 1 && (wbuf_used_r != 2'd0)));\nendproperty\nassert_p_pop_assignment: assert property (p_pop_assignment) else $error(\"Assertion failed: pop signal does not reflect the correct state when o_valid, i_accepted are high and wbuf_used_r is not zero\");",
        "sva_id": "175_24_1_1"
    },
    {
        "sva": "property p_o_addr_assignment;\n    @(posedge i_clk)\n        wbuf_used_r != 2'd0 |-> o_addr == wbuf_addr_r[wbuf_rp_r];\nendproperty\nassert_p_o_addr_assignment: assert property (p_o_addr_assignment) else $error(\"Assertion failed: o_addr does not match wbuf_addr_r[wbuf_rp_r] when wbuf_used_r is not zero\");",
        "sva_id": "175_27_1_1"
    },
    {
        "sva": "property p_bpc_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 bpc_ex == 30'h0;\nendproperty\nassert_p_bpc_ex_assignment_on_grst: assert property (p_bpc_ex_assignment_on_grst) else $error(\"Assertion failed: bpc_ex is not assigned to 30'h0 one cycle after grst is asserted.\");",
        "sva_id": "69_9_1_1"
    },
    {
        "sva": "property p_clk_358_counter_reset_logic;\n    @(posedge clk_50) disable iff (reset_n == 1)\n        reset_n == 0 |-> ##1 clk_358 == 0 && counter == 0;\nendproperty\nassert_p_clk_358_counter_reset_logic: assert property (p_clk_358_counter_reset_logic) else $error(\"Assertion failed: clk_358 and counter are not reset to 0 one cycle after reset_n is deasserted\");",
        "sva_id": "1557_2_1_1"
    },
    {
        "sva": "property p_rBSR_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && imm_ex == 2'o0) |-> ##1 rBSR == $past(rBSRL);\nendproperty\nassert_p_rBSR_assignment_logic: assert property (p_rBSR_assignment_logic) else $error(\"Assertion failed: rBSR does not match the past value of rBSRL under the specified conditions\");",
        "sva_id": "65_4_1_1"
    },
    {
        "sva": "property p_result_assignment_logic;\n    @(posedge clock) disable iff (aclr == 1)\n        (stage_values[0] == 1 && result_width == 1) |-> (result == stage_values[0]);\nendproperty\nassert_p_result_assignment_logic: assert property (p_result_assignment_logic) else $error(\"Assertion failed: result does not match stage_values[0] when stage_values[0] is 1 and result_width is 1\");",
        "sva_id": "468_4_1_1"
    },
    {
        "sva": "property p_write_data_assignment;\n    @(posedge clk_50) disable iff (reset_n == 0)\n        hor_counter < 68 |-> write_data == vert_counter[2:0];\nendproperty\nassert_p_write_data_assignment: assert property (p_write_data_assignment) else $error(\"Assertion failed: write_data does not match vert_counter[2:0] when hor_counter is less than 68\");",
        "sva_id": "1557_9_1_1"
    },
    {
        "sva": "property p_pixel_assignment;\n    @(posedge clk_50) disable iff (reset_n == 0)\n        hor_counter < 68 |-> pixel == 3'd0;\nendproperty\nassert_p_pixel_assignment: assert property (p_pixel_assignment) else $error(\"Assertion failed: pixel signal is not equal to 3'd0 when hor_counter is less than 68\");",
        "sva_id": "1557_6_1_1"
    },
    {
        "sva": "property p_clk_358_counter_reset;\n    @(posedge clk_50) disable iff (reset_n == 1)\n        reset_n == 0 |-> ##1 (clk_358 == 0 && counter == 0);\nendproperty\nassert_p_clk_358_counter_reset: assert property (p_clk_358_counter_reset) else $error(\"Assertion failed: clk_358 and counter are not reset correctly one cycle after reset_n is deasserted\");",
        "sva_id": "1557_3_1_1"
    },
    {
        "sva": "property p_o_rdata_i_rdata;\n    @(posedge i_clk)\n        i_rdata == 8'hA5 |-> o_rdata == 8'hA5;\nendproperty\nassert_p_o_rdata_i_rdata: assert property (p_o_rdata_i_rdata) else $error(\"Assertion failed: o_rdata does not equal 8'hA5 when i_rdata is 8'hA5\");",
        "sva_id": "175_31_1_1"
    },
    {
        "sva": "property p_mem_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 mem_ex == 30'h0;\nendproperty\nassert_p_mem_ex_assignment_on_grst: assert property (p_mem_ex_assignment_on_grst) else $error(\"Assertion failed: mem_ex is not assigned to 30'h0 one cycle after grst is asserted\");",
        "sva_id": "69_8_1_1"
    },
    {
        "sva": "property p_write_enable_n_assignment;\n    @(posedge clk_50) disable iff (reset_n == 0)\n        hor_counter < 68 |-> write_enable_n == 1'b1;\nendproperty\nassert_p_write_enable_n_assignment: assert property (p_write_enable_n_assignment) else $error(\"Assertion failed: write_enable_n should be 1 when hor_counter is less than 68\");",
        "sva_id": "1557_7_1_1"
    },
    {
        "sva": "property p_rMSR_BE_reset_logic;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rMSR_BE == 0;\nendproperty\nassert_p_rMSR_BE_reset_logic: assert property (p_rMSR_BE_reset_logic) else $error(\"Assertion failed: rMSR_BE signal is not 0 one cycle after grst is asserted.\");",
        "sva_id": "69_5_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_4_1_1"
    },
    {
        "sva": "property p_alu_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 alu_ex == 32'h0;\nendproperty\nassert_p_alu_ex_reset: assert property (p_alu_ex_reset) else $error(\"Assertion failed: alu_ex is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_10_1_1"
    },
    {
        "sva": "property p_alu_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 alu_ex == 32'h0;\nendproperty\nassert_p_alu_ex_reset: assert property (p_alu_ex_reset) else $error(\"Assertion failed: alu_ex is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_7_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == 8'b00000000;\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal is not 8'b00000000 one cycle after reset is asserted\");",
        "sva_id": "353_3_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_9_1_1"
    },
    {
        "sva": "property p_state_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == {RNUM{1'b0}};\nendproperty\nassert_p_state_reset_logic: assert property (p_state_reset_logic) else $error(\"Assertion failed: state is not reset to all zeros after reset is asserted\");",
        "sva_id": "353_12_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_2_1_1"
    },
    {
        "sva": "property p_inc_state_increment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (state < 1) |-> (inc_state == (state + 1));\nendproperty\nassert_p_inc_state_increment: assert property (p_inc_state_increment) else $error(\"Assertion failed: inc_state is not equal to state + 1 when state is less than 1\");",
        "sva_id": "353_7_1_1"
    },
    {
        "sva": "property p_rMSR_BE_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && fMTS == 1 && fMOP == 0) |-> ##1 rMSR_BE == $past(opa_of[0]);\nendproperty\nassert_p_rMSR_BE_assignment: assert property (p_rMSR_BE_assignment) else $error(\"Assertion failed: rMSR_BE does not match the past value of opa_of[0] under the specified conditions\");",
        "sva_id": "69_16_1_1"
    },
    {
        "sva": "property p_state_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == 3'b000;\nendproperty\nassert_p_state_reset_logic: assert property (p_state_reset_logic) else $error(\"Assertion failed: state signal is not reset to 3'b000 one cycle after rst_i is asserted\");",
        "sva_id": "353_6_1_1"
    },
    {
        "sva": "property p_sfr_mx_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        (grst == 1) |-> ##1 (sfr_mx == 32'h0);\nendproperty\nassert_p_sfr_mx_assignment_on_grst: assert property (p_sfr_mx_assignment_on_grst) else $error(\"Assertion failed: sfr_mx is not assigned to 32'h0 one cycle after grst is asserted.\");",
        "sva_id": "69_15_1_1"
    },
    {
        "sva": "property p_write_addr_assignment;\n    @(posedge clk_50) disable iff (reset_n == 0)\n        hor_counter < 68 |-> write_addr == 0;\nendproperty\nassert_p_write_addr_assignment: assert property (p_write_addr_assignment) else $error(\"Assertion failed: write_addr is not 0 when hor_counter is less than 68\");",
        "sva_id": "1557_8_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_14_1_1"
    },
    {
        "sva": "property p_rMSR_BE_reset_logic;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rMSR_BE == 0;\nendproperty\nassert_p_rMSR_BE_reset_logic: assert property (p_rMSR_BE_reset_logic) else $error(\"Assertion failed: rMSR_BE signal is not 0 one cycle after grst is asserted\");",
        "sva_id": "69_23_1_1"
    },
    {
        "sva": "property p_sfr_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 sfr_ex == 32'h0;\nendproperty\nassert_p_sfr_ex_assignment_on_grst: assert property (p_sfr_ex_assignment_on_grst) else $error(\"Assertion failed: sfr_ex is not assigned to 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_3_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_10_1_1"
    },
    {
        "sva": "property p_fifo_tail_reset_initialization;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_tail == 0;\nendproperty\nassert_p_fifo_tail_reset_initialization: assert property (p_fifo_tail_reset_initialization) else $error(\"Assertion failed: fifo_tail is not initialized to 0 after reset\");",
        "sva_id": "803_2_1_1"
    },
    {
        "sva": "property p_sfr_mx_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && sfr_sel[2:0] == 3'o5) |-> ##1 (sfr_mx == {30'd0, $past(rESR_C)});\nendproperty\nassert_p_sfr_mx_assignment: assert property (p_sfr_mx_assignment) else $error(\"Assertion failed: sfr_mx does not match the expected value after the specified conditions are met.\");",
        "sva_id": "69_13_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_1_1_1"
    },
    {
        "sva": "property p_eps_delta_minor_sum;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (eps == 5 && delta_minor == 3) |-> (eps_delta_minor == 8);\nendproperty\nassert_p_eps_delta_minor_sum: assert property (p_eps_delta_minor_sum) else $error(\"Assertion failed: eps_delta_minor is not equal to 8 when eps is 5 and delta_minor is 3\");",
        "sva_id": "808_11_1_1"
    },
    {
        "sva": "property p_state_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == $past(wait_state);\nendproperty\nassert_p_state_reset_logic: assert property (p_state_reset_logic) else $error(\"Assertion failed: state does not match the previous wait_state after reset\");",
        "sva_id": "808_12_1_1"
    },
    {
        "sva": "property p_x_major_o_delta_major_delta_minor_assignment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (rst_i == 0 && state == line_prep_state && xdiff > ydiff) |-> ##1 \n        (x_major_o == 1 && delta_major == $past(xdiff) && delta_minor == $past(ydiff));\nendproperty\nassert_p_x_major_o_delta_major_delta_minor_assignment: assert property (p_x_major_o_delta_major_delta_minor_assignment) else $error(\"Assertion failed: x_major_o, delta_major, or delta_minor does not reflect the correct state after the specified conditions.\");",
        "sva_id": "808_5_1_1"
    },
    {
        "sva": "property p_is_inside_screen;\n    @(posedge clk_i) disable iff (rst_i)\n        (minor_o == 1 && major_o == 0) |-> (is_inside_screen == 1);\nendproperty\nassert_p_is_inside_screen: assert property (p_is_inside_screen) else $error(\"Assertion failed: is_inside_screen signal is not 1 when minor_o is 1 and major_o is 0\");",
        "sva_id": "808_10_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal does not reset to all zeros one cycle after reset is asserted\");",
        "sva_id": "353_5_1_1"
    },
    {
        "sva": "property p_state_assignment_on_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == $past(wait_state);\nendproperty\nassert_p_state_assignment_on_reset: assert property (p_state_assignment_on_reset) else $error(\"Assertion failed: state signal does not reflect the correct state after reset\");",
        "sva_id": "808_3_1_1"
    },
    {
        "sva": "property p_inc_state_assignment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (rst_i == 0 && state < '1) |-> inc_state == (state + 1);\nendproperty\nassert_p_inc_state_assignment: assert property (p_inc_state_assignment) else $error(\"Assertion failed: inc_state does not correctly reflect state increment when rst_i is low and state is less than '1\");",
        "sva_id": "353_8_1_1"
    },
    {
        "sva": "property p_eps_delta_minor_sum;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (eps == 10 && delta_minor == 5) |-> eps_delta_minor == (eps + delta_minor);\nendproperty\nassert_p_eps_delta_minor_sum: assert property (p_eps_delta_minor_sum) else $error(\"Assertion failed: eps_delta_minor does not equal the sum of eps and delta_minor when eps is 10 and delta_minor is 5\");",
        "sva_id": "808_9_1_1"
    },
    {
        "sva": "property p_rEAR_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rEAR == 32'h0;\nendproperty\nassert_p_rEAR_assignment_on_grst: assert property (p_rEAR_assignment_on_grst) else $error(\"Assertion failed: rEAR is not assigned to 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_21_1_1"
    },
    {
        "sva": "property p_rEAR_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rEAR == 32'h0;\nendproperty\nassert_p_rEAR_assignment_on_grst: assert property (p_rEAR_assignment_on_grst) else $error(\"Assertion failed: rEAR is not assigned to 32'h0 one cycle after grst is asserted.\");",
        "sva_id": "69_4_1_1"
    },
    {
        "sva": "property p_grant_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 grant == {RCNT{1'b0}};\nendproperty\nassert_p_grant_reset_logic: assert property (p_grant_reset_logic) else $error(\"Assertion failed: grant signal is not reset to zero as expected after reset\");",
        "sva_id": "353_11_1_1"
    },
    {
        "sva": "property p_valid_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 valid_o == 0;\nendproperty\nassert_p_valid_o_reset: assert property (p_valid_o_reset) else $error(\"Assertion failed: valid_o signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "803_4_1_1"
    },
    {
        "sva": "property p_fifo_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_tail == 0;\nendproperty\nassert_p_fifo_tail_reset: assert property (p_fifo_tail_reset) else $error(\"Assertion failed: fifo_tail is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_3_1_1"
    },
    {
        "sva": "property p_valid_o_reset;\n    @(posedge clk_i) disable iff (rst_i==0)\n        (rst_i == 1) |-> ##1 (valid_o == 0);\nendproperty\nassert_p_valid_o_reset: assert property (p_valid_o_reset) else $error(\"Assertion failed: valid_o signal is not 0 one cycle after rst_i is asserted\");",
        "sva_id": "808_7_1_1"
    },
    {
        "sva": "property p_state_assignment_on_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == $past(wait_state);\nendproperty\nassert_p_state_assignment_on_reset: assert property (p_state_assignment_on_reset) else $error(\"Assertion failed: state does not match the expected wait_state value after reset\");",
        "sva_id": "808_2_1_1"
    },
    {
        "sva": "property p_alu_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 alu_ex == 32'h0;\nendproperty\nassert_p_alu_ex_reset: assert property (p_alu_ex_reset) else $error(\"Assertion failed: alu_ex is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_11_1_1"
    },
    {
        "sva": "property p_fifo_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_tail == 0;\nendproperty\nassert_p_fifo_tail_reset: assert property (p_fifo_tail_reset) else $error(\"Assertion failed: fifo_tail is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_1_1_1"
    },
    {
        "sva": "property p_state_assignment_during_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == $past(wait_state);\nendproperty\nassert_p_state_assignment_during_reset: assert property (p_state_assignment_during_reset) else $error(\"Assertion failed: state signal does not reflect the correct wait_state during reset\");",
        "sva_id": "808_1_1_1"
    },
    {
        "sva": "property p_sfr_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        (grst == 1) |-> ##1 (sfr_ex == 32'h0);\nendproperty\nassert_p_sfr_ex_reset: assert property (p_sfr_ex_reset) else $error(\"Assertion failed: sfr_ex is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_20_1_1"
    },
    {
        "sva": "property p_sfr_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 sfr_ex == 32'h0;\nendproperty\nassert_p_sfr_ex_reset: assert property (p_sfr_ex_reset) else $error(\"Assertion failed: sfr_ex is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "69_14_1_1"
    },
    {
        "sva": "property p_fifo_head_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_head == 0;\nendproperty\nassert_p_fifo_head_reset: assert property (p_fifo_head_reset) else $error(\"Assertion failed: fifo_head is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_11_1_1"
    },
    {
        "sva": "property p_next_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 next_tail == 1;\nendproperty\nassert_p_next_tail_reset: assert property (p_next_tail_reset) else $error(\"Assertion failed: next_tail is not 1 in the cycle following a reset\");",
        "sva_id": "803_12_1_1"
    },
    {
        "sva": "property p_count_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 count_o == 0;\nendproperty\nassert_p_count_o_reset: assert property (p_count_o_reset) else $error(\"Assertion failed: count_o is not 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_7_1_1"
    },
    {
        "sva": "property p_data_o_assignment_when_valid_o_not_asserted;\n    @(posedge clk_i) disable iff (rst_i)\n        valid_o == 0 |-> ##1 data_o == $past(fifo_data[fifo_head[fifo_bit_depth-1:0]]);\nendproperty\nassert_p_data_o_assignment_when_valid_o_not_asserted: assert property (p_data_o_assignment_when_valid_o_not_asserted) else $error(\"Assertion failed: data_o does not match the expected value when valid_o is not asserted\");",
        "sva_id": "803_20_1_1"
    },
    {
        "sva": "property p_fifo_tail_next_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 (fifo_tail == 0 && next_tail == 1);\nendproperty\nassert_p_fifo_tail_next_tail_reset: assert property (p_fifo_tail_next_tail_reset) else $error(\"Assertion failed: fifo_tail should be 0 and next_tail should be 1 one cycle after reset is asserted\");",
        "sva_id": "803_17_1_1"
    },
    {
        "sva": "property p_fifo_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_tail == 0;\nendproperty\nassert_p_fifo_tail_reset: assert property (p_fifo_tail_reset) else $error(\"Assertion failed: fifo_tail is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_10_1_1"
    },
    {
        "sva": "property p_counter_load;\n    @(posedge clk) disable iff (reset)\n        load == 1 |-> ##1 counter == $past(count);\nendproperty\nassert_p_counter_load: assert property (p_counter_load) else $error(\"Assertion failed: counter does not match the previous count value after load signal is asserted\");",
        "sva_id": "1717_1_1_1"
    },
    {
        "sva": "property p_fifo_tail_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 fifo_tail == 0;\nendproperty\nassert_p_fifo_tail_reset: assert property (p_fifo_tail_reset) else $error(\"Assertion failed: fifo_tail is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_8_1_1"
    },
    {
        "sva": "property p_iwb_adr_o_rADR;\n    @(posedge gclk) disable iff (grst == 1)\n        rADR |-> iwb_adr_o == rADR;\nendproperty\nassert_p_iwb_adr_o_rADR: assert property (p_iwb_adr_o_rADR) else $error(\"Assertion failed: iwb_adr_o does not match rADR at the rising edge of gclk when grst is not asserted\");",
        "sva_id": "70_1_1_1"
    },
    {
        "sva": "property p_valid_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 valid_o == 0;\nendproperty\nassert_p_valid_o_reset: assert property (p_valid_o_reset) else $error(\"Assertion failed: valid_o signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "803_6_1_1"
    },
    {
        "sva": "property p_done_counter_zero;\n    @(posedge clk) disable iff (reset)\n        (counter == 0) |-> (done == 1);\nendproperty\nassert_p_done_counter_zero: assert property (p_done_counter_zero) else $error(\"Assertion failed: When counter is zero, done signal should be 1\");",
        "sva_id": "1717_7_1_1"
    },
    {
        "sva": "property p_valid_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 valid_o == 0;\nendproperty\nassert_p_valid_o_reset: assert property (p_valid_o_reset) else $error(\"Assertion failed: valid_o signal should be 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_14_1_1"
    },
    {
        "sva": "property p_counter_load_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        load == 1 |-> ##1 counter == $past(count);\nendproperty\nassert_p_counter_load_assignment: assert property (p_counter_load_assignment) else $error(\"Assertion failed: counter does not equal the previous count value after load is asserted\");",
        "sva_id": "1717_6_1_1"
    },
    {
        "sva": "property p_counter_load;\n    @(posedge clk) disable iff (reset == 1)\n        load == 1 |-> ##1 counter == $past(count);\nendproperty\nassert_p_counter_load: assert property (p_counter_load) else $error(\"Assertion failed: counter does not match the previous count value after load signal is asserted\");",
        "sva_id": "1717_3_1_1"
    },
    {
        "sva": "property p_valid_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        (rst_i == 1) |-> ##1 (valid_o == 0);\nendproperty\nassert_p_valid_o_reset: assert property (p_valid_o_reset) else $error(\"Assertion failed: valid_o signal should be 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_19_1_1"
    },
    {
        "sva": "property p_done_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        (counter == 0) |-> (done == 1);\nendproperty\nassert_p_done_assignment: assert property (p_done_assignment) else $error(\"Assertion failed: 'done' signal is not set to 1 when 'counter' is 0\");",
        "sva_id": "1717_5_1_1"
    },
    {
        "sva": "property p_radical_width_check;\n    @(posedge clk) disable iff (aclr == 1)\n        (aclr == 0 && radical == 1'b0) |-> radical == 1'b0;\nendproperty\nassert_p_radical_width_check: assert property (p_radical_width_check) else $error(\"Assertion failed: radical signal should remain 0 when aclr is 0 and radical is initially 0\");",
        "sva_id": "447_3_1_1"
    },
    {
        "sva": "property p_iwb_tag_o_msr_ex;\n    @(posedge gclk) disable iff (grst == 1)\n        msr_ex[5] == 1 |-> iwb_tag_o == (msr_ex[5] == 1);\nendproperty\nassert_p_iwb_tag_o_msr_ex: assert property (p_iwb_tag_o_msr_ex) else $error(\"Assertion failed: iwb_tag_o does not reflect the correct state when msr_ex[5] is 1\");",
        "sva_id": "70_6_1_1"
    },
    {
        "sva": "property p_state_assignment_on_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 state == $past(wait_state);\nendproperty\nassert_p_state_assignment_on_reset: assert property (p_state_assignment_on_reset) else $error(\"Assertion failed: state signal does not reflect the correct wait_state value after reset\");",
        "sva_id": "808_6_1_1"
    },
    {
        "sva": "property p_adr_o_assignment;\n    @(posedge hclk) disable iff (hresetn == 0)\n        (hresetn == 1 && addr_temp == 16'hABCD) |-> (adr_o == 16'hABCD);\nendproperty\nassert_p_adr_o_assignment: assert property (p_adr_o_assignment) else $error(\"Assertion failed: adr_o signal does not match the expected value 16'hABCD when addr_temp is 16'hABCD and hresetn is 1\");",
        "sva_id": "168_2_1_1"
    },
    {
        "sva": "property p_rFSLSTB_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rFSLSTB == 0;\nendproperty\nassert_p_rFSLSTB_grst: assert property (p_rFSLSTB_grst) else $error(\"Assertion failed: rFSLSTB signal is not 0 one cycle after grst is 1\");",
        "sva_id": "78_8_1_1"
    },
    {
        "sva": "property p_q_remainder_pipeline_reset;\n    @(posedge clk) disable iff (aclr == 0)\n        aclr == 1 |-> ##1 (q_pipeline[i1] == 0 && remainder_pipeline[i1] == 0);\nendproperty\nassert_p_q_remainder_pipeline_reset: assert property (p_q_remainder_pipeline_reset) else $error(\"Assertion failed: q_pipeline and remainder_pipeline are not reset to 0 at index i1 after aclr is asserted\");",
        "sva_id": "447_9_1_1"
    },
    {
        "sva": "property p_rpc_if_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rpc_if == 0;\nendproperty\nassert_p_rpc_if_reset: assert property (p_rpc_if_reset) else $error(\"Assertion failed: rpc_if signal is not 0 one cycle after grst is 1\");",
        "sva_id": "70_9_1_1"
    },
    {
        "sva": "property p_count_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 count_o == 0;\nendproperty\nassert_p_count_o_reset: assert property (p_count_o_reset) else $error(\"Assertion failed: count_o is not 0 one cycle after rst_i is asserted\");",
        "sva_id": "803_18_1_1"
    },
    {
        "sva": "property p_wAFWD_M_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (xRW == wRA && xMXDST == 2'o2 && wRDWE == 1) |-> (wAFWD_M == 1);\nendproperty\nassert_p_wAFWD_M_assignment_logic: assert property (p_wAFWD_M_assignment_logic) else $error(\"Assertion failed: wAFWD_M is not assigned correctly when xRW == wRA, xMXDST == 2'o2, and wRDWE == 1\");",
        "sva_id": "78_13_1_1"
    },
    {
        "sva": "property p_cyc_o_assignment;\n    @(posedge hclk) disable iff (hresetn == 0)\n        (hresetn == 1 && hready == 1 && hsel == 1 && hburst == 3'b000 && htrans == 2'b00) |-> ##1 (cyc_o == 0);\nendproperty\nassert_p_cyc_o_assignment: assert property (p_cyc_o_assignment) else $error(\"Assertion failed: cyc_o signal is not 0 one cycle after the specified conditions are met\");",
        "sva_id": "168_7_1_1"
    },
    {
        "sva": "property p_ich_adr_rADR;\n    @(posedge gclk) disable iff (grst == 1)\n        (rADR == 32'h12345678) |-> (ich_adr == 32'h12345678);\nendproperty\nassert_p_ich_adr_rADR: assert property (p_ich_adr_rADR) else $error(\"Assertion failed: ich_adr does not equal 32'h12345678 when rADR is 32'h12345678\");",
        "sva_id": "70_7_1_1"
    },
    {
        "sva": "property p_iwb_cyc_o_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        iwb_stb_o == 1 |-> iwb_cyc_o == (iwb_stb_o == 1);\nendproperty\nassert_p_iwb_cyc_o_assignment: assert property (p_iwb_cyc_o_assignment) else $error(\"Assertion failed: iwb_cyc_o does not match the expected value when iwb_stb_o is asserted\");",
        "sva_id": "70_5_1_1"
    },
    {
        "sva": "property p_wPCINC_rADR_increment;\n    @(posedge gclk) disable iff (grst == 1)\n        (rADR < 1) |-> (wPCINC == (rADR + 1));\nendproperty\nassert_p_wPCINC_rADR_increment: assert property (p_wPCINC_rADR_increment) else $error(\"Assertion failed: wPCINC is not equal to rADR + 1 when rADR is less than 1\");",
        "sva_id": "70_15_1_1"
    },
    {
        "sva": "property p_fFACK_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (fsl_stb_o == 1 && fsl_ack_i == 0) |-> (fFACK == ~(fsl_stb_o ^ fsl_ack_i));\nendproperty\nassert_p_fFACK_assignment: assert property (p_fFACK_assignment) else $error(\"Assertion failed: fFACK signal does not reflect the correct state when fsl_stb_o is 1 and fsl_ack_i is 0\");",
        "sva_id": "78_16_1_1"
    },
    {
        "sva": "property p_cyc_o_assignment;\n    @(posedge hclk) disable iff (hresetn == 1)\n        (hresetn == 0) |-> ##1 (cyc_o == 0);\nendproperty\nassert_p_cyc_o_assignment: assert property (p_cyc_o_assignment) else $error(\"Assertion failed: cyc_o is not 0 one cycle after hresetn is deasserted\");",
        "sva_id": "168_3_1_1"
    },
    {
        "sva": "property p_wr_pointer_increment;\n    @(posedge wr_clk)\n        (i_push == 1 && o_full == 0 && wr_pointer < '1) |-> ##1 wr_pointer == $past(wr_pointer) + 1'd1;\nendproperty\nassert_p_wr_pointer_increment: assert property (p_wr_pointer_increment) else $error(\"Assertion failed: wr_pointer did not increment correctly when i_push is asserted and o_full is deasserted.\");",
        "sva_id": "195_3_1_1"
    },
    {
        "sva": "property p_cyc_o_assignment;\n    @(posedge hclk) disable iff (hresetn == 1)\n        hresetn == 0 |-> ##1 cyc_o == 0;\nendproperty\nassert_p_cyc_o_assignment: assert property (p_cyc_o_assignment) else $error(\"Assertion failed: cyc_o signal should be 0 one cycle after hresetn is deasserted (hresetn == 0)\");",
        "sva_id": "168_12_1_1"
    },
    {
        "sva": "property p_iwb_stb_o_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        (grst == 1) |-> ##1 (iwb_stb_o == 0);\nendproperty\nassert_p_iwb_stb_o_reset: assert property (p_iwb_stb_o_reset) else $error(\"Assertion failed: iwb_stb_o is not 0 one cycle after grst is 1\");",
        "sva_id": "70_2_1_1"
    },
    {
        "sva": "property p_fSKIP_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (rBRA == 1 && rDLY == 0) |-> (fSKIP == 1);\nendproperty\nassert_p_fSKIP_assignment: assert property (p_fSKIP_assignment) else $error(\"Assertion failed: fSKIP should be 1 when rBRA is 1 and rDLY is 0\");",
        "sva_id": "78_14_1_1"
    },
    {
        "sva": "property p_o_full_assignment;\n    @(posedge wr_clk)\n        {~wr_pointer[2], wr_pointer[1:0]} == rd_pointer_wr |-> o_full == 1;\nendproperty\nassert_p_o_full_assignment: assert property (p_o_full_assignment) else $error(\"Assertion failed: o_full signal is not set to 1 when {~wr_pointer[2], wr_pointer[1:0]} equals rd_pointer_wr\");",
        "sva_id": "195_14_1_1"
    },
    {
        "sva": "property p_wREGA_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        rMXALT == 2'o2 |-> wREGA == rDWBDI;\nendproperty\nassert_p_wREGA_assignment: assert property (p_wREGA_assignment) else $error(\"Assertion failed: wREGA does not equal rDWBDI when rMXALT is 2'o2\");",
        "sva_id": "77_7_1_1"
    },
    {
        "sva": "property p_rpc_mx_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rpc_mx == 0;\nendproperty\nassert_p_rpc_mx_assignment_on_grst: assert property (p_rpc_mx_assignment_on_grst) else $error(\"Assertion failed: rpc_mx is not 0 one cycle after grst is asserted\");",
        "sva_id": "70_11_1_1"
    },
    {
        "sva": "property p_o_full_fifo_full;\n    @(posedge wr_clk)\n        {~wr_pointer[2], wr_pointer[1:0]} == rd_pointer_wr |-> o_full == 1;\nendproperty\nassert_p_o_full_fifo_full: assert property (p_o_full_fifo_full) else $error(\"Assertion failed: o_full signal does not indicate FIFO full when write pointer and read pointer match the specified condition\");",
        "sva_id": "195_9_1_1"
    },
    {
        "sva": "property p_rpc_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rpc_ex == 0;\nendproperty\nassert_p_rpc_ex_assignment_on_grst: assert property (p_rpc_ex_assignment_on_grst) else $error(\"Assertion failed: rpc_ex is not 0 one cycle after grst is 1\");",
        "sva_id": "70_10_1_1"
    },
    {
        "sva": "property p_o_empty_wr_pointer_rd_eq_rd_pointer;\n    @(posedge rd_clk)\n        wr_pointer_rd == rd_pointer |-> o_empty == 1;\nendproperty\nassert_p_o_empty_wr_pointer_rd_eq_rd_pointer: assert property (p_o_empty_wr_pointer_rd_eq_rd_pointer) else $error(\"Assertion failed: o_empty signal is not 1 when wr_pointer_rd equals rd_pointer at the rising edge of rd_clk\");",
        "sva_id": "195_10_1_1"
    },
    {
        "sva": "property p_rMXDST_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rMXDST == 0;\nendproperty\nassert_p_rMXDST_assignment_on_grst: assert property (p_rMXDST_assignment_on_grst) else $error(\"Assertion failed: rMXDST is not assigned to 0 one cycle after grst is asserted\");",
        "sva_id": "78_2_1_1"
    },
    {
        "sva": "property p_rDWBSTB_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        (grst == 1) |-> ##1 (rDWBSTB == 0);\nendproperty\nassert_p_rDWBSTB_assignment_on_grst: assert property (p_rDWBSTB_assignment_on_grst) else $error(\"Assertion failed: rDWBSTB is not assigned to 0 one cycle after grst is 1\");",
        "sva_id": "78_7_1_1"
    },
    {
        "sva": "property p_rDWBSTB_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rDWBSTB == 0;\nendproperty\nassert_p_rDWBSTB_reset: assert property (p_rDWBSTB_reset) else $error(\"Assertion failed: rDWBSTB is not 0 one cycle after grst is 1\");",
        "sva_id": "78_4_1_1"
    },
    {
        "sva": "property p_wREGA_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        rMXALT == 2'o2 |-> wREGA == rDWBDI;\nendproperty\nassert_p_wREGA_assignment_logic: assert property (p_wREGA_assignment_logic) else $error(\"Assertion failed: wREGA does not equal rDWBDI when rMXALT is 2'o2\");",
        "sva_id": "77_10_1_1"
    },
    {
        "sva": "property p_o_data_assignment;\n    @(posedge rd_clk)\n        rd_pointer[1:0] == 2'b01 |-> o_data == data[rd_pointer[1:0]];\nendproperty\nassert_p_o_data_assignment: assert property (p_o_data_assignment) else $error(\"Assertion failed: o_data does not match data at the specified read pointer value\");",
        "sva_id": "195_2_1_1"
    },
    {
        "sva": "property p_rMXDST_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && gena == 1) |-> ##1 rMXDST == $past(xMXDST);\nendproperty\nassert_p_rMXDST_assignment: assert property (p_rMXDST_assignment) else $error(\"Assertion failed: rMXDST does not match the past value of xMXDST after one clock cycle when grst is 0 and gena is 1\");",
        "sva_id": "78_6_1_1"
    },
    {
        "sva": "property p_rd_pointer_increment;\n    @(posedge rd_clk)\n        (i_pop == 1 && o_empty == 0 && rd_pointer < 1) |-> ##1 rd_pointer == $past(rd_pointer) + 1;\nendproperty\nassert_p_rd_pointer_increment: assert property (p_rd_pointer_increment) else $error(\"Assertion failed: rd_pointer did not increment correctly when i_pop is 1, o_empty is 0, and rd_pointer is less than 1\");",
        "sva_id": "195_4_1_1"
    },
    {
        "sva": "property p_rd_pointer_d1_assignment;\n    @(posedge wr_clk)\n        rd_pointer == 5 |-> ##1 rd_pointer_d1 == $past(gray8(rd_pointer));\nendproperty\nassert_p_rd_pointer_d1_assignment: assert property (p_rd_pointer_d1_assignment) else $error(\"Assertion failed: rd_pointer_d1 does not match the expected value derived from gray8(rd_pointer) after one clock cycle\");",
        "sva_id": "195_6_1_1"
    },
    {
        "sva": "property p_rDLY_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rDLY == 0;\nendproperty\nassert_p_rDLY_assignment_on_grst: assert property (p_rDLY_assignment_on_grst) else $error(\"Assertion failed: rDLY is not assigned to 0 one cycle after grst is asserted\");",
        "sva_id": "77_3_1_1"
    },
    {
        "sva": "property p_rADR_rADR_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 (rADR == 30'h0 && rADR_ == 30'h0);\nendproperty\nassert_p_rADR_rADR_reset: assert property (p_rADR_rADR_reset) else $error(\"Assertion failed: rADR and rADR_ are not reset to 30'h0 after grst is asserted\");",
        "sva_id": "70_13_1_1"
    },
    {
        "sva": "property p_rd_pointer_d1_assignment;\n    @(posedge wr_clk)\n        rd_pointer == 8'b00000001 |-> ##1 rd_pointer_d1 == $past(gray8(rd_pointer));\nendproperty\nassert_p_rd_pointer_d1_assignment: assert property (p_rd_pointer_d1_assignment) else $error(\"Assertion failed: rd_pointer_d1 does not match the expected value derived from gray8(rd_pointer) at the previous cycle\");",
        "sva_id": "195_7_1_1"
    },
    {
        "sva": "property p_rIPC_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && gena == 1) |-> ##1 rIPC == $past(xIPC);\nendproperty\nassert_p_rIPC_assignment: assert property (p_rIPC_assignment) else $error(\"Assertion failed: rIPC does not match the past value of xIPC one cycle after grst is 0 and gena is 1\");",
        "sva_id": "77_6_1_1"
    },
    {
        "sva": "property p_hresp_assignment;\n    @(posedge hclk) disable iff (hresetn==1)\n        (hresetn == 0) |-> ##1 (hresp == 2'b00);\nendproperty\nassert_p_hresp_assignment: assert property (p_hresp_assignment) else $error(\"Assertion failed: hresp signal is not 2'b00 one cycle after hresetn is deasserted\");",
        "sva_id": "168_6_1_1"
    },
    {
        "sva": "property p_cyc_o_assignment;\n    @(posedge hclk) disable iff (hresetn == 1)\n        (hresetn == 0) |-> ##1 (cyc_o == 0);\nendproperty\nassert_p_cyc_o_assignment: assert property (p_cyc_o_assignment) else $error(\"Assertion failed: cyc_o signal is not 0 one cycle after hresetn is deasserted\");",
        "sva_id": "168_11_1_1"
    },
    {
        "sva": "property p_rATOM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rATOM == 0;\nendproperty\nassert_p_rATOM_assignment_on_grst: assert property (p_rATOM_assignment_on_grst) else $error(\"Assertion failed: rATOM signal is not assigned to 0 one cycle after grst is asserted\");",
        "sva_id": "77_5_1_1"
    },
    {
        "sva": "property p_rMXDST_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && gena == 1) |-> ##1 rMXDST == $past(xMXDST);\nendproperty\nassert_p_rMXDST_assignment_logic: assert property (p_rMXDST_assignment_logic) else $error(\"Assertion failed: rMXDST does not match the previous value of xMXDST when enabled and not in reset\");",
        "sva_id": "78_9_1_1"
    },
    {
        "sva": "property p_wSFT_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n    wOPC == 6'o44 |-> wSFT == 1;\nendproperty\nassert_p_wSFT_assignment_logic: assert property (p_wSFT_assignment_logic) else $error(\"Assertion failed: wSFT signal is not assigned correctly when wOPC is 6'o44\");",
        "sva_id": "78_11_1_1"
    },
    {
        "sva": "property p_wr_pointer_increment;\n    @(posedge wr_clk)\n        (i_push == 1 && o_full == 0 && wr_pointer < '1) |-> ##1 wr_pointer == $past(wr_pointer) + 1'd1;\nendproperty\nassert_wr_pointer_increment: assert property (p_wr_pointer_increment) else $error(\"Assertion failed: wr_pointer did not increment correctly when i_push is asserted and o_full is deasserted.\");",
        "sva_id": "195_1_1_1"
    },
    {
        "sva": "property p_rATOM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rATOM == 0;\nendproperty\nassert_p_rATOM_assignment_on_grst: assert property (p_rATOM_assignment_on_grst) else $error(\"Assertion failed: rATOM is not assigned to 0 one cycle after grst is 1\");",
        "sva_id": "77_9_1_1"
    },
    {
        "sva": "property p_wr_pointer_increment;\n    @(posedge wr_clk)\n        (i_push == 1 && o_full == 0 && wr_pointer < 1) |-> ##1 wr_pointer == $past(wr_pointer) + 1'd1;\nendproperty\nassert_p_wr_pointer_increment: assert property (p_wr_pointer_increment) else $error(\"Assertion failed: wr_pointer did not increment correctly when i_push is 1, o_full is 0, and wr_pointer is less than 1\");",
        "sva_id": "195_5_1_1"
    },
    {
        "sva": "property p_hresp_assignment;\n    @(posedge hclk) disable iff (hresetn == 1)\n        hresetn == 0 |-> ##1 hresp == 2'b00;\nendproperty\nassert_p_hresp_assignment: assert property (p_hresp_assignment) else $error(\"Assertion failed: hresp signal is not 2'b00 one cycle after hresetn is deasserted\");",
        "sva_id": "168_5_1_1"
    },
    {
        "sva": "property p_rATOM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rATOM == 0;\nendproperty\nassert_p_rATOM_assignment_on_grst: assert property (p_rATOM_assignment_on_grst) else $error(\"Assertion failed: rATOM signal is not 0 one cycle after grst is 1\");",
        "sva_id": "77_4_1_1"
    },
    {
        "sva": "property p_dwb_adr_o_mem_ex;\n    @(posedge gclk) disable iff (grst == 1)\n        mem_ex |-> dwb_adr_o == mem_ex;\nendproperty\nassert_p_dwb_adr_o_mem_ex: assert property (p_dwb_adr_o_mem_ex) else $error(\"Assertion failed: dwb_adr_o does not match mem_ex when mem_ex has a specific value\");",
        "sva_id": "68_1_1_1"
    },
    {
        "sva": "property p_wPCNXT_rADR_;\n    @(posedge gclk)\n    disable iff (grst == 1)\n    rADR_ == 32'h12345678 |-> wPCNXT == rADR_;\nendproperty\nassert_p_wPCNXT_rADR_: assert property (p_wPCNXT_rADR_) else $error(\"Assertion failed: wPCNXT does not equal rADR_ when rADR_ is 32'h12345678\");",
        "sva_id": "70_16_1_1"
    },
    {
        "sva": "property p_rDWBSTB_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rDWBSTB == 0;\nendproperty\nassert_p_rDWBSTB_assignment_on_grst: assert property (p_rDWBSTB_assignment_on_grst) else $error(\"Assertion failed: rDWBSTB signal should be 0 one cycle after grst is 1\");",
        "sva_id": "78_5_1_1"
    },
    {
        "sva": "property p_dwb_tag_o_msr_ex;\n    @(posedge gclk) disable iff (grst == 1)\n        msr_ex[7] == 1 |-> dwb_tag_o == (msr_ex[7] == 1);\nendproperty\nassert_p_dwb_tag_o_msr_ex: assert property (p_dwb_tag_o_msr_ex) else $error(\"Assertion failed: dwb_tag_o does not reflect the correct state when msr_ex[7] is 1\");",
        "sva_id": "68_5_1_1"
    },
    {
        "sva": "property p_wr_en_assignment_logic;\n    @(negedge clk)\n        (rw_index_vld == 1 && wr_vld_tmp == 1 && rw_disable == 0) |-> (wr_en == 1);\nendproperty\nassert_p_wr_en_assignment_logic: assert property (p_wr_en_assignment_logic) else $error(\"Assertion failed: wr_en signal is not set to 1 when rw_index_vld is 1, wr_vld_tmp is 1, and rw_disable is 0 at the falling edge of clk\");",
        "sva_id": "979_4_1_1"
    },
    {
        "sva": "property p_o_empty_assignment;\n    @(posedge rd_clk)\n        wr_pointer_rd == rd_pointer |-> o_empty == 1;\nendproperty\nassert_p_o_empty_assignment: assert property (p_o_empty_assignment) else $error(\"Assertion failed: o_empty signal is not 1 when wr_pointer_rd equals rd_pointer\");",
        "sva_id": "195_15_1_1"
    },
    {
        "sva": "property p_xdiff_ydiff_assignment_logic;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (rst_i == 0 && state == wait_state && draw_line_i == 1 && pixel0_x_i > pixel1_x_i && pixel1_y_i > pixel0_y_i) |-> \n        ##1 (xdiff == ($past(pixel0_x_i) - $past(pixel1_x_i)) && ydiff == ($past(pixel1_y_i) - $past(pixel0_y_i)));\nendproperty\nassert_p_xdiff_ydiff_assignment_logic: assert property (p_xdiff_ydiff_assignment_logic) else $error(\"Assertion failed: xdiff and ydiff do not reflect the correct values based on pixel coordinates.\");",
        "sva_id": "808_4_1_1"
    },
    {
        "sva": "property p_rd_tte_data_assignment;\n    @(negedge clk)\n        rdwe == 1 |-> rd_tte_data == wr_tte_data_d;\nendproperty\nassert_p_rd_tte_data_assignment: assert property (p_rd_tte_data_assignment) else $error(\"Assertion failed: rd_tte_data does not match wr_tte_data_d when rdwe is asserted\");",
        "sva_id": "979_6_1_1"
    },
    {
        "sva": "property p_rd_addr_assignment;\n    @(negedge clk)\n        rd_data == 1 |-> rd_addr == rw_index;\nendproperty\nassert_p_rd_addr_assignment: assert property (p_rd_addr_assignment) else $error(\"Assertion failed: rd_addr does not match rw_index when rd_data is 1\");",
        "sva_id": "979_2_1_1"
    },
    {
        "sva": "property p_hresp_assignment;\n    @(posedge hclk) disable iff (hresetn == 0)\n        hresetn == 1 |-> ##1 hresp == 2'b00;\nendproperty\nassert_p_hresp_assignment: assert property (p_hresp_assignment) else $error(\"Assertion failed: hresp signal is not 2'b00 one cycle after hresetn is asserted\");",
        "sva_id": "168_8_1_1"
    },
    {
        "sva": "property p_we_o_hwrite_temp_delay;\n    @(posedge hclk) disable iff (hresetn == 0)\n        hwrite_temp == 1 |-> ##2 we_o == hwrite_temp;\nendproperty\nassert_p_we_o_hwrite_temp_delay: assert property (p_we_o_hwrite_temp_delay) else $error(\"Assertion failed: we_o does not match hwrite_temp after a delay of 2 time units\");",
        "sva_id": "168_9_1_1"
    },
    {
        "sva": "property p_dwb_wre_o_reset;\n    @(posedge gclk) disable iff (grst==0)\n        grst == 1 |-> ##1 dwb_wre_o == 0;\nendproperty\nassert_p_dwb_wre_o_reset: assert property (p_dwb_wre_o_reset) else $error(\"Assertion failed: dwb_wre_o signal is not 0 one cycle after grst is 1\");",
        "sva_id": "68_6_1_1"
    },
    {
        "sva": "property p_dwb_stb_o_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_stb_o == 0;\nendproperty\nassert_p_dwb_stb_o_reset: assert property (p_dwb_stb_o_reset) else $error(\"Assertion failed: dwb_stb_o is not 0 one cycle after grst is 1\");",
        "sva_id": "68_3_1_1"
    },
    {
        "sva": "property p_sel_mx_assignment;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 sel_mx == 4'h0;\nendproperty\nassert_p_sel_mx_assignment: assert property (p_sel_mx_assignment) else $error(\"Assertion failed: sel_mx is not 4'h0 one cycle after grst is 1\");",
        "sva_id": "68_9_1_1"
    },
    {
        "sva": "property p_dwb_lat_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_lat == 32'h0;\nendproperty\nassert_p_dwb_lat_reset: assert property (p_dwb_lat_reset) else $error(\"Assertion failed: dwb_lat is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "68_12_1_1"
    },
    {
        "sva": "property p_imm_of_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 imm_of == 16'h0;\nendproperty\nassert_p_imm_of_assignment_on_grst: assert property (p_imm_of_assignment_on_grst) else $error(\"Assertion failed: imm_of is not 16'h0 one cycle after grst is asserted\");",
        "sva_id": "66_6_1_1"
    },
    {
        "sva": "property p_wr_tte_data_d_assignment;\n    @(negedge clk)\n        wr_tte_data == 8'hA5 |-> ##1 wr_tte_data_d == $past(wr_tte_data);\nendproperty\nassert_p_wr_tte_data_d_assignment: assert property (p_wr_tte_data_d_assignment) else $error(\"Assertion failed: wr_tte_data_d does not correctly reflect the past value of wr_tte_data\");",
        "sva_id": "979_9_1_1"
    },
    {
        "sva": "property p_dwb_fb_xnor_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (dwb_stb_o == 1 && dwb_ack_i == 0) |-> (dwb_fb == (dwb_stb_o ~^ dwb_ack_i));\nendproperty\nassert_p_dwb_fb_xnor_assignment: assert property (p_dwb_fb_xnor_assignment) else $error(\"Assertion failed: dwb_fb signal does not reflect the correct XNOR state of dwb_stb_o and dwb_ack_i when dwb_stb_o is 1 and dwb_ack_i is 0\");",
        "sva_id": "68_8_1_1"
    },
    {
        "sva": "property p_rdwe_assignment;\n    @(negedge clk)\n        wr_en == 1 |-> ##1 rdwe == 1;\nendproperty\nassert_p_rdwe_assignment: assert property (p_rdwe_assignment) else $error(\"Assertion failed: rdwe signal is not set to 1 one cycle after wr_en is asserted\");",
        "sva_id": "979_10_1_1"
    },
    {
        "sva": "property p_dwb_mx_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_mx == 32'h0;\nendproperty\nassert_p_dwb_mx_reset: assert property (p_dwb_mx_reset) else $error(\"Assertion failed: dwb_mx is not 32'h0 one cycle after grst is asserted.\");",
        "sva_id": "68_10_1_1"
    },
    {
        "sva": "property p_w_write_assignment;\n    @(posedge i_clk)\n        r_write_n == 0 |-> w_write == 1;\nendproperty\nassert_p_w_write_assignment: assert property (p_w_write_assignment) else $error(\"Assertion failed: w_write signal is not set to 1 when r_write_n is 0 at the rising edge of i_clk\");",
        "sva_id": "1301_8_1_1"
    },
    {
        "sva": "property p_o_data_blocking_assignment;\n    @(posedge rd_clk)\n        rd_pointer[1:0] == 2'b01 |-> o_data == data[2'b01];\nendproperty\nassert_p_o_data_blocking_assignment: assert property (p_o_data_blocking_assignment) else $error(\"Assertion failed: o_data does not match data[2'b01] when rd_pointer[1:0] is 2'b01\");",
        "sva_id": "195_13_1_1"
    },
    {
        "sva": "property p_tte_data_ram_assignment;\n    @(negedge clk) disable iff (rst_tri_en == 1)\n        wr_en == 1 |-> ##1 tte_data_ram[$past(wr_addr)] == $past(wr_tte_data[42:0]);\nendproperty\nassert_p_tte_data_ram_assignment: assert property (p_tte_data_ram_assignment) else $error(\"Assertion failed: tte_data_ram assignment does not match the expected value based on wr_tte_data and wr_addr\");",
        "sva_id": "979_7_1_1"
    },
    {
        "sva": "property p_dwb_cyc_o_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_cyc_o == 0;\nendproperty\nassert_p_dwb_cyc_o_grst: assert property (p_dwb_cyc_o_grst) else $error(\"Assertion failed: dwb_cyc_o is not 0 one cycle after grst is 1\");",
        "sva_id": "68_4_1_1"
    },
    {
        "sva": "property p_wr_addr_assignment_logic;\n    @(negedge clk)\n        (rw_index_vld == 1 && wr_vld_tmp == 1) |-> (wr_addr == rw_index);\nendproperty\nassert_p_wr_addr_assignment_logic: assert property (p_wr_addr_assignment_logic) else $error(\"Assertion failed: wr_addr does not match rw_index when rw_index_vld and wr_vld_tmp are both valid\");",
        "sva_id": "979_3_1_1"
    },
    {
        "sva": "property p_o_depp_assignment;\n    @(posedge i_clk)\n        (o_tx_busy == 0 && i_tx_stb == 1) |-> ##1 o_depp == { $past(i_tx_data[7]), $past(i_tx_data[6:0]) };\nendproperty\nassert_p_o_depp_assignment: assert property (p_o_depp_assignment) else $error(\"Assertion failed: o_depp signal does not correctly reflect the past i_tx_data values when o_tx_busy is 0 and i_tx_stb is 1\");",
        "sva_id": "1301_5_1_1"
    },
    {
        "sva": "property p_dwb_dat_o_assignment;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_dat_o == 32'h0;\nendproperty\nassert_p_dwb_dat_o_assignment: assert property (p_dwb_dat_o_assignment) else $error(\"Assertion failed: dwb_dat_o is not assigned to 32'h0 one cycle after grst is asserted.\");",
        "sva_id": "68_15_1_1"
    },
    {
        "sva": "property p_M_AXI_BREADY_bready;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        bready == 1 |-> M_AXI_BREADY == (bready == 1);\nendproperty\nassert_p_M_AXI_BREADY_bready: assert property (p_M_AXI_BREADY_bready) else $error(\"Assertion failed: M_AXI_BREADY signal does not reflect the correct state when bready is 1\");",
        "sva_id": "577_18_1_1"
    },
    {
        "sva": "property p_astb_assignment;\n    @(posedge i_clk)\n        (r_astb_n == 0 && l_astb_n == 1) |-> astb == (!r_astb_n & l_astb_n);\nendproperty\nassert_p_astb_assignment: assert property (p_astb_assignment) else $error(\"Assertion failed: astb signal does not reflect the correct state when r_astb_n is 0 and l_astb_n is 1\");",
        "sva_id": "1301_6_1_1"
    },
    {
        "sva": "property p_awvalid_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        awvalid == 1 |-> M_AXI_AWVALID == awvalid;\nendproperty\nassert_p_awvalid_assignment: assert property (p_awvalid_assignment) else $error(\"Assertion failed: M_AXI_AWVALID does not match awvalid when awvalid is asserted\");",
        "sva_id": "577_15_1_1"
    },
    {
        "sva": "property p_fINT_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (brk_if[0] == 1 && gpha == 1 && rFIM1 == 0) |-> (fINT == (brk_if[0] & gpha & ~rFIM1));\nendproperty\nassert_p_fINT_assignment: assert property (p_fINT_assignment) else $error(\"Assertion failed: fINT signal does not reflect the correct state based on brk_if[0], gpha, and rFIM1 conditions\");",
        "sva_id": "66_12_1_1"
    },
    {
        "sva": "property p_o_rx_stb_assignment;\n    @(posedge i_clk)\n        (w_write == 1 && dstb == 1 && addr == 0) |-> ##1 (o_rx_stb == 1);\nendproperty\nassert_p_o_rx_stb_assignment: assert property (p_o_rx_stb_assignment) else $error(\"Assertion failed: o_rx_stb signal is not assigned correctly one cycle after w_write, dstb, and addr conditions are met.\");",
        "sva_id": "1301_3_1_1"
    },
    {
        "sva": "property p_rFIM0_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rFIM0 == 0;\nendproperty\nassert_p_rFIM0_assignment_on_grst: assert property (p_rFIM0_assignment_on_grst) else $error(\"Assertion failed: rFIM0 is not assigned to 0 one cycle after grst is asserted\");",
        "sva_id": "66_14_1_1"
    },
    {
        "sva": "property p_M_AXI_WDATA_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        (wdata == 32'hA5A5A5A5) |-> (M_AXI_WDATA == 32'hA5A5A5A5);\nendproperty\nassert_p_M_AXI_WDATA_assignment: assert property (p_M_AXI_WDATA_assignment) else $error(\"Assertion failed: M_AXI_WDATA does not match the expected value 32'hA5A5A5A5 when wdata is 32'hA5A5A5A5\");",
        "sva_id": "577_3_1_1"
    },
    {
        "sva": "property p_rready_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        M_AXI_ARESETN == 0 |-> ##1 rready == 0;\nendproperty\nassert_p_rready_reset_logic: assert property (p_rready_reset_logic) else $error(\"Assertion failed: rready signal is not 0 one cycle after M_AXI_ARESETN is deasserted\");",
        "sva_id": "577_11_1_1"
    },
    {
        "sva": "property p_awvalid_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        M_AXI_ARESETN == 0 |-> ##1 awvalid == 0;\nendproperty\nassert_p_awvalid_reset_logic: assert property (p_awvalid_reset_logic) else $error(\"Assertion failed: awvalid signal should be 0 one cycle after M_AXI_ARESETN is deasserted (M_AXI_ARESETN == 0)\");",
        "sva_id": "577_7_1_1"
    },
    {
        "sva": "property p_o_wait_assignment;\n    @(posedge i_clk)\n        (i_dstb_n == 0 && i_astb_n == 0) |-> (o_wait == 1);\nendproperty\nassert_p_o_wait_assignment: assert property (p_o_wait_assignment) else $error(\"Assertion failed: o_wait signal is not 1 when both i_dstb_n and i_astb_n are 0\");",
        "sva_id": "1301_9_1_1"
    },
    {
        "sva": "property p_fSFT_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        rOPC == 6'o44 |-> fSFT == 1;\nendproperty\nassert_p_fSFT_assignment_logic: assert property (p_fSFT_assignment_logic) else $error(\"Assertion failed: fSFT signal is not equal to 1 when rOPC is 6'o44 at the rising edge of gclk\");",
        "sva_id": "78_10_1_1"
    },
    {
        "sva": "property p_imm_if_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        wIMM == 16'hABCD |-> imm_if[15:0] == 16'hABCD;\nendproperty\nassert_p_imm_if_assignment: assert property (p_imm_if_assignment) else $error(\"Assertion failed: imm_if[15:0] does not equal 16'hABCD when wIMM is 16'hABCD\");",
        "sva_id": "66_17_1_1"
    },
    {
        "sva": "property p_hzd_fwd_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (opd_fwd == 1 && opa_fwd == 1 && opb_fwd == 1 && mux_ex[2] == 1) |-> (hzd_fwd == 1);\nendproperty\nassert_p_hzd_fwd_assignment_logic: assert property (p_hzd_fwd_assignment_logic) else $error(\"Assertion failed: hzd_fwd signal is not set correctly when opd_fwd, opa_fwd, opb_fwd, and mux_ex[2] are all 1\");",
        "sva_id": "66_2_1_1"
    },
    {
        "sva": "property p_M_AXI_ARVALID_arvalid;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        arvalid == 1 |-> M_AXI_ARVALID == (arvalid == 1);\nendproperty\nassert_p_M_AXI_ARVALID_arvalid: assert property (p_M_AXI_ARVALID_arvalid) else $error(\"Assertion failed: M_AXI_ARVALID does not match arvalid signal when arvalid is asserted.\");",
        "sva_id": "577_20_1_1"
    },
    {
        "sva": "property p_addr_assignment_logic;\n    @(posedge i_clk)\n        (w_write == 1 && astb == 1) |-> ##1 addr == $past(r_depp);\nendproperty\nassert_p_addr_assignment_logic: assert property (p_addr_assignment_logic) else $error(\"Assertion failed: addr signal does not match the expected value based on the previous r_depp value\");",
        "sva_id": "1301_2_1_1"
    },
    {
        "sva": "property p_dwb_sel_o_assignment;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_sel_o == 4'h0;\nendproperty\nassert_p_dwb_sel_o_assignment: assert property (p_dwb_sel_o_assignment) else $error(\"Assertion failed: dwb_sel_o is not assigned to 4'h0 one cycle after grst is high.\");",
        "sva_id": "68_2_1_1"
    },
    {
        "sva": "property p_fwd_ex_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 fwd_ex == 0;\nendproperty\nassert_p_fwd_ex_reset: assert property (p_fwd_ex_reset) else $error(\"Assertion failed: fwd_ex signal is not 0 one cycle after grst is 1\");",
        "sva_id": "66_15_1_1"
    },
    {
        "sva": "property p_bready_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        M_AXI_ARESETN == 0 |-> ##1 bready == 0;\nendproperty\nassert_p_bready_reset_logic: assert property (p_bready_reset_logic) else $error(\"Assertion failed: bready signal is not 0 one cycle after reset is deasserted\");",
        "sva_id": "577_9_1_1"
    },
    {
        "sva": "property p_o_tx_busy_assignment;\n    @(posedge i_clk)\n        (l_dstb_n == 0 && r_dstb_n == 1 && l_write_n == 1 && addr == 8'h00) |-> ##1 (o_tx_busy == 0);\nendproperty\nassert_p_o_tx_busy_assignment: assert property (p_o_tx_busy_assignment) else $error(\"Assertion failed: o_tx_busy is not 0 one cycle after the specified conditions are met.\");",
        "sva_id": "1301_4_1_1"
    },
    {
        "sva": "property p_dstb_assignment;\n    @(posedge i_clk)\n        (r_dstb_n == 0 && l_dstb_n == 1) |-> (dstb == (~r_dstb_n & l_dstb_n));\nendproperty\nassert_p_dstb_assignment: assert property (p_dstb_assignment) else $error(\"Assertion failed: dstb signal does not reflect the correct state when r_dstb_n is 0 and l_dstb_n is 1\");",
        "sva_id": "1301_7_1_1"
    },
    {
        "sva": "property p_fXCE_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (exc_ill == 1 && exc_iwb == 0 && exc_dwb == 0) |-> (fXCE == (exc_ill | exc_iwb | exc_dwb));\nendproperty\nassert_p_fXCE_assignment: assert property (p_fXCE_assignment) else $error(\"Assertion failed: fXCE signal does not reflect the correct state when exc_ill is 1 and both exc_iwb and exc_dwb are 0\");",
        "sva_id": "66_5_1_1"
    },
    {
        "sva": "property p_M_AXI_ARADDR_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        araddr == 32'h12345678 |-> M_AXI_ARADDR == 32'h12345678;\nendproperty\nassert_p_M_AXI_ARADDR_assignment: assert property (p_M_AXI_ARADDR_assignment) else $error(\"Assertion failed: M_AXI_ARADDR does not match the expected value 32'h12345678 when araddr is 32'h12345678\");",
        "sva_id": "577_5_1_1"
    },
    {
        "sva": "property p_M_AXI_AWADDR_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        awaddr == 32'h12345678 |-> M_AXI_AWADDR == 32'h12345678;\nendproperty\nassert_p_M_AXI_AWADDR_assignment: assert property (p_M_AXI_AWADDR_assignment) else $error(\"Assertion failed: M_AXI_AWADDR is not assigned the expected value 32'h12345678 when awaddr is 32'h12345678\");",
        "sva_id": "577_12_1_1"
    },
    {
        "sva": "property p_M_AXI_AWADDR_awaddr;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        awaddr == 32'hA5A5A5A5 |-> M_AXI_AWADDR == 32'hA5A5A5A5;\nendproperty\nassert_p_M_AXI_AWADDR_awaddr: assert property (p_M_AXI_AWADDR_awaddr) else $error(\"Assertion failed: M_AXI_AWADDR does not match the expected value 32'hA5A5A5A5 when awaddr is 32'hA5A5A5A5\");",
        "sva_id": "577_2_1_1"
    },
    {
        "sva": "property p_exc_dwb_concat;\n    @(posedge gclk) disable iff (grst)\n        dwb_exc == 1 |-> exc_dwb == {dwb_exc, 1'b0};\nendproperty\nassert_p_exc_dwb_concat: assert property (p_exc_dwb_concat) else $error(\"Assertion failed: exc_dwb does not match the expected concatenation of dwb_exc and 1'b0\");",
        "sva_id": "68_11_1_1"
    },
    {
        "sva": "property p_time_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 time_counter == 0;\nendproperty\nassert_p_time_counter_reset: assert property (p_time_counter_reset) else $error(\"Assertion failed: time_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_3_1_1"
    },
    {
        "sva": "property p_hzd_fwd_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (opd_fwd == 1 && opa_fwd == 1 && opb_fwd == 0 && mux_ex[2] == 1) |-> \n        (hzd_fwd == ((opd_fwd | opa_fwd | opb_fwd) & mux_ex[2]));\nendproperty\nassert_p_hzd_fwd_assignment: assert property (p_hzd_fwd_assignment) else $error(\"Assertion failed: hzd_fwd signal does not reflect the correct state when opd_fwd, opa_fwd, and mux_ex[2] are active and opb_fwd is inactive\");",
        "sva_id": "66_21_1_1"
    },
    {
        "sva": "property p_time_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 time_counter == 0;\nendproperty\nassert_p_time_counter_reset: assert property (p_time_counter_reset) else $error(\"Assertion failed: time_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_2_1_1"
    },
    {
        "sva": "property p_M_AXI_RREADY_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        rready == 1 |-> M_AXI_RREADY == (rready == 1);\nendproperty\nassert_p_M_AXI_RREADY_assignment: assert property (p_M_AXI_RREADY_assignment) else $error(\"Assertion failed: M_AXI_RREADY signal does not reflect the correct state when rready is asserted\");",
        "sva_id": "577_22_1_1"
    },
    {
        "sva": "property p_wvalid_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        M_AXI_ARESETN == 0 |-> ##1 wvalid == 0;\nendproperty\nassert_p_wvalid_reset_logic: assert property (p_wvalid_reset_logic) else $error(\"Assertion failed: wvalid signal should be 0 one cycle after M_AXI_ARESETN is deasserted (0).\");",
        "sva_id": "577_8_1_1"
    },
    {
        "sva": "property p_counter_load;\n    @(posedge clk) disable iff (reset == 1)\n        load == 1 |-> ##1 counter == $past(count);\nendproperty\nassert_p_counter_load: assert property (p_counter_load) else $error(\"Assertion failed: counter does not reflect the correct state after load\");",
        "sva_id": "1717_4_1_1"
    },
    {
        "sva": "property p_hzd_bpc_assignment_logic;\n    @(posedge gclk) disable iff (grst)\n        (bra_ex[1] == 1 && bra_ex[0] == 0) |-> (hzd_bpc == (bra_ex[1] & ~bra_ex[0]));\nendproperty\nassert_p_hzd_bpc_assignment_logic: assert property (p_hzd_bpc_assignment_logic) else $error(\"Assertion failed: hzd_bpc does not reflect the correct state when bra_ex[1] == 1 and bra_ex[0] == 0\");",
        "sva_id": "66_9_1_1"
    },
    {
        "sva": "property p_tte_data_ram_assignment;\n    @(negedge clk)\n        wr_en == 1 |-> ##1 tte_data_ram[$past(wr_addr)] == $past(wr_tte_data[42:0]);\nendproperty\nassert_p_tte_data_ram_assignment: assert property (p_tte_data_ram_assignment) else $error(\"Assertion failed: tte_data_ram assignment does not match the expected value based on wr_tte_data and wr_addr\");",
        "sva_id": "979_1_1_1"
    },
    {
        "sva": "property p_arvalid_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        (M_AXI_ARESETN == 0) |-> ##1 (arvalid == 0);\nendproperty\nassert_p_arvalid_reset_logic: assert property (p_arvalid_reset_logic) else $error(\"Assertion failed: arvalid signal should be 0 one cycle after M_AXI_ARESETN is deasserted\");",
        "sva_id": "577_10_1_1"
    },
    {
        "sva": "property p_bready_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN==1)\n        (M_AXI_ARESETN == 0) |-> ##1 (bready == 0);\nendproperty\nassert_p_bready_reset_logic: assert property (p_bready_reset_logic) else $error(\"Assertion failed: bready signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "577_4_1_1"
    },
    {
        "sva": "property p_broadcast_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 broadcast_counter == 0;\nendproperty\nassert_p_broadcast_counter_reset: assert property (p_broadcast_counter_reset) else $error(\"Assertion failed: broadcast_counter is not reset to 0 after Reset is asserted\");",
        "sva_id": "1419_12_1_1"
    },
    {
        "sva": "property p_x_signals_assignment;\n    @(posedge i_clk)\n        { i_dstb_n == 1, i_astb_n == 1, i_write_n == 1, i_depp == 1 } |-> ##1 { x_dstb_n, x_astb_n, x_write_n, x_depp } == $past({ i_dstb_n, i_astb_n, i_write_n, i_depp });\nendproperty\nassert_p_x_signals_assignment: assert property (p_x_signals_assignment) else $error(\"Assertion failed: x_signals do not match the past values of i_signals after one clock cycle\");",
        "sva_id": "1301_11_1_1"
    },
    {
        "sva": "property p_empty_assignment;\n    @(posedge clock) disable iff (aclr == 1)\n        i_empty == 1 |-> empty == 1;\nendproperty\nassert_p_empty_assignment: assert property (p_empty_assignment) else $error(\"Assertion failed: empty signal should be 1 when i_empty is 1\");",
        "sva_id": "464_3_1_1"
    },
    {
        "sva": "property p_broadcast_drop_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 broadcast_drop == 0;\nendproperty\nassert_p_broadcast_drop_reset: assert property (p_broadcast_drop_reset) else $error(\"Assertion failed: broadcast_drop signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_14_1_1"
    },
    {
        "sva": "property p_dwb_exc_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 dwb_exc == 0;\nendproperty\nassert_p_dwb_exc_reset: assert property (p_dwb_exc_reset) else $error(\"Assertion failed: dwb_exc is not 0 one cycle after grst is 1\");",
        "sva_id": "68_13_1_1"
    },
    {
        "sva": "property p_mux_of_assignment;\n    @(posedge gclk) disable iff (grst==0)\n        grst == 1 |-> ##1 mux_of == 3'h0;\nendproperty\nassert_p_mux_of_assignment: assert property (p_mux_of_assignment) else $error(\"Assertion failed: mux_of is not 3'h0 one cycle after grst is 1\");",
        "sva_id": "66_4_1_1"
    },
    {
        "sva": "property p_broadcast_drop_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 broadcast_drop == 0;\nendproperty\nassert_p_broadcast_drop_reset: assert property (p_broadcast_drop_reset) else $error(\"Assertion failed: broadcast_drop is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_5_1_1"
    },
    {
        "sva": "property p_M_AXI_WDATA_assignment;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        (wdata == 32'hA5A5A5A5) |-> (M_AXI_WDATA == 32'hA5A5A5A5);\nendproperty\nassert_p_M_AXI_WDATA_assignment: assert property (p_M_AXI_WDATA_assignment) else $error(\"Assertion failed: M_AXI_WDATA does not match the expected value 32'hA5A5A5A5 when wdata is 32'hA5A5A5A5\");",
        "sva_id": "577_13_1_1"
    },
    {
        "sva": "property p_time_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 time_counter == 0;\nendproperty\nassert_p_time_counter_reset: assert property (p_time_counter_reset) else $error(\"Assertion failed: time_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_1_1_1"
    },
    {
        "sva": "property p_broadcast_drop_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 broadcast_drop == 0;\nendproperty\nassert_p_broadcast_drop_reset: assert property (p_broadcast_drop_reset) else $error(\"Assertion failed: broadcast_drop signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_11_1_1"
    },
    {
        "sva": "property p_fwd_ex_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 fwd_ex == 0;\nendproperty\nassert_p_fwd_ex_assignment_on_grst: assert property (p_fwd_ex_assignment_on_grst) else $error(\"Assertion failed: fwd_ex signal is not 0 one cycle after grst is 1\");",
        "sva_id": "66_8_1_1"
    },
    {
        "sva": "property p_mux_opb_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (wOPC[3] == 1 && opb_fwd == 0) |-> (mux_opb == {wOPC[3], opb_fwd});\nendproperty\nassert_p_mux_opb_assignment_logic: assert property (p_mux_opb_assignment_logic) else $error(\"Assertion failed: mux_opb does not reflect the correct assignment logic when wOPC[3] is 1 and opb_fwd is 0\");",
        "sva_id": "66_20_1_1"
    },
    {
        "sva": "property p_rready_reset_logic;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        M_AXI_ARESETN == 0 |-> ##1 rready == 0;\nendproperty\nassert_p_rready_reset_logic: assert property (p_rready_reset_logic) else $error(\"Assertion failed: rready signal is not 0 one cycle after M_AXI_ARESETN is deasserted\");",
        "sva_id": "577_6_1_1"
    },
    {
        "sva": "property p_broadcast_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (broadcast_counter == 0);\nendproperty\nassert_p_broadcast_counter_reset: assert property (p_broadcast_counter_reset) else $error(\"Assertion failed: broadcast_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_10_1_1"
    },
    {
        "sva": "property p_broadcast_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 broadcast_counter == 0;\nendproperty\nassert_p_broadcast_counter_reset: assert property (p_broadcast_counter_reset) else $error(\"Assertion failed: broadcast_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_4_1_1"
    },
    {
        "sva": "property p_read_resp_error;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 0)\n        (rready == 1 && M_AXI_RVALID == 1 && M_AXI_RRESP[1] == 1) |-> (read_resp_error == 1);\nendproperty\nassert_p_read_resp_error: assert property (p_read_resp_error) else $error(\"Assertion failed: read_resp_error signal should be 1 when rready, M_AXI_RVALID, and M_AXI_RRESP[1] are all 1\");",
        "sva_id": "577_24_1_1"
    },
    {
        "sva": "property p_time_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 time_counter == 0;\nendproperty\nassert_p_time_counter_reset: assert property (p_time_counter_reset) else $error(\"Assertion failed: time_counter is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_8_1_1"
    },
    {
        "sva": "property p_write_resp_error_assignment;\n    @(posedge M_AXI_ACLK)\n    disable iff (M_AXI_ARESETN == 0)\n    (bready == 1 && M_AXI_BVALID == 1 && M_AXI_BRESP[1] == 1) |-> (write_resp_error == 1);\nendproperty\nassert_p_write_resp_error_assignment: assert property (p_write_resp_error_assignment) else $error(\"Assertion failed: write_resp_error signal is not set correctly when bready, M_AXI_BVALID, and M_AXI_BRESP[1] are all high\");",
        "sva_id": "577_23_1_1"
    },
    {
        "sva": "property p_broadcast_drop_reset;\n    @(posedge Clk)\n    disable iff (Reset == 0)\n    Reset == 1 |-> ##1 broadcast_drop == 0;\nendproperty\nassert_p_broadcast_drop_reset: assert property (p_broadcast_drop_reset) else $error(\"Assertion failed: broadcast_drop signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1419_13_1_1"
    },
    {
        "sva": "property p_opa_of_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 opa_of == 32'h0;\nendproperty\nassert_p_opa_of_assignment_on_grst: assert property (p_opa_of_assignment_on_grst) else $error(\"Assertion failed: opa_of is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "66_13_1_1"
    },
    {
        "sva": "property p_opa_of_assignment;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 opa_of == 32'h0;\nendproperty\nassert_p_opa_of_assignment: assert property (p_opa_of_assignment) else $error(\"Assertion failed: opa_of is not 32'h0 one cycle after grst is 1\");",
        "sva_id": "66_1_1_1"
    },
    {
        "sva": "property p_full_i_full;\n    @(posedge clock) disable iff (aclr == 1)\n        i_full == 1 |-> full == (i_full == 1);\nendproperty\nassert_p_full_i_full: assert property (p_full_i_full) else $error(\"Assertion failed: full signal does not reflect the correct state when i_full is 1\");",
        "sva_id": "464_4_1_1"
    },
    {
        "sva": "property p_empty_assignment;\n    @(posedge clock) disable iff (aclr == 1)\n        i_empty == 1 |-> empty == i_empty;\nendproperty\nassert_p_empty_assignment: assert property (p_empty_assignment) else $error(\"Assertion failed: empty signal does not match i_empty when i_empty is 1\");",
        "sva_id": "464_12_1_1"
    },
    {
        "sva": "property p_imm_of_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 imm_of == 16'h0;\nendproperty\nassert_p_imm_of_assignment_on_grst: assert property (p_imm_of_assignment_on_grst) else $error(\"Assertion failed: imm_of is not 16'h0 one cycle after grst is asserted\");",
        "sva_id": "66_10_1_1"
    },
    {
        "sva": "property p_full_assignment;\n    @(posedge clock) disable iff (aclr == 1)\n        i_full == 1 |-> full == 1;\nendproperty\nassert_p_full_assignment: assert property (p_full_assignment) else $error(\"Assertion failed: When i_full is 1, full should also be 1\");",
        "sva_id": "464_13_1_1"
    },
    {
        "sva": "property p_addr_assignment_logic;\n    @(posedge i_clk)\n        (w_write == 1 && astb == 1) |-> ##1 addr == $past(r_depp);\nendproperty\nassert_p_addr_assignment_logic: assert property (p_addr_assignment_logic) else $error(\"Assertion failed: addr signal does not match the expected value from r_depp after one clock cycle\");",
        "sva_id": "1301_1_1_1"
    },
    {
        "sva": "property p_e_cnt_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 e_cnt == 0;\nendproperty\nassert_p_e_cnt_reset: assert property (p_e_cnt_reset) else $error(\"Assertion failed: e_cnt is not reset to 0 one cycle after reset is asserted\");",
        "sva_id": "906_5_1_1"
    },
    {
        "sva": "property p_K_assignment_Step2;\n    @(posedge clk) disable iff (reset == 1)\n        (Step == Step2 && K < 1) |-> ##1 K == $past(K) + 1;\nendproperty\nassert_p_K_assignment_Step2: assert property (p_K_assignment_Step2) else $error(\"Assertion failed: K is not correctly incremented by 1 in Step2\");",
        "sva_id": "906_6_1_1"
    },
    {
        "sva": "property p_wb_dat_o_HWDATA;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        HWDATA == 32'hA5A5A5A5 |-> wb_dat_o == HWDATA;\nendproperty\nassert_p_wb_dat_o_HWDATA: assert property (p_wb_dat_o_HWDATA) else $error(\"Assertion failed: wb_dat_o does not match HWDATA when HWDATA is 32'hA5A5A5A5\");",
        "sva_id": "169_4_1_1"
    },
    {
        "sva": "property p_awvalid_reset;\n    @(posedge M_AXI_ACLK) disable iff (M_AXI_ARESETN == 1)\n        (M_AXI_ARESETN == 0) |-> ##1 (awvalid == 0);\nendproperty\nassert_p_awvalid_reset: assert property (p_awvalid_reset) else $error(\"Assertion failed: awvalid signal should be 0 one cycle after M_AXI_ARESETN is deasserted\");",
        "sva_id": "577_1_1_1"
    },
    {
        "sva": "property p_wb_we_o_master_wants_write;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        master_wants_write == 1 |-> wb_we_o == (master_wants_write == 1);\nendproperty\nassert_p_wb_we_o_master_wants_write: assert property (p_wb_we_o_master_wants_write) else $error(\"Assertion failed: wb_we_o signal does not reflect the correct state when master_wants_write is asserted\");",
        "sva_id": "169_5_1_1"
    },
    {
        "sva": "property p_HRDATA_wb_dat_i;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        wb_dat_i == 1 |-> HRDATA == wb_dat_i;\nendproperty\nassert_p_HRDATA_wb_dat_i: assert property (p_HRDATA_wb_dat_i) else $error(\"Assertion failed: HRDATA does not match wb_dat_i when wb_dat_i has a specific value\");",
        "sva_id": "169_24_1_1"
    },
    {
        "sva": "property p_mux_of_assignment_logic;\n    @(posedge gclk) disable iff (grst == 1)\n        (grst == 0 && dena == 1 && (hzd_bpc == 1 || hzd_fwd == 1 || fSTR == 1 || fRTD == 1 || fBCC == 1))\n        |-> ##1 mux_of == $past(MUX_NOP);\nendproperty\nassert_p_mux_of_assignment_logic: assert property (p_mux_of_assignment_logic) else $error(\"Assertion failed: mux_of does not match the expected value of $past(MUX_NOP) when conditions are met.\");",
        "sva_id": "66_11_1_1"
    },
    {
        "sva": "property p_wb_we_o_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        master_wants_write == 1 |-> wb_we_o == 1;\nendproperty\nassert_p_wb_we_o_assignment: assert property (p_wb_we_o_assignment) else $error(\"Assertion failed: When master_wants_write is 1, wb_we_o should be 1\");",
        "sva_id": "169_17_1_1"
    },
    {
        "sva": "property p_rHSIZE_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        (HRESETn == 0) |-> ##1 (rHSIZE == 0);\nendproperty\nassert_p_rHSIZE_assignment: assert property (p_rHSIZE_assignment) else $error(\"Assertion failed: rHSIZE is not assigned to 0 one cycle after HRESETn is deasserted\");",
        "sva_id": "169_7_1_1"
    },
    {
        "sva": "property p_sm_empty_aclr;\n    @(posedge clock) disable iff (aclr == 0)\n        aclr == 1 |-> ##1 sm_empty == 2'b00;\nendproperty\nassert_p_sm_empty_aclr: assert property (p_sm_empty_aclr) else $error(\"Assertion failed: sm_empty is not 2'b00 one cycle after aclr is asserted\");",
        "sva_id": "464_5_1_1"
    },
    {
        "sva": "property p_L1_assignment_logic;\n    @(posedge clk) disable iff (reset == 1)\n        L[2] == 1 |-> L1 == (L[2] == 1);\nendproperty\nassert_p_L1_assignment_logic: assert property (p_L1_assignment_logic) else $error(\"Assertion failed: L1 does not reflect the correct state when L[2] is 1\");",
        "sva_id": "906_15_1_1"
    },
    {
        "sva": "property p_add_dec1_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        IS_255_1 == 1 |-> add_dec1 == 8'h00;\nendproperty\nassert_p_add_dec1_assignment: assert property (p_add_dec1_assignment) else $error(\"Assertion failed: add_dec1 is not 8'h00 when IS_255_1 is 1\");",
        "sva_id": "906_18_1_1"
    },
    {
        "sva": "property p_HREADYOUT_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (r_wb_cyc_o == 1 && wb_ack_i == 1) |-> (HREADYOUT == 1);\nendproperty\nassert_p_HREADYOUT_assignment: assert property (p_HREADYOUT_assignment) else $error(\"Assertion failed: HREADYOUT signal is not assigned correctly when r_wb_cyc_o and wb_ack_i are both high\");",
        "sva_id": "169_23_1_1"
    },
    {
        "sva": "property p_wb_rst_o_negation;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        HRESETn == 0 |-> wb_rst_o == 1;\nendproperty\nassert_p_wb_rst_o_negation: assert property (p_wb_rst_o_negation) else $error(\"Assertion failed: wb_rst_o should be 1 when HRESETn is 0 at the rising edge of HCLK\");",
        "sva_id": "169_2_1_1"
    },
    {
        "sva": "property p_wb_adr_o_rHADDR;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (rHADDR == 32'hA5A5A5A5) |-> (wb_adr_o == rHADDR);\nendproperty\nassert_p_wb_adr_o_rHADDR: assert property (p_wb_adr_o_rHADDR) else $error(\"Assertion failed: wb_adr_o does not match rHADDR when rHADDR is 32'hA5A5A5A5\");",
        "sva_id": "169_3_1_1"
    },
    {
        "sva": "property p_i_full_assignment;\n    @(posedge clock) disable iff (aclr == 1)\n        (aclr == 0 && usedw_in >= almostfull && $time > 0) |-> ##1 i_full == 1'b1;\nendproperty\nassert_p_i_full_assignment: assert property (p_i_full_assignment) else $error(\"Assertion failed: i_full signal is not set to 1'b1 as expected when aclr is 0, usedw_in is greater than or equal to almostfull, and $time is greater than 0\");",
        "sva_id": "464_2_1_1"
    },
    {
        "sva": "property p_wb_rst_o_negation;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        (HRESETn == 0) |-> (wb_rst_o == 1);\nendproperty\nassert_p_wb_rst_o_negation: assert property (p_wb_rst_o_negation) else $error(\"Assertion failed: wb_rst_o is not asserted when HRESETn is deasserted\");",
        "sva_id": "169_22_1_1"
    },
    {
        "sva": "property p_rHTRANS_reset_logic;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        HRESETn == 0 |-> ##1 rHTRANS == 0;\nendproperty\nassert_p_rHTRANS_reset_logic: assert property (p_rHTRANS_reset_logic) else $error(\"Assertion failed: rHTRANS signal is not 0 one cycle after HRESETn is deasserted\");",
        "sva_id": "169_6_1_1"
    },
    {
        "sva": "property p_L_ready_Step8;\n    @(posedge clk) disable iff (reset == 1)\n    (reset == 0 && Step == Step8 && const_timing == 0) |-> ##1 L_ready == 1;\nendproperty\nassert_p_L_ready_Step8: assert property (p_L_ready_Step8) else $error(\"Assertion failed: L_ready signal is not set to 1 one cycle after Step is Step8 and const_timing is 0 while reset is 0\");",
        "sva_id": "906_12_1_1"
    },
    {
        "sva": "property p_rDINT_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rDINT == 2'h0;\nendproperty\nassert_p_rDINT_assignment_on_grst: assert property (p_rDINT_assignment_on_grst) else $error(\"Assertion failed: rDINT signal is not assigned to 2'h0 one cycle after grst is asserted.\");",
        "sva_id": "79_12_1_1"
    },
    {
        "sva": "property p_fIMM_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        rOPC == 6'o54 |-> fIMM == 1;\nendproperty\nassert_p_fIMM_assignment: assert property (p_fIMM_assignment) else $error(\"Assertion failed: When rOPC is 6'o54, fIMM should be 1\");",
        "sva_id": "79_20_1_1"
    },
    {
        "sva": "property p_r_wb_cyc_o_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        HRESETn == 0 |-> ##1 r_wb_cyc_o == 0;\nendproperty\nassert_p_r_wb_cyc_o_assignment: assert property (p_r_wb_cyc_o_assignment) else $error(\"Assertion failed: r_wb_cyc_o should be 0 one cycle after HRESETn is deasserted\");",
        "sva_id": "169_14_1_1"
    },
    {
        "sva": "property p_sm_empty_read_mode;\n    @(posedge clock) disable iff (aclr == 1)\n        (aclr == 0 && $time > 0 && lpm_mode == \"READ\" && sm_empty == 2'b00 && usedw_in != 0) |-> ##1 (sm_empty == 2'b01);\nendproperty\nassert_p_sm_empty_read_mode: assert property (p_sm_empty_read_mode) else $error(\"Assertion failed: sm_empty should transition to 2'b01 one cycle after the specified conditions are met in READ mode.\");",
        "sva_id": "464_6_1_1"
    },
    {
        "sva": "property p_S_and_Step_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0 && Step == Step1 && Sm_ready == 1) |-> \n        ##1 S[1] == $past(Sm1) && \n            S[2] == $past(Sm2) && \n            S[3] == $past(Sm3) && \n            S[4] == $past(Sm4) && \n            S[5] == $past(Sm5) && \n            S[6] == $past(Sm6) && \n            S[7] == $past(Sm7) && \n            S[8] == $past(Sm8) && \n            S[9] == $past(Sm9) && \n            S[10] == $past(Sm10) && \n            S[11] == $past(Sm11) && \n            S[12] == $past(Sm12) && \n            S[13] == $past(Sm13) && \n            S[14] == $past(Sm14) && \n            S[15] == $past(Sm15) && \n            S[16] == $past(Sm16) && \n            Step == $past(Step2);\nendproperty\nassert_p_S_and_Step_assignment: assert property (p_S_and_Step_assignment) else $error(\"Assertion failed: S and Step signals do not reflect the correct state after Step1 and Sm_ready\");",
        "sva_id": "906_4_1_1"
    },
    {
        "sva": "property p_rOPC_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rOPC == 6'h0;\nendproperty\nassert_p_rOPC_assignment_on_grst: assert property (p_rOPC_assignment_on_grst) else $error(\"Assertion failed: rOPC is not assigned to 6'h0 one cycle after grst is asserted\");",
        "sva_id": "79_11_1_1"
    },
    {
        "sva": "property p_rIMM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rIMM == 16'h0;\nendproperty\nassert_p_rIMM_assignment_on_grst: assert property (p_rIMM_assignment_on_grst) else $error(\"Assertion failed: rIMM is not assigned to 16'h0 one cycle after grst is asserted\");",
        "sva_id": "79_8_1_1"
    },
    {
        "sva": "property p_wIDAT_iwb_dat_i;\n    @(posedge gclk) disable iff (grst == 1)\n        iwb_dat_i == 8'hA5 |-> wIDAT == 8'hA5;\nendproperty\nassert_p_wIDAT_iwb_dat_i: assert property (p_wIDAT_iwb_dat_i) else $error(\"Assertion failed: When iwb_dat_i is 8'hA5, wIDAT should also be 8'hA5\");",
        "sva_id": "79_17_1_1"
    },
    {
        "sva": "property p_rSTALL_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rSTALL == 0;\nendproperty\nassert_p_rSTALL_assignment_on_grst: assert property (p_rSTALL_assignment_on_grst) else $error(\"Assertion failed: rSTALL signal is not 0 one cycle after grst is 1\");",
        "sva_id": "79_14_1_1"
    },
    {
        "sva": "property p_cop_clk_assignment;\n    @(posedge cop_clk) disable iff (async_rst_b == 0)\n        scantestmode == 1 |-> cop_clk == bus_clk;\nendproperty\nassert_p_cop_clk_assignment: assert property (p_cop_clk_assignment) else $error(\"Assertion failed: cop_clk does not match bus_clk when scantestmode is enabled\");",
        "sva_id": "371_12_1_1"
    },
    {
        "sva": "property p_fMUL_wOPC;\n    @(posedge gclk) disable iff (grst == 1)\n        wOPC == 6'o20 |-> fMUL == 1;\nendproperty\nassert_p_fMUL_wOPC: assert property (p_fMUL_wOPC) else $error(\"Assertion failed: When wOPC is 6'o20, fMUL should be 1\");",
        "sva_id": "79_25_1_1"
    },
    {
        "sva": "property p_rIMM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rIMM == 16'h0;\nendproperty\nassert_p_rIMM_assignment_on_grst: assert property (p_rIMM_assignment_on_grst) else $error(\"Assertion failed: rIMM is not assigned to 16'h0 one cycle after grst is asserted\");",
        "sva_id": "79_13_1_1"
    },
    {
        "sva": "property p_rHADDR_reset;\n    @(posedge HCLK) disable iff (HRESETn == 1)\n        (HRESETn == 0) |-> ##1 (rHADDR == 0);\nendproperty\nassert_p_rHADDR_reset: assert property (p_rHADDR_reset) else $error(\"Assertion failed: rHADDR is not 0 one cycle after HRESETn is deasserted\");",
        "sva_id": "169_13_1_1"
    },
    {
        "sva": "property p_fBCC_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (rOPC == 6'o47) |-> (fBCC == 1);\nendproperty\nassert_p_fBCC_assignment: assert property (p_fBCC_assignment) else $error(\"Assertion failed: fBCC signal is not assigned correctly when rOPC is 6'o47\");",
        "sva_id": "79_23_1_1"
    },
    {
        "sva": "property p_fBSF_wOPC;\n    @(posedge gclk) disable iff (grst == 1)\n        (wOPC == 6'o21) |-> (fBSF == 1);\nendproperty\nassert_p_fBSF_wOPC: assert property (p_fBSF_wOPC) else $error(\"Assertion failed: When wOPC is 6'o21, fBSF should be 1\");",
        "sva_id": "79_26_1_1"
    },
    {
        "sva": "property p_cop_clk_assignment;\n    @(posedge cop_clk) disable iff (async_rst_b == 0)\n        scantestmode == 1 |-> cop_clk == bus_clk;\nendproperty\nassert_p_cop_clk_assignment: assert property (p_cop_clk_assignment) else $error(\"Assertion failed: cop_clk does not match bus_clk when scantestmode is enabled\");",
        "sva_id": "371_20_1_1"
    },
    {
        "sva": "property p_fRTD_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        rOPC == 6'o55 |-> fRTD == 1;\nendproperty\nassert_p_fRTD_assignment: assert property (p_fRTD_assignment) else $error(\"Assertion failed: When rOPC is 6'o55, fRTD should be 1\");",
        "sva_id": "79_21_1_1"
    },
    {
        "sva": "property p_wb_dat_o_HWDATA;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        HWDATA == 32'hA5A5A5A5 |-> wb_dat_o == 32'hA5A5A5A5;\nendproperty\nassert_p_wb_dat_o_HWDATA: assert property (p_wb_dat_o_HWDATA) else $error(\"Assertion failed: wb_dat_o does not match HWDATA when HWDATA is 32'hA5A5A5A5\");",
        "sva_id": "169_18_1_1"
    },
    {
        "sva": "property p_cop_counter_assignment;\n    @(posedge cop_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_counter == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_cop_counter_assignment: assert property (p_cop_counter_assignment) else $error(\"Assertion failed: cop_counter is not assigned to all 1's one cycle after async_rst_b is deasserted\");",
        "sva_id": "371_2_1_1"
    },
    {
        "sva": "property p_cop_rst_o_assignment;\n    @(posedge cop_clk) disable iff (por_reset_i == 1)\n    por_reset_i == 0 |-> ##1 cop_rst_o == 0;\nendproperty\nassert_p_cop_rst_o_assignment: assert property (p_cop_rst_o_assignment) else $error(\"Assertion failed: cop_rst_o signal is not 0 one cycle after por_reset_i is deasserted\");",
        "sva_id": "371_5_1_1"
    },
    {
        "sva": "property p_rRA_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rRA == 5'h0;\nendproperty\nassert_p_rRA_assignment_on_grst: assert property (p_rRA_assignment_on_grst) else $error(\"Assertion failed: rRA is not assigned to 5'h0 one cycle after grst is asserted\");",
        "sva_id": "79_9_1_1"
    },
    {
        "sva": "property p_wSHOT_rDINT;\n    @(posedge gclk) disable iff (grst == 1)\n        rDINT == 8'b00000001 |-> wSHOT == rDINT[0];\nendproperty\nassert_p_wSHOT_rDINT: assert property (p_wSHOT_rDINT) else $error(\"Assertion failed: wSHOT does not match the least significant bit of rDINT when rDINT is 8'b00000001\");",
        "sva_id": "79_19_1_1"
    },
    {
        "sva": "property p_cop_irq_en_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_irq_en == 2'b00;\nendproperty\nassert_p_cop_irq_en_assignment: assert property (p_cop_irq_en_assignment) else $error(\"Assertion failed: cop_irq_en is not 2'b00 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_5_1_1"
    },
    {
        "sva": "property p_cop_irq_assignment_on_reset;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_irq == 0;\nendproperty\nassert_p_cop_irq_assignment_on_reset: assert property (p_cop_irq_assignment_on_reset) else $error(\"Assertion failed: cop_irq is not 0 one cycle after async_rst_b is deasserted.\");",
        "sva_id": "371_6_1_1"
    },
    {
        "sva": "property p_cop_event_assignment;\n    @(posedge bus_clk) disable iff (por_reset_i == 1)\n        por_reset_i == 0 |-> ##1 cop_event == 0;\nendproperty\nassert_p_cop_event_assignment: assert property (p_cop_event_assignment) else $error(\"Assertion failed: cop_event is not 0 one cycle after por_reset_i is deasserted\");",
        "sva_id": "371_7_1_1"
    },
    {
        "sva": "property p_rDINT_reset_logic;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rDINT == 2'h0;\nendproperty\nassert_p_rDINT_reset_logic: assert property (p_rDINT_reset_logic) else $error(\"Assertion failed: rDINT is not reset to 2'h0 one cycle after grst is asserted\");",
        "sva_id": "79_3_1_1"
    },
    {
        "sva": "property p_rSTALL_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rSTALL == 0;\nendproperty\nassert_p_rSTALL_grst: assert property (p_rSTALL_grst) else $error(\"Assertion failed: rSTALL signal is not 0 one cycle after grst is 1\");",
        "sva_id": "79_5_1_1"
    },
    {
        "sva": "property p_rALT_rIMM_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        rIMM == 8'hA5 |-> rALT == rIMM;\nendproperty\nassert_p_rALT_rIMM_assignment: assert property (p_rALT_rIMM_assignment) else $error(\"Assertion failed: rALT does not match rIMM when rIMM is 8'hA5\");",
        "sva_id": "79_10_1_1"
    },
    {
        "sva": "property p_wb_stb_o_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (master_wants_read == 1 && master_wants_write == 0) |-> (wb_stb_o == 1);\nendproperty\nassert_p_wb_stb_o_assignment: assert property (p_wb_stb_o_assignment) else $error(\"Assertion failed: When master wants to read and does not want to write, wb_stb_o should be 1\");",
        "sva_id": "169_16_1_1"
    },
    {
        "sva": "property p_cop_clk_resync1_reset;\n    @(posedge bus_clk) disable iff (sync_reset == 0)\n        sync_reset == 1 |-> ##1 cop_clk_resync1 == 0;\nendproperty\nassert_p_cop_clk_resync1_reset: assert property (p_cop_clk_resync1_reset) else $error(\"Assertion failed: cop_clk_resync1 is not 0 one cycle after sync_reset is asserted\");",
        "sva_id": "371_16_1_1"
    },
    {
        "sva": "property p_fBRU_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        (rOPC == 6'o46) |-> (fBRU == 1);\nendproperty\nassert_p_fBRU_assignment: assert property (p_fBRU_assignment) else $error(\"Assertion failed: When rOPC is 6'o46, fBRU should be 1\");",
        "sva_id": "79_22_1_1"
    },
    {
        "sva": "property p_HREADYOUT_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (r_wb_cyc_o == 1 && wb_ack_i == 1) |-> (HREADYOUT == 1);\nendproperty\nassert_p_HREADYOUT_assignment: assert property (p_HREADYOUT_assignment) else $error(\"Assertion failed: HREADYOUT signal is not set to 1 when r_wb_cyc_o and wb_ack_i are both 1\");",
        "sva_id": "169_8_1_1"
    },
    {
        "sva": "property p_stop_counter_debug_mode;\n    @(posedge cop_clk) disable iff (async_rst_b == 0)\n        (debug_mode_i == 1 && debug_ena == 1) |-> stop_counter == 1;\nendproperty\nassert_p_stop_counter_debug_mode: assert property (p_stop_counter_debug_mode) else $error(\"Assertion failed: stop_counter is not set to 1 when debug_mode_i and debug_ena are both enabled in debug mode\");",
        "sva_id": "371_9_1_1"
    },
    {
        "sva": "property p_const_timing_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0 && Step == Step1) |-> ##1 (const_timing == 500);\nendproperty\nassert_p_const_timing_assignment: assert property (p_const_timing_assignment) else $error(\"Assertion failed: const_timing is not equal to 500 one cycle after Step is Step1 and reset is deasserted\");",
        "sva_id": "906_16_1_1"
    },
    {
        "sva": "property p_rIMM_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 rIMM == 16'h0;\nendproperty\nassert_p_rIMM_assignment_on_grst: assert property (p_rIMM_assignment_on_grst) else $error(\"Assertion failed: rIMM is not assigned to 16'h0 one cycle after grst is asserted.\");",
        "sva_id": "79_2_1_1"
    },
    {
        "sva": "property p_master_wants_read_assignment;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (rHSEL == 1 && rHTRANS[1] == 1 && rHWRITE == 0) |-> (master_wants_read == 1);\nendproperty\nassert_p_master_wants_read_assignment: assert property (p_master_wants_read_assignment) else $error(\"Assertion failed: master_wants_read signal is not set correctly when master wants to read\");",
        "sva_id": "169_9_1_1"
    },
    {
        "sva": "property p_cop_capture_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_capture == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_cop_capture_assignment: assert property (p_cop_capture_assignment) else $error(\"Assertion failed: cop_capture does not match the expected value {COUNT_SIZE{1'b1}} one cycle after async_rst_b is deasserted\");",
        "sva_id": "371_4_1_1"
    },
    {
        "sva": "property p_sm_empty_assignment;\n    @(posedge clock) disable iff (aclr == 1)\n        (aclr == 0 && $time > 0 && lpm_mode == \"READ\" && sm_empty == 2'b00 && usedw_in != 0) |-> ##1 (sm_empty == 2'b01);\nendproperty\nassert_p_sm_empty_assignment: assert property (p_sm_empty_assignment) else $error(\"Assertion failed: sm_empty should be 2'b01 one cycle after the conditions are met\");",
        "sva_id": "464_10_1_1"
    },
    {
        "sva": "property p_D_assignment_logic_Step3;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0 && Step == Step3 && N == 0 && S[K + e_cnt] != 0) |-> ##1 (D == $past(S[K + e_cnt]) && Step == $past(Step4));\nendproperty\nassert_p_D_assignment_logic_Step3: assert property (p_D_assignment_logic_Step3) else $error(\"Assertion failed: D does not match the expected value or Step is not Step4 in the next cycle after the conditions are met.\");",
        "sva_id": "906_7_1_1"
    },
    {
        "sva": "property p_stop_counter_assignment;\n    @(posedge cop_clk)\n    disable iff (async_rst_b == 0 || por_reset_i == 0 || sync_reset == 1)\n    (stop_mode_i == 1 && stop_ena == 1) |-> (stop_counter == 1);\nendproperty\nassert_p_stop_counter_assignment: assert property (p_stop_counter_assignment) else $error(\"Assertion failed: stop_counter is not set to 1 when stop_mode_i and stop_ena are both 1\");",
        "sva_id": "371_11_1_1"
    },
    {
        "sva": "property p_cop_clk_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        scantestmode == 1 |-> cop_clk == bus_clk;\nendproperty\nassert_p_cop_clk_assignment: assert property (p_cop_clk_assignment) else $error(\"Assertion failed: cop_clk does not match bus_clk when scantestmode is enabled\");",
        "sva_id": "371_8_1_1"
    },
    {
        "sva": "property p_cop_counter_assignment;\n    @(posedge cop_clk) disable iff (async_rst_b==1)\n        async_rst_b == 0 |-> ##1 cop_counter == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_cop_counter_assignment: assert property (p_cop_counter_assignment) else $error(\"Assertion failed: cop_counter is not assigned to all 1's after async_rst_b is deasserted\");",
        "sva_id": "371_15_1_1"
    },
    {
        "sva": "property p_step_assignment_during_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 Step == $past(Step);\nendproperty\nassert_p_step_assignment_during_reset: assert property (p_step_assignment_during_reset) else $error(\"Assertion failed: Step signal does not match the previous value of Step1 during reset\");",
        "sva_id": "906_3_1_1"
    },
    {
        "sva": "property p_stop_counter_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        (wait_mode_i == 1 && wait_ena == 1) |-> (stop_counter == 1);\nendproperty\nassert_p_stop_counter_assignment: assert property (p_stop_counter_assignment) else $error(\"Assertion failed: stop_counter is not set to 1 when wait_mode_i and wait_ena are both 1\");",
        "sva_id": "371_10_1_1"
    },
    {
        "sva": "property p_cop_counter_init;\n    @(posedge cop_clk) disable iff (async_rst_b==1)\n        async_rst_b==0 |-> ##1 cop_counter == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_cop_counter_init: assert property (p_cop_counter_init) else $error(\"Assertion failed: cop_counter is not initialized to all 1's after reset\");",
        "sva_id": "371_1_1_1"
    },
    {
        "sva": "property p_timeout_value_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 timeout_value == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_timeout_value_assignment: assert property (p_timeout_value_assignment) else $error(\"Assertion failed: timeout_value is not assigned the correct value after reset\");",
        "sva_id": "372_4_1_1"
    },
    {
        "sva": "property p_add_1_reset_logic;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 add_1 == 0;\nendproperty\nassert_p_add_1_reset_logic: assert property (p_add_1_reset_logic) else $error(\"Assertion failed: add_1 signal should be 0 one cycle after reset is asserted\");",
        "sva_id": "906_1_1_1"
    },
    {
        "sva": "property p_cop_clk_posedge;\n    @(posedge cop_clk) disable iff (async_rst_b == 0)\n        (cop_clk_resync1 == 1 && cop_clk_resync2 == 0) |-> (cop_clk_posedge == (cop_clk_resync1 & ~cop_clk_resync2));\nendproperty\nassert_p_cop_clk_posedge: assert property (p_cop_clk_posedge) else $error(\"Assertion failed: cop_clk_posedge does not reflect the correct state based on cop_clk_resync1 and cop_clk_resync2\");",
        "sva_id": "371_14_1_1"
    },
    {
        "sva": "property p_cop_irq_o_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_irq_o == 0;\nendproperty\nassert_p_cop_irq_o_assignment: assert property (p_cop_irq_o_assignment) else $error(\"Assertion failed: cop_irq_o should be 0 one cycle after async_rst_b is deasserted.\");",
        "sva_id": "371_18_1_1"
    },
    {
        "sva": "property p_wait_ena_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b==1)\n        async_rst_b == 0 |-> ##1 wait_ena == 1'b0;\nendproperty\nassert_p_wait_ena_assignment: assert property (p_wait_ena_assignment) else $error(\"Assertion failed: wait_ena signal is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_8_1_1"
    },
    {
        "sva": "property p_clck_assignment_on_async_rst_b_deasserted;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 clck == 1'b0;\nendproperty\nassert_p_clck_assignment_on_async_rst_b_deasserted: assert property (p_clck_assignment_on_async_rst_b_deasserted) else $error(\"Assertion failed: clck signal is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_11_1_1"
    },
    {
        "sva": "property p_master_wants_read;\n    @(posedge HCLK) disable iff (HRESETn == 0)\n        (rHSEL == 1 && rHTRANS[1] == 1 && rHWRITE == 0) |-> \n        master_wants_read == (rHSEL == 1 && rHTRANS[1] == 1 && rHWRITE == 0);\nendproperty\nassert_p_master_wants_read: assert property (p_master_wants_read) else $error(\"Assertion failed: master_wants_read signal does not reflect the correct state when the master wants to read\");",
        "sva_id": "169_15_1_1"
    },
    {
        "sva": "property p_xwb_dat_o_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_dat_o == 32'h0;\nendproperty\nassert_p_xwb_dat_o_reset: assert property (p_xwb_dat_o_reset) else $error(\"Assertion failed: xwb_dat_o is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "76_2_1_1"
    },
    {
        "sva": "property p_debug_ena_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 debug_ena == 1'b0;\nendproperty\nassert_p_debug_ena_assignment: assert property (p_debug_ena_assignment) else $error(\"Assertion failed: debug_ena signal is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_6_1_1"
    },
    {
        "sva": "property p_xwb_wre_o_assignment;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_wre_o == 1'h0;\nendproperty\nassert_p_xwb_wre_o_assignment: assert property (p_xwb_wre_o_assignment) else $error(\"Assertion failed: xwb_wre_o is not assigned to 1'h0 one cycle after grst is asserted\");",
        "sva_id": "76_7_1_1"
    },
    {
        "sva": "property p_cop_ena_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_ena == $past(INIT_ENA);\nendproperty\nassert_p_cop_ena_assignment: assert property (p_cop_ena_assignment) else $error(\"Assertion failed: cop_ena does not match the past value of INIT_ENA one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_9_1_1"
    },
    {
        "sva": "property p_cwp_assignment_on_reset;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cwp == 1'b0;\nendproperty\nassert_p_cwp_assignment_on_reset: assert property (p_cwp_assignment_on_reset) else $error(\"Assertion failed: cwp signal is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_10_1_1"
    },
    {
        "sva": "property p_xwb_tag_o_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_tag_o == 1'h0;\nendproperty\nassert_p_xwb_tag_o_reset: assert property (p_xwb_tag_o_reset) else $error(\"Assertion failed: xwb_tag_o is not 0 one cycle after grst is 1\");",
        "sva_id": "76_4_1_1"
    },
    {
        "sva": "property p_add_1_reset_logic;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 add_1 == 0;\nendproperty\nassert_p_add_1_reset_logic: assert property (p_add_1_reset_logic) else $error(\"Assertion failed: add_1 signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "906_19_1_1"
    },
    {
        "sva": "property p_service_cop_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 service_cop == 0;\nendproperty\nassert_p_service_cop_assignment: assert property (p_service_cop_assignment) else $error(\"Assertion failed: service_cop is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_15_1_1"
    },
    {
        "sva": "property p_reload_count_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 reload_count == 1'b0;\nendproperty\nassert_p_reload_count_assignment: assert property (p_reload_count_assignment) else $error(\"Assertion failed: reload_count is not assigned to 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_12_1_1"
    },
    {
        "sva": "property p_xwb_lat_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_lat == 32'h0;\nendproperty\nassert_p_xwb_lat_reset: assert property (p_xwb_lat_reset) else $error(\"Assertion failed: xwb_lat is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "76_10_1_1"
    },
    {
        "sva": "property p_xwb_cyc_o_xwb_stb_o;\n    @(posedge gclk) disable iff (grst == 1)\n        xwb_stb_o == 1 |-> xwb_cyc_o == (xwb_stb_o == 1);\nendproperty\nassert_p_xwb_cyc_o_xwb_stb_o: assert property (p_xwb_cyc_o_xwb_stb_o) else $error(\"Assertion failed: xwb_cyc_o does not match the condition when xwb_stb_o is asserted.\");",
        "sva_id": "76_20_1_1"
    },
    {
        "sva": "property p_xwb_stb_o_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_stb_o == 0;\nendproperty\nassert_p_xwb_stb_o_grst: assert property (p_xwb_stb_o_grst) else $error(\"Assertion failed: xwb_stb_o signal is not 0 one cycle after grst is 1\");",
        "sva_id": "76_5_1_1"
    },
    {
        "sva": "property p_stop_ena_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 stop_ena == 1'b0;\nendproperty\nassert_p_stop_ena_assignment: assert property (p_stop_ena_assignment) else $error(\"Assertion failed: stop_ena signal should be 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "372_7_1_1"
    },
    {
        "sva": "property p_xwb_fb_xnor;\n    @(posedge gclk) disable iff (grst == 1)\n        (xwb_stb_o == 1 && xwb_ack_i == 0) |-> (xwb_fb == (xwb_stb_o ~^ xwb_ack_i));\nendproperty\nassert_p_xwb_fb_xnor: assert property (p_xwb_fb_xnor) else $error(\"Assertion failed: xwb_fb does not match the XNOR of xwb_stb_o and xwb_ack_i when xwb_stb_o is 1 and xwb_ack_i is 0\");",
        "sva_id": "76_8_1_1"
    },
    {
        "sva": "property p_xwb_mx_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_mx == 32'h0;\nendproperty\nassert_p_xwb_mx_reset: assert property (p_xwb_mx_reset) else $error(\"Assertion failed: xwb_mx is not 32'h0 one cycle after grst is asserted\");",
        "sva_id": "76_9_1_1"
    },
    {
        "sva": "property p_xwb_cyc_o_assignment;\n    @(posedge gclk) disable iff (grst == 1)\n        xwb_stb_o == 1 |-> xwb_cyc_o == 1;\nendproperty\nassert_p_xwb_cyc_o_assignment: assert property (p_xwb_cyc_o_assignment) else $error(\"Assertion failed: xwb_cyc_o is not assigned correctly when xwb_stb_o is asserted.\");",
        "sva_id": "76_6_1_1"
    },
    {
        "sva": "property p_xBLK_reset_logic;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xBLK == 0;\nendproperty\nassert_p_xBLK_reset_logic: assert property (p_xBLK_reset_logic) else $error(\"Assertion failed: xBLK signal is not 0 one cycle after grst is asserted\");",
        "sva_id": "76_17_1_1"
    },
    {
        "sva": "property p_wr_vld_assignment;\n    @(posedge clk) disable iff (reset_l == 0)\n        (wr_en == 1 && rst_tri_en == 0 && reset_l == 1) |-> (wr_vld == 1);\nendproperty\nassert_p_wr_vld_assignment: assert property (p_wr_vld_assignment) else $error(\"Assertion failed: wr_vld is not assigned correctly when wr_en is enabled, rst_tri_en is disabled, and reset_l is active\");",
        "sva_id": "977_2_1_1"
    },
    {
        "sva": "property p_wr_vld_assignment;\n    @(posedge clk) disable iff (reset_l == 0)\n        (wr_en == 1 && rst_tri_en == 0 && reset_l == 1) |-> (wr_vld == 1);\nendproperty\nassert_p_wr_vld_assignment: assert property (p_wr_vld_assignment) else $error(\"Assertion failed: wr_vld signal should be 1 when wr_en is 1, rst_tri_en is 0, and reset_l is 1\");",
        "sva_id": "977_5_1_1"
    },
    {
        "sva": "property p_wr_vld_assignment;\n    @(posedge clk) disable iff (reset_l == 0)\n        (wr_en == 1 && rst_tri_en == 0 && reset_l == 1) |-> (wr_vld == 1);\nendproperty\nassert_p_wr_vld_assignment: assert property (p_wr_vld_assignment) else $error(\"Assertion failed: wr_vld signal is not asserted when wr_en is enabled, rst_tri_en is disabled, and reset_l is active\");",
        "sva_id": "977_4_1_1"
    },
    {
        "sva": "property p_Step_assignment_logic;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0 && Step == Step3 && N != 0 && cnt == N + 4 && (D ^ dec1) == 0) |-> ##1 (Step == Step6);\nendproperty\nassert_p_Step_assignment_logic: assert property (p_Step_assignment_logic) else $error(\"Assertion failed: Step should be Step6 one cycle after the specified conditions are met.\");",
        "sva_id": "906_14_1_1"
    },
    {
        "sva": "property p_xwb_fb_xnor;\n    @(posedge gclk) disable iff (grst == 1)\n        (xwb_stb_o == 1 && xwb_ack_i == 0) |-> (xwb_fb == (xwb_stb_o ~^ xwb_ack_i));\nendproperty\nassert_p_xwb_fb_xnor: assert property (p_xwb_fb_xnor) else $error(\"Assertion failed: xwb_fb does not reflect the XNOR of xwb_stb_o and xwb_ack_i when xwb_stb_o is 1 and xwb_ack_i is 0\");",
        "sva_id": "76_18_1_1"
    },
    {
        "sva": "property p_cc_assignment_on_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 cc == 0;\nendproperty\nassert_p_cc_assignment_on_reset: assert property (p_cc_assignment_on_reset) else $error(\"Assertion failed: cc signal is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "678_12_1_1"
    },
    {
        "sva": "property p_timeout_value_assignment_during_async_reset;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 timeout_value == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_timeout_value_assignment_during_async_reset: assert property (p_timeout_value_assignment_during_async_reset) else $error(\"Assertion failed: timeout_value is not assigned to all 1's during asynchronous reset\");",
        "sva_id": "372_2_1_1"
    },
    {
        "sva": "property p_xwb_adr_o_reset;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_adr_o == {((1+(AEMB_XWB-1)-(2))){1'b0}};\nendproperty\nassert_p_xwb_adr_o_reset: assert property (p_xwb_adr_o_reset) else $error(\"Assertion failed: xwb_adr_o does not match the expected reset pattern after grst is asserted.\");",
        "sva_id": "76_14_1_1"
    },
    {
        "sva": "property p_O_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (B == 1 && D == 1 && A == 0 && C == 0) |-> (O == ((B & D) | (~A & ~C)));\nendproperty\nassert_p_O_assignment_logic: assert property (p_O_assignment_logic) else $error(\"Assertion failed: O signal does not reflect the correct assignment logic when B == 1, D == 1, A == 0, and C == 0\");",
        "sva_id": "678_19_1_1"
    },
    {
        "sva": "property p_HCN_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (HBF == 1 && np == p) |-> (HCN == (HBF & (np == p)));\nendproperty\nassert_p_HCN_assignment: assert property (p_HCN_assignment) else $error(\"Assertion failed: HCN signal does not reflect the correct state when HBF is 1 and np equals p\");",
        "sva_id": "678_3_1_1"
    },
    {
        "sva": "property p_Quotient_assignment;\n    @(posedge clock) disable iff (reset == 1)\n        neg == 0 |-> Quotient == result;\nendproperty\nassert_p_Quotient_assignment: assert property (p_Quotient_assignment) else $error(\"Assertion failed: Quotient does not match result when neg is 0\");",
        "sva_id": "705_6_1_1"
    },
    {
        "sva": "property p_Ep_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (A == 1 && B == 0) |-> (Ep == (1 & ~0));\nendproperty\nassert_p_Ep_assignment: assert property (p_Ep_assignment) else $error(\"Assertion failed: Ep signal does not reflect the correct state when A is 1 and B is 0\");",
        "sva_id": "678_18_1_1"
    },
    {
        "sva": "property p_timeout_value_assignment_during_reset;\n    @(posedge bus_clk)\n    disable iff (sync_reset == 0)\n    sync_reset == 1 |-> ##1 timeout_value == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_timeout_value_assignment_during_reset: assert property (p_timeout_value_assignment_during_reset) else $error(\"Assertion failed: timeout_value is not assigned to all 1's during reset\");",
        "sva_id": "372_3_1_1"
    },
    {
        "sva": "property p_data_out_lane_polarity;\n    @(posedge clk) disable iff (res_n == 0)\n        lane_polarity == 1 |-> data_out == (data_out_temp ^ {DWIDTH{1'b1}});\nendproperty\nassert_p_data_out_lane_polarity: assert property (p_data_out_lane_polarity) else $error(\"Assertion failed: data_out does not match the expected polarity-inverted value of data_out_temp when lane_polarity is 1\");",
        "sva_id": "774_6_1_1"
    },
    {
        "sva": "property p_data_out_lane_polarity;\n    @(posedge clk) disable iff (res_n == 0)\n        lane_polarity == 1 |-> data_out == (data_out_temp ^ {DWIDTH{1'b1}});\nendproperty\nassert_p_data_out_lane_polarity: assert property (p_data_out_lane_polarity) else $error(\"Assertion failed: data_out does not match the expected polarity-inverted value of data_out_temp when lane_polarity is 1\");",
        "sva_id": "774_7_1_1"
    },
    {
        "sva": "property p_CLR_Ec_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        Ec == 1 |-> CLR == (Ec == 1);\nendproperty\nassert_p_CLR_Ec_assignment: assert property (p_CLR_Ec_assignment) else $error(\"Assertion failed: CLR signal does not reflect the correct state when Ec is 1\");",
        "sva_id": "678_20_1_1"
    },
    {
        "sva": "property p_DMG_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (O == 1 && f == 0 && hp != h) |-> (DMG == (O & ~(f & (hp == h))));\nendproperty\nassert_p_DMG_assignment: assert property (p_DMG_assignment) else $error(\"Assertion failed: DMG signal does not reflect the correct state when O is 1, f is 0, and hp is not equal to h\");",
        "sva_id": "678_15_1_1"
    },
    {
        "sva": "property p_Stall_active;\n    @(posedge clock) disable iff (reset == 1)\n        active == 1 |-> Stall == (active == 1);\nendproperty\nassert_p_Stall_active: assert property (p_Stall_active) else $error(\"Assertion failed: Stall signal does not reflect the correct state when active is asserted\");",
        "sva_id": "705_8_1_1"
    },
    {
        "sva": "property p_HCN_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (HBF == 1 && np == p) |-> (HCN == (HBF & (np == p)));\nendproperty\nassert_p_HCN_assignment: assert property (p_HCN_assignment) else $error(\"Assertion failed: HCN signal does not reflect the correct state when HBF is 1 and np equals p\");",
        "sva_id": "678_21_1_1"
    },
    {
        "sva": "property p_clk_assignment_logic;\n    @(posedge rclk) disable iff (reset_l == 0)\n        clk == rclk;\nendproperty\nassert_p_clk_assignment_logic: assert property (p_clk_assignment_logic) else $error(\"Assertion failed: clk does not match rclk at the rising edge of rclk when reset_l is not active\");",
        "sva_id": "977_12_1_1"
    },
    {
        "sva": "property p_cop_rst_o_assignment;\n    @(posedge cop_clk) disable iff (por_reset_i == 1)\n        por_reset_i == 0 |-> ##1 cop_rst_o == 0;\nendproperty\nassert_p_cop_rst_o_assignment: assert property (p_cop_rst_o_assignment) else $error(\"Assertion failed: cop_rst_o is not 0 one cycle after por_reset_i is deasserted\");",
        "sva_id": "371_17_1_1"
    },
    {
        "sva": "property p_cc_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && datavalid == 1 && Ec == 1 && cc < '1) |-> ##1 cc == $past(cc) + 1;\nendproperty\nassert_p_cc_assignment_logic: assert property (p_cc_assignment_logic) else $error(\"Assertion failed: cc signal did not increment correctly when conditions were met.\");",
        "sva_id": "678_13_1_1"
    },
    {
        "sva": "property p_D_assignment_Step3_N0;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0 && Step == Step3 && N == 0 && S[K + e_cnt] != 0) |-> ##1 D == $past(S[K + e_cnt]);\nendproperty\nassert_p_D_assignment_Step3_N0: assert property (p_D_assignment_Step3_N0) else $error(\"Assertion failed: D does not match the past value of S[K + e_cnt] when Step is Step3 and N is 0\");",
        "sva_id": "906_17_1_1"
    },
    {
        "sva": "property p_cc_assignment_on_rst;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 cc == 0;\nendproperty\nassert_p_cc_assignment_on_rst: assert property (p_cc_assignment_on_rst) else $error(\"Assertion failed: cc is not assigned to 0 one cycle after rst is asserted\");",
        "sva_id": "678_11_1_1"
    },
    {
        "sva": "property p_wr_vld_assignment;\n    @(posedge clk) disable iff (reset_l == 0)\n        (wr_en == 1 && rst_tri_en == 0 && reset_l == 1) |-> (wr_vld == (wr_en && !rst_tri_en && reset_l));\nendproperty\nassert_p_wr_vld_assignment: assert property (p_wr_vld_assignment) else $error(\"Assertion failed: wr_vld signal does not reflect the correct state when wr_en is enabled, rst_tri_en is disabled, and reset_l is active\");",
        "sva_id": "977_16_1_1"
    },
    {
        "sva": "property p_data_out_temp_assignment;\n    @(posedge clk) disable iff (res_n == 0)\n        (res_n == 1 && bit_slip_cnt < DWIDTH-1) |-> ##1 data_out_temp == $past(buffer2);\nendproperty\nassert_p_data_out_temp_assignment: assert property (p_data_out_temp_assignment) else $error(\"Assertion failed: data_out_temp does not match the past value of buffer2 when res_n is 1 and bit_slip_cnt is less than DWIDTH-1\");",
        "sva_id": "774_10_1_1"
    },
    {
        "sva": "property p_DMG_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (O == 1 && f == 0 && hp == h) |-> (DMG == (O & ~(f & (hp == h))));\nendproperty\nassert_p_DMG_assignment_logic: assert property (p_DMG_assignment_logic) else $error(\"Assertion failed: DMG assignment logic is incorrect when O == 1, f == 0, and hp == h\");",
        "sva_id": "678_9_1_1"
    },
    {
        "sva": "property p_wr_vld_rst_tri_en;\n    @(posedge clk) disable iff (reset_l == 0)\n        (reset_l == 1 && rst_tri_en == 1 && wr_en == 1) |-> (wr_vld == 0);\nendproperty\nassert_p_wr_vld_rst_tri_en: assert property (p_wr_vld_rst_tri_en) else $error(\"Assertion failed: When reset_l, rst_tri_en, and wr_en are all high, wr_vld should be low.\");",
        "sva_id": "977_9_1_1"
    },
    {
        "sva": "property p_xBLK_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xBLK == 0;\nendproperty\nassert_p_xBLK_assignment_on_grst: assert property (p_xBLK_assignment_on_grst) else $error(\"Assertion failed: xBLK is not assigned to 0 one cycle after grst is asserted\");",
        "sva_id": "76_12_1_1"
    },
    {
        "sva": "property p_cc_assignment_on_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 cc == 0;\nendproperty\nassert_p_cc_assignment_on_reset: assert property (p_cc_assignment_on_reset) else $error(\"Assertion failed: cc is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "678_2_1_1"
    },
    {
        "sva": "property p_bit_slip_cnt_reset;\n    @(posedge clk) disable iff (res_n == 1)\n        res_n == 0 |-> ##1 bit_slip_cnt == 0;\nendproperty\nassert_p_bit_slip_cnt_reset: assert property (p_bit_slip_cnt_reset) else $error(\"Assertion failed: bit_slip_cnt is not reset to 0 one cycle after res_n is deasserted\");",
        "sva_id": "774_8_1_1"
    },
    {
        "sva": "property p_remainder_work_assignment;\n    @(posedge clock) disable iff (reset == 1)\n        (work == 5) |-> (Remainder == 5);\nendproperty\nassert_p_remainder_work_assignment: assert property (p_remainder_work_assignment) else $error(\"Assertion failed: When work is 5, Remainder should be 5\");",
        "sva_id": "705_7_1_1"
    },
    {
        "sva": "property p_dout_assignment_logic;\n    @(posedge clk) disable iff (reset_l == 0)\n        (reset_l == 1 && rd_en == 1) |-> ##1 dout == $past(dfq_mem[rd_adr[4:0]]);\nendproperty\nassert_p_dout_assignment_logic: assert property (p_dout_assignment_logic) else $error(\"Assertion failed: dout signal does not reflect the correct state based on dfq_mem and rd_adr after one clock cycle\");",
        "sva_id": "977_6_1_1"
    },
    {
        "sva": "property p_cc_reset_logic;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 cc == 0;\nendproperty\nassert_p_cc_reset_logic: assert property (p_cc_reset_logic) else $error(\"Assertion failed: cc signal is not 0 one cycle after rst is asserted\");",
        "sva_id": "678_6_1_1"
    },
    {
        "sva": "property p_cop_counter_reset;\n    @(posedge cop_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 cop_counter == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_cop_counter_reset: assert property (p_cop_counter_reset) else $error(\"Assertion failed: cop_counter is not reset to all 1's one cycle after async_rst_b is deasserted\");",
        "sva_id": "371_19_1_1"
    },
    {
        "sva": "property p_cycle_assignment_OP_div;\n    @(posedge clock) disable iff (reset == 1)\n        (reset == 0 && OP_div == 1) |-> ##1 cycle == 31;\nendproperty\nassert_p_cycle_assignment_OP_div: assert property (p_cycle_assignment_OP_div) else $error(\"Assertion failed: cycle is not equal to 31 one cycle after OP_div is asserted while reset is deasserted\");",
        "sva_id": "705_3_1_1"
    },
    {
        "sva": "property p_active_reset_logic;\n    @(posedge clock) disable iff (reset == 0)\n        reset == 1 |-> ##1 active == 0;\nendproperty\nassert_p_active_reset_logic: assert property (p_active_reset_logic) else $error(\"Assertion failed: 'active' signal is not 0 one cycle after 'reset' is asserted\");",
        "sva_id": "705_2_1_1"
    },
    {
        "sva": "property p_timeout_value_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 timeout_value == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_timeout_value_assignment: assert property (p_timeout_value_assignment) else $error(\"Assertion failed: timeout_value is not assigned to the maximum value after async_rst_b is deasserted.\");",
        "sva_id": "372_1_1_1"
    },
    {
        "sva": "property p_mode6_assignment;\n    @(posedge clk)\n        (CS == 1 && WR == 1) |-> ##1 mode[6] == 1;\nendproperty\nassert_p_mode6_assignment: assert property (p_mode6_assignment) else $error(\"Assertion failed: mode[6] is not assigned to 1 one cycle after CS and WR are both 1\");",
        "sva_id": "752_2_1_1"
    },
    {
        "sva": "property p_xwb_adr_o_assignment_on_grst;\n    @(posedge gclk) disable iff (grst == 0)\n        grst == 1 |-> ##1 xwb_adr_o == {((1+(AEMB_XWB-1)-(2))){1'b0}};\nendproperty\nassert_p_xwb_adr_o_assignment_on_grst: assert property (p_xwb_adr_o_assignment_on_grst) else $error(\"Assertion failed: xwb_adr_o does not match the expected assignment when grst is asserted\");",
        "sva_id": "76_13_1_1"
    },
    {
        "sva": "property p_curr_bit_assignment;\n    @(posedge fast_clk) disable iff (res_n == 1)\n        res_n == 0 |-> ##1 curr_bit == {LOG_DWIDTH{1'b0}};\nendproperty\nassert_p_curr_bit_assignment: assert property (p_curr_bit_assignment) else $error(\"Assertion failed: curr_bit is not assigned to all zeros one cycle after res_n is deasserted\");",
        "sva_id": "774_1_1_1"
    },
    {
        "sva": "property p_curr_bit_assignment;\n    @(posedge fast_clk) disable iff (res_n == 1)\n        res_n == 0 |-> ##1 curr_bit == {LOG_DWIDTH{1'b0}};\nendproperty\nassert_p_curr_bit_assignment: assert property (p_curr_bit_assignment) else $error(\"Assertion failed: curr_bit is not assigned to {LOG_DWIDTH{1'b0}} one cycle after res_n is 0\");",
        "sva_id": "774_3_1_1"
    },
    {
        "sva": "property p_curr_bit_assignment;\n    @(posedge fast_clk) disable iff (res_n == 1)\n        res_n == 0 |-> ##1 curr_bit == 1'b0;\nendproperty\nassert_p_curr_bit_assignment: assert property (p_curr_bit_assignment) else $error(\"Assertion failed: curr_bit is not '0' one cycle after res_n is '0'\");",
        "sva_id": "774_5_1_1"
    },
    {
        "sva": "property p_module_sel_assignment;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i)\n    (wb_cyc_i == 1 && wb_stb_i == 1) |-> module_sel == (wb_cyc_i == 1 && wb_stb_i == 1);\nendproperty\nassert_p_module_sel_assignment: assert property (p_module_sel_assignment) else $error(\"Assertion failed: module_sel does not correctly reflect the state when wb_cyc_i and wb_stb_i are both asserted\");",
        "sva_id": "373_8_1_1"
    },
    {
        "sva": "property p_cc_reset_logic;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 cc == 0;\nendproperty\nassert_p_cc_reset_logic: assert property (p_cc_reset_logic) else $error(\"Assertion failed: cc signal is not 0 one cycle after rst is asserted\");",
        "sva_id": "678_5_1_1"
    },
    {
        "sva": "property p_active_reset_logic;\n    @(posedge clock) disable iff (reset == 0)\n        reset == 1 |-> ##1 active == 0;\nendproperty\nassert_p_active_reset_logic: assert property (p_active_reset_logic) else $error(\"Assertion failed: 'active' signal should be 0 one cycle after 'reset' is asserted.\");",
        "sva_id": "705_1_1_1"
    },
    {
        "sva": "property p_module_sel_assignment;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i == 1)\n    (wb_cyc_i == 1 && wb_stb_i == 1) |-> (module_sel == (wb_cyc_i == 1 && wb_stb_i == 1));\nendproperty\nassert_p_module_sel_assignment: assert property (p_module_sel_assignment) else $error(\"Assertion failed: module_sel does not correctly reflect the state when wb_cyc_i and wb_stb_i are both asserted\");",
        "sva_id": "373_7_1_1"
    },
    {
        "sva": "property p_bus_wait_state_assignment;\n    @(posedge wb_clk_i) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 bus_wait_state == 0;\nendproperty\nassert_p_bus_wait_state_assignment: assert property (p_bus_wait_state_assignment) else $error(\"Assertion failed: bus_wait_state is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "373_2_1_1"
    },
    {
        "sva": "property p_timeout_value_assignment;\n    @(posedge bus_clk) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 timeout_value == {COUNT_SIZE{1'b1}};\nendproperty\nassert_p_timeout_value_assignment: assert property (p_timeout_value_assignment) else $error(\"Assertion failed: timeout_value is not assigned to all 1's after async_rst_b is deasserted\");",
        "sva_id": "372_17_1_1"
    },
    {
        "sva": "property p_sync_reset_assignment;\n    @(posedge wb_clk_i) disable iff (wb_rst_i == 0)\n        wb_rst_i == 1 |-> sync_reset == wb_rst_i;\nendproperty\nassert_p_sync_reset_assignment: assert property (p_sync_reset_assignment) else $error(\"Assertion failed: sync_reset signal does not match wb_rst_i when wb_rst_i is asserted\");",
        "sva_id": "373_19_1_1"
    },
    {
        "sva": "property p_rd_assignment_logic;\n    @(posedge clk)\n        (CS == 1 && WR == 0) |-> ##1 (rd == ~$past(rd));\nendproperty\nassert_p_rd_assignment_logic: assert property (p_rd_assignment_logic) else $error(\"Assertion failed: rd signal does not reflect the correct inverted state one cycle after the condition CS == 1 && WR == 0 is met\");",
        "sva_id": "752_14_1_1"
    },
    {
        "sva": "property p_module_sel_assignment;\n    @(posedge wb_clk_i) disable iff (wb_rst_i)\n        (wb_cyc_i == 1 && wb_stb_i == 1) |-> module_sel == (wb_cyc_i == 1 && wb_stb_i == 1);\nendproperty\nassert_p_module_sel_assignment: assert property (p_module_sel_assignment) else $error(\"Assertion failed: module_sel does not reflect the correct state when wb_cyc_i and wb_stb_i are both asserted\");",
        "sva_id": "373_4_1_1"
    },
    {
        "sva": "property p_wb_wacc_assignment;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i == 1)\n    (module_sel == 1 && wb_we_i == 1 && wb_ack_o == 1) |-> (wb_wacc == 1);\nendproperty\nassert_p_wb_wacc_assignment: assert property (p_wb_wacc_assignment) else $error(\"Assertion failed: wb_wacc signal should be 1 when module_sel, wb_we_i, and wb_ack_o are all 1\");",
        "sva_id": "373_6_1_1"
    },
    {
        "sva": "property p_wb_wacc_assignment;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i)\n    (module_sel == 1 && wb_we_i == 1 && (wb_ack_o == 1 || SINGLE_CYCLE == 1)) |-> \n    wb_wacc == (module_sel == 1 && wb_we_i == 1 && (wb_ack_o == 1 || SINGLE_CYCLE == 1));\nendproperty\nassert_p_wb_wacc_assignment: assert property (p_wb_wacc_assignment) else $error(\"Assertion failed: wb_wacc signal does not reflect the correct state when module_sel, wb_we_i, and wb_ack_o or SINGLE_CYCLE conditions are met\");",
        "sva_id": "373_21_1_1"
    },
    {
        "sva": "property p_in_alu_ctl_state_alu;\n    @(posedge clk) disable iff (nreset == 0)\n        ctl_state_alu == 1 |-> in_alu == ctl_state_alu;\nendproperty\nassert_p_in_alu_ctl_state_alu: assert property (p_in_alu_ctl_state_alu) else $error(\"Assertion failed: in_alu signal does not match ctl_state_alu when ctl_state_alu is 1\");",
        "sva_id": "38_9_1_1"
    },
    {
        "sva": "property p_async_rst_b_assignment;\n    @(posedge wb_clk_i)\n    disable iff (arst_i == 0)\n    (arst_i == 1 && ARST_LVL == 0) |-> async_rst_b == (arst_i ^ ARST_LVL);\nendproperty\nassert_p_async_rst_b_assignment: assert property (p_async_rst_b_assignment) else $error(\"Assertion failed: async_rst_b does not match the expected value when arst_i is asserted and ARST_LVL is 0\");",
        "sva_id": "373_3_1_1"
    },
    {
        "sva": "property p_async_rst_b_xor;\n    @(posedge wb_clk_i) disable iff (arst_i == 0)\n        (arst_i == 1 && ARST_LVL == 1'b0) |-> async_rst_b == (arst_i ^ ARST_LVL);\nendproperty\nassert_p_async_rst_b_xor: assert property (p_async_rst_b_xor) else $error(\"Assertion failed: async_rst_b signal does not match the expected XOR result of arst_i and ARST_LVL\");",
        "sva_id": "373_18_1_1"
    },
    {
        "sva": "property p_wb_racc_assignment;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i == 1)\n    (module_sel == 1 && wb_we_i == 0) |-> (wb_racc == (module_sel & ~wb_we_i));\nendproperty\nassert_p_wb_racc_assignment: assert property (p_wb_racc_assignment) else $error(\"Assertion failed: wb_racc signal does not reflect the correct state when module_sel is 1 and wb_we_i is 0\");",
        "sva_id": "373_22_1_1"
    },
    {
        "sva": "property p_mode6_assignment;\n    @(posedge clk)\n        (CS == 1 && WR == 1) |-> ##1 (mode[6] == 1);\nendproperty\nassert_p_mode6_assignment: assert property (p_mode6_assignment) else $error(\"Assertion failed: mode[6] is not set to 1 one cycle after CS and WR are both 1\");",
        "sva_id": "752_1_1_1"
    },
    {
        "sva": "property p_Mdo_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Mdo == 0;\nendproperty\nassert_p_Mdo_reset_logic: assert property (p_Mdo_reset_logic) else $error(\"Assertion failed: Mdo signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1424_4_1_1"
    },
    {
        "sva": "property p_mode6_assignment;\n    @(posedge clk)\n        (CS == 1 && WR == 1) |-> ##1 (mode[6] == 1);\nendproperty\nassert_p_mode6_assignment: assert property (p_mode6_assignment) else $error(\"Assertion failed: mode[6] is not assigned correctly when CS and WR are both high\");",
        "sva_id": "752_8_1_1"
    },
    {
        "sva": "property p_bus_wait_state_assignment;\n    @(posedge wb_clk_i) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 bus_wait_state == 0;\nendproperty\nassert_p_bus_wait_state_assignment: assert property (p_bus_wait_state_assignment) else $error(\"Assertion failed: bus_wait_state is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "373_16_1_1"
    },
    {
        "sva": "property p_mode_6_assignment;\n    @(posedge clk)\n        (CS == 1 && WR == 1) |-> ##1 (mode[6] == 1);\nendproperty\nassert_p_mode_6_assignment: assert property (p_mode_6_assignment) else $error(\"Assertion failed: mode[6] is not assigned to 1 one cycle after CS and WR are both 1\");",
        "sva_id": "752_11_1_1"
    },
    {
        "sva": "property p_async_rst_b_xor;\n    @(posedge wb_clk_i)\n    disable iff (arst_i == 0)\n    (arst_i == 1 && ARST_LVL == 1'b0) |-> async_rst_b == (arst_i ^ ARST_LVL);\nendproperty\nassert_p_async_rst_b_xor: assert property (p_async_rst_b_xor) else $error(\"Assertion failed: async_rst_b does not match the expected value of (arst_i ^ ARST_LVL) when arst_i is 1 and ARST_LVL is 0\");",
        "sva_id": "373_14_1_1"
    },
    {
        "sva": "property p_wb_wacc_assignment_logic;\n    @(posedge wb_clk_i) disable iff (wb_rst_i)\n        (module_sel == 1 && wb_we_i == 1 && (wb_ack_o == 1 || SINGLE_CYCLE == 1)) |-> \n        wb_wacc == (module_sel == 1 && wb_we_i == 1 && (wb_ack_o == 1 || SINGLE_CYCLE == 1));\nendproperty\nassert_p_wb_wacc_assignment_logic: assert property (p_wb_wacc_assignment_logic) else $error(\"Assertion failed: wb_wacc does not reflect the correct state when module_sel, wb_we_i, and wb_ack_o or SINGLE_CYCLE are asserted\");",
        "sva_id": "373_5_1_1"
    },
    {
        "sva": "property p_dout_assignment_logic;\n    @(posedge clk)\n        (mode[5] == 1 && mode[4] == 0) |-> (dout == count[15:8]);\nendproperty\nassert_p_dout_assignment_logic: assert property (p_dout_assignment_logic) else $error(\"Assertion failed: dout does not match count[15:8] when mode[5] is 1 and mode[4] is 0\");",
        "sva_id": "752_17_1_1"
    },
    {
        "sva": "property p_MdoEn_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 (MdoEn_2d == 0 && MdoEn_d == 0 && MdoEn == 0);\nendproperty\nassert_p_MdoEn_reset_logic: assert property (p_MdoEn_reset_logic) else $error(\"Assertion failed: MdoEn signals are not all zero after one cycle of Reset being high\");",
        "sva_id": "1424_1_1_1"
    },
    {
        "sva": "property p_timer_reset_logic;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 timer == 16'h0000;\nendproperty\nassert_p_timer_reset_logic: assert property (p_timer_reset_logic) else $error(\"Assertion failed: timer signal is not reset to 16'h0000 one cycle after rst is deasserted\");",
        "sva_id": "1563_13_1_1"
    },
    {
        "sva": "property p_sva_z_stb_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        s_sva_z_stb == 1 |-> sva_z_stb == s_sva_z_stb;\nendproperty\nassert_p_sva_z_stb_assignment: assert property (p_sva_z_stb_assignment) else $error(\"Assertion failed: sva_z_stb does not match s_sva_z_stb when s_sva_z_stb is asserted\");",
        "sva_id": "1563_18_1_1"
    },
    {
        "sva": "property p_sva_z_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        s_sva_z == 1 |-> sva_z == s_sva_z;\nendproperty\nassert_p_sva_z_assignment: assert property (p_sva_z_assignment) else $error(\"Assertion failed: sva_z does not match s_sva_z when s_sva_z is 1\");",
        "sva_id": "1563_19_1_1"
    },
    {
        "sva": "property p_timer_reset_logic;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 timer == 16'h0000;\nendproperty\nassert_p_timer_reset_logic: assert property (p_timer_reset_logic) else $error(\"Assertion failed: timer is not reset to 16'h0000 one cycle after rst is deasserted\");",
        "sva_id": "1563_15_1_1"
    },
    {
        "sva": "property p_SerialEn_assignment_logic;\n    @(posedge Clk) disable iff (Reset == 1)\n        (WriteOp == 1 && InProgress == 1 && BitCounter == 0 && NoPre == 1) |-> (SerialEn == 1);\nendproperty\nassert_p_SerialEn_assignment_logic: assert property (p_SerialEn_assignment_logic) else $error(\"Assertion failed: SerialEn should be 1 when WriteOp, InProgress, BitCounter, and NoPre conditions are met.\");",
        "sva_id": "1424_7_1_1"
    },
    {
        "sva": "property p_wb_wacc_assignment;\n    @(posedge wb_clk_i) disable iff (wb_rst_i == 1)\n        (module_sel == 1 && wb_we_i == 1 && wb_ack_o == 1) |-> (wb_wacc == 1);\nendproperty\nassert_p_wb_wacc_assignment: assert property (p_wb_wacc_assignment) else $error(\"Assertion failed: wb_wacc signal should be 1 when module_sel, wb_we_i, and wb_ack_o are all 1\");",
        "sva_id": "373_13_1_1"
    },
    {
        "sva": "property p_cstate_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_assignment: assert property (p_cstate_assignment) else $error(\"Assertion failed: cstate is not assigned to 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_1_1_1"
    },
    {
        "sva": "property p_cstate_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_assignment_logic: assert property (p_cstate_assignment_logic) else $error(\"Assertion failed: cstate is not assigned to 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_5_1_1"
    },
    {
        "sva": "property p_cstate_assignment;\n    @(posedge clk) disable iff (rst==1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_assignment: assert property (p_cstate_assignment) else $error(\"Assertion failed: cstate is not assigned to 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_3_1_1"
    },
    {
        "sva": "property p_module_sel;\n    @(posedge wb_clk_i)\n    disable iff (wb_rst_i == 1)\n    (wb_cyc_i == 1 && wb_stb_i == 1) |-> module_sel == (wb_cyc_i == 1 && wb_stb_i == 1);\nendproperty\nassert_p_module_sel: assert property (p_module_sel) else $error(\"Assertion failed: module_sel does not reflect the correct state when wb_cyc_i and wb_stb_i are both asserted\");",
        "sva_id": "373_20_1_1"
    },
    {
        "sva": "property p_input_a_ack_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        s_input_a_ack == 1 |-> input_a_ack == (s_input_a_ack == 1);\nendproperty\nassert_p_input_a_ack_assignment: assert property (p_input_a_ack_assignment) else $error(\"Assertion failed: input_a_ack does not correctly reflect s_input_a_ack when s_input_a_ack is 1\");",
        "sva_id": "1563_16_1_1"
    },
    {
        "sva": "property p_program_counter_transition;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && program_counter == 16'd0) |-> ##1 (program_counter == 16'd3);\nendproperty\nassert_p_program_counter_transition: assert property (p_program_counter_transition) else $error(\"Assertion failed: program_counter did not transition from 0 to 3 as expected\");",
        "sva_id": "1563_2_1_1"
    },
    {
        "sva": "property p_d_out_assignment_logic;\n    @(posedge clk) disable iff (rst == 0)\n        enable_i == 1 |-> d_out == d_out_reg;\nendproperty\nassert_p_d_out_assignment_logic: assert property (p_d_out_assignment_logic) else $error(\"Assertion failed: d_out signal does not match d_out_reg when enable_i is asserted\");",
        "sva_id": "1686_7_1_1"
    },
    {
        "sva": "property p_program_counter_initialization;\n    @(posedge clk) disable iff (rst)\n        program_counter == 16'd0 |-> ##1 program_counter == 16'd3;\nendproperty\nassert_p_program_counter_initialization: assert property (p_program_counter_initialization) else $error(\"Assertion failed: program_counter did not initialize to 16'd3 after being 16'd0\");",
        "sva_id": "1563_1_1_1"
    },
    {
        "sva": "property p_input_b_ack_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        s_input_b_ack == 1 |-> input_b_ack == (s_input_b_ack == 1);\nendproperty\nassert_p_input_b_ack_assignment: assert property (p_input_b_ack_assignment) else $error(\"Assertion failed: input_b_ack does not reflect the correct state when s_input_b_ack is asserted\");",
        "sva_id": "1563_17_1_1"
    },
    {
        "sva": "property p_MdoEn_2d_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (MdoEn_2d == 0);\nendproperty\nassert_p_MdoEn_2d_reset_logic: assert property (p_MdoEn_2d_reset_logic) else $error(\"Assertion failed: MdoEn_2d signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1424_6_1_1"
    },
    {
        "sva": "property p_d_out_assignment_logic;\n    @(posedge clk) disable iff (rst == 0)\n        enable_i == 1 |-> d_out == d_out_reg;\nendproperty\nassert_p_d_out_assignment_logic: assert property (p_d_out_assignment_logic) else $error(\"Assertion failed: d_out does not match d_out_reg when enable_i is asserted\");",
        "sva_id": "1686_11_1_1"
    },
    {
        "sva": "property p_o_dly_data_assignment;\n    @(posedge i_clk)\n        o_wb_stall == 0 |-> ##1 o_dly_data == $past(i_wb_data);\nendproperty\nassert_p_o_dly_data_assignment: assert property (p_o_dly_data_assignment) else $error(\"Assertion failed: o_dly_data does not match the past value of i_wb_data when o_wb_stall is 0\");",
        "sva_id": "1804_6_1_1"
    },
    {
        "sva": "property p_cstate_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_assignment: assert property (p_cstate_assignment) else $error(\"Assertion failed: cstate is not assigned to 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_9_1_1"
    },
    {
        "sva": "property p_cstate_assignment;\n    @(posedge clk) disable iff (rst==1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_assignment: assert property (p_cstate_assignment) else $error(\"Assertion failed: cstate is not assigned to 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_10_1_1"
    },
    {
        "sva": "property p_bus_wait_state_assignment;\n    @(posedge wb_clk_i) disable iff (async_rst_b == 1)\n        async_rst_b == 0 |-> ##1 bus_wait_state == 0;\nendproperty\nassert_p_bus_wait_state_assignment: assert property (p_bus_wait_state_assignment) else $error(\"Assertion failed: bus_wait_state is not 0 one cycle after async_rst_b is deasserted\");",
        "sva_id": "373_10_1_1"
    },
    {
        "sva": "property p_d_out_assignment;\n    @(posedge clk) disable iff (rst == 0)\n        enable_i == 1 |-> d_out == d_out_reg;\nendproperty\nassert_p_d_out_assignment: assert property (p_d_out_assignment) else $error(\"Assertion failed: d_out does not match d_out_reg when enable_i is high\");",
        "sva_id": "1686_6_1_1"
    },
    {
        "sva": "property p_DFFE_instNonRep_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        (nreset == 0) |-> ##1 (DFFE_instNonRep == 0);\nendproperty\nassert_p_DFFE_instNonRep_assignment: assert property (p_DFFE_instNonRep_assignment) else $error(\"Assertion failed: DFFE_instNonRep is not 0 one cycle after nreset is 0\");",
        "sva_id": "38_12_1_1"
    },
    {
        "sva": "property p_cstate_reset;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 cstate == 3'b000;\nendproperty\nassert_p_cstate_reset: assert property (p_cstate_reset) else $error(\"Assertion failed: cstate is not 3'b000 one cycle after reset is deasserted\");",
        "sva_id": "1686_4_1_1"
    },
    {
        "sva": "property p_DFFE_instED_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        (nreset == 0) |-> ##1 (DFFE_instED == 0);\nendproperty\nassert_p_DFFE_instED_assignment: assert property (p_DFFE_instED_assignment) else $error(\"Assertion failed: DFFE_instED is not 0 one cycle after nreset is 0\");",
        "sva_id": "38_10_1_1"
    },
    {
        "sva": "property p_program_counter_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && program_counter == 16'd0) |-> ##1 program_counter == 16'd3;\nendproperty\nassert_p_program_counter_assignment: assert property (p_program_counter_assignment) else $error(\"Assertion failed: program_counter is not assigned to 16'd3 one cycle after it is 16'd0 when rst is 0\");",
        "sva_id": "1563_9_1_1"
    },
    {
        "sva": "property p_MdoEn_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 MdoEn == 0;\nendproperty\nassert_p_MdoEn_reset: assert property (p_MdoEn_reset) else $error(\"Assertion failed: MdoEn signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1424_3_1_1"
    },
    {
        "sva": "property p_crc_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (Crc == 32'hffffffff);\nendproperty\nassert_p_crc_reset: assert property (p_crc_reset) else $error(\"Assertion failed: Crc is not equal to 32'hffffffff one cycle after Reset is asserted\");",
        "sva_id": "501_1_1_1"
    },
    {
        "sva": "property p_dout_assignment_logic;\n    @(posedge clk)\n        mode[5] == 1 && (mode[4] == 0 || rd == 1) |-> dout == count[15:8];\nendproperty\nassert_p_dout_assignment_logic: assert property (p_dout_assignment_logic) else $error(\"Assertion failed: dout signal does not match the expected value of count[15:8] when mode[5] is 1 and (mode[4] is 0 or rd is 1)\");",
        "sva_id": "752_7_1_1"
    },
    {
        "sva": "property p_o_wb_ack_assignment;\n    @(posedge i_clk)\n        (i_dly_ack == 1 && i_wb_cyc == 1 && o_dly_cyc == 1) |-> ##1 (o_wb_ack == 1);\nendproperty\nassert_p_o_wb_ack_assignment: assert property (p_o_wb_ack_assignment) else $error(\"Assertion failed: o_wb_ack is not asserted 1 cycle after i_dly_ack, i_wb_cyc, and o_dly_cyc are all high\");",
        "sva_id": "1804_7_1_1"
    },
    {
        "sva": "property p_MdoEn_2d_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 MdoEn_2d == 0;\nendproperty\nassert_p_MdoEn_2d_reset: assert property (p_MdoEn_2d_reset) else $error(\"Assertion failed: MdoEn_2d is not 0 one cycle after Reset is 1\");",
        "sva_id": "1424_2_1_1"
    },
    {
        "sva": "property p_o_wb_stall_assignment;\n    @(posedge i_clk)\n        (i_dly_stall == 1 && o_dly_stb == 1) |-> (o_wb_stall == (i_dly_stall == 1 && o_dly_stb == 1));\nendproperty\nassert_p_o_wb_stall_assignment: assert property (p_o_wb_stall_assignment) else $error(\"Assertion failed: o_wb_stall does not reflect the correct state when i_dly_stall and o_dly_stb are both 1\");",
        "sva_id": "1804_10_1_1"
    },
    {
        "sva": "property p_o_dly_we_assignment;\n    @(posedge i_clk)\n        o_wb_stall == 0 |-> ##1 o_dly_we == $past(i_wb_we);\nendproperty\nassert_p_o_dly_we_assignment: assert property (p_o_dly_we_assignment) else $error(\"Assertion failed: o_dly_we does not correctly reflect the past value of i_wb_we when o_wb_stall is 0\");",
        "sva_id": "1804_4_1_1"
    },
    {
        "sva": "property p_o_wb_data_assignment;\n    @(posedge i_clk)\n        i_dly_data == 8'hA5 |-> ##1 o_wb_data == 8'hA5;\nendproperty\nassert_p_o_wb_data_assignment: assert property (p_o_wb_data_assignment) else $error(\"Assertion failed: o_wb_data is not assigned the expected value 8'hA5 one cycle after i_dly_data is 8'hA5\");",
        "sva_id": "1804_8_1_1"
    },
    {
        "sva": "property p_in_halt_assignment;\n    @(posedge clk) disable iff (nreset==1)\n        nreset == 0 |-> ##1 in_halt == 0;\nendproperty\nassert_p_in_halt_assignment: assert property (p_in_halt_assignment) else $error(\"Assertion failed: in_halt signal is not 0 one cycle after nreset is 0\");",
        "sva_id": "38_6_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_3_assignment;\n    @(posedge clk) disable iff (nreset == 0)\n        (in_nmi == 1 && in_intr == 1) |-> (SYNTHESIZED_WIRE_3 == 1);\nendproperty\nassert_p_SYNTHESIZED_WIRE_3_assignment: assert property (p_SYNTHESIZED_WIRE_3_assignment) else $error(\"Assertion failed: SYNTHESIZED_WIRE_3 is not assigned correctly when both in_nmi and in_intr are high\");",
        "sva_id": "38_5_1_1"
    },
    {
        "sva": "property p_o_wb_data_assignment;\n    @(posedge i_clk)\n        i_dly_data < 1 |-> ##1 o_wb_data == $past(i_dly_data);\nendproperty\nassert_p_o_wb_data_assignment: assert property (p_o_wb_data_assignment) else $error(\"Assertion failed: o_wb_data does not match the previous value of i_dly_data after one clock cycle\");",
        "sva_id": "1804_18_1_1"
    },
    {
        "sva": "property p_DFFE_inst4_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        (nreset == 0) |-> ##1 (DFFE_inst4 == 0);\nendproperty\nassert_p_DFFE_inst4_assignment: assert property (p_DFFE_inst4_assignment) else $error(\"Assertion failed: DFFE_inst4 is not 0 one cycle after nreset is deasserted\");",
        "sva_id": "38_3_1_1"
    },
    {
        "sva": "property p_o_dly_cyc_assignment;\n    @(posedge i_clk)\n        i_wb_cyc == 1 |-> ##1 o_dly_cyc == 1;\nendproperty\nassert_p_o_dly_cyc_assignment: assert property (p_o_dly_cyc_assignment) else $error(\"Assertion failed: o_dly_cyc signal does not reflect the correct state one cycle after i_wb_cyc is asserted\");",
        "sva_id": "1804_2_1_1"
    },
    {
        "sva": "property p_curr_bit_assignment;\n    @(posedge fast_clk) disable iff (res_n == 1)\n        res_n == 0 |-> ##1 curr_bit == {LOG_DWIDTH{1'b0}};\nendproperty\nassert_p_curr_bit_assignment: assert property (p_curr_bit_assignment) else $error(\"Assertion failed: curr_bit is not assigned to zero after reset is de-asserted\");",
        "sva_id": "774_2_1_1"
    },
    {
        "sva": "property p_o_dly_addr_assignment;\n    @(posedge i_clk)\n        o_wb_stall == 0 |-> ##1 o_dly_addr == $past(i_wb_addr);\nendproperty\nassert_p_o_dly_addr_assignment: assert property (p_o_dly_addr_assignment) else $error(\"Assertion failed: o_dly_addr does not match the past value of i_wb_addr when o_wb_stall is 0\");",
        "sva_id": "1804_5_1_1"
    },
    {
        "sva": "property p_MdoEn_2d_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 MdoEn_2d == 0;\nendproperty\nassert_p_MdoEn_2d_reset_logic: assert property (p_MdoEn_2d_reset_logic) else $error(\"Assertion failed: MdoEn_2d signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1424_8_1_1"
    },
    {
        "sva": "property p_mode_assignment_logic;\n    @(posedge clk)\n        (CS == 1 && WR == 1 && cmd == 1 && (din[5] == 1 || din[4] == 1)) |-> ##1 mode[5:0] == $past(din[5:0]);\nendproperty\nassert_p_mode_assignment_logic: assert property (p_mode_assignment_logic) else $error(\"Assertion failed: mode[5:0] does not match the previous value of din[5:0] when CS, WR, and cmd are all 1 and either din[5] or din[4] is 1\");",
        "sva_id": "752_5_1_1"
    },
    {
        "sva": "property p_o_dly_cyc_assignment;\n    @(posedge i_clk)\n        i_wb_cyc == 1 |-> ##1 o_dly_cyc == 1;\nendproperty\nassert_p_o_dly_cyc_assignment: assert property (p_o_dly_cyc_assignment) else $error(\"Assertion failed: o_dly_cyc signal does not become 1 one cycle after i_wb_cyc is 1\");",
        "sva_id": "1804_1_1_1"
    },
    {
        "sva": "property p_DFFE_inst4_assignment;\n    @(posedge clk) disable iff (nreset==1)\n        nreset == 0 |-> ##1 DFFE_inst4 == 0;\nendproperty\nassert_p_DFFE_inst4_assignment: assert property (p_DFFE_inst4_assignment) else $error(\"Assertion failed: DFFE_inst4 should be 0 one cycle after nreset is 0\");",
        "sva_id": "38_2_1_1"
    },
    {
        "sva": "property p_crc_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Crc == 32'hffffffff;\nendproperty\nassert_p_crc_reset_logic: assert property (p_crc_reset_logic) else $error(\"Assertion failed: Crc does not equal 32'hffffffff one cycle after Reset is asserted\");",
        "sva_id": "501_2_1_1"
    },
    {
        "sva": "property p_in_alu_ctl_state_alu;\n    @(posedge clk) disable iff (nreset == 0)\n        ctl_state_alu == 1 |-> in_alu == (ctl_state_alu == 1);\nendproperty\nassert_p_in_alu_ctl_state_alu: assert property (p_in_alu_ctl_state_alu) else $error(\"Assertion failed: in_alu signal does not reflect the correct state when ctl_state_alu is 1\");",
        "sva_id": "38_7_1_1"
    },
    {
        "sva": "property p_o_dly_stb_assignment;\n    @(posedge i_clk)\n        (o_wb_stall == 0 && i_wb_cyc == 1 && i_wb_stb == 1) |-> ##1 (o_dly_stb == ($past(i_wb_cyc) && $past(i_wb_stb)));\nendproperty\nassert_p_o_dly_stb_assignment: assert property (p_o_dly_stb_assignment) else $error(\"Assertion failed: o_dly_stb does not reflect the correct state based on past values of i_wb_cyc and i_wb_stb\");",
        "sva_id": "1804_3_1_1"
    },
    {
        "sva": "property p_crc_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Crc == 32'hffffffff;\nendproperty\nassert_p_crc_reset_logic: assert property (p_crc_reset_logic) else $error(\"Assertion failed: Crc does not equal 32'hffffffff one cycle after Reset is asserted\");",
        "sva_id": "501_7_1_1"
    },
    {
        "sva": "property p_o_wb_err_assignment;\n    @(posedge i_clk)\n        i_dly_err == 1 |-> o_wb_err == 1;\nendproperty\nassert_p_o_wb_err_assignment: assert property (p_o_wb_err_assignment) else $error(\"Assertion failed: o_wb_err signal is not set to 1 when i_dly_err is 1\");",
        "sva_id": "1804_9_1_1"
    },
    {
        "sva": "property p_o_dly_addr_assignment;\n    @(posedge i_clk)\n        o_wb_stall == 0 |-> ##1 o_dly_addr == $past(i_wb_addr);\nendproperty\nassert_p_o_dly_addr_assignment: assert property (p_o_dly_addr_assignment) else $error(\"Assertion failed: o_dly_addr does not match the previous cycle's i_wb_addr when o_wb_stall is 0\");",
        "sva_id": "1804_17_1_1"
    },
    {
        "sva": "property p_CrcError_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Crc[31:0] != 32'hc704dd7b) |-> (CrcError == 1);\nendproperty\nassert_p_CrcError_assignment: assert property (p_CrcError_assignment) else $error(\"Assertion failed: CrcError signal should be 1 when Crc[31:0] is not equal to 32'hc704dd7b\");",
        "sva_id": "501_8_1_1"
    },
    {
        "sva": "property p_DFFE_inst4_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 DFFE_inst4 == 0;\nendproperty\nassert_p_DFFE_inst4_assignment: assert property (p_DFFE_inst4_assignment) else $error(\"Assertion failed: DFFE_inst4 is not 0 one cycle after nreset is 0\");",
        "sva_id": "38_8_1_1"
    },
    {
        "sva": "property p_crc_reset_assignment;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Crc == 32'hffffffff;\nendproperty\nassert_p_crc_reset_assignment: assert property (p_crc_reset_assignment) else $error(\"Assertion failed: Crc does not equal 32'hffffffff one cycle after Reset is asserted.\");",
        "sva_id": "501_5_1_1"
    },
    {
        "sva": "property p_DFFE_inst4_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        (nreset == 0) |-> ##1 (DFFE_inst4 == 0);\nendproperty\nassert_p_DFFE_inst4_assignment: assert property (p_DFFE_inst4_assignment) else $error(\"Assertion failed: DFFE_inst4 is not 0 one cycle after nreset is 0\");",
        "sva_id": "38_4_1_1"
    },
    {
        "sva": "property p_curr_bit_assignment;\n    @(posedge fast_clk) disable iff (res_n==1)\n        res_n == 0 |-> ##1 curr_bit == {LOG_DWIDTH{1'b0}};\nendproperty\nassert_p_curr_bit_assignment: assert property (p_curr_bit_assignment) else $error(\"Assertion failed: curr_bit is not assigned to {LOG_DWIDTH{1'b0}} one cycle after res_n is 0\");",
        "sva_id": "774_4_1_1"
    },
    {
        "sva": "property p_mode_assignment_logic;\n    @(posedge clk)\n        (CS == 1 && WR == 1 && cmd == 1 && (din[5] == 1 || din[4] == 1)) |-> ##1 mode[5:0] == $past(din[5:0]);\nendproperty\nassert_p_mode_assignment_logic: assert property (p_mode_assignment_logic) else $error(\"Assertion failed: mode[5:0] does not match the previous value of din[5:0] when CS, WR, and cmd are all 1 and either din[5] or din[4] is 1\");",
        "sva_id": "752_4_1_1"
    },
    {
        "sva": "property p_reset_r_assignment;\n    @(posedge clk) disable iff (reset == 0)\n        (reset == 1) |-> ##1 (reset_r == 1);\nendproperty\nassert_p_reset_r_assignment: assert property (p_reset_r_assignment) else $error(\"Assertion failed: reset_r is not assigned to 1 one cycle after reset is asserted\");",
        "sva_id": "755_14_1_1"
    },
    {
        "sva": "property p_crc_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Crc == 32'hffffffff;\nendproperty\nassert_p_crc_reset: assert property (p_crc_reset) else $error(\"Assertion failed: Crc signal does not equal 32'hffffffff one cycle after Reset is asserted\");",
        "sva_id": "501_11_1_1"
    },
    {
        "sva": "property p_dbg_phase_cnt_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        phase_cnt == 5'b10101 |-> dbg_phase_cnt == 5'b10101;\nendproperty\nassert_p_dbg_phase_cnt_assignment: assert property (p_dbg_phase_cnt_assignment) else $error(\"Assertion failed: dbg_phase_cnt does not match phase_cnt when phase_cnt is 5'b10101\");",
        "sva_id": "755_5_1_1"
    },
    {
        "sva": "property p_CrcError_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Crc[31:0] != 32'hc704dd7b) |-> (CrcError == 1);\nendproperty\nassert_p_CrcError_assignment: assert property (p_CrcError_assignment) else $error(\"Assertion failed: CrcError signal should be 1 when Crc[31:0] is not equal to 32'hc704dd7b\");",
        "sva_id": "501_12_1_1"
    },
    {
        "sva": "property p_tapfordqs_default_tap;\n    @(posedge clk) disable iff (reset == 1)\n        ##1 tapfordqs == 5'b11101;\nendproperty\nassert_p_tapfordqs_default_tap: assert property (p_tapfordqs_default_tap) else $error(\"Assertion failed: tapfordqs signal does not equal 5'b11101 one cycle after the rising edge of clk when reset is not asserted\");",
        "sva_id": "755_18_1_1"
    },
    {
        "sva": "property p_QSync_reset_assertion;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 QSync == 3'b011;\nendproperty\nassert_p_QSync_reset_assertion: assert property (p_QSync_reset_assertion) else $error(\"Assertion failed: QSync does not equal 3'b011 one cycle after rst is asserted.\");",
        "sva_id": "1548_2_1_1"
    },
    {
        "sva": "property p_trans_onedtct_reset;\n    @(posedge clk) disable iff (reset)\n    reset_r == 1 |-> ##1 trans_onedtct == 0;\nendproperty\nassert_p_trans_onedtct_reset: assert property (p_trans_onedtct_reset) else $error(\"Assertion failed: trans_onedtct signal is not 0 one cycle after reset_r is 1\");",
        "sva_id": "755_15_1_1"
    },
    {
        "sva": "property p_QSync_initialization;\n    @(posedge clk) disable iff (rst==0)\n        rst == 1 |-> ##1 QSync == 3'b011;\nendproperty\nassert_p_QSync_initialization: assert property (p_QSync_initialization) else $error(\"Assertion failed: QSync is not initialized to 3'b011 one cycle after reset is asserted\");",
        "sva_id": "1548_1_1_1"
    },
    {
        "sva": "property p_out_assignment_logic;\n    @(posedge clk) disable iff (reset == 1)\n        (not_zero == 1 && out_counter == 1) |-> (out == (out_counter & not_zero));\nendproperty\nassert_p_out_assignment_logic: assert property (p_out_assignment_logic) else $error(\"Assertion failed: out signal does not reflect the correct logic when not_zero and out_counter are both 1\");",
        "sva_id": "557_5_1_1"
    },
    {
        "sva": "property p_QSync_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        rst == 0 |-> ##1 QSync == {~$past(QSync[0]) & $past(QSync[1]), $past(QSync[0]), $past(din)};\nendproperty\nassert_p_QSync_assignment_logic: assert property (p_QSync_assignment_logic) else $error(\"Assertion failed: QSync assignment logic is incorrect\");",
        "sva_id": "1548_3_1_1"
    },
    {
        "sva": "property p_reset_r_assignment;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 reset_r == 1;\nendproperty\nassert_p_reset_r_assignment: assert property (p_reset_r_assignment) else $error(\"Assertion failed: reset_r is not assigned to 1 one cycle after reset is asserted\");",
        "sva_id": "755_2_1_1"
    },
    {
        "sva": "property p_counter_reset;\n    @(posedge clk) disable iff (reset==0)\n    reset == 1 |-> ##1 counter == 1;\nendproperty\nassert_p_counter_reset: assert property (p_counter_reset) else $error(\"Assertion failed: counter is not equal to 1 one cycle after reset is asserted\");",
        "sva_id": "557_4_1_1"
    },
    {
        "sva": "property p_cnt_reset_logic;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 cnt == 0;\nendproperty\nassert_p_cnt_reset_logic: assert property (p_cnt_reset_logic) else $error(\"Assertion failed: cnt is not reset to 0 one cycle after reset_r is asserted\");",
        "sva_id": "755_12_1_1"
    },
    {
        "sva": "property p_counter_out_counter_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 (counter == 1 && out_counter == 1);\nendproperty\nassert_p_counter_out_counter_reset: assert property (p_counter_out_counter_reset) else $error(\"Assertion failed: counter and out_counter are not 1 one cycle after reset is asserted\");",
        "sva_id": "557_1_1_1"
    },
    {
        "sva": "property p_enb_trans_two_dtct_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 enb_trans_two_dtct == 0;\nendproperty\nassert_p_enb_trans_two_dtct_reset: assert property (p_enb_trans_two_dtct_reset) else $error(\"Assertion failed: enb_trans_two_dtct is not 0 one cycle after reset_r is 1\");",
        "sva_id": "755_9_1_1"
    },
    {
        "sva": "property p_counter_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 counter == 1;\nendproperty\nassert_p_counter_reset: assert property (p_counter_reset) else $error(\"Assertion failed: counter is not equal to 1 one cycle after reset is asserted\");",
        "sva_id": "557_9_1_1"
    },
    {
        "sva": "property p_counter_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 counter == 1;\nendproperty\nassert_p_counter_reset: assert property (p_counter_reset) else $error(\"Assertion failed: counter does not reset to 1 after reset signal is asserted\");",
        "sva_id": "557_7_1_1"
    },
    {
        "sva": "property p_enb_trans_two_dtct_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 enb_trans_two_dtct == 0;\nendproperty\nassert_p_enb_trans_two_dtct_reset: assert property (p_enb_trans_two_dtct_reset) else $error(\"Assertion failed: enb_trans_two_dtct signal is not 0 one cycle after reset_r is 1\");",
        "sva_id": "755_17_1_1"
    },
    {
        "sva": "property p_counter_out_counter_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 (counter == 1 && out_counter == 1);\nendproperty\nassert_p_counter_out_counter_reset: assert property (p_counter_out_counter_reset) else $error(\"Assertion failed: counter and out_counter are not both 1 after reset\");",
        "sva_id": "557_6_1_1"
    },
    {
        "sva": "property p_trans_onedtct_reset_r;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 trans_onedtct == 0;\nendproperty\nassert_p_trans_onedtct_reset_r: assert property (p_trans_onedtct_reset_r) else $error(\"Assertion failed: trans_onedtct signal is not 0 one cycle after reset_r is asserted\");",
        "sva_id": "755_7_1_1"
    },
    {
        "sva": "property p_trans_twodtct_reset;\n    @(posedge clk) disable iff (reset==1)\n        reset_r == 1 |-> ##1 trans_twodtct == 0;\nendproperty\nassert_p_trans_twodtct_reset: assert property (p_trans_twodtct_reset) else $error(\"Assertion failed: trans_twodtct is not 0 one cycle after reset_r is 1\");",
        "sva_id": "755_16_1_1"
    },
    {
        "sva": "property p_counter_reset_assignment;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 counter == 1;\nendproperty\nassert_p_counter_reset_assignment: assert property (p_counter_reset_assignment) else $error(\"Assertion failed: counter is not assigned to 1 one cycle after reset is asserted\");",
        "sva_id": "557_10_1_1"
    },
    {
        "sva": "property p_data_o_assignment_on_reset_deasserted;\n    @(posedge clk) disable iff (reset == 1)\n        reset == 0 |-> ##1 data_o == 0;\nendproperty\nassert_p_data_o_assignment_on_reset_deasserted: assert property (p_data_o_assignment_on_reset_deasserted) else $error(\"Assertion failed: data_o is not assigned to 0 when reset is deasserted\");",
        "sva_id": "518_4_1_1"
    },
    {
        "sva": "property p_count_reset_logic;\n    @(posedge clk_i) disable iff (rst_i==0)\n        rst_i == 1 |-> ##1 count == {CW{1'b0}};\nendproperty\nassert_p_count_reset_logic: assert property (p_count_reset_logic) else $error(\"Assertion failed: count signal is not reset to zero as expected when rst_i is asserted\");",
        "sva_id": "360_6_1_1"
    },
    {
        "sva": "property p_changed_xor_assignment;\n    @(posedge clk_i) disable iff (rst_i)\n        (button_2 == 0 && button_o == 0) |-> (changed == (button_2 ^ button_o));\nendproperty\nassert_p_changed_xor_assignment: assert property (p_changed_xor_assignment) else $error(\"Assertion failed: 'changed' signal does not reflect the XOR of 'button_2' and 'button_o' when both are 0\");",
        "sva_id": "360_5_1_1"
    },
    {
        "sva": "property p_data_o_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0) |-> ##1 (data_o == 0);\nendproperty\nassert_p_data_o_assignment: assert property (p_data_o_assignment) else $error(\"Assertion failed: data_o is not assigned to 0 one cycle after reset is deasserted\");",
        "sva_id": "518_8_1_1"
    },
    {
        "sva": "property p_button_1_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 button_1 == 0;\nendproperty\nassert_p_button_1_reset: assert property (p_button_1_reset) else $error(\"Assertion failed: button_1 should be 0 one cycle after rst_i is asserted\");",
        "sva_id": "360_3_1_1"
    },
    {
        "sva": "property p_cnt_reset_logic;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 cnt == 0;\nendproperty\nassert_p_cnt_reset_logic: assert property (p_cnt_reset_logic) else $error(\"Assertion failed: cnt is not 0 one cycle after reset_r is asserted\");",
        "sva_id": "755_10_1_1"
    },
    {
        "sva": "property p_level_prefix_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 level_prefix == 0;\nendproperty\nassert_p_level_prefix_reset: assert property (p_level_prefix_reset) else $error(\"Assertion failed: level_prefix is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_2_1_1"
    },
    {
        "sva": "property p_dbg_phase_cnt_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        phase_cnt == 5 |-> dbg_phase_cnt == phase_cnt;\nendproperty\nassert_p_dbg_phase_cnt_assignment: assert property (p_dbg_phase_cnt_assignment) else $error(\"Assertion failed: dbg_phase_cnt does not match phase_cnt when phase_cnt is 5\");",
        "sva_id": "755_21_1_1"
    },
    {
        "sva": "property p_tmp1_assignment_logic;\n    @(posedge clk) disable iff (rst_n == 0)\n        (first_level == 1 && TrailingOnes < 3) |-> (tmp1 == 2'd2);\nendproperty\nassert_p_tmp1_assignment_logic: assert property (p_tmp1_assignment_logic) else $error(\"Assertion failed: tmp1 is not assigned the value 2'd2 when first_level is 1 and TrailingOnes is less than 3\");",
        "sva_id": "368_10_1_1"
    },
    {
        "sva": "property p_phase_cnt_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 phase_cnt == 0;\nendproperty\nassert_p_phase_cnt_reset: assert property (p_phase_cnt_reset) else $error(\"Assertion failed: phase_cnt is not reset to 0 one cycle after reset_r is asserted\");",
        "sva_id": "755_19_1_1"
    },
    {
        "sva": "property p_level_abs_refresh;\n    @(posedge clk) disable iff (rst_n == 1)\n        (calc_sel == 1 && ena == 1) |-> (level_abs_refresh == (calc_sel == 1 && ena == 1));\nendproperty\nassert_p_level_abs_refresh: assert property (p_level_abs_refresh) else $error(\"Assertion failed: level_abs_refresh signal does not reflect the correct state when calc_sel and ena are both 1\");",
        "sva_id": "368_11_1_1"
    },
    {
        "sva": "property p_tapfordqs1_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        reset_r == 1 |-> ##1 tapfordqs1 == $past(default_tap);\nendproperty\nassert_p_tapfordqs1_assignment: assert property (p_tapfordqs1_assignment) else $error(\"Assertion failed: tapfordqs1 does not match the past value of default_tap one cycle after reset_r is asserted\");",
        "sva_id": "755_3_1_1"
    },
    {
        "sva": "property p_level_abs_reset;\n    @(posedge clk or negedge rst_n)\n    disable iff (rst_n == 1)\n    rst_n == 0 |-> ##1 level_abs == 0;\nendproperty\nassert_p_level_abs_reset: assert property (p_level_abs_reset) else $error(\"Assertion failed: level_abs is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_5_1_1"
    },
    {
        "sva": "property p_button_1_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 button_1 == 0;\nendproperty\nassert_p_button_1_reset_logic: assert property (p_button_1_reset_logic) else $error(\"Assertion failed: button_1 should be 0 one cycle after rst_i is asserted.\");",
        "sva_id": "360_10_1_1"
    },
    {
        "sva": "property p_button_1_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 button_1 == 0;\nendproperty\nassert_p_button_1_reset: assert property (p_button_1_reset) else $error(\"Assertion failed: button_1 is not 0 one cycle after rst_i is asserted\");",
        "sva_id": "360_1_1_1"
    },
    {
        "sva": "property p_level_code_tmp_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 level_code_tmp == 0;\nendproperty\nassert_p_level_code_tmp_reset: assert property (p_level_code_tmp_reset) else $error(\"Assertion failed: level_code_tmp is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_4_1_1"
    },
    {
        "sva": "property p_button_1_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 button_1 == 0;\nendproperty\nassert_p_button_1_reset_logic: assert property (p_button_1_reset_logic) else $error(\"Assertion failed: button_1 signal is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "360_4_1_1"
    },
    {
        "sva": "property p_mode6_assignment;\n    @(posedge clk)\n        (CS == 1 && WR == 1) |-> ##1 (mode[6] == 1);\nendproperty\nassert_p_mode6_assignment: assert property (p_mode6_assignment) else $error(\"Assertion failed: mode[6] is not assigned to 1 one cycle after CS and WR are both 1\");",
        "sva_id": "752_9_1_1"
    },
    {
        "sva": "property p_data_d_assignment;\n    @(posedge clk) disable iff (reset==1)\n        (reset == 0) |-> ##1 (data_d == 0);\nendproperty\nassert_p_data_d_assignment: assert property (p_data_d_assignment) else $error(\"Assertion failed: data_d is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_6_1_1"
    },
    {
        "sva": "property p_internal_registers_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 (button_1 == 0 && button_2 == 0 && count == 0 && button_o == 0);\nendproperty\nassert_p_internal_registers_reset: assert property (p_internal_registers_reset) else $error(\"Assertion failed: Internal registers are not reset correctly when rst_i is asserted.\");",
        "sva_id": "360_2_1_1"
    },
    {
        "sva": "property p_zero_divisor_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        (r_divisor == 0 && r_busy == 1) |-> ##1 (zero_divisor == 1);\nendproperty\nassert_p_zero_divisor_assignment: assert property (p_zero_divisor_assignment) else $error(\"Assertion failed: zero_divisor signal should be 1 when r_divisor is 0 and r_busy is 1\");",
        "sva_id": "1805_12_1_1"
    },
    {
        "sva": "property p_tapfordqs1_assignment_on_reset;\n    @(posedge clk) disable iff (reset == 0)\n        reset_r == 1 |-> ##1 tapfordqs1 == $past(default_tap);\nendproperty\nassert_p_tapfordqs1_assignment_on_reset: assert property (p_tapfordqs1_assignment_on_reset) else $error(\"Assertion failed: tapfordqs1 does not match the past value of default_tap after reset\");",
        "sva_id": "755_13_1_1"
    },
    {
        "sva": "property p_count_reset_logic;\n    @(posedge clk_i) disable iff (rst_i)\n        (rst_i == 0 && changed == 0 && count < 1) |-> ##1 count == {CW{1'b0}};\nendproperty\nassert_p_count_reset_logic: assert property (p_count_reset_logic) else $error(\"Assertion failed: count signal does not reset to zero correctly when rst_i is low, changed is zero, and count is less than 1\");",
        "sva_id": "360_7_1_1"
    },
    {
        "sva": "property p_button_o_assignment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (rst_i == 0 && changed == 1 && count == '1) |-> ##1 button_o == $past(button_2);\nendproperty\nassert_p_button_o_assignment: assert property (p_button_o_assignment) else $error(\"Assertion failed: button_o does not match the previous state of button_2 when conditions are met.\");",
        "sva_id": "360_8_1_1"
    },
    {
        "sva": "property p_tapfordqs_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        reset == 0 |-> ##1 tapfordqs == $past(default_tap);\nendproperty\nassert_p_tapfordqs_assignment: assert property (p_tapfordqs_assignment) else $error(\"Assertion failed: tapfordqs signal does not match the past value of default_tap\");",
        "sva_id": "755_4_1_1"
    },
    {
        "sva": "property p_counter_reset_assignment;\n    @(posedge clk) disable iff (reset == 0)\n        reset == 1 |-> ##1 counter == 1;\nendproperty\nassert_p_counter_reset_assignment: assert property (p_counter_reset_assignment) else $error(\"Assertion failed: Counter is not assigned to 1 one cycle after reset is asserted.\");",
        "sva_id": "557_8_1_1"
    },
    {
        "sva": "property p_CrcNext0_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Enable == 1 && Data[0] == 1 && Crc[28] == 0) |-> (CrcNext[0] == 1);\nendproperty\nassert_p_CrcNext0_assignment: assert property (p_CrcNext0_assignment) else $error(\"Assertion failed: CrcNext[0] should be 1 when Enable is 1, Data[0] is 1, and Crc[28] is 0\");",
        "sva_id": "501_4_1_1"
    },
    {
        "sva": "property p_cnt_reset_logic;\n    @(posedge clk) disable iff (reset == 1)\n        reset == 0 |-> ##1 cnt == 0;\nendproperty\nassert_p_cnt_reset_logic: assert property (p_cnt_reset_logic) else $error(\"Assertion failed: cnt is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_7_1_1"
    },
    {
        "sva": "property p_tapfordqs1_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        reset_r == 1 |-> ##1 tapfordqs1 == $past(default_tap);\nendproperty\nassert_p_tapfordqs1_assignment: assert property (p_tapfordqs1_assignment) else $error(\"Assertion failed: tapfordqs1 does not match the past value of default_tap one cycle after reset_r is asserted.\");",
        "sva_id": "755_20_1_1"
    },
    {
        "sva": "property p_data_d_assignment_on_reset_deasserted;\n    @(posedge clk) disable iff (reset == 1)\n        reset == 0 |-> ##1 data_d == 0;\nendproperty\nassert_p_data_d_assignment_on_reset_deasserted: assert property (p_data_d_assignment_on_reset_deasserted) else $error(\"Assertion failed: data_d is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_1_1_1"
    },
    {
        "sva": "property p_data_d_assignment;\n    @(posedge clk) disable iff (reset == 1)\n        (reset == 0) |-> ##1 (data_d == 0);\nendproperty\nassert_p_data_d_assignment: assert property (p_data_d_assignment) else $error(\"Assertion failed: data_d is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_3_1_1"
    },
    {
        "sva": "property p_o_busy_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1) |-> ##1 (o_busy == 0);\nendproperty\nassert_p_o_busy_reset: assert property (p_o_busy_reset) else $error(\"Assertion failed: o_busy signal is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1805_7_1_1"
    },
    {
        "sva": "property p_first_level_assignment;\n    @(posedge clk) disable iff (rst_n == 0)\n        (i == TotalCoeff - TrailingOnes - 1) |-> (first_level == 1);\nendproperty\nassert_p_first_level_assignment: assert property (p_first_level_assignment) else $error(\"Assertion failed: first_level is not equal to 1 when i equals TotalCoeff - TrailingOnes - 1\");",
        "sva_id": "368_9_1_1"
    },
    {
        "sva": "property p_suffixLength_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 suffixLength == 0;\nendproperty\nassert_p_suffixLength_reset: assert property (p_suffixLength_reset) else $error(\"Assertion failed: suffixLength is not zero one cycle after reset is deasserted\");",
        "sva_id": "368_3_1_1"
    },
    {
        "sva": "property p_data_d_reset_initialization;\n    @(posedge clk) disable iff (reset == 1)\n        reset == 0 |-> ##1 data_d == 0;\nendproperty\nassert_p_data_d_reset_initialization: assert property (p_data_d_reset_initialization) else $error(\"Assertion failed: data_d is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_2_1_1"
    },
    {
        "sva": "property p_level_0_assignment;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 level_0 == 0;\nendproperty\nassert_p_level_0_assignment: assert property (p_level_0_assignment) else $error(\"Assertion failed: level_0 signal is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_6_1_1"
    },
    {
        "sva": "property p_o_err_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 o_err == 0;\nendproperty\nassert_p_o_err_reset: assert property (p_o_err_reset) else $error(\"Assertion failed: o_err is not 0 one cycle after i_rst is asserted.\");",
        "sva_id": "1805_15_1_1"
    },
    {
        "sva": "property p_CrcNext0_assignment_logic;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Enable == 1 && Data[0] == 1 && Crc[28] == 0) |-> (CrcNext[0] == (Enable & (Data[0] ^ Crc[28])));\nendproperty\nassert_p_CrcNext0_assignment_logic: assert property (p_CrcNext0_assignment_logic) else $error(\"Assertion failed: CrcNext[0] does not match the expected logic when Enable is 1, Data[0] is 1, and Crc[28] is 0\");",
        "sva_id": "501_3_1_1"
    },
    {
        "sva": "property p_data_o_reset;\n    @(posedge clk) disable iff (reset == 1)\n    reset == 0 |-> ##1 data_o == 0;\nendproperty\nassert_p_data_o_reset: assert property (p_data_o_reset) else $error(\"Assertion failed: data_o is not 0 one cycle after reset is deasserted\");",
        "sva_id": "518_10_1_1"
    },
    {
        "sva": "property p_r_busy_reset_logic;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 r_busy == 0;\nendproperty\nassert_p_r_busy_reset_logic: assert property (p_r_busy_reset_logic) else $error(\"Assertion failed: r_busy is not 0 one cycle after i_rst is asserted.\");",
        "sva_id": "1805_13_1_1"
    },
    {
        "sva": "property p_w_n_o_quotient_MSB;\n    @(posedge i_clk) disable iff (i_rst)\n        o_quotient[BW-1] == 1 |-> w_n == o_quotient[BW-1];\nendproperty\nassert_p_w_n_o_quotient_MSB: assert property (p_w_n_o_quotient_MSB) else $error(\"Assertion failed: w_n does not match the MSB of o_quotient\");",
        "sva_id": "1805_23_1_1"
    },
    {
        "sva": "property p_r_dividend_assignment;\n    @(posedge i_clk)\n        i_wr == 1 |-> ##1 r_dividend == $past(i_numerator);\nendproperty\nassert_p_r_dividend_assignment: assert property (p_r_dividend_assignment) else $error(\"Assertion failed: r_dividend does not match the previous value of i_numerator after one clock cycle\");",
        "sva_id": "1805_5_1_1"
    },
    {
        "sva": "property p_MB_current_ff_q;\n    @(posedge clk) disable iff (RST == 1)\n        current_ff_q |-> MB == current_ff_q;\nendproperty\nassert_p_MB_current_ff_q: assert property (p_MB_current_ff_q) else $error(\"Assertion failed: MB signal does not match current_ff_q value\");",
        "sva_id": "814_9_1_1"
    },
    {
        "sva": "property p_o_quotient_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 o_quotient == 0;\nendproperty\nassert_p_o_quotient_assignment: assert property (p_o_quotient_assignment) else $error(\"Assertion failed: o_quotient is not assigned to 0 one cycle after i_wr is asserted\");",
        "sva_id": "1805_17_1_1"
    },
    {
        "sva": "property p_current_ff_q_assignment;\n    @(posedge clk) disable iff (RST == 0)\n        (RST == 1 && player == 1'b1) |-> ##1 current_ff_q == $past(R);\nendproperty\nassert_p_current_ff_q_assignment: assert property (p_current_ff_q_assignment) else $error(\"Assertion failed: current_ff_q does not match the past value of R when RST is 1 and player is 1\");",
        "sva_id": "814_12_1_1"
    },
    {
        "sva": "property p_o_err_assignment_logic;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1 || o_valid == 1) |-> ##1 o_err == 0;\nendproperty\nassert_p_o_err_assignment_logic: assert property (p_o_err_assignment_logic) else $error(\"Assertion failed: o_err should be 0 one cycle after i_rst is 1 or o_valid is 1\");",
        "sva_id": "1805_9_1_1"
    },
    {
        "sva": "property p_o_flags_assignment_logic;\n    @(posedge i_clk) disable iff (i_rst)\n        (o_quotient[BW-1] == 0 && r_busy == 0 && diff != 0 && r_dividend != 0 && r_z == 0) |-> o_flags == 4'b0000;\nendproperty\nassert_p_o_flags_assignment_logic: assert property (p_o_flags_assignment_logic) else $error(\"Assertion failed: o_flags should be 4'b0000 when o_quotient[BW-1] == 0, r_busy == 0, diff != 0, r_dividend != 0, and r_z == 0\");",
        "sva_id": "1805_11_1_1"
    },
    {
        "sva": "property p_o_quotient_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 o_quotient == 0;\nendproperty\nassert_p_o_quotient_assignment: assert property (p_o_quotient_assignment) else $error(\"Assertion failed: o_quotient is not assigned to 0 one cycle after i_wr is asserted\");",
        "sva_id": "1805_10_1_1"
    },
    {
        "sva": "property p_cur_state_reset_initialization;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == STOPPED;\nendproperty\nassert_p_cur_state_reset_initialization: assert property (p_cur_state_reset_initialization) else $error(\"Assertion failed: cur_state is not STOPPED one cycle after rst_i is asserted\");",
        "sva_id": "355_1_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET after one clock cycle when RST is asserted\");",
        "sva_id": "814_10_1_1"
    },
    {
        "sva": "property p_changed_xor_assignment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        (synchro[2] == 1 && synchro[1] == 0) |-> (changed == 1);\nendproperty\nassert_p_changed_xor_assignment: assert property (p_changed_xor_assignment) else $error(\"Assertion failed: 'changed' signal is not 1 when 'synchro[2] == 1 && synchro[1] == 0' at the rising edge of clk_i\");",
        "sva_id": "355_7_1_1"
    },
    {
        "sva": "property p_wb_ack_o_reset;\n    @(posedge wb_clk_i) disable iff (wb_rst_i == 0)\n        wb_rst_i == 1 |-> ##1 wb_ack_o == 0;\nendproperty\nassert_p_wb_ack_o_reset: assert property (p_wb_ack_o_reset) else $error(\"Assertion failed: wb_ack_o is not 0 one cycle after wb_rst_i is asserted\");",
        "sva_id": "495_2_1_1"
    },
    {
        "sva": "property p_cur_state_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == STOPPED;\nendproperty\nassert_p_cur_state_reset: assert property (p_cur_state_reset) else $error(\"Assertion failed: cur_state is not STOPPED one cycle after rst_i is asserted\");",
        "sva_id": "355_3_1_1"
    },
    {
        "sva": "property p_data_i_ram_assignment;\n    @(posedge clk_i)\n        wr_i == 1 |-> ##1 ram[$past(addr_i)] == $past(data_i);\nendproperty\nassert_p_data_i_ram_assignment: assert property (p_data_i_ram_assignment) else $error(\"Assertion failed: RAM data assignment does not match the expected value based on previous address and data inputs\");",
        "sva_id": "593_4_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST==0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET one cycle after RST is asserted\");",
        "sva_id": "814_13_1_1"
    },
    {
        "sva": "property p_data_assignment_raw_mode;\n    @(posedge clk_i)\n        (wr_i == 1 && MODE == \"RAW\") |-> ##1 data == $past(data_i);\nendproperty\nassert_p_data_assignment_raw_mode: assert property (p_data_assignment_raw_mode) else $error(\"Assertion failed: data signal does not match the previous data_i value in RAW mode\");",
        "sva_id": "593_12_1_1"
    },
    {
        "sva": "property p_current_ff_q_oponent_ff_q_assignment;\n    @(posedge clk) disable iff (RST == 0)\n        (RST == 1 && player == RED) |-> ##1 (current_ff_q == $past(R) && oponent_ff_q == $past(B));\nendproperty\nassert_p_current_ff_q_oponent_ff_q_assignment: assert property (p_current_ff_q_oponent_ff_q_assignment) else $error(\"Assertion failed: current_ff_q and oponent_ff_q do not reflect the correct state after one clock cycle when RST is 1 and player is RED\");",
        "sva_id": "814_11_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET after one clock cycle when RST is high\");",
        "sva_id": "814_4_1_1"
    },
    {
        "sva": "property p_pre_sign_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 pre_sign == $past(i_signed);\nendproperty\nassert_p_pre_sign_assignment: assert property (p_pre_sign_assignment) else $error(\"Assertion failed: pre_sign does not match the previous value of i_signed one cycle after i_wr is asserted\");",
        "sva_id": "1805_4_1_1"
    },
    {
        "sva": "property p_countx_ff_q_assignment_on_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 countx_ff_q == $past(X);\nendproperty\nassert_p_countx_ff_q_assignment_on_reset: assert property (p_countx_ff_q_assignment_on_reset) else $error(\"Assertion failed: countx_ff_q does not match the past value of X after reset\");",
        "sva_id": "814_7_1_1"
    },
    {
        "sva": "property p_timeout_assignment;\n    @(posedge clk_i) disable iff (rst_i == 1)\n        counter == 8'b11111111 |-> timeout == 1;\nendproperty\nassert_p_timeout_assignment: assert property (p_timeout_assignment) else $error(\"Assertion failed: timeout signal is not set when counter reaches 8'b11111111\");",
        "sva_id": "355_9_1_1"
    },
    {
        "sva": "property p_r_divisor_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 r_divisor == { $past(i_denominator), {BW-1{1'b0}} };\nendproperty\nassert_p_r_divisor_assignment: assert property (p_r_divisor_assignment) else $error(\"Assertion failed: r_divisor is not assigned correctly one cycle after i_wr is asserted\");",
        "sva_id": "1805_18_1_1"
    },
    {
        "sva": "property p_r_dividend_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 r_dividend == $past(i_numerator);\nendproperty\nassert_p_r_dividend_assignment: assert property (p_r_dividend_assignment) else $error(\"Assertion failed: r_dividend does not match the past value of i_numerator after one clock cycle when i_wr is asserted\");",
        "sva_id": "1805_19_1_1"
    },
    {
        "sva": "property p_cur_state_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == $past(STOPPED);\nendproperty\nassert_p_cur_state_reset: assert property (p_cur_state_reset) else $error(\"Assertion failed: cur_state is not equal to the previous STOPPED state after reset\");",
        "sva_id": "355_2_1_1"
    },
    {
        "sva": "property p_alive_o_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 alive_o == 0;\nendproperty\nassert_p_alive_o_reset: assert property (p_alive_o_reset) else $error(\"Assertion failed: alive_o signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "355_11_1_1"
    },
    {
        "sva": "property p_cur_state_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == $past(STOPPED);\nendproperty\nassert_p_cur_state_reset: assert property (p_cur_state_reset) else $error(\"Assertion failed: cur_state is not STOPPED one cycle after rst_i is asserted.\");",
        "sva_id": "355_4_1_1"
    },
    {
        "sva": "property p_synchro_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 synchro == 3'b0;\nendproperty\nassert_p_synchro_reset: assert property (p_synchro_reset) else $error(\"Assertion failed: synchro signal is not 3'b0 one cycle after reset is asserted\");",
        "sva_id": "355_6_1_1"
    },
    {
        "sva": "property p_o_valid_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1) |-> ##1 (o_valid == 0);\nendproperty\nassert_p_o_valid_reset: assert property (p_o_valid_reset) else $error(\"Assertion failed: o_valid is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1805_14_1_1"
    },
    {
        "sva": "property p_count_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 count == 0;\nendproperty\nassert_p_count_reset_logic: assert property (p_count_reset_logic) else $error(\"Assertion failed: count is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "360_9_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET one cycle after RST is asserted\");",
        "sva_id": "814_5_1_1"
    },
    {
        "sva": "property p_r_busy_assignment;\n    @(posedge i_clk) disable iff (i_rst)\n        (i_rst == 0 && i_wr == 1) |-> ##1 (r_busy == 1);\nendproperty\nassert_p_r_busy_assignment: assert property (p_r_busy_assignment) else $error(\"Assertion failed: r_busy signal was not set to 1 one cycle after i_wr is asserted while i_rst is deasserted\");",
        "sva_id": "1805_3_1_1"
    },
    {
        "sva": "property p_ram_assignment_logic;\n    @(posedge clk_i)\n        wr_i == 1 |-> ##1 ram[$past(addr_i)] == $past(data_i);\nendproperty\nassert_p_ram_assignment_logic: assert property (p_ram_assignment_logic) else $error(\"Assertion failed: RAM assignment logic error. The value in RAM at the past address does not match the past data value.\");",
        "sva_id": "593_1_1_1"
    },
    {
        "sva": "property p_cur_state_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == $past(STOPPED);\nendproperty\nassert_p_cur_state_reset_logic: assert property (p_cur_state_reset_logic) else $error(\"Assertion failed: cur_state does not reflect the STOPPED state one cycle after reset is asserted.\");",
        "sva_id": "355_12_1_1"
    },
    {
        "sva": "property p_ram_write;\n    @(posedge clk_i)\n        wr_i == 1 |-> ##1 ram[$past(addr_i)] == $past(data_i);\nendproperty\nassert_p_ram_write: assert property (p_ram_write) else $error(\"Assertion failed: RAM write operation did not store the correct data at the expected address.\");",
        "sva_id": "593_2_1_1"
    },
    {
        "sva": "property p_pause_quanta_val_dl1_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n    Reset == 1 |-> ##1 pause_quanta_val_dl1 == 0;\nendproperty\nassert_p_pause_quanta_val_dl1_reset: assert property (p_pause_quanta_val_dl1_reset) else $error(\"Assertion failed: pause_quanta_val_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_12_1_1"
    },
    {
        "sva": "property p_cur_state_reset;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 cur_state == $past(STOPPED);\nendproperty\nassert_p_cur_state_reset: assert property (p_cur_state_reset) else $error(\"Assertion failed: cur_state is not equal to the previous value of STOPPED one cycle after reset is asserted\");",
        "sva_id": "355_5_1_1"
    },
    {
        "sva": "property p_tx_pause_en_dl1_reset;\n    @(posedge Clk) disable iff (Reset==0)\n        (Reset == 1) |-> ##1 (tx_pause_en_dl1 == 0);\nendproperty\nassert_p_tx_pause_en_dl1_reset: assert property (p_tx_pause_en_dl1_reset) else $error(\"Assertion failed: tx_pause_en_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_13_1_1"
    },
    {
        "sva": "property p_ram_write;\n    @(posedge clk_i)\n        wr_i == 1 |-> ##1 ram[$past(addr_i)] == $past(data_i);\nendproperty\nassert_p_ram_write: assert property (p_ram_write) else $error(\"Assertion failed: RAM write operation did not correctly store the data at the specified address\");",
        "sva_id": "593_3_1_1"
    },
    {
        "sva": "property p_r_busy_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1) |-> ##1 (r_busy == 0);\nendproperty\nassert_p_r_busy_reset: assert property (p_r_busy_reset) else $error(\"Assertion failed: r_busy signal is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1805_2_1_1"
    },
    {
        "sva": "property p_current_oponent_ff_q_assignment;\n    @(posedge clk) disable iff (RST == 0)\n        (RST == 1 && player == RED) |-> ##1 (current_ff_q == $past(R) && oponent_ff_q == $past(B));\nendproperty\nassert_p_current_oponent_ff_q_assignment: assert property (p_current_oponent_ff_q_assignment) else $error(\"Assertion failed: current_ff_q or oponent_ff_q does not reflect the correct state after one clock cycle when RST is 1 and player is RED\");",
        "sva_id": "814_6_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET one cycle after RST is high\");",
        "sva_id": "814_8_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET after one clock cycle when RST is asserted\");",
        "sva_id": "814_1_1_1"
    },
    {
        "sva": "property p_xoff_gen_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 xoff_gen == 0;\nendproperty\nassert_p_xoff_gen_reset: assert property (p_xoff_gen_reset) else $error(\"Assertion failed: xoff_gen is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_4_1_1"
    },
    {
        "sva": "property p_counter_reset_logic;\n    @(posedge clk_i) disable iff (rst_i == 0)\n        rst_i == 1 |-> ##1 counter == 0;\nendproperty\nassert_p_counter_reset_logic: assert property (p_counter_reset_logic) else $error(\"Assertion failed: counter is not reset to 0 one cycle after rst_i is asserted\");",
        "sva_id": "355_13_1_1"
    },
    {
        "sva": "property p_TxCtrlStartFrm_on_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (TxCtrlStartFrm == 0);\nendproperty\nassert_p_TxCtrlStartFrm_on_TxReset: assert property (p_TxCtrlStartFrm_on_TxReset) else $error(\"Assertion failed: TxCtrlStartFrm is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_2_1_1"
    },
    {
        "sva": "property p_xon_gen_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 xon_gen == 0;\nendproperty\nassert_p_xon_gen_reset: assert property (p_xon_gen_reset) else $error(\"Assertion failed: xon_gen is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_5_1_1"
    },
    {
        "sva": "property p_ram_write_operation;\n    @(posedge clk_i)\n        wr_i == 1 |-> ##1 ram[$past(addr_i)] == $past(data_i);\nendproperty\nassert_p_ram_write_operation: assert property (p_ram_write_operation) else $error(\"Assertion failed: RAM write operation did not store the correct data at the specified address\");",
        "sva_id": "593_11_1_1"
    },
    {
        "sva": "property p_pause_quanta_dl1_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (pause_quanta_dl1 == 0);\nendproperty\nassert_p_pause_quanta_dl1_reset: assert property (p_pause_quanta_dl1_reset) else $error(\"Assertion failed: pause_quanta_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_11_1_1"
    },
    {
        "sva": "property p_level_prefix_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 level_prefix == 0;\nendproperty\nassert_p_level_prefix_reset: assert property (p_level_prefix_reset) else $error(\"Assertion failed: level_prefix is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_1_1_1"
    },
    {
        "sva": "property p_TxCtrlEndFrm_on_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (TxCtrlEndFrm == 0);\nendproperty\nassert_p_TxCtrlEndFrm_on_TxReset: assert property (p_TxCtrlEndFrm_on_TxReset) else $error(\"Assertion failed: TxCtrlEndFrm is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_3_1_1"
    },
    {
        "sva": "property p_pause_quanta_counter_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 pause_quanta_counter == 0;\nendproperty\nassert_p_pause_quanta_counter_reset: assert property (p_pause_quanta_counter_reset) else $error(\"Assertion failed: pause_quanta_counter is not reset to 0 after one clock cycle when Reset is active\");",
        "sva_id": "1426_7_1_1"
    },
    {
        "sva": "property p_level_0_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 level_0 == 0;\nendproperty\nassert_p_level_0_reset: assert property (p_level_0_reset) else $error(\"Assertion failed: level_0 is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "368_7_1_1"
    },
    {
        "sva": "property p_pause_quanta_dl1_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (pause_quanta_dl1 == 0);\nendproperty\nassert_p_pause_quanta_dl1_reset: assert property (p_pause_quanta_dl1_reset) else $error(\"Assertion failed: pause_quanta_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_6_1_1"
    },
    {
        "sva": "property p_tx_pause_en_dl1_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 tx_pause_en_dl1 == 0;\nendproperty\nassert_p_tx_pause_en_dl1_reset: assert property (p_tx_pause_en_dl1_reset) else $error(\"Assertion failed: tx_pause_en_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_3_1_1"
    },
    {
        "sva": "property p_crc_reset_assignment;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Crc == 32'hffffffff;\nendproperty\nassert_p_crc_reset_assignment: assert property (p_crc_reset_assignment) else $error(\"Assertion failed: Crc signal is not assigned to 32'hffffffff one cycle after Reset is asserted\");",
        "sva_id": "501_9_1_1"
    },
    {
        "sva": "property p_state_ff_q_reset;\n    @(posedge clk) disable iff (RST == 0)\n        RST == 1 |-> ##1 state_ff_q == $past(RESET);\nendproperty\nassert_p_state_ff_q_reset: assert property (p_state_ff_q_reset) else $error(\"Assertion failed: state_ff_q does not match the past value of RESET after one clock cycle when RST is high\");",
        "sva_id": "814_2_1_1"
    },
    {
        "sva": "property p_WillSendControlFrame_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 WillSendControlFrame == 0;\nendproperty\nassert_p_WillSendControlFrame_TxReset: assert property (p_WillSendControlFrame_TxReset) else $error(\"Assertion failed: WillSendControlFrame should be 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_7_1_1"
    },
    {
        "sva": "property p_IncrementDlyCrcCnt_assignment;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        (CtrlMux == 1 && TxUsedDataIn == 1 && DlyCrcCnt[2] == 0) |-> (IncrementDlyCrcCnt == (CtrlMux & TxUsedDataIn & ~DlyCrcCnt[2]));\nendproperty\nassert_p_IncrementDlyCrcCnt_assignment: assert property (p_IncrementDlyCrcCnt_assignment) else $error(\"Assertion failed: IncrementDlyCrcCnt does not match the expected value when CtrlMux, TxUsedDataIn, and DlyCrcCnt[2] conditions are met.\");",
        "sva_id": "189_12_1_1"
    },
    {
        "sva": "property p_CrcNext_0_assignment_logic;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Enable == 1 && Data[0] == 1 && Crc[28] == 0) |-> (CrcNext[0] == (Enable & (Data[0] ^ Crc[28])));\nendproperty\nassert_p_CrcNext_0_assignment_logic: assert property (p_CrcNext_0_assignment_logic) else $error(\"Assertion failed: CrcNext[0] does not reflect the correct logic when Enable is 1, Data[0] is 1, and Crc[28] is 0\");",
        "sva_id": "501_10_1_1"
    },
    {
        "sva": "property p_SendingCtrlFrm_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 SendingCtrlFrm == 0;\nendproperty\nassert_p_SendingCtrlFrm_TxReset: assert property (p_SendingCtrlFrm_TxReset) else $error(\"Assertion failed: SendingCtrlFrm is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_4_1_1"
    },
    {
        "sva": "property p_TxUsedDataIn_q_reset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 TxUsedDataIn_q == 0;\nendproperty\nassert_p_TxUsedDataIn_q_reset: assert property (p_TxUsedDataIn_q_reset) else $error(\"Assertion failed: TxUsedDataIn_q is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_19_1_1"
    },
    {
        "sva": "property p_BlockTxDone_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (BlockTxDone == 0);\nendproperty\nassert_p_BlockTxDone_TxReset: assert property (p_BlockTxDone_TxReset) else $error(\"Assertion failed: BlockTxDone signal is not 0 one cycle after TxReset is asserted.\");",
        "sva_id": "189_8_1_1"
    },
    {
        "sva": "property p_DlyCrcCnt_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (DlyCrcCnt == 4'h0);\nendproperty\nassert_p_DlyCrcCnt_TxReset: assert property (p_DlyCrcCnt_TxReset) else $error(\"Assertion failed: DlyCrcCnt is not 4'h0 one cycle after TxReset is asserted\");",
        "sva_id": "189_9_1_1"
    },
    {
        "sva": "property p_EnableCnt_assignment;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        DlyCrcEn == 0 |-> EnableCnt == 1;\nendproperty\nassert_p_EnableCnt_assignment: assert property (p_EnableCnt_assignment) else $error(\"Assertion failed: EnableCnt is not assigned to 1 when DlyCrcEn is 0\");",
        "sva_id": "189_16_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not assigned correctly one cycle after i_reset is asserted.\");",
        "sva_id": "389_15_1_1"
    },
    {
        "sva": "property p_CtrlMux_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (CtrlMux == 0);\nendproperty\nassert_p_CtrlMux_TxReset: assert property (p_CtrlMux_TxReset) else $error(\"Assertion failed: CtrlMux is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_5_1_1"
    },
    {
        "sva": "property p_ControlEnd_ByteCnt;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        ByteCnt[5:0] == 6'h22 |-> ControlEnd == 1;\nendproperty\nassert_p_ControlEnd_ByteCnt: assert property (p_ControlEnd_ByteCnt) else $error(\"Assertion failed: ControlEnd signal is not 1 when ByteCnt[5:0] is 0x22\");",
        "sva_id": "189_11_1_1"
    },
    {
        "sva": "property p_ControlData_assignment_on_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (ControlData[7:0] == 8'h0);\nendproperty\nassert_p_ControlData_assignment_on_TxReset: assert property (p_ControlData_assignment_on_TxReset) else $error(\"Assertion failed: ControlData[7:0] is not assigned to 8'h0 one cycle after TxReset is asserted\");",
        "sva_id": "189_17_1_1"
    },
    {
        "sva": "property p_ControlEnd_q_assignment;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        ControlEnd |-> ##1 ControlEnd_q == $past(ControlEnd);\nendproperty\nassert_p_ControlEnd_q_assignment: assert property (p_ControlEnd_q_assignment) else $error(\"Assertion failed: ControlEnd_q does not match the previous value of ControlEnd\");",
        "sva_id": "189_18_1_1"
    },
    {
        "sva": "property p_SendingCtrlFrm_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 SendingCtrlFrm == 0;\nendproperty\nassert_p_SendingCtrlFrm_TxReset: assert property (p_SendingCtrlFrm_TxReset) else $error(\"Assertion failed: SendingCtrlFrm signal is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_22_1_1"
    },
    {
        "sva": "property p_BlockTxDone_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 BlockTxDone == 0;\nendproperty\nassert_p_BlockTxDone_TxReset: assert property (p_BlockTxDone_TxReset) else $error(\"Assertion failed: BlockTxDone signal is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_20_1_1"
    },
    {
        "sva": "property p_o_out_assignment;\n    @(posedge i_clk) disable iff (i_reset == 1)\n        i_ce == 1 |-> ##1 o_out == $past(brmem[rdaddr]);\nendproperty\nassert_p_o_out_assignment: assert property (p_o_out_assignment) else $error(\"Assertion failed: o_out does not match the expected value from brmem at rdaddr after one cycle.\");",
        "sva_id": "389_17_1_1"
    },
    {
        "sva": "property p_IncrementByteCnt_CtrlMux;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        (TxCtrlStartFrm == 1 && TxCtrlStartFrm_q == 0 && TxUsedDataIn == 0) |-> (IncrementByteCnt == CtrlMux);\nendproperty\nassert_p_IncrementByteCnt_CtrlMux: assert property (p_IncrementByteCnt_CtrlMux) else $error(\"Assertion failed: IncrementByteCnt does not match CtrlMux when TxCtrlStartFrm transitions from 0 to 1 and TxUsedDataIn is 0\");",
        "sva_id": "189_14_1_1"
    },
    {
        "sva": "property p_CtrlMux_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (CtrlMux == 0);\nendproperty\nassert_p_CtrlMux_TxReset: assert property (p_CtrlMux_TxReset) else $error(\"Assertion failed: CtrlMux is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_23_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not assigned correctly after reset\");",
        "sva_id": "389_2_1_1"
    },
    {
        "sva": "property p_xoff_cpu_dl1_reset;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 xoff_cpu_dl1 == 0;\nendproperty\nassert_p_xoff_cpu_dl1_reset: assert property (p_xoff_cpu_dl1_reset) else $error(\"Assertion failed: xoff_cpu_dl1 is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1426_2_1_1"
    },
    {
        "sva": "property p_o_sync_reset;\n    @(posedge i_clk) disable iff (i_reset==0)\n        i_reset == 1 |-> ##1 o_sync == 0;\nendproperty\nassert_p_o_sync_reset: assert property (p_o_sync_reset) else $error(\"Assertion failed: o_sync is not 0 one cycle after i_reset is asserted\");",
        "sva_id": "389_8_1_1"
    },
    {
        "sva": "property p_o_sync_reset;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        (i_reset == 1) |-> ##1 (o_sync == 0);\nendproperty\nassert_p_o_sync_reset: assert property (p_o_sync_reset) else $error(\"Assertion failed: o_sync signal is not 0 one cycle after i_reset is asserted\");",
        "sva_id": "389_18_1_1"
    },
    {
        "sva": "property p_ControlData_assignment_on_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ##1 ControlData[7:0] == 8'h0;\nendproperty\nassert_p_ControlData_assignment_on_TxReset: assert property (p_ControlData_assignment_on_TxReset) else $error(\"Assertion failed: ControlData[7:0] is not assigned to 8'h0 one cycle after TxReset is asserted\");",
        "sva_id": "189_21_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not assigned correctly after reset\");",
        "sva_id": "389_9_1_1"
    },
    {
        "sva": "property p_ByteCnt_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (ByteCnt == 0);\nendproperty\nassert_p_ByteCnt_TxReset: assert property (p_ByteCnt_TxReset) else $error(\"Assertion failed: ByteCnt is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_10_1_1"
    },
    {
        "sva": "property p_r_freeze_compare_assignment;\n    @(posedge clk) disable iff (run_i == 1)\n        run_i == 0 |-> ##1 r_freeze_compare == 0;\nendproperty\nassert_p_r_freeze_compare_assignment: assert property (p_r_freeze_compare_assignment) else $error(\"Assertion failed: r_freeze_compare is not 0 one cycle after run_i is 0\");",
        "sva_id": "364_4_1_1"
    },
    {
        "sva": "property p_IncrementByteCntBy2;\n    @(posedge MTxClk) disable iff (TxReset == 1)\n        (CtrlMux == 1 && TxCtrlStartFrm == 1 && TxCtrlStartFrm_q == 0 && TxUsedDataIn == 1) |-> \n        (IncrementByteCntBy2 == (CtrlMux & TxCtrlStartFrm & ~TxCtrlStartFrm_q & TxUsedDataIn));\nendproperty\nassert_p_IncrementByteCntBy2: assert property (p_IncrementByteCntBy2) else $error(\"Assertion failed: IncrementByteCntBy2 signal does not reflect the correct state when CtrlMux, TxCtrlStartFrm, TxCtrlStartFrm_q, and TxUsedDataIn conditions are met\");",
        "sva_id": "189_15_1_1"
    },
    {
        "sva": "property p_wraddr_reset;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        (i_reset == 1) |-> ##1 (wraddr == 0);\nendproperty\nassert_p_wraddr_reset: assert property (p_wraddr_reset) else $error(\"Assertion failed: wraddr is not reset to 0 one cycle after i_reset is asserted\");",
        "sva_id": "389_5_1_1"
    },
    {
        "sva": "property p_r_swap_0_assignment;\n    @(posedge clk)\n        swap_i == 1 |-> ##1 r_swap[0] == 1;\nendproperty\nassert_p_r_swap_0_assignment: assert property (p_r_swap_0_assignment) else $error(\"Assertion failed: r_swap[0] is not assigned to 1 one cycle after swap_i is set to 1\");",
        "sva_id": "364_2_1_1"
    },
    {
        "sva": "property p_r_bit1_assignment;\n    @(posedge clk)\n        bit1_i == 1 |-> ##1 r_bit1 == $past(bit1_i);\nendproperty\nassert_p_r_bit1_assignment: assert property (p_r_bit1_assignment) else $error(\"Assertion failed: r_bit1 does not match the previous value of bit1_i\");",
        "sva_id": "364_5_1_1"
    },
    {
        "sva": "property p_r_run_0_assignment;\n    @(posedge clk)\n        run_i == 1 |-> ##1 r_run[0] == 1;\nendproperty\nassert_p_r_run_0_assignment: assert property (p_r_run_0_assignment) else $error(\"Assertion failed: r_run[0] is not assigned to 1 one cycle after run_i is 1\");",
        "sva_id": "364_7_1_1"
    },
    {
        "sva": "property p_wraddr_reset;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 wraddr == 0;\nendproperty\nassert_p_wraddr_reset: assert property (p_wraddr_reset) else $error(\"Assertion failed: wraddr is not 0 one cycle after reset is asserted\");",
        "sva_id": "389_4_1_1"
    },
    {
        "sva": "property p_pin_control_oe_assignment;\n    @(posedge clk) disable iff (nreset == 0)\n        (SYNTHESIZED_WIRE_3 == 1 && nreset == 1) |-> pin_control_oe == (SYNTHESIZED_WIRE_3 & nreset);\nendproperty\nassert_p_pin_control_oe_assignment: assert property (p_pin_control_oe_assignment) else $error(\"Assertion failed: pin_control_oe does not match the expected value when SYNTHESIZED_WIRE_3 is high and nreset is active\");",
        "sva_id": "37_5_1_1"
    },
    {
        "sva": "property p_TempDivider_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (Divider[7:0] < 2) |-> (TempDivider[7:0] == 8'h02);\nendproperty\nassert_p_TempDivider_assignment: assert property (p_TempDivider_assignment) else $error(\"Assertion failed: TempDivider[7:0] is not assigned to 8'h02 when Divider[7:0] is less than 2\");",
        "sva_id": "1423_7_1_1"
    },
    {
        "sva": "property p_r_swap_0_assignment;\n    @(posedge clk)\n        (run_i == 1 && swap_i == 1) |-> ##1 r_swap[0] == $past(swap_i);\nendproperty\nassert_p_r_swap_0_assignment: assert property (p_r_swap_0_assignment) else $error(\"Assertion failed: r_swap[0] does not match the past value of swap_i after one cycle delay\");",
        "sva_id": "364_6_1_1"
    },
    {
        "sva": "property p_WillSendControlFrame_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (WillSendControlFrame == 0);\nendproperty\nassert_p_WillSendControlFrame_TxReset: assert property (p_WillSendControlFrame_TxReset) else $error(\"Assertion failed: WillSendControlFrame signal should be 0 one cycle after TxReset is asserted\");",
        "sva_id": "189_1_1_1"
    },
    {
        "sva": "property p_iorq_Tw_DFF_inst5;\n    @(posedge clk) disable iff (nreset == 0)\n        DFF_inst5 == 1 |-> iorq_Tw == DFF_inst5;\nendproperty\nassert_p_iorq_Tw_DFF_inst5: assert property (p_iorq_Tw_DFF_inst5) else $error(\"Assertion failed: iorq_Tw does not match DFF_inst5 value\");",
        "sva_id": "37_7_1_1"
    },
    {
        "sva": "property p_NibCntEq7_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        NibCnt[2:0] == 3'b111 |-> NibCntEq7 == 1;\nendproperty\nassert_p_NibCntEq7_assignment: assert property (p_NibCntEq7_assignment) else $error(\"Assertion failed: NibCntEq7 is not equal to 1 when NibCnt[2:0] is 3'b111\");",
        "sva_id": "190_7_1_1"
    },
    {
        "sva": "property p_MdcEn_n_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (CountEq0 == 1 && Mdc == 1) |-> (MdcEn_n == (CountEq0 == 1 && Mdc == 1));\nendproperty\nassert_p_MdcEn_n_assignment: assert property (p_MdcEn_n_assignment) else $error(\"Assertion failed: MdcEn_n does not match the expected condition when CountEq0 and Mdc are both 1\");",
        "sva_id": "1423_3_1_1"
    },
    {
        "sva": "property p_rdaddr_wraddr_not;\n    @(posedge i_clk) disable iff (i_reset == 1)\n        wraddr[LGSIZE] == 0 |-> rdaddr[LGSIZE] == 1;\nendproperty\nassert_p_rdaddr_wraddr_not: assert property (p_rdaddr_wraddr_not) else $error(\"Assertion failed: rdaddr[LGSIZE] is not 1 when wraddr[LGSIZE] is 0\");",
        "sva_id": "389_23_1_1"
    },
    {
        "sva": "property p_CounterPreset_assignment;\n    @(posedge Clk) disable iff (Reset == 1)\n        (TempDivider == 8'b00001111) |-> (CounterPreset == 8'b00000110);\nendproperty\nassert_p_CounterPreset_assignment: assert property (p_CounterPreset_assignment) else $error(\"Assertion failed: CounterPreset is not assigned the value 8'b00000110 when TempDivider is 8'b00001111\");",
        "sva_id": "1423_6_1_1"
    },
    {
        "sva": "property p_ExcessiveDeferCnt_Assignment;\n    @(posedge MTxClk)\n    disable iff (Reset == 1)\n    NibCnt[13:0] == 16'h17b7 |-> ExcessiveDeferCnt == 1;\nendproperty\nassert_p_ExcessiveDeferCnt_Assignment: assert property (p_ExcessiveDeferCnt_Assignment) else $error(\"Assertion failed: ExcessiveDeferCnt is not assigned to 1 when NibCnt[13:0] equals 16'h17b7\");",
        "sva_id": "190_10_1_1"
    },
    {
        "sva": "property p_NibCnt_reset_logic;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 NibCnt == 16'h0;\nendproperty\nassert_p_NibCnt_reset_logic: assert property (p_NibCnt_reset_logic) else $error(\"Assertion failed: NibCnt is not reset to 16'h0 one cycle after Reset is asserted\");",
        "sva_id": "190_2_1_1"
    },
    {
        "sva": "property p_r_compare_result_assignment;\n    @(posedge clk) disable iff (run_i == 1)\n        run_i == 0 |-> ##1 r_compare_result == 0;\nendproperty\nassert_p_r_compare_result_assignment: assert property (p_r_compare_result_assignment) else $error(\"Assertion failed: r_compare_result is not 0 one cycle after run_i is 0\");",
        "sva_id": "364_1_1_1"
    },
    {
        "sva": "property p_ByteCnt_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ByteCnt[15:0] == 16'h0;\nendproperty\nassert_p_ByteCnt_Reset: assert property (p_ByteCnt_Reset) else $error(\"Assertion failed: ByteCnt[15:0] is not reset to 16'h0 one cycle after Reset is asserted\");",
        "sva_id": "190_3_1_1"
    },
    {
        "sva": "property p_ByteCntMax_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        ByteCnt[15:0] == 16'hFFFF |-> ByteCntMax == 1;\nendproperty\nassert_p_ByteCntMax_assignment: assert property (p_ByteCntMax_assignment) else $error(\"Assertion failed: ByteCntMax is not set to 1 when ByteCnt[15:0] is 16'hFFFF\");",
        "sva_id": "190_15_1_1"
    },
    {
        "sva": "property p_Mdc_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Mdc == 0;\nendproperty\nassert_p_Mdc_reset_logic: assert property (p_Mdc_reset_logic) else $error(\"Assertion failed: Mdc signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "1423_1_1_1"
    },
    {
        "sva": "property p_nhold_clk_wait_not_SYNTHESIZED_WIRE_9;\n    @(posedge clk) disable iff (nreset == 0)\n        SYNTHESIZED_WIRE_9 == 1 |-> nhold_clk_wait == (~SYNTHESIZED_WIRE_9);\nendproperty\nassert_p_nhold_clk_wait_not_SYNTHESIZED_WIRE_9: assert property (p_nhold_clk_wait_not_SYNTHESIZED_WIRE_9) else $error(\"Assertion failed: nhold_clk_wait does not reflect the correct state when SYNTHESIZED_WIRE_9 is 1\");",
        "sva_id": "37_13_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not set to 1 one cycle after i_reset is asserted.\");",
        "sva_id": "389_14_1_1"
    },
    {
        "sva": "property p_rdaddr_bit_reversed_assignment;\n    @(posedge i_clk) disable iff (i_reset == 1)\n        wraddr == 5'b10101 |-> rdaddr[0] == 1;\nendproperty\nassert_p_rdaddr_bit_reversed_assignment: assert property (p_rdaddr_bit_reversed_assignment) else $error(\"Assertion failed: rdaddr[0] is not equal to 1 when wraddr is 5'b10101\");",
        "sva_id": "389_6_1_1"
    },
    {
        "sva": "property p_Counter_Reset_Assignment;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Counter == 8'h1;\nendproperty\nassert_p_Counter_Reset_Assignment: assert property (p_Counter_Reset_Assignment) else $error(\"Assertion failed: Counter is not assigned to 8'h1 one cycle after Reset is asserted\");",
        "sva_id": "1423_4_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_4_assignment;\n    @(posedge clk) disable iff (nreset == 0)\n        (in_intr == 1 && M1 == 1 && T1 == 1) |-> (SYNTHESIZED_WIRE_4 == 1);\nendproperty\nassert_p_SYNTHESIZED_WIRE_4_assignment: assert property (p_SYNTHESIZED_WIRE_4_assignment) else $error(\"Assertion failed: SYNTHESIZED_WIRE_4 is not assigned correctly when in_intr, M1, and T1 are all 1\");",
        "sva_id": "37_4_1_1"
    },
    {
        "sva": "property p_IncrementByteCnt_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (Reset == 0 && StateData[1] == 1 && ByteCntMax == 0) |-> (IncrementByteCnt == 1);\nendproperty\nassert_p_IncrementByteCnt_assignment: assert property (p_IncrementByteCnt_assignment) else $error(\"Assertion failed: IncrementByteCnt is not assigned correctly when Reset is 0, StateData[1] is 1, and ByteCntMax is 0\");",
        "sva_id": "190_12_1_1"
    },
    {
        "sva": "property p_Counter_Reset_Assignment;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Counter == 8'h1;\nendproperty\nassert_p_Counter_Reset_Assignment: assert property (p_Counter_Reset_Assignment) else $error(\"Assertion failed: Counter is not assigned to 8'h1 one cycle after Reset is asserted\");",
        "sva_id": "1423_5_1_1"
    },
    {
        "sva": "property p_counter_reset_logic;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Counter == 8'h1;\nendproperty\nassert_p_counter_reset_logic: assert property (p_counter_reset_logic) else $error(\"Assertion failed: Counter does not equal 8'h1 one cycle after Reset is asserted\");",
        "sva_id": "1423_9_1_1"
    },
    {
        "sva": "property p_MaxFrame_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (ByteCnt[15:0] == MaxFL[15:0] && HugEn == 0) |-> MaxFrame == 1;\nendproperty\nassert_p_MaxFrame_assignment: assert property (p_MaxFrame_assignment) else $error(\"Assertion failed: MaxFrame is not assigned correctly when ByteCnt equals MaxFL and HugEn is 0\");",
        "sva_id": "190_14_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_9_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 SYNTHESIZED_WIRE_9 == 0;\nendproperty\nassert_p_SYNTHESIZED_WIRE_9_assignment: assert property (p_SYNTHESIZED_WIRE_9_assignment) else $error(\"Assertion failed: SYNTHESIZED_WIRE_9 is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_2_1_1"
    },
    {
        "sva": "property p_r_freeze_compare_assignment;\n    @(posedge clk) disable iff (run_i == 1)\n        run_i == 0 |-> ##1 r_freeze_compare == 0;\nendproperty\nassert_p_r_freeze_compare_assignment: assert property (p_r_freeze_compare_assignment) else $error(\"Assertion failed: r_freeze_compare is not 0 one cycle after run_i is 0\");",
        "sva_id": "364_3_1_1"
    },
    {
        "sva": "property p_DlyCrcCnt_reset_logic;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (DlyCrcCnt == 3'h0);\nendproperty\nassert_p_DlyCrcCnt_reset_logic: assert property (p_DlyCrcCnt_reset_logic) else $error(\"Assertion failed: DlyCrcCnt is not reset to 3'h0 one cycle after Reset is asserted\");",
        "sva_id": "190_4_1_1"
    },
    {
        "sva": "property p_NibCntEq15_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        NibCnt[3:0] == 4'b1111 |-> NibCntEq15 == 1;\nendproperty\nassert_p_NibCntEq15_assignment: assert property (p_NibCntEq15_assignment) else $error(\"Assertion failed: NibCntEq15 is not equal to 1 when NibCnt[3:0] is 4'b1111\");",
        "sva_id": "190_8_1_1"
    },
    {
        "sva": "property p_Counter_Reset_Assignment;\n    @(posedge Clk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 Counter == 8'h1;\nendproperty\nassert_p_Counter_Reset_Assignment: assert property (p_Counter_Reset_Assignment) else $error(\"Assertion failed: Counter is not assigned to 8'h1 one cycle after Reset is asserted\");",
        "sva_id": "1423_10_1_1"
    },
    {
        "sva": "property p_wraddr_reset;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        (i_reset == 1) |-> ##1 (wraddr == 0);\nendproperty\nassert_p_wraddr_reset: assert property (p_wraddr_reset) else $error(\"Assertion failed: wraddr is not 0 one cycle after i_reset is asserted\");",
        "sva_id": "389_16_1_1"
    },
    {
        "sva": "property p_ExcessiveDefer_Assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (NibCnt[13:0] == 16'h17b7 && ExDfrEn == 0) |-> (ExcessiveDefer == 1);\nendproperty\nassert_p_ExcessiveDefer_Assignment: assert property (p_ExcessiveDefer_Assignment) else $error(\"Assertion failed: ExcessiveDefer signal should be 1 when NibCnt[13:0] is 16'h17b7 and ExDfrEn is 0\");",
        "sva_id": "190_11_1_1"
    },
    {
        "sva": "property p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 hold_clk_busrq_ALTERA_SYNTHESIZED == 0;\nendproperty\nassert_p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment: assert property (p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment) else $error(\"Assertion failed: hold_clk_busrq_ALTERA_SYNTHESIZED is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_8_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not assigned correctly one cycle after i_reset is asserted.\");",
        "sva_id": "389_1_1_1"
    },
    {
        "sva": "property p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 hold_clk_busrq_ALTERA_SYNTHESIZED == 0;\nendproperty\nassert_p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment: assert property (p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment) else $error(\"Assertion failed: hold_clk_busrq_ALTERA_SYNTHESIZED is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_9_1_1"
    },
    {
        "sva": "property p_ResetByteCnt_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (StartBackoff == 1 && StateIdle == 1 && TxStartFrm == 1 && PacketFinished_q == 1) |-> (ResetByteCnt == 1);\nendproperty\nassert_p_ResetByteCnt_assignment: assert property (p_ResetByteCnt_assignment) else $error(\"Assertion failed: ResetByteCnt is not set to 1 when StartBackoff, StateIdle, TxStartFrm, and PacketFinished_q are all 1 at the rising edge of MTxClk\");",
        "sva_id": "190_13_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_8_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 SYNTHESIZED_WIRE_8 == 0;\nendproperty\nassert_p_SYNTHESIZED_WIRE_8_assignment: assert property (p_SYNTHESIZED_WIRE_8_assignment) else $error(\"Assertion failed: SYNTHESIZED_WIRE_8 is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_3_1_1"
    },
    {
        "sva": "property p_ResetNibCnt_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (StateDefer == 1 && ExcessiveDefer == 1 && TxStartFrm == 0) |-> (ResetNibCnt == 1);\nendproperty\nassert_p_ResetNibCnt_assignment: assert property (p_ResetNibCnt_assignment) else $error(\"Assertion failed: ResetNibCnt is not set to 1 when StateDefer, ExcessiveDefer are 1 and TxStartFrm is 0\");",
        "sva_id": "190_6_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_9_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 SYNTHESIZED_WIRE_9 == 0;\nendproperty\nassert_p_SYNTHESIZED_WIRE_9_assignment: assert property (p_SYNTHESIZED_WIRE_9_assignment) else $error(\"Assertion failed: SYNTHESIZED_WIRE_9 is not 0 one cycle after nreset is deasserted\");",
        "sva_id": "37_10_1_1"
    },
    {
        "sva": "property p_in_reset_assignment;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        i_reset == 1 |-> ##1 in_reset == 1;\nendproperty\nassert_p_in_reset_assignment: assert property (p_in_reset_assignment) else $error(\"Assertion failed: in_reset signal is not assigned correctly after reset\");",
        "sva_id": "389_11_1_1"
    },
    {
        "sva": "property p_wraddr_reset;\n    @(posedge i_clk) disable iff (i_reset == 0)\n        (i_reset == 1) |-> ##1 (wraddr == 0);\nendproperty\nassert_p_wraddr_reset: assert property (p_wraddr_reset) else $error(\"Assertion failed: wraddr is not reset to 0 one cycle after i_reset is asserted\");",
        "sva_id": "389_12_1_1"
    },
    {
        "sva": "property p_NibbleMinFl_assignment;\n    @(posedge MTxClk) disable iff (Reset == 1)\n        (NibCnt >= (((MinFL - 3'h4) << 1) - 1)) |-> (NibbleMinFl == 1);\nendproperty\nassert_p_NibbleMinFl_assignment: assert property (p_NibbleMinFl_assignment) else $error(\"Assertion failed: NibbleMinFl is not 1 when NibCnt is greater than or equal to the specified threshold.\");",
        "sva_id": "190_9_1_1"
    },
    {
        "sva": "property p_IncrementNibCnt_StateIPG;\n    @(posedge MTxClk)\n    disable iff (Reset == 1)\n    (StateIPG == 1 && StatePreamble == 0 && StateData == 0 && StatePAD == 0 && StateFCS == 0 && StateJam == 0 && StateBackOff == 0 && StateDefer == 0 && ExcessiveDefer == 0 && TxStartFrm == 0) |-> (IncrementNibCnt == 1);\nendproperty\nassert_p_IncrementNibCnt_StateIPG: assert property (p_IncrementNibCnt_StateIPG) else $error(\"Assertion failed: IncrementNibCnt should be 1 when StateIPG is 1 and all other states are 0\");",
        "sva_id": "190_5_1_1"
    },
    {
        "sva": "property p_ResetByteCnt_assignment;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        TxReset == 1 |-> ResetByteCnt == (TxReset || (!TxCtrlStartFrm && (TxDoneIn || TxAbortIn)));\nendproperty\nassert_p_ResetByteCnt_assignment: assert property (p_ResetByteCnt_assignment) else $error(\"Assertion failed: ResetByteCnt signal does not reflect the expected state when TxReset is active.\");",
        "sva_id": "189_13_1_1"
    },
    {
        "sva": "property p_hold_clk_iorq_assignment_logic;\n    @(posedge clk) disable iff (nreset == 0)\n        (DFF_inst5 == 1 && SYNTHESIZED_WIRE_7 == 0) |-> hold_clk_iorq == (DFF_inst5 | SYNTHESIZED_WIRE_7);\nendproperty\nassert_p_hold_clk_iorq_assignment_logic: assert property (p_hold_clk_iorq_assignment_logic) else $error(\"Assertion failed: hold_clk_iorq does not reflect the correct logic when DFF_inst5 is 1 and SYNTHESIZED_WIRE_7 is 0\");",
        "sva_id": "37_6_1_1"
    },
    {
        "sva": "property p_double_deser_calculation;\n    @(posedge tx_fastclk or negedge tx_fastclk)\n        deserialization_factor == 4 |-> DOUBLE_DESER == 8;\nendproperty\nassert_p_double_deser_calculation: assert property (p_double_deser_calculation) else $error(\"Assertion failed: DOUBLE_DESER is not equal to 8 when deserialization_factor is 4\");",
        "sva_id": "460_6_1_1"
    },
    {
        "sva": "property p_w_we_assignment_logic;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        (o_full == 0 && i_wstrobe == 1) |-> (w_we == 1);\nendproperty\nassert_p_w_we_assignment_logic: assert property (p_w_we_assignment_logic) else $error(\"Assertion failed: When o_full is 0 and i_wstrobe is 1, w_we should be 1\");",
        "sva_id": "1760_3_1_1"
    },
    {
        "sva": "property p_SYNTHESIZED_WIRE_9_reset;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 SYNTHESIZED_WIRE_9 == 0;\nendproperty\nassert_p_SYNTHESIZED_WIRE_9_reset: assert property (p_SYNTHESIZED_WIRE_9_reset) else $error(\"Assertion failed: SYNTHESIZED_WIRE_9 is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_12_1_1"
    },
    {
        "sva": "property p_r_dividend_assignment_logic;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        (pre_sign == 1 && r_dividend[31] == 1) |-> ##1 r_dividend == -$past(r_dividend);\nendproperty\nassert_p_r_dividend_assignment_logic: assert property (p_r_dividend_assignment_logic) else $error(\"Assertion failed: r_dividend does not equal the negation of its past value when pre_sign and r_dividend[31] are both 1\");",
        "sva_id": "1315_5_1_1"
    },
    {
        "sva": "property p_r_busy_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1) |-> ##1 (r_busy == 0);\nendproperty\nassert_p_r_busy_reset: assert property (p_r_busy_reset) else $error(\"Assertion failed: r_busy signal should be 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_14_1_1"
    },
    {
        "sva": "property p_o_empty_rs_status;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        rs_status == 0 |-> o_empty == 1;\nendproperty\nassert_p_o_empty_rs_status: assert property (p_o_empty_rs_status) else $error(\"Assertion failed: When rs_status is 0, o_empty should be 1\");",
        "sva_id": "1760_8_1_1"
    },
    {
        "sva": "property p_zero_divisor_reset;\n    @(posedge i_clk) disable iff (i_rst==0)\n        (i_rst == 1) |-> ##1 (zero_divisor == 0);\nendproperty\nassert_p_zero_divisor_reset: assert property (p_zero_divisor_reset) else $error(\"Assertion failed: zero_divisor is not 0 one cycle after reset is asserted\");",
        "sva_id": "1315_15_1_1"
    },
    {
        "sva": "property p_LGBW_correct_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        BW == 32 |-> LGBW == 5;\nendproperty\nassert_p_LGBW_correct_assignment: assert property (p_LGBW_correct_assignment) else $error(\"Assertion failed: LGBW is not correctly assigned when BW is 32\");",
        "sva_id": "1315_13_1_1"
    },
    {
        "sva": "property p_pre_sign_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 pre_sign == $past(i_signed);\nendproperty\nassert_p_pre_sign_assignment: assert property (p_pre_sign_assignment) else $error(\"Assertion failed: pre_sign does not match the previous value of i_signed after one clock cycle when i_wr is asserted\");",
        "sva_id": "1315_20_1_1"
    },
    {
        "sva": "property p_diff_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        (r_dividend == 50 && r_divisor == 20) |-> (diff == (50 - 20) & ((1 << 31) - 1));\nendproperty\nassert_p_diff_assignment: assert property (p_diff_assignment) else $error(\"Assertion failed: diff signal does not reflect the correct difference value when r_dividend is 50 and r_divisor is 20\");",
        "sva_id": "1315_12_1_1"
    },
    {
        "sva": "property p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment;\n    @(posedge clk) disable iff (nreset == 1)\n        nreset == 0 |-> ##1 hold_clk_busrq_ALTERA_SYNTHESIZED == 0;\nendproperty\nassert_p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment: assert property (p_hold_clk_busrq_ALTERA_SYNTHESIZED_assignment) else $error(\"Assertion failed: hold_clk_busrq_ALTERA_SYNTHESIZED is not 0 one cycle after nreset is 0\");",
        "sva_id": "37_1_1_1"
    },
    {
        "sva": "property p_o_err_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 o_err == 0;\nendproperty\nassert_p_o_err_reset: assert property (p_o_err_reset) else $error(\"Assertion failed: o_err signal is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_17_1_1"
    },
    {
        "sva": "property p_w_n_msb_o_quotient;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        o_quotient == 32'h80000000 |-> w_n == (o_quotient[31] == 1);\nendproperty\nassert_p_w_n_msb_o_quotient: assert property (p_w_n_msb_o_quotient) else $error(\"Assertion failed: w_n does not match the MSB of o_quotient when o_quotient is 32'h80000000\");",
        "sva_id": "1315_27_1_1"
    },
    {
        "sva": "property p_last_bit_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        (r_busy == 1 && r_bit == {{(LGBW-1){1'b0}}, 1'b1}) |-> ##1 (last_bit == 1);\nendproperty\nassert_p_last_bit_assignment: assert property (p_last_bit_assignment) else $error(\"Assertion failed: last_bit is not assigned correctly one cycle after r_bit is the last bit.\");",
        "sva_id": "1315_19_1_1"
    },
    {
        "sva": "property p_r_sign_assignment_logic;\n    @(posedge i_clk) disable iff (i_rst)\n        pre_sign == 1 |-> ##1 r_sign == ($past(r_divisor[(2*BW-2)]) ^ $past(r_dividend[(BW-1)]));\nendproperty\nassert_p_r_sign_assignment_logic: assert property (p_r_sign_assignment_logic) else $error(\"Assertion failed: r_sign does not match the expected XOR of past r_divisor and r_dividend bits\");",
        "sva_id": "1315_23_1_1"
    },
    {
        "sva": "property p_o_valid_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 o_valid == 0;\nendproperty\nassert_p_o_valid_reset: assert property (p_o_valid_reset) else $error(\"Assertion failed: o_valid should be 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_16_1_1"
    },
    {
        "sva": "property p_o_err_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 o_err == 0;\nendproperty\nassert_p_o_err_reset: assert property (p_o_err_reset) else $error(\"Assertion failed: o_err signal is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_9_1_1"
    },
    {
        "sva": "property p_o_busy_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 o_busy == 0;\nendproperty\nassert_p_o_busy_reset: assert property (p_o_busy_reset) else $error(\"Assertion failed: o_busy signal is not 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_7_1_1"
    },
    {
        "sva": "property p_r_c_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        (r_busy == 1 && diff == 0) |-> ##1 (r_c == 1);\nendproperty\nassert_p_r_c_assignment: assert property (p_r_c_assignment) else $error(\"Assertion failed: r_c signal should be 1 one cycle after r_busy is 1 and diff is 0\");",
        "sva_id": "1315_25_1_1"
    },
    {
        "sva": "property p_r_dividend_negation;\n    @(posedge i_clk) disable iff (i_rst)\n        (pre_sign == 1 && r_dividend[31] == 1) |-> ##1 r_dividend == -$past(r_dividend);\nendproperty\nassert_p_r_dividend_negation: assert property (p_r_dividend_negation) else $error(\"Assertion failed: r_dividend does not equal the negation of its previous value when pre_sign and r_dividend[31] are both 1\");",
        "sva_id": "1315_21_1_1"
    },
    {
        "sva": "property p_r_busy_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 r_busy == 0;\nendproperty\nassert_p_r_busy_reset: assert property (p_r_busy_reset) else $error(\"Assertion failed: r_busy is not 0 one cycle after i_rst is asserted.\");",
        "sva_id": "1315_3_1_1"
    },
    {
        "sva": "property p_o_empty_blocking_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rs_status == 0 |-> o_empty == 1;\nendproperty\nassert_p_o_empty_blocking_assignment: assert property (p_o_empty_blocking_assignment) else $error(\"Assertion failed: o_empty signal is not 1 when rs_status is 0\");",
        "sva_id": "1760_18_1_1"
    },
    {
        "sva": "property p_w_re_assignment;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (i_renable == 1 && o_empty == 0) |-> (w_re == (i_renable == 1 && ~o_empty));\nendproperty\nassert_p_w_re_assignment: assert property (p_w_re_assignment) else $error(\"Assertion failed: w_re signal does not reflect the correct state when i_renable is 1 and o_empty is 0\");",
        "sva_id": "1760_22_1_1"
    },
    {
        "sva": "property p_o_full_assignment;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        rs_status == P_DEPTH |-> o_full == 1;\nendproperty\nassert_p_o_full_assignment: assert property (p_o_full_assignment) else $error(\"Assertion failed: o_full signal is not assigned correctly when rs_status equals P_DEPTH\");",
        "sva_id": "1760_5_1_1"
    },
    {
        "sva": "property p_rs_write_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_write_counter == 0;\nendproperty\nassert_p_rs_write_counter_reset: assert property (p_rs_write_counter_reset) else $error(\"Assertion failed: rs_write_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_24_1_1"
    },
    {
        "sva": "property p_o_dt_rs_data_buffer;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        (rs_read_counter >= 0 && rs_read_counter < $size(rs_data_buffer)) |-> o_dt == rs_data_buffer[rs_read_counter];\nendproperty\nassert_p_o_dt_rs_data_buffer: assert property (p_o_dt_rs_data_buffer) else $error(\"Assertion failed: o_dt does not match the expected value from rs_data_buffer at the given rs_read_counter index\");",
        "sva_id": "1760_7_1_1"
    },
    {
        "sva": "property p_w_we_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        (o_full == 0 && i_wstrobe == 1) |-> (w_we == (o_full == 0 && i_wstrobe == 1));\nendproperty\nassert_p_w_we_assignment: assert property (p_w_we_assignment) else $error(\"Assertion failed: w_we signal does not reflect the correct state when o_full is 0 and i_wstrobe is 1\");",
        "sva_id": "1760_21_1_1"
    },
    {
        "sva": "property p_rs_read_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_read_counter == 0;\nendproperty\nassert_p_rs_read_counter_reset: assert property (p_rs_read_counter_reset) else $error(\"Assertion failed: rs_read_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_26_1_1"
    },
    {
        "sva": "property p_o_valid_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        (i_rst == 1) |-> ##1 (o_valid == 0);\nendproperty\nassert_p_o_valid_reset: assert property (p_o_valid_reset) else $error(\"Assertion failed: o_valid signal should be 0 one cycle after i_rst is asserted\");",
        "sva_id": "1315_8_1_1"
    },
    {
        "sva": "property p_zero_divisor_reset;\n    @(posedge i_clk) disable iff (i_rst == 0)\n        i_rst == 1 |-> ##1 zero_divisor == 0;\nendproperty\nassert_p_zero_divisor_reset: assert property (p_zero_divisor_reset) else $error(\"Assertion failed: zero_divisor is not 0 one cycle after reset is asserted\");",
        "sva_id": "1315_6_1_1"
    },
    {
        "sva": "property p_EF_negation_nEF;\n    @(posedge Clk) disable iff (Rst == 1)\n        nEF == 0 |-> EF == 1;\nendproperty\nassert_p_EF_negation_nEF: assert property (p_EF_negation_nEF) else $error(\"Assertion failed: EF signal should be 1 when nEF is 0 at the rising edge of Clk\");",
        "sva_id": "1547_8_1_1"
    },
    {
        "sva": "property p_diff_assignment;\n    @(posedge i_clk) disable iff (i_rst)\n        (r_dividend == 32'h00000010 && r_divisor == 32'h00000008) |-> \n        (diff == (r_dividend - r_divisor) & 32'h7FFFFFFF);\nendproperty\nassert_p_diff_assignment: assert property (p_diff_assignment) else $error(\"Assertion failed: diff signal does not reflect the correct difference between r_dividend and r_divisor\");",
        "sva_id": "1315_26_1_1"
    },
    {
        "sva": "property p_o_dnum_rs_status;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        rs_status == 3 |-> o_dnum == rs_status;\nendproperty\nassert_p_o_dnum_rs_status: assert property (p_o_dnum_rs_status) else $error(\"Assertion failed: o_dnum does not match rs_status when rs_status is 3\");",
        "sva_id": "1760_9_1_1"
    },
    {
        "sva": "property p_rs_write_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_write_counter == 0;\nendproperty\nassert_p_rs_write_counter_reset: assert property (p_rs_write_counter_reset) else $error(\"Assertion failed: rs_write_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_13_1_1"
    },
    {
        "sva": "property p_rs_read_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_read_counter == 0;\nendproperty\nassert_p_rs_read_counter_reset: assert property (p_rs_read_counter_reset) else $error(\"Assertion failed: rs_read_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_15_1_1"
    },
    {
        "sva": "property p_Rd_blocking_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (RE == 1 && EF == 0) |-> (Rd == (RE == 1 && EF == 0));\nendproperty\nassert_p_Rd_blocking_assignment: assert property (p_Rd_blocking_assignment) else $error(\"Assertion failed: Rd signal does not reflect the correct state when RE is 1 and EF is 0\");",
        "sva_id": "1547_4_1_1"
    },
    {
        "sva": "property p_nEF_assignment_on_reset;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 nEF == 0;\nendproperty\nassert_p_nEF_assignment_on_reset: assert property (p_nEF_assignment_on_reset) else $error(\"Assertion failed: nEF signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "1547_17_1_1"
    },
    {
        "sva": "property p_HF_blocking_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Cnt[addr] == 1 && Cnt[(addr - 1)] == 0) |-> HF == (Cnt[addr] | Cnt[(addr - 1)]);\nendproperty\nassert_p_HF_blocking_assignment: assert property (p_HF_blocking_assignment) else $error(\"Assertion failed: HF signal does not reflect the correct state based on Cnt[addr] and Cnt[(addr - 1)]\");",
        "sva_id": "1547_9_1_1"
    },
    {
        "sva": "property p_ZeroLeft_assignment;\n    @(posedge clk) disable iff (rst_n == 0)\n        (rst_n == 1 && ena == 1 && clr == 0 && ZeroLeft_init == 1 && sel == 0) |-> ##1 ZeroLeft == $past(TotalZeros_comb);\nendproperty\nassert_p_ZeroLeft_assignment: assert property (p_ZeroLeft_assignment) else $error(\"Assertion failed: ZeroLeft signal does not reflect the correct state based on TotalZeros_comb\");",
        "sva_id": "369_6_1_1"
    },
    {
        "sva": "property p_rFF_reset_assignment;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 rFF == 0;\nendproperty\nassert_p_rFF_reset_assignment: assert property (p_rFF_reset_assignment) else $error(\"Assertion failed: rFF is not assigned to 0 one cycle after Rst is asserted\");",
        "sva_id": "1547_18_1_1"
    },
    {
        "sva": "property p_ZeroLeft_reset_logic;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_reset_logic: assert property (p_ZeroLeft_reset_logic) else $error(\"Assertion failed: ZeroLeft signal is not zero one cycle after rst_n is deasserted\");",
        "sva_id": "369_9_1_1"
    },
    {
        "sva": "property p_DPRA_reset_assignment;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 DPRA == 0;\nendproperty\nassert_p_DPRA_reset_assignment: assert property (p_DPRA_reset_assignment) else $error(\"Assertion failed: DPRA is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "1547_15_1_1"
    },
    {
        "sva": "property p_o_dt_rs_data_buffer_assignment;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (rs_read_counter >= 0 && rs_read_counter < $size(rs_data_buffer)) |-> o_dt == rs_data_buffer[rs_read_counter];\nendproperty\nassert_p_o_dt_rs_data_buffer_assignment: assert property (p_o_dt_rs_data_buffer_assignment) else $error(\"Assertion failed: o_dt does not match the expected value from rs_data_buffer at the given rs_read_counter index\");",
        "sva_id": "1760_19_1_1"
    },
    {
        "sva": "property p_HF_blocking_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Cnt[addr] == 1 && Cnt[(addr - 1)] == 0) |-> HF == (Cnt[addr] | Cnt[(addr - 1)]);\nendproperty\nassert_p_HF_blocking_assignment: assert property (p_HF_blocking_assignment) else $error(\"Assertion failed: HF signal does not reflect the correct state based on Cnt[addr] and Cnt[(addr - 1)]\");",
        "sva_id": "1547_12_1_1"
    },
    {
        "sva": "property p_coeff_assignment_when_i_zero;\n    @(posedge clk) disable iff (rst_n == 0)\n        (ena == 1 && sel == 1 && i == 0) |-> (coeff == level_0);\nendproperty\nassert_p_coeff_assignment_when_i_zero: assert property (p_coeff_assignment_when_i_zero) else $error(\"Assertion failed: coeff is not assigned to level_0 when ena, sel are 1 and i is 0\");",
        "sva_id": "369_10_1_1"
    },
    {
        "sva": "property p_WCnt_reset_logic;\n    @(posedge Clk) disable iff (Rst==0)\n        (Rst == 1) |-> ##1 (WCnt == 0);\nendproperty\nassert_p_WCnt_reset_logic: assert property (p_WCnt_reset_logic) else $error(\"Assertion failed: WCnt is not 0 one cycle after Rst is asserted\");",
        "sva_id": "1547_16_1_1"
    },
    {
        "sva": "property p_A_assignment_on_reset;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 A == 0;\nendproperty\nassert_p_A_assignment_on_reset: assert property (p_A_assignment_on_reset) else $error(\"Assertion failed: A is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "1547_14_1_1"
    },
    {
        "sva": "property p_ZeroLeft_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_reset: assert property (p_ZeroLeft_reset) else $error(\"Assertion failed: ZeroLeft signal is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "369_12_1_1"
    },
    {
        "sva": "property p_pre_sign_assignment;\n    @(posedge i_clk) disable iff (i_rst == 1)\n        i_wr == 1 |-> ##1 pre_sign == $past(i_signed);\nendproperty\nassert_p_pre_sign_assignment: assert property (p_pre_sign_assignment) else $error(\"Assertion failed: pre_sign does not match the past value of i_signed one cycle after i_wr is asserted\");",
        "sva_id": "1315_4_1_1"
    },
    {
        "sva": "property p_ZeroLeft_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_reset: assert property (p_ZeroLeft_reset) else $error(\"Assertion failed: ZeroLeft is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "369_3_1_1"
    },
    {
        "sva": "property p_ZeroLeft_reset_initialization;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_reset_initialization: assert property (p_ZeroLeft_reset_initialization) else $error(\"Assertion failed: ZeroLeft is not initialized to 0 after reset\");",
        "sva_id": "369_2_1_1"
    },
    {
        "sva": "property p_Wr_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (WE == 1 && FF == 0) |-> (Wr == (WE & ~FF));\nendproperty\nassert_p_Wr_assignment: assert property (p_Wr_assignment) else $error(\"Assertion failed: Wr signal does not match the expected value when WE is 1 and FF is 0\");",
        "sva_id": "1547_3_1_1"
    },
    {
        "sva": "property p_DO_assignment_logic;\n    @(posedge Clk) disable iff (Rst == 1)\n        (RE == 1 && EF == 0) |-> (DO == RAM[DPRA]);\nendproperty\nassert_p_DO_assignment_logic: assert property (p_DO_assignment_logic) else $error(\"Assertion failed: DO signal does not match RAM[DPRA] when RE is high and EF is low\");",
        "sva_id": "1547_6_1_1"
    },
    {
        "sva": "property p_A_assignment_logic;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Rst == 0 && Wr == 1 && A < 1) |-> ##1 A == $past(A) + 1;\nendproperty\nassert_p_A_assignment_logic: assert property (p_A_assignment_logic) else $error(\"Assertion failed: A signal does not increment correctly when Wr is high and A is less than 1\");",
        "sva_id": "1547_2_1_1"
    },
    {
        "sva": "property p_WCnt_reset;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 WCnt == 0;\nendproperty\nassert_p_WCnt_reset: assert property (p_WCnt_reset) else $error(\"Assertion failed: WCnt is not reset to 0 one cycle after Rst is asserted\");",
        "sva_id": "1547_10_1_1"
    },
    {
        "sva": "property p_DI_to_RAM_A;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Rst == 0 && Wr == 1) |-> ##1 RAM[$past(A)] == $past(DI);\nendproperty\nassert_p_DI_to_RAM_A: assert property (p_DI_to_RAM_A) else $error(\"Assertion failed: RAM content at address A does not match the previous value of DI after one clock cycle\");",
        "sva_id": "1547_5_1_1"
    },
    {
        "sva": "property p_Rd_blocking_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (RE == 1 && EF == 0) |-> (Rd == (RE == 1 && !EF));\nendproperty\nassert_p_Rd_blocking_assignment: assert property (p_Rd_blocking_assignment) else $error(\"Assertion failed: Rd signal does not reflect the correct state when RE is 1 and EF is 0\");",
        "sva_id": "1547_21_1_1"
    },
    {
        "sva": "property p_o_quotient_assignment;\n    @(posedge i_clk) disable iff (i_rst)\n        (r_busy == 1 && r_divisor[(2*BW-2):(BW)] == 0 && diff[BW] == 0) |-> ##1 o_quotient == { $past(o_quotient[(BW-2):0]), 1'b1 };\nendproperty\nassert_p_o_quotient_assignment: assert property (p_o_quotient_assignment) else $error(\"Assertion failed: o_quotient is not assigned correctly when r_busy is 1, r_divisor[(2*BW-2):(BW)] is 0, and diff[BW] is 0\");",
        "sva_id": "1315_24_1_1"
    },
    {
        "sva": "property p_rFF_reset_logic;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 rFF == 0;\nendproperty\nassert_p_rFF_reset_logic: assert property (p_rFF_reset_logic) else $error(\"Assertion failed: rFF signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "1547_7_1_1"
    },
    {
        "sva": "property p_ZeroLeft_assignment;\n    @(posedge clk) disable iff (rst_n == 0)\n        (rst_n == 1 && ena == 1 && clr == 1) |-> ##1 (ZeroLeft == 0);\nendproperty\nassert_p_ZeroLeft_assignment: assert property (p_ZeroLeft_assignment) else $error(\"Assertion failed: ZeroLeft signal is not assigned to 0 one cycle after the conditions rst_n, ena, and clr are all 1\");",
        "sva_id": "369_4_1_1"
    },
    {
        "sva": "property p_memory_write_operation;\n    @(posedge Clk) disable iff (Rst == 1)\n        Wr == 1 |-> ##1 RAM[$past(A)] == $past(DI);\nendproperty\nassert_p_memory_write_operation: assert property (p_memory_write_operation) else $error(\"Assertion failed: RAM content does not match the expected data after a write operation\");",
        "sva_id": "1547_19_1_1"
    },
    {
        "sva": "property p_rs_write_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_write_counter == 0;\nendproperty\nassert_p_rs_write_counter_reset: assert property (p_rs_write_counter_reset) else $error(\"Assertion failed: rs_write_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_2_1_1"
    },
    {
        "sva": "property p_CE_XOR_Wr_Rd;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Wr == 1 && Rd == 0) |-> (CE == (Wr ^ Rd));\nendproperty\nassert_p_CE_XOR_Wr_Rd: assert property (p_CE_XOR_Wr_Rd) else $error(\"Assertion failed: CE does not equal Wr XOR Rd when Wr is 1 and Rd is 0\");",
        "sva_id": "1547_22_1_1"
    },
    {
        "sva": "property p_coeff_1_assignment_logic;\n    @(posedge clk) disable iff (rst_n == 0)\n        (rst_n == 1 && ena == 1 && clr == 0 && sel == 1 && ZeroLeft == 1 && i == 0) |-> ##1 coeff_1 == $past(coeff);\nendproperty\nassert_p_coeff_1_assignment_logic: assert property (p_coeff_1_assignment_logic) else $error(\"Assertion failed: coeff_1 does not reflect the correct state based on the past value of coeff under the specified conditions\");",
        "sva_id": "369_11_1_1"
    },
    {
        "sva": "property p_EF_negation_nEF;\n    @(posedge Clk) disable iff (Rst == 1)\n        nEF == 0 |-> EF == ~nEF;\nendproperty\nassert_p_EF_negation_nEF: assert property (p_EF_negation_nEF) else $error(\"Assertion failed: EF does not equal the negation of nEF when nEF is 0\");",
        "sva_id": "1547_24_1_1"
    },
    {
        "sva": "property p_ZeroLeft_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_reset: assert property (p_ZeroLeft_reset) else $error(\"Assertion failed: ZeroLeft signal is not 0 one cycle after rst_n is deasserted\");",
        "sva_id": "369_7_1_1"
    },
    {
        "sva": "property p_FF_rFF;\n    @(posedge Clk) disable iff (Rst == 1)\n        rFF == 1 |-> FF == rFF;\nendproperty\nassert_p_FF_rFF: assert property (p_FF_rFF) else $error(\"Assertion failed: FF signal does not match rFF signal when rFF is 1\");",
        "sva_id": "1547_25_1_1"
    },
    {
        "sva": "property p_A_assignment_on_reset;\n    @(posedge Clk) disable iff (Rst == 0)\n        Rst == 1 |-> ##1 A == 0;\nendproperty\nassert_p_A_assignment_on_reset: assert property (p_A_assignment_on_reset) else $error(\"Assertion failed: A is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "1547_1_1_1"
    },
    {
        "sva": "property p_minx1_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (DAC == 1 && x < d[data_bit-1:data_bit-x_bit]) |-> (minx1 == x);\nendproperty\nassert_p_minx1_assignment: assert property (p_minx1_assignment) else $error(\"Assertion failed: minx1 is not equal to x when DAC is 1 and x is less than the specified range of d\");",
        "sva_id": "679_5_1_1"
    },
    {
        "sva": "property p_rs_status_reset_logic;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_status == 0;\nendproperty\nassert_p_rs_status_reset_logic: assert property (p_rs_status_reset_logic) else $error(\"Assertion failed: rs_status is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1760_27_1_1"
    },
    {
        "sva": "property p_LatchedMRxErr_idle_condition;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && MRxErr == 1 && MRxDV == 1 && RxStateIdle == 1 && Transmitting == 0) |-> ##1 LatchedMRxErr == 1;\nendproperty\nassert_p_LatchedMRxErr_idle_condition: assert property (p_LatchedMRxErr_idle_condition) else $error(\"Assertion failed: LatchedMRxErr is not set to 1 under idle condition when MRxErr is asserted\");",
        "sva_id": "180_9_1_1"
    },
    {
        "sva": "property p_coeff_assignment_logic;\n    @(posedge clk) disable iff (rst_n == 0)\n        (ena == 1 && sel == 1 && i == 0) |-> (coeff == level_0);\nendproperty\nassert_p_coeff_assignment_logic: assert property (p_coeff_assignment_logic) else $error(\"Assertion failed: coeff does not equal level_0 when ena, sel, and i are set to 1, 1, and 0 respectively.\");",
        "sva_id": "369_15_1_1"
    },
    {
        "sva": "property p_x_y_assignment_on_rst;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 x == $past(rstx[x_bit-1:0]) && y == $past(rsty[y_bit-1:0]);\nendproperty\nassert_p_x_y_assignment_on_rst: assert property (p_x_y_assignment_on_rst) else $error(\"Assertion failed: x and y do not reflect the correct state after reset\");",
        "sva_id": "679_1_1_1"
    },
    {
        "sva": "property p_A_assignment_logic;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Rst == 0 && Wr == 1 && A < '1) |-> ##1 A == $past(A) + 1;\nendproperty\nassert_p_A_assignment_logic: assert property (p_A_assignment_logic) else $error(\"Assertion failed: A signal does not increment correctly when Wr is asserted and Rst is deasserted\");",
        "sva_id": "1547_11_1_1"
    },
    {
        "sva": "property p_d_assignment_logic;\n    @(posedge clk) disable iff (rst)\n        (rst == 0 && datavalid == 1 && CLR == 1) |-> ##1 d == { {x_bit{1'b1}}, {x_bit{1'b0}}, {y_bit{1'b1}}, {y_bit{1'b0}} };\nendproperty\nassert_p_d_assignment_logic: assert property (p_d_assignment_logic) else $error(\"Assertion failed: 'd' signal does not match the expected pattern after the specified conditions are met\");",
        "sva_id": "679_4_1_1"
    },
    {
        "sva": "property p_d_assignment_on_rst;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 d == {{x_bit{1'b1}}, {x_bit{1'b0}}, {y_bit{1'b1}}, {y_bit{1'b0}}};\nendproperty\nassert_p_d_assignment_on_rst: assert property (p_d_assignment_on_rst) else $error(\"Assertion failed: 'd' signal does not match the expected pattern after reset\");",
        "sva_id": "679_3_1_1"
    },
    {
        "sva": "property p_ZeroLeft_assignment_on_reset;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 ZeroLeft == 0;\nendproperty\nassert_p_ZeroLeft_assignment_on_reset: assert property (p_ZeroLeft_assignment_on_reset) else $error(\"Assertion failed: ZeroLeft signal is not assigned to 0 one cycle after reset is deasserted\");",
        "sva_id": "369_1_1_1"
    },
    {
        "sva": "property p_miny_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (DMG == 1 && dp[17:9] < miny1) |-> (miny == dp[17:9]);\nendproperty\nassert_p_miny_assignment_logic: assert property (p_miny_assignment_logic) else $error(\"Assertion failed: miny signal does not match dp[17:9] when DMG is 1 and dp[17:9] is less than miny1\");",
        "sva_id": "679_11_1_1"
    },
    {
        "sva": "property p_minx_assignment_logic;\n    @(posedge clk) disable iff (rst)\n        (DMG == 1 && dp[data_bit-1:data_bit-x_bit] < minx1) |-> minx == dp[data_bit-1:data_bit-x_bit];\nendproperty\nassert_p_minx_assignment_logic: assert property (p_minx_assignment_logic) else $error(\"Assertion failed: minx does not match the expected value from dp[data_bit-1:data_bit-x_bit] when DMG is 1 and dp[data_bit-1:data_bit-x_bit] is less than minx1\");",
        "sva_id": "679_9_1_1"
    },
    {
        "sva": "property p_maxy_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (DMG == 1 && dp[8:0] > maxy1) |-> (maxy == dp[8:0]);\nendproperty\nassert_p_maxy_assignment_logic: assert property (p_maxy_assignment_logic) else $error(\"Assertion failed: maxy does not correctly reflect the value of dp[8:0] when DMG is 1 and dp[8:0] is greater than maxy1\");",
        "sva_id": "679_12_1_1"
    },
    {
        "sva": "property p_HF_blocking_assignment;\n    @(posedge Clk) disable iff (Rst == 1)\n        (Cnt[addr] == 1 && Cnt[addr - 1] == 0) |-> HF == (Cnt[addr] | Cnt[addr - 1]);\nendproperty\nassert_p_HF_blocking_assignment: assert property (p_HF_blocking_assignment) else $error(\"Assertion failed: HF signal does not reflect the correct state based on Cnt[addr] and Cnt[addr - 1]\");",
        "sva_id": "1547_26_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LatchedCrcError == 0;\nendproperty\nassert_p_LatchedCrcError_Reset: assert property (p_LatchedCrcError_Reset) else $error(\"Assertion failed: LatchedCrcError should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_3_1_1"
    },
    {
        "sva": "property p_LoadRxStatus_Reset;\n    @(posedge MRxClk) disable iff (Reset==0)\n        Reset == 1 |-> ##1 LoadRxStatus == 0;\nendproperty\nassert_p_LoadRxStatus_Reset: assert property (p_LoadRxStatus_Reset) else $error(\"Assertion failed: LoadRxStatus should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_14_1_1"
    },
    {
        "sva": "property p_ReceivedPacketGood_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        LatchedCrcError == 0 |-> ReceivedPacketGood == 1;\nendproperty\nassert_p_ReceivedPacketGood_assignment: assert property (p_ReceivedPacketGood_assignment) else $error(\"Assertion failed: ReceivedPacketGood is not 1 when LatchedCrcError is 0\");",
        "sva_id": "180_39_1_1"
    },
    {
        "sva": "property p_maxy1_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (DAC == 1 && y > d[y_bit-1:0]) |-> maxy1 == y;\nendproperty\nassert_p_maxy1_assignment_logic: assert property (p_maxy1_assignment_logic) else $error(\"Assertion failed: maxy1 does not equal y when DAC is 1 and y is greater than d[y_bit-1:0]\");",
        "sva_id": "679_8_1_1"
    },
    {
        "sva": "property p_miny1_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (DAC == 1 && y < d[2*y_bit-1:y_bit]) |-> (miny1 == y);\nendproperty\nassert_p_miny1_assignment_logic: assert property (p_miny1_assignment_logic) else $error(\"Assertion failed: miny1 does not equal y when DAC is 1 and y is less than the specified range in d\");",
        "sva_id": "679_7_1_1"
    },
    {
        "sva": "property p_RetryCntLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryCntLatched == 4'h0;\nendproperty\nassert_p_RetryCntLatched_Reset: assert property (p_RetryCntLatched_Reset) else $error(\"Assertion failed: RetryCntLatched is not 4'h0 one cycle after Reset is asserted\");",
        "sva_id": "180_24_1_1"
    },
    {
        "sva": "property p_CarrierSenseLost_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 CarrierSenseLost == 0;\nendproperty\nassert_p_CarrierSenseLost_Reset: assert property (p_CarrierSenseLost_Reset) else $error(\"Assertion failed: CarrierSenseLost signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_32_1_1"
    },
    {
        "sva": "property p_ReceiveEnd_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ReceiveEnd == 0;\nendproperty\nassert_p_ReceiveEnd_Reset: assert property (p_ReceiveEnd_Reset) else $error(\"Assertion failed: ReceiveEnd signal is not 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_38_1_1"
    },
    {
        "sva": "property p_ShortFrame_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ShortFrame == 0;\nendproperty\nassert_p_ShortFrame_Reset: assert property (p_ShortFrame_Reset) else $error(\"Assertion failed: ShortFrame signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_19_1_1"
    },
    {
        "sva": "property p_RetryLimit_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryLimit == 0;\nendproperty\nassert_p_RetryLimit_Reset: assert property (p_RetryLimit_Reset) else $error(\"Assertion failed: RetryLimit is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "180_23_1_1"
    },
    {
        "sva": "property p_DeferLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (DeferLatched == 0);\nendproperty\nassert_p_DeferLatched_Reset: assert property (p_DeferLatched_Reset) else $error(\"Assertion failed: DeferLatched signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_28_1_1"
    },
    {
        "sva": "property p_RxLateCollision_Reset;\n    @(posedge MRxClk) disable iff (Reset==0)\n        Reset == 1 |-> ##1 RxLateCollision == 0;\nendproperty\nassert_p_RxLateCollision_Reset: assert property (p_RxLateCollision_Reset) else $error(\"Assertion failed: RxLateCollision signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_27_1_1"
    },
    {
        "sva": "property p_ReceivedLengthOK_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (RxByteCnt >= r_MinFL && RxByteCnt <= r_MaxFL) |-> (ReceivedLengthOK == 1);\nendproperty\nassert_p_ReceivedLengthOK_assignment: assert property (p_ReceivedLengthOK_assignment) else $error(\"Assertion failed: ReceivedLengthOK signal is not set correctly when RxByteCnt is within the valid range\");",
        "sva_id": "180_37_1_1"
    },
    {
        "sva": "property p_ReceivedPacketTooBig_TakeSample;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && LoadRxStatus == 0 && TakeSample == 1 && (~r_HugEn && RxByteCnt[15:0] > r_MaxFL[15:0])) |-> ##1 (ReceivedPacketTooBig == 1);\nendproperty\nassert_p_ReceivedPacketTooBig_TakeSample: assert property (p_ReceivedPacketTooBig_TakeSample) else $error(\"Assertion failed: ReceivedPacketTooBig signal should be 1 when the packet size exceeds the maximum frame length and TakeSample is active\");",
        "sva_id": "180_20_1_1"
    },
    {
        "sva": "property p_RetryCntLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryCntLatched == 4'h0;\nendproperty\nassert_p_RetryCntLatched_Reset: assert property (p_RetryCntLatched_Reset) else $error(\"Assertion failed: RetryCntLatched is not 4'h0 one cycle after Reset is asserted\");",
        "sva_id": "180_22_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LatchedCrcError == 0;\nendproperty\nassert_p_LatchedCrcError_Reset: assert property (p_LatchedCrcError_Reset) else $error(\"Assertion failed: LatchedCrcError should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_41_1_1"
    },
    {
        "sva": "property p_coeff_0_assignment;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 coeff_0 == 0;\nendproperty\nassert_p_coeff_0_assignment: assert property (p_coeff_0_assignment) else $error(\"Assertion failed: coeff_0 is not assigned to 0 one cycle after rst_n is deasserted\");",
        "sva_id": "369_5_1_1"
    },
    {
        "sva": "property p_ReceivedPacketTooBig_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ReceivedPacketTooBig == 0;\nendproperty\nassert_p_ReceivedPacketTooBig_Reset: assert property (p_ReceivedPacketTooBig_Reset) else $error(\"Assertion failed: ReceivedPacketTooBig signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_21_1_1"
    },
    {
        "sva": "property p_RetryLimit_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryLimit == 0;\nendproperty\nassert_p_RetryLimit_Reset: assert property (p_RetryLimit_Reset) else $error(\"Assertion failed: RetryLimit is not reset to 0 one cycle after Reset is asserted\");",
        "sva_id": "180_26_1_1"
    },
    {
        "sva": "property p_RxColWindow_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxColWindow == 1;\nendproperty\nassert_p_RxColWindow_Reset: assert property (p_RxColWindow_Reset) else $error(\"Assertion failed: RxColWindow signal does not equal 1 one cycle after Reset is asserted\");",
        "sva_id": "180_17_1_1"
    },
    {
        "sva": "property p_LateCollLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n    Reset == 1 |-> ##1 LateCollLatched == 0;\nendproperty\nassert_p_LateCollLatched_Reset: assert property (p_LateCollLatched_Reset) else $error(\"Assertion failed: LateCollLatched signal is not 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_49_1_1"
    },
    {
        "sva": "property p_ShortFrame_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ShortFrame == 0;\nendproperty\nassert_p_ShortFrame_Reset: assert property (p_ShortFrame_Reset) else $error(\"Assertion failed: ShortFrame signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_43_1_1"
    },
    {
        "sva": "property p_LatchedMRxErr_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (LatchedMRxErr == 0);\nendproperty\nassert_p_LatchedMRxErr_Reset: assert property (p_LatchedMRxErr_Reset) else $error(\"Assertion failed: LatchedMRxErr is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_8_1_1"
    },
    {
        "sva": "property p_LoadRxStatus_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LoadRxStatus == 0;\nendproperty\nassert_p_LoadRxStatus_Reset: assert property (p_LoadRxStatus_Reset) else $error(\"Assertion failed: LoadRxStatus is not 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_46_1_1"
    },
    {
        "sva": "property p_RetryLimit_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryLimit == 0;\nendproperty\nassert_p_RetryLimit_Reset: assert property (p_RetryLimit_Reset) else $error(\"Assertion failed: RetryLimit is not reset to 0 after Reset is asserted\");",
        "sva_id": "180_48_1_1"
    },
    {
        "sva": "property p_x_assignment_on_rst;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 x == $past(rstx[8:0]);\nendproperty\nassert_p_x_assignment_on_rst: assert property (p_x_assignment_on_rst) else $error(\"Assertion failed: x does not match the past value of rstx[8:0] after reset\");",
        "sva_id": "679_2_1_1"
    },
    {
        "sva": "property p_CarrierSenseLost_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 CarrierSenseLost == 0;\nendproperty\nassert_p_CarrierSenseLost_Reset: assert property (p_CarrierSenseLost_Reset) else $error(\"Assertion failed: CarrierSenseLost signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_30_1_1"
    },
    {
        "sva": "property p_CarrierSenseLost_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 CarrierSenseLost == 0;\nendproperty\nassert_p_CarrierSenseLost_Reset: assert property (p_CarrierSenseLost_Reset) else $error(\"Assertion failed: CarrierSenseLost signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_31_1_1"
    },
    {
        "sva": "property p_InvalidSymbol_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 InvalidSymbol == 0;\nendproperty\nassert_p_InvalidSymbol_Reset: assert property (p_InvalidSymbol_Reset) else $error(\"Assertion failed: InvalidSymbol should be 0 one cycle after Reset is asserted high\");",
        "sva_id": "180_40_1_1"
    },
    {
        "sva": "property p_ReceivedPacketTooBig_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ReceivedPacketTooBig == 0;\nendproperty\nassert_p_ReceivedPacketTooBig_Reset: assert property (p_ReceivedPacketTooBig_Reset) else $error(\"Assertion failed: ReceivedPacketTooBig signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_63_1_1"
    },
    {
        "sva": "property p_RxLateCollision_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxLateCollision == 0;\nendproperty\nassert_p_RxLateCollision_Reset: assert property (p_RxLateCollision_Reset) else $error(\"Assertion failed: RxLateCollision is not 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_16_1_1"
    },
    {
        "sva": "property p_ReceiveEnd_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ReceiveEnd == 0;\nendproperty\nassert_p_ReceiveEnd_Reset: assert property (p_ReceiveEnd_Reset) else $error(\"Assertion failed: ReceiveEnd signal is not 0 one cycle after Reset is 1\");",
        "sva_id": "180_57_1_1"
    },
    {
        "sva": "property p_CarrierSenseLost_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 CarrierSenseLost == 0;\nendproperty\nassert_p_CarrierSenseLost_Reset: assert property (p_CarrierSenseLost_Reset) else $error(\"Assertion failed: CarrierSenseLost signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_68_1_1"
    },
    {
        "sva": "property p_InvalidSymbol_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 InvalidSymbol == 0;\nendproperty\nassert_p_InvalidSymbol_Reset: assert property (p_InvalidSymbol_Reset) else $error(\"Assertion failed: InvalidSymbol is not 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_58_1_1"
    },
    {
        "sva": "property p_LoadRxStatus_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LoadRxStatus == 0;\nendproperty\nassert_p_LoadRxStatus_Reset: assert property (p_LoadRxStatus_Reset) else $error(\"Assertion failed: LoadRxStatus should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_56_1_1"
    },
    {
        "sva": "property p_RxLateCollision_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxLateCollision == 0;\nendproperty\nassert_p_RxLateCollision_Reset: assert property (p_RxLateCollision_Reset) else $error(\"Assertion failed: RxLateCollision should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_59_1_1"
    },
    {
        "sva": "property p_LateCollLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LateCollLatched == 0;\nendproperty\nassert_p_LateCollLatched_Reset: assert property (p_LateCollLatched_Reset) else $error(\"Assertion failed: LateCollLatched signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_66_1_1"
    },
    {
        "sva": "property p_ReceivedPacketTooBig_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n    Reset == 1 |-> ##1 ReceivedPacketTooBig == 0;\nendproperty\nassert_p_ReceivedPacketTooBig_Reset: assert property (p_ReceivedPacketTooBig_Reset) else $error(\"Assertion failed: ReceivedPacketTooBig signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_45_1_1"
    },
    {
        "sva": "property p_RetryLimit_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RetryLimit == 0;\nendproperty\nassert_p_RetryLimit_Reset: assert property (p_RetryLimit_Reset) else $error(\"Assertion failed: RetryLimit is not reset to 0 one cycle after Reset is asserted.\");",
        "sva_id": "180_65_1_1"
    },
    {
        "sva": "property p_DeferLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (DeferLatched == 0);\nendproperty\nassert_p_DeferLatched_Reset: assert property (p_DeferLatched_Reset) else $error(\"Assertion failed: DeferLatched signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_36_1_1"
    },
    {
        "sva": "property p_sign_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 sign == ($past(opa[63]) ^ $past(opb[63]));\nendproperty\nassert_p_sign_assignment_logic: assert property (p_sign_assignment_logic) else $error(\"Assertion failed: sign signal does not reflect the correct XOR state of the most significant bits of opa and opb\");",
        "sva_id": "401_5_1_1"
    },
    {
        "sva": "property p_RxLateCollision_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxLateCollision == 0;\nendproperty\nassert_p_RxLateCollision_Reset: assert property (p_RxLateCollision_Reset) else $error(\"Assertion failed: RxLateCollision signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_42_1_1"
    },
    {
        "sva": "property p_ShortFrame_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 ShortFrame == 0;\nendproperty\nassert_p_ShortFrame_Reset: assert property (p_ShortFrame_Reset) else $error(\"Assertion failed: ShortFrame signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_61_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LatchedCrcError == 0;\nendproperty\nassert_p_LatchedCrcError_Reset: assert property (p_LatchedCrcError_Reset) else $error(\"Assertion failed: LatchedCrcError should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_54_1_1"
    },
    {
        "sva": "property p_CarrierSenseLost_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 CarrierSenseLost == 0;\nendproperty\nassert_p_CarrierSenseLost_Reset: assert property (p_CarrierSenseLost_Reset) else $error(\"Assertion failed: CarrierSenseLost signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_51_1_1"
    },
    {
        "sva": "property p_RxLateCollision_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxLateCollision == 0;\nendproperty\nassert_p_RxLateCollision_Reset: assert property (p_RxLateCollision_Reset) else $error(\"Assertion failed: RxLateCollision signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_18_1_1"
    },
    {
        "sva": "property p_RxLateCollision_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && LoadRxStatus == 0 && Collision == 1 && r_FullD == 0 && RxColWindow == 0 && r_RecSmall == 1) |-> ##1 (RxLateCollision == 1);\nendproperty\nassert_p_RxLateCollision_assignment: assert property (p_RxLateCollision_assignment) else $error(\"Assertion failed: RxLateCollision signal was not set correctly under the specified conditions.\");",
        "sva_id": "180_35_1_1"
    },
    {
        "sva": "property p_DribbleNibble_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 DribbleNibble == 0;\nendproperty\nassert_p_DribbleNibble_Reset: assert property (p_DribbleNibble_Reset) else $error(\"Assertion failed: DribbleNibble is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_62_1_1"
    },
    {
        "sva": "property p_LatchedMRxErr_Reset;\n    @(posedge MRxClk) disable iff (Reset==0)\n        (Reset == 1) |-> ##1 (LatchedMRxErr == 0);\nendproperty\nassert_p_LatchedMRxErr_Reset: assert property (p_LatchedMRxErr_Reset) else $error(\"Assertion failed: LatchedMRxErr should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_52_1_1"
    },
    {
        "sva": "property p_DribbleNibble_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (DribbleNibble == 0);\nendproperty\nassert_p_DribbleNibble_Reset: assert property (p_DribbleNibble_Reset) else $error(\"Assertion failed: DribbleNibble is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_44_1_1"
    },
    {
        "sva": "property p_LatchedMRxErr_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LatchedMRxErr == 0;\nendproperty\nassert_p_LatchedMRxErr_Reset: assert property (p_LatchedMRxErr_Reset) else $error(\"Assertion failed: LatchedMRxErr signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_5_1_1"
    },
    {
        "sva": "property p_a_is_norm_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 a_is_norm == 0;\nendproperty\nassert_p_a_is_norm_reset: assert property (p_a_is_norm_reset) else $error(\"Assertion failed: a_is_norm signal is not 0 one cycle after rst is asserted\");",
        "sva_id": "401_8_1_1"
    },
    {
        "sva": "property p_RxColWindow_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 RxColWindow == 1;\nendproperty\nassert_p_RxColWindow_Reset: assert property (p_RxColWindow_Reset) else $error(\"Assertion failed: RxColWindow signal does not become 1 one cycle after Reset is asserted\");",
        "sva_id": "180_60_1_1"
    },
    {
        "sva": "property p_sign_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 sign == ($past(opa[63]) ^ $past(opb[63]));\nendproperty\nassert_p_sign_assignment_logic: assert property (p_sign_assignment_logic) else $error(\"Assertion failed: sign signal does not reflect the correct state based on opa[63] and opb[63] after one clock cycle\");",
        "sva_id": "401_3_1_1"
    },
    {
        "sva": "property p_exponent_a_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 exponent_a == $past(opa[62:52]);\nendproperty\nassert_p_exponent_a_assignment: assert property (p_exponent_a_assignment) else $error(\"Assertion failed: exponent_a does not match the expected value from opa[62:52] in the previous cycle\");",
        "sva_id": "401_7_1_1"
    },
    {
        "sva": "property p_DeferLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 DeferLatched == 0;\nendproperty\nassert_p_DeferLatched_Reset: assert property (p_DeferLatched_Reset) else $error(\"Assertion failed: DeferLatched signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_67_1_1"
    },
    {
        "sva": "property p_a_is_zero_assignment;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 a_is_zero == 0;\nendproperty\nassert_p_a_is_zero_assignment: assert property (p_a_is_zero_assignment) else $error(\"Assertion failed: a_is_zero is not 0 one cycle after rst is 1\");",
        "sva_id": "401_9_1_1"
    },
    {
        "sva": "property p_LatchedMRxErr_Reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 LatchedMRxErr == 0;\nendproperty\nassert_p_LatchedMRxErr_Reset: assert property (p_LatchedMRxErr_Reset) else $error(\"Assertion failed: LatchedMRxErr signal should be 0 one cycle after Reset is asserted\");",
        "sva_id": "180_55_1_1"
    },
    {
        "sva": "property p_mul_a_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 mul_a == { $past(a_is_norm), $past(mantissa_a) };\nendproperty\nassert_p_mul_a_assignment: assert property (p_mul_a_assignment) else $error(\"Assertion failed: mul_a does not correctly reflect the concatenation of past values of a_is_norm and mantissa_a\");",
        "sva_id": "401_12_1_1"
    },
    {
        "sva": "property p_DeferLatched_Reset;\n    @(posedge MTxClk) disable iff (Reset == 0)\n        Reset == 1 |-> ##1 DeferLatched == 0;\nendproperty\nassert_p_DeferLatched_Reset: assert property (p_DeferLatched_Reset) else $error(\"Assertion failed: DeferLatched signal is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_50_1_1"
    },
    {
        "sva": "property p_RetryCntLatched_Reset;\n    @(posedge MTxClk)\n    disable iff (Reset == 0)\n    Reset == 1 |-> ##1 RetryCntLatched == 4'h0;\nendproperty\nassert_p_RetryCntLatched_Reset: assert property (p_RetryCntLatched_Reset) else $error(\"Assertion failed: RetryCntLatched is not 4'h0 one cycle after Reset is asserted\");",
        "sva_id": "180_25_1_1"
    },
    {
        "sva": "property p_product_lsb_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 product_lsb == $past(|product_6[51:0]);\nendproperty\nassert_p_product_lsb_assignment: assert property (p_product_lsb_assignment) else $error(\"Assertion failed: product_lsb does not match the expected value based on the past value of product_6[51:0]\");",
        "sva_id": "401_17_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && RxStateSFD == 1) |-> ##1 (LatchedCrcError == 0);\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError should be 0 one cycle after RxStateSFD is 1 and Reset is 0\");",
        "sva_id": "180_6_1_1"
    },
    {
        "sva": "property p_coeff_0_assignment;\n    @(posedge clk) disable iff (rst_n == 1)\n        rst_n == 0 |-> ##1 coeff_0 == 0;\nendproperty\nassert_p_coeff_0_assignment: assert property (p_coeff_0_assignment) else $error(\"Assertion failed: coeff_0 is not assigned to 0 one cycle after rst_n is deasserted\");",
        "sva_id": "369_13_1_1"
    },
    {
        "sva": "property p_in_zero_assignment_on_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 in_zero == 0;\nendproperty\nassert_p_in_zero_assignment_on_reset: assert property (p_in_zero_assignment_on_reset) else $error(\"Assertion failed: in_zero signal is not assigned to 0 one cycle after reset is asserted\");",
        "sva_id": "401_10_1_1"
    },
    {
        "sva": "property p_ReceivedLengthOK_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (RxByteCnt >= r_MinFL && RxByteCnt <= r_MaxFL) |-> (ReceivedLengthOK == 1);\nendproperty\nassert_p_ReceivedLengthOK_assignment: assert property (p_ReceivedLengthOK_assignment) else $error(\"Assertion failed: ReceivedLengthOK signal is not set correctly when RxByteCnt is within the valid range\");",
        "sva_id": "180_70_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_reset;\n    @(posedge MRxClk) disable iff (Reset == 0)\n        (Reset == 1) |-> ##1 (LatchedCrcError == 0);\nendproperty\nassert_p_LatchedCrcError_reset: assert property (p_LatchedCrcError_reset) else $error(\"Assertion failed: LatchedCrcError is not 0 one cycle after Reset is asserted\");",
        "sva_id": "180_53_1_1"
    },
    {
        "sva": "property p_sign_assignment_logic;\n    @(posedge clk) disable iff (rst==1)\n        (rst == 0 && enable == 1) |-> ##1 sign == ($past(opa[63]) ^ $past(opb[63]));\nendproperty\nassert_p_sign_assignment_logic: assert property (p_sign_assignment_logic) else $error(\"Assertion failed: sign signal does not reflect the correct XOR state of the MSBs of opa and opb after one clock cycle\");",
        "sva_id": "401_4_1_1"
    },
    {
        "sva": "property p_exponent_terms_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 exponent_terms == ($past(exponent_a) + $past(exponent_b) + $past(~a_is_norm) + $past(~b_is_norm));\nendproperty\nassert_p_exponent_terms_assignment: assert property (p_exponent_terms_assignment) else $error(\"Assertion failed: exponent_terms does not reflect the correct sum of past exponent_a, exponent_b, and the negations of a_is_norm and b_is_norm\");",
        "sva_id": "401_11_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk)\n    disable iff (Reset == 1)\n    (Reset == 0 && RxStateSFD == 0 && RxStateData[0] == 1 && RxCrcError == 1 && RxByteCntEq0 == 0) |-> ##1 LatchedCrcError == 1;\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError was not assigned correctly when the specified conditions were met.\");",
        "sva_id": "180_2_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && RxStateSFD == 0 && RxStateData[0] == 1 && RxCrcError == 1 && RxByteCntEq0 == 0) |-> ##1 LatchedCrcError == 1;\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError was not set to 1 as expected when the antecedent conditions were met.\");",
        "sva_id": "180_4_1_1"
    },
    {
        "sva": "property p_empty_assignment;\n    @(posedge clock) disable iff (resetn == 0)\n        (write_ptr - read_ptr == 5'b00000) |-> (empty == 1'b1);\nendproperty\nassert_p_empty_assignment: assert property (p_empty_assignment) else $error(\"Assertion failed: empty signal is not asserted when write_ptr - read_ptr equals 0\");",
        "sva_id": "1556_5_1_1"
    },
    {
        "sva": "property p_write_ptr_reset;\n    @(posedge clock) disable iff (resetn == 1)\n        resetn == 0 |-> ##1 write_ptr == 5'b00000;\nendproperty\nassert_p_write_ptr_reset: assert property (p_write_ptr_reset) else $error(\"Assertion failed: write_ptr is not reset to 5'b00000 one cycle after resetn is deasserted\");",
        "sva_id": "1556_9_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && RxStateSFD == 0 && RxStateData[0] == 1 && RxCrcError == 1 && RxByteCntEq0 == 0) |-> ##1 LatchedCrcError == 1;\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError is not set correctly when the specified conditions are met.\");",
        "sva_id": "180_15_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && RxStateSFD == 0 && RxStateData[0] == 1 && RxCrcError == 1 && RxByteCntEq0 == 0) |-> ##1 LatchedCrcError == 1;\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError was not set to 1 as expected when Reset is 0, RxStateSFD is 0, RxStateData[0] is 1, RxCrcError is 1, and RxByteCntEq0 is 0\");",
        "sva_id": "180_7_1_1"
    },
    {
        "sva": "property p_fifo_full_assignment;\n    @(posedge clock) disable iff (resetn == 0)\n        (write_ptr - read_ptr) == 5'b10000 |-> full == 1'b1;\nendproperty\nassert_p_fifo_full_assignment: assert property (p_fifo_full_assignment) else $error(\"Assertion failed: full signal should be 1 when (write_ptr - read_ptr) equals 5'b10000\");",
        "sva_id": "1556_6_1_1"
    },
    {
        "sva": "property p_DetectionWindow_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 DetectionWindow == 1;\nendproperty\nassert_p_DetectionWindow_assignment_on_RxReset: assert property (p_DetectionWindow_assignment_on_RxReset) else $error(\"Assertion failed: DetectionWindow is not assigned correctly after RxReset\");",
        "sva_id": "183_12_1_1"
    },
    {
        "sva": "property p_LatchedTimerValue_Reset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 LatchedTimerValue[15:0] == 16'h0;\nendproperty\nassert_p_LatchedTimerValue_Reset: assert property (p_LatchedTimerValue_Reset) else $error(\"Assertion failed: LatchedTimerValue[15:0] is not 16'h0 one cycle after RxReset is asserted.\");",
        "sva_id": "183_13_1_1"
    },
    {
        "sva": "property p_ResetSlotTimer_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ResetSlotTimer == (RxReset == 1);\nendproperty\nassert_p_ResetSlotTimer_RxReset: assert property (p_ResetSlotTimer_RxReset) else $error(\"Assertion failed: ResetSlotTimer does not match the expected state when RxReset is active\");",
        "sva_id": "183_25_1_1"
    },
    {
        "sva": "property p_SetPauseTimer_Assignment;\n    @(posedge MRxClk) disable iff (RxReset == 1)\n        (ReceiveEnd == 1 && ReceivedPauseFrmWAddr == 1 && ReceivedPacketGood == 1 && ReceivedLengthOK == 1 && RxFlow == 1) |-> \n        (SetPauseTimer == (ReceiveEnd == 1 && ReceivedPauseFrmWAddr == 1 && ReceivedPacketGood == 1 && ReceivedLengthOK == 1 && RxFlow == 1));\nendproperty\nassert_p_SetPauseTimer_Assignment: assert property (p_SetPauseTimer_Assignment) else $error(\"Assertion failed: SetPauseTimer does not match the expected condition when ReceiveEnd, ReceivedPauseFrmWAddr, ReceivedPacketGood, ReceivedLengthOK, and RxFlow are all 1\");",
        "sva_id": "183_24_1_1"
    },
    {
        "sva": "property p_TypeLengthOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 TypeLengthOK == 0;\nendproperty\nassert_p_TypeLengthOK_RxReset: assert property (p_TypeLengthOK_RxReset) else $error(\"Assertion failed: TypeLengthOK signal is not 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_3_1_1"
    },
    {
        "sva": "property p_sum_round_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 sum_round == 0;\nendproperty\nassert_p_sum_round_reset: assert property (p_sum_round_reset) else $error(\"Assertion failed: sum_round is not 0 one cycle after reset is asserted\");",
        "sva_id": "402_7_1_1"
    },
    {
        "sva": "property p_sum_round_overflow;\n    @(posedge clk) disable iff (rst)\n        sum_round[55] == 1 |-> sum_round_overflow == sum_round[55];\nendproperty\nassert_p_sum_round_overflow: assert property (p_sum_round_overflow) else $error(\"Assertion failed: sum_round_overflow does not match sum_round[55] when sum_round[55] is 1\");",
        "sva_id": "402_8_1_1"
    },
    {
        "sva": "property p_Pause_TxReset;\n    @(posedge MTxClk) disable iff (TxReset == 0)\n        (TxReset == 1) |-> ##1 (Pause == 0);\nendproperty\nassert_p_Pause_TxReset: assert property (p_Pause_TxReset) else $error(\"Assertion failed: Pause signal is not 0 one cycle after TxReset is asserted\");",
        "sva_id": "183_18_1_1"
    },
    {
        "sva": "property p_DlyCrcCnt_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 DlyCrcCnt == 3'h0;\nendproperty\nassert_p_DlyCrcCnt_assignment_on_RxReset: assert property (p_DlyCrcCnt_assignment_on_RxReset) else $error(\"Assertion failed: DlyCrcCnt is not assigned to 3'h0 one cycle after RxReset is asserted\");",
        "sva_id": "183_14_1_1"
    },
    {
        "sva": "property p_sum_round_overflow_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        sum_round[55] == 1 |-> sum_round_overflow == sum_round[55];\nendproperty\nassert_p_sum_round_overflow_assignment: assert property (p_sum_round_overflow_assignment) else $error(\"Assertion failed: sum_round_overflow does not match sum_round[55] when sum_round[55] is 1\");",
        "sva_id": "402_17_1_1"
    },
    {
        "sva": "property p_AssembledTimerValue_reset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 AssembledTimerValue[15:0] == 16'h0;\nendproperty\nassert_p_AssembledTimerValue_reset: assert property (p_AssembledTimerValue_reset) else $error(\"Assertion failed: AssembledTimerValue[15:0] is not 16'h0 one cycle after RxReset is asserted.\");",
        "sva_id": "183_11_1_1"
    },
    {
        "sva": "property p_ReceivedPauseFrmWAddr_reset;\n    @(posedge MRxClk) disable iff (RxReset==0)\n        (RxReset == 1) |-> ##1 (ReceivedPauseFrmWAddr == 0);\nendproperty\nassert_p_ReceivedPauseFrmWAddr_reset: assert property (p_ReceivedPauseFrmWAddr_reset) else $error(\"Assertion failed: ReceivedPauseFrmWAddr is not 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_10_1_1"
    },
    {
        "sva": "property p_Divider2_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (Divider2 == 0);\nendproperty\nassert_p_Divider2_assignment_on_RxReset: assert property (p_Divider2_assignment_on_RxReset) else $error(\"Assertion failed: Divider2 is not assigned to 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_19_1_1"
    },
    {
        "sva": "property p_z2_next_assignment;\n    @(posedge clk) disable iff (rstn == 0)\n        (z2 == z2) |-> z2_next == {z2[50:6], (z2[44:26] ^ z2[63:45])};\nendproperty\nassert_p_z2_next_assignment: assert property (p_z2_next_assignment) else $error(\"Assertion failed: z2_next does not match the expected value based on z2\");",
        "sva_id": "559_6_1_1"
    },
    {
        "sva": "property p_ReceivedPauseFrm_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 ReceivedPauseFrm == 0;\nendproperty\nassert_p_ReceivedPauseFrm_RxReset: assert property (p_ReceivedPauseFrm_RxReset) else $error(\"Assertion failed: ReceivedPauseFrm is not 0 one cycle after RxReset is asserted.\");",
        "sva_id": "183_21_1_1"
    },
    {
        "sva": "property p_write_ptr_reset;\n    @(posedge clock) disable iff (resetn == 1)\n        resetn == 0 |-> ##1 write_ptr == 5'b00000;\nendproperty\nassert_p_write_ptr_reset: assert property (p_write_ptr_reset) else $error(\"Assertion failed: write_ptr is not reset to 5'b00000 one cycle after resetn is deasserted\");",
        "sva_id": "1556_10_1_1"
    },
    {
        "sva": "property p_LatchedCrcError_assignment;\n    @(posedge MRxClk) disable iff (Reset == 1)\n        (Reset == 0 && RxStateSFD == 0 && RxStateData[0] == 1) |-> ##1 LatchedCrcError == ($past(RxCrcError) & $past(~RxByteCntEq0));\nendproperty\nassert_p_LatchedCrcError_assignment: assert property (p_LatchedCrcError_assignment) else $error(\"Assertion failed: LatchedCrcError signal does not reflect the correct state based on RxCrcError and RxByteCntEq0 conditions\");",
        "sva_id": "180_1_1_1"
    },
    {
        "sva": "property p_sum_final_rounding_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && round_trigger == 1) |-> ##1 sum_final == $past(sum_round_2);\nendproperty\nassert_p_sum_final_rounding_logic: assert property (p_sum_final_rounding_logic) else $error(\"Assertion failed: sum_final does not match the expected value from the previous round (sum_round_2) after rounding logic is triggered.\");",
        "sva_id": "402_11_1_1"
    },
    {
        "sva": "property p_SlotTimer_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (SlotTimer[5:0] == 6'h0);\nendproperty\nassert_p_SlotTimer_assignment_on_RxReset: assert property (p_SlotTimer_assignment_on_RxReset) else $error(\"Assertion failed: SlotTimer[5:0] is not assigned to 6'h0 one cycle after RxReset is asserted\");",
        "sva_id": "183_20_1_1"
    },
    {
        "sva": "property p_valid_out_reset;\n    @(posedge clk) disable iff (rstn == 1)\n        rstn == 0 |-> ##1 valid_out == 0;\nendproperty\nassert_p_valid_out_reset: assert property (p_valid_out_reset) else $error(\"Assertion failed: valid_out signal should be 0 one cycle after rstn is deasserted\");",
        "sva_id": "559_3_1_1"
    },
    {
        "sva": "property p_o_empty_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rs_valid == 0 |-> o_empty == 1;\nendproperty\nassert_p_o_empty_assignment: assert property (p_o_empty_assignment) else $error(\"Assertion failed: o_empty signal is not 1 when rs_valid is 0\");",
        "sva_id": "1762_6_1_1"
    },
    {
        "sva": "property p_sum_0_assignment_logic;\n    @(posedge clk) disable iff (rst==1)\n        (rst == 0 && enable == 1) |-> ##1 sum_0 == ($past(product_a[40:17]) + $past(product_b));\nendproperty\nassert_p_sum_0_assignment_logic: assert property (p_sum_0_assignment_logic) else $error(\"Assertion failed: sum_0 does not reflect the correct sum of past values of product_a[40:17] and product_b\");",
        "sva_id": "401_14_1_1"
    },
    {
        "sva": "property p_sum_round_2_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && sum_round_overflow == 1) |-> ##1 sum_round_2 == ($past(sum_round) >> 1);\nendproperty\nassert_p_sum_round_2_assignment: assert property (p_sum_round_2_assignment) else $error(\"Assertion failed: sum_round_2 does not equal the right-shifted value of the previous sum_round when sum_round_overflow occurs and rst is 0\");",
        "sva_id": "402_9_1_1"
    },
    {
        "sva": "property p_write_ptr_reset;\n    @(posedge clock) disable iff (resetn==1)\n        resetn == 0 |-> ##1 write_ptr == 5'b00000;\nendproperty\nassert_p_write_ptr_reset: assert property (p_write_ptr_reset) else $error(\"Assertion failed: write_ptr is not reset to 5'b00000 one cycle after resetn is deasserted\");",
        "sva_id": "1556_7_1_1"
    },
    {
        "sva": "property p_rounding_amount_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        1 |-> rounding_amount == 53'b0_1_00;\nendproperty\nassert_p_rounding_amount_assignment: assert property (p_rounding_amount_assignment) else $error(\"Assertion failed: rounding_amount is not equal to 53'b0_1_00\");",
        "sva_id": "402_14_1_1"
    },
    {
        "sva": "property p_round_nearest_trigger;\n    @(posedge clk) disable iff (rst == 1)\n        (round_nearest == 1 && mantissa_term[1] == 1) |-> round_nearest_trigger == 1;\nendproperty\nassert_p_round_nearest_trigger: assert property (p_round_nearest_trigger) else $error(\"Assertion failed: round_nearest_trigger is not set when round_nearest is 1 and mantissa_term[1] is 1\");",
        "sva_id": "402_6_1_1"
    },
    {
        "sva": "property p_sign_assignment_on_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 sign == 0;\nendproperty\nassert_p_sign_assignment_on_reset: assert property (p_sign_assignment_on_reset) else $error(\"Assertion failed: sign signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "401_1_1_1"
    },
    {
        "sva": "property p_exponent_5_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && in_zero == 1) |-> ##1 (exponent_5 == 12'b0);\nendproperty\nassert_p_exponent_5_assignment: assert property (p_exponent_5_assignment) else $error(\"Assertion failed: exponent_5 is not assigned to 12'b0 one cycle after in_zero is 1 while enable is 1 and rst is 0\");",
        "sva_id": "401_18_1_1"
    },
    {
        "sva": "property p_z1_assignment_on_reset;\n    @(posedge clk) disable iff (rstn == 1)\n        rstn == 0 |-> ##1 z1 == $past(INIT_Z1);\nendproperty\nassert_p_z1_assignment_on_reset: assert property (p_z1_assignment_on_reset) else $error(\"Assertion failed: z1 signal does not reflect the correct state after reset\");",
        "sva_id": "559_1_1_1"
    },
    {
        "sva": "property p_OpCodeOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (OpCodeOK == 0);\nendproperty\nassert_p_OpCodeOK_RxReset: assert property (p_OpCodeOK_RxReset) else $error(\"Assertion failed: OpCodeOK signal should be 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_9_1_1"
    },
    {
        "sva": "property p_minuend_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 minuend == {$past(!large_is_denorm), $past(mantissa_large), 2'b00};\nendproperty\nassert_p_minuend_assignment_logic: assert property (p_minuend_assignment_logic) else $error(\"Assertion failed: minuend signal does not reflect the correct state based on the antecedent conditions\");",
        "sva_id": "403_9_1_1"
    },
    {
        "sva": "property p_z1_assignment_on_reset;\n    @(posedge clk) disable iff (rstn == 1)\n        rstn == 0 |-> ##1 z1 == $past(INIT_Z1);\nendproperty\nassert_p_z1_assignment_on_reset: assert property (p_z1_assignment_on_reset) else $error(\"Assertion failed: z1 signal does not reflect the correct state after reset\");",
        "sva_id": "559_2_1_1"
    },
    {
        "sva": "property p_write_ptr_reset;\n    @(posedge clock) disable iff (resetn == 1)\n        resetn == 0 |-> ##1 write_ptr == 5'b00000;\nendproperty\nassert_p_write_ptr_reset: assert property (p_write_ptr_reset) else $error(\"Assertion failed: write_ptr is not reset to 5'b00000 one cycle after resetn is deasserted\");",
        "sva_id": "1556_8_1_1"
    },
    {
        "sva": "property p_data_out_reset_logic;\n    @(posedge clk) disable iff (rstn == 1)\n        rstn == 0 |-> ##1 data_out == 0;\nendproperty\nassert_p_data_out_reset_logic: assert property (p_data_out_reset_logic) else $error(\"Assertion failed: data_out is not 0 one cycle after rstn is deasserted\");",
        "sva_id": "559_4_1_1"
    },
    {
        "sva": "property p_sum_round_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 sum_round == 0;\nendproperty\nassert_p_sum_round_reset: assert property (p_sum_round_reset) else $error(\"Assertion failed: sum_round is not 0 one cycle after reset is asserted\");",
        "sva_id": "402_2_1_1"
    },
    {
        "sva": "property p_AddressOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (AddressOK == 0);\nendproperty\nassert_p_AddressOK_RxReset: assert property (p_AddressOK_RxReset) else $error(\"Assertion failed: AddressOK signal should be 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_7_1_1"
    },
    {
        "sva": "property p_round_nearest_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        round_mode == 2'b00 |-> round_nearest == 1;\nendproperty\nassert_p_round_nearest_assignment: assert property (p_round_nearest_assignment) else $error(\"Assertion failed: round_nearest signal is not assigned correctly when round_mode is 2'b00\");",
        "sva_id": "402_15_1_1"
    },
    {
        "sva": "property p_o_full_rs_valid;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (&rs_valid == 1) |-> (o_full == 1);\nendproperty\nassert_p_o_full_rs_valid: assert property (p_o_full_rs_valid) else $error(\"Assertion failed: o_full signal should be 1 when rs_valid is asserted\");",
        "sva_id": "1762_5_1_1"
    },
    {
        "sva": "property p_round_nearest_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        round_mode == 2'b00 |-> round_nearest == 1;\nendproperty\nassert_p_round_nearest_assignment: assert property (p_round_nearest_assignment) else $error(\"Assertion failed: round_nearest is not set correctly when round_mode is 2'b00\");",
        "sva_id": "402_4_1_1"
    },
    {
        "sva": "property p_rs_read_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_read_counter == 0;\nendproperty\nassert_p_rs_read_counter_reset: assert property (p_rs_read_counter_reset) else $error(\"Assertion failed: rs_read_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1762_14_1_1"
    },
    {
        "sva": "property p_rs_write_counter_reset;\n    @(posedge clk_core) disable iff (rst_x==1)\n        (rst_x == 0) |-> ##1 (rs_write_counter == 0);\nendproperty\nassert_p_rs_write_counter_reset: assert property (p_rs_write_counter_reset) else $error(\"Assertion failed: rs_write_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1762_3_1_1"
    },
    {
        "sva": "property p_z3_next_assignment;\n    @(posedge clk) disable iff (rstn == 0)\n        rstn == 1 |-> z3_next == {z3[56:9], z3[39:24] ^ z3[63:48]};\nendproperty\nassert_p_z3_next_assignment: assert property (p_z3_next_assignment) else $error(\"Assertion failed: z3_next does not match the expected assignment based on z3\");",
        "sva_id": "559_7_1_1"
    },
    {
        "sva": "property p_o_dt_rs_data_buffer_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        (rs_read_counter >= 0 && rs_read_counter < DEPTH) |-> (o_dt == rs_data_buffer[rs_read_counter]);\nendproperty\nassert_p_o_dt_rs_data_buffer_assignment: assert property (p_o_dt_rs_data_buffer_assignment) else $error(\"Assertion failed: o_dt does not match the expected value from rs_data_buffer at rs_read_counter\");",
        "sva_id": "1762_7_1_1"
    },
    {
        "sva": "property p_rs_write_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_write_counter == 0;\nendproperty\nassert_p_rs_write_counter_reset: assert property (p_rs_write_counter_reset) else $error(\"Assertion failed: rs_write_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1762_13_1_1"
    },
    {
        "sva": "property p_rs_valid_reset_logic;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_valid == {DEPTH{1'b0}};\nendproperty\nassert_p_rs_valid_reset_logic: assert property (p_rs_valid_reset_logic) else $error(\"Assertion failed: rs_valid signal is not reset to all zeros one cycle after rst_x is deasserted\");",
        "sva_id": "1762_15_1_1"
    },
    {
        "sva": "property p_mul_a_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 mul_a == { $past(a_is_norm), $past(mantissa_a) };\nendproperty\nassert_p_mul_a_assignment_logic: assert property (p_mul_a_assignment_logic) else $error(\"Assertion failed: mul_a does not reflect the correct combination of a_is_norm and mantissa_a after one cycle\");",
        "sva_id": "401_13_1_1"
    },
    {
        "sva": "property p_w_we_assignment;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (o_full == 0 && i_wstrobe == 1) |-> (w_we == (o_full == 0 && i_wstrobe == 1));\nendproperty\nassert_p_w_we_assignment: assert property (p_w_we_assignment) else $error(\"Assertion failed: w_we signal does not match the expected condition when o_full is 0 and i_wstrobe is 1\");",
        "sva_id": "1762_10_1_1"
    },
    {
        "sva": "property p_TypeLengthOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (TypeLengthOK == 0);\nendproperty\nassert_p_TypeLengthOK_RxReset: assert property (p_TypeLengthOK_RxReset) else $error(\"Assertion failed: TypeLengthOK signal is not 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_8_1_1"
    },
    {
        "sva": "property p_round_out_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 round_out == 0;\nendproperty\nassert_p_round_out_reset: assert property (p_round_out_reset) else $error(\"Assertion failed: round_out signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "402_12_1_1"
    },
    {
        "sva": "property p_subtrahend_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 subtrahend == {$past(!small_is_denorm), $past(mantissa_small), 2'b00};\nendproperty\nassert_p_subtrahend_assignment_logic: assert property (p_subtrahend_assignment_logic) else $error(\"Assertion failed: subtrahend assignment logic is incorrect.\");",
        "sva_id": "403_11_1_1"
    },
    {
        "sva": "property p_w_status_concat;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (w_re == 1 && w_we == 0) |-> (w_status == {w_re, w_we});\nendproperty\nassert_p_w_status_concat: assert property (p_w_status_concat) else $error(\"Assertion failed: w_status does not correctly concatenate w_re and w_we when w_re is 1 and w_we is 0\");",
        "sva_id": "1762_12_1_1"
    },
    {
        "sva": "property p_write_ptr_reset_logic;\n    @(posedge clock) disable iff (resetn == 1)\n        resetn == 0 |-> ##1 write_ptr == 5'b00000;\nendproperty\nassert_p_write_ptr_reset_logic: assert property (p_write_ptr_reset_logic) else $error(\"Assertion failed: write_ptr is not reset to 5'b00000 one cycle after resetn is deasserted\");",
        "sva_id": "1556_2_1_1"
    },
    {
        "sva": "property p_exponent_a_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 exponent_a == $past(opa[62:52]);\nendproperty\nassert_p_exponent_a_assignment: assert property (p_exponent_a_assignment) else $error(\"Assertion failed: exponent_a does not equal the past value of opa[62:52] one cycle after enable is asserted and reset is deasserted.\");",
        "sva_id": "403_3_1_1"
    },
    {
        "sva": "property p_round_nearest_trigger_assignment;\n    @(posedge clk) disable iff (rst)\n        (round_nearest == 1 && mantissa_term[1] == 1) |-> \n        round_nearest_trigger == (round_nearest == 1 && mantissa_term[1] == 1);\nendproperty\nassert_p_round_nearest_trigger_assignment: assert property (p_round_nearest_trigger_assignment) \n    else $error(\"Assertion failed: round_nearest_trigger does not reflect the correct state when round_nearest and mantissa_term[1] are both 1\");",
        "sva_id": "402_16_1_1"
    },
    {
        "sva": "property p_PauseTimer_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 PauseTimer[15:0] == 16'h0;\nendproperty\nassert_p_PauseTimer_assignment_on_RxReset: assert property (p_PauseTimer_assignment_on_RxReset) else $error(\"Assertion failed: PauseTimer[15:0] is not assigned to 16'h0 one cycle after RxReset is asserted\");",
        "sva_id": "183_16_1_1"
    },
    {
        "sva": "property p_sign_reset_logic;\n    @(posedge clk) disable iff (rst==0)\n        rst == 1 |-> ##1 sign == 0;\nendproperty\nassert_p_sign_reset_logic: assert property (p_sign_reset_logic) else $error(\"Assertion failed: sign signal is not reset to 0 one cycle after rst is asserted\");",
        "sva_id": "401_2_1_1"
    },
    {
        "sva": "property p_rs_data_buffer_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        w_we == 1 |-> ##1 rs_data_buffer[$past(rs_write_counter)] == $past(i_dt);\nendproperty\nassert_p_rs_data_buffer_assignment: assert property (p_rs_data_buffer_assignment) else $error(\"Assertion failed: rs_data_buffer assignment is incorrect. Expected rs_data_buffer[$past(rs_write_counter)] to be equal to $past(i_dt)\");",
        "sva_id": "1762_16_1_1"
    },
    {
        "sva": "property p_product_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 product == { $past(sum_8), $past(sum_7[16:0]), $past(sum_5[6:0]), $past(sum_4[9:0]), $past(sum_2[6:0]), $past(sum_1[9:0]), $past(sum_0[6:0]), $past(product_a[16:0]) };\nendproperty\nassert_p_product_assignment_logic: assert property (p_product_assignment_logic) else $error(\"Assertion failed: product signal does not match the expected concatenation of past values.\");",
        "sva_id": "401_16_1_1"
    },
    {
        "sva": "property p_AddressOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 AddressOK == 0;\nendproperty\nassert_p_AddressOK_RxReset: assert property (p_AddressOK_RxReset) else $error(\"Assertion failed: AddressOK should be 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_2_1_1"
    },
    {
        "sva": "property p_sign_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && a_gtet_b == 1) |-> ##1 sign == $past(opa[63]);\nendproperty\nassert_p_sign_assignment_logic: assert property (p_sign_assignment_logic) else $error(\"Assertion failed: sign signal does not reflect the correct state based on opa[63] when rst is 0, enable is 1, and a_gtet_b is 1\");",
        "sva_id": "403_19_1_1"
    },
    {
        "sva": "property p_exponent_assignment_logic;\n    @(posedge clk) disable iff (rst)\n        (rst == 0 && enable == 1 && diffshift_gt_exponent == 1) |-> ##1 (exponent == 0);\nendproperty\nassert_p_exponent_assignment_logic: assert property (p_exponent_assignment_logic) else $error(\"Assertion failed: exponent is not assigned to 0 as expected when rst is 0, enable is 1, and diffshift_gt_exponent is 1\");",
        "sva_id": "403_13_1_1"
    },
    {
        "sva": "property p_exponent_small_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && a_gtet_b == 1) |-> ##1 exponent_small == $past(exponent_b);\nendproperty\nassert_p_exponent_small_assignment: assert property (p_exponent_small_assignment) else $error(\"Assertion failed: exponent_small does not correctly reflect the past value of exponent_b when rst is 0, enable is 1, and a_gtet_b is 1\");",
        "sva_id": "403_6_1_1"
    },
    {
        "sva": "property p_sum_round_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 sum_round == 0;\nendproperty\nassert_p_sum_round_reset: assert property (p_sum_round_reset) else $error(\"Assertion failed: sum_round is not zero one cycle after reset is asserted\");",
        "sva_id": "402_1_1_1"
    },
    {
        "sva": "property p_small_is_denorm_assignment;\n    @(posedge clk) disable iff (rst)\n        (rst == 0 && enable == 1 && exponent_small == 0) |-> ##1 small_is_denorm == 1;\nendproperty\nassert_p_small_is_denorm_assignment: assert property (p_small_is_denorm_assignment) else $error(\"Assertion failed: small_is_denorm signal is not set to 1 when rst is 0, enable is 1, and exponent_small is 0\");",
        "sva_id": "403_7_1_1"
    },
    {
        "sva": "property p_AddressOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        (RxReset == 1) |-> ##1 (AddressOK == 0);\nendproperty\nassert_p_AddressOK_RxReset: assert property (p_AddressOK_RxReset) else $error(\"Assertion failed: AddressOK signal is not 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_6_1_1"
    },
    {
        "sva": "property p_exponent_a_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 exponent_a == 0;\nendproperty\nassert_p_exponent_a_reset: assert property (p_exponent_a_reset) else $error(\"Assertion failed: exponent_a is not 0 one cycle after rst is asserted\");",
        "sva_id": "403_4_1_1"
    },
    {
        "sva": "property p_subtra_shift_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 subtra_shift == ($past(subtrahend) >> $past(exponent_diff));\nendproperty\nassert_p_subtra_shift_assignment: assert property (p_subtra_shift_assignment) else $error(\"Assertion failed: subtra_shift does not reflect the correct shifted value of subtrahend by exponent_diff\");",
        "sva_id": "403_10_1_1"
    },
    {
        "sva": "property p_AddressOK_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 AddressOK == 0;\nendproperty\nassert_p_AddressOK_RxReset: assert property (p_AddressOK_RxReset) else $error(\"Assertion failed: AddressOK should be 0 one cycle after RxReset is asserted\");",
        "sva_id": "183_1_1_1"
    },
    {
        "sva": "property p_subtra_shift_nonzero_assignment;\n    @(posedge clk) disable iff (rst)\n        (|subtra_shift[54:0] == 1) |-> subtra_shift_nonzero == (|subtra_shift[54:0]);\nendproperty\nassert_p_subtra_shift_nonzero_assignment: assert property (p_subtra_shift_nonzero_assignment) else $error(\"Assertion failed: subtra_shift_nonzero does not reflect the non-zero state of subtra_shift[54:0]\");",
        "sva_id": "403_15_1_1"
    },
    {
        "sva": "property p_ByteCnt_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 ByteCnt[4:0] == 5'h0;\nendproperty\nassert_p_ByteCnt_RxReset: assert property (p_ByteCnt_RxReset) else $error(\"Assertion failed: ByteCnt[4:0] is not 5'h0 one cycle after RxReset is asserted\");",
        "sva_id": "183_15_1_1"
    },
    {
        "sva": "property p_ByteCntEq0_assignment_logic;\n    @(posedge MRxClk) disable iff (RxReset == 1)\n        (RxValid == 1 && ByteCnt[4:0] == 5'h0) |-> ByteCntEq0 == (RxValid == 1 && ByteCnt[4:0] == 5'h0);\nendproperty\nassert_p_ByteCntEq0_assignment_logic: assert property (p_ByteCntEq0_assignment_logic) else $error(\"Assertion failed: ByteCntEq0 does not reflect the correct state when RxValid is 1 and ByteCnt[4:0] is 0\");",
        "sva_id": "183_23_1_1"
    },
    {
        "sva": "property p_diffshift_gt_exponent_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && diff_shift_2 > exponent_large) |-> ##1 diffshift_gt_exponent == 1;\nendproperty\nassert_p_diffshift_gt_exponent_assignment: assert property (p_diffshift_gt_exponent_assignment) else $error(\"Assertion failed: diffshift_gt_exponent is not set to 1 one cycle after diff_shift_2 is greater than exponent_large when enable is active and reset is not asserted\");",
        "sva_id": "403_12_1_1"
    },
    {
        "sva": "property p_irq_assignment;\n    @(posedge clk) disable iff (rst)\n        (TSR[7] == 1 && TCR[7] == 1) |-> (irq == 1);\nendproperty\nassert_p_irq_assignment: assert property (p_irq_assignment) else $error(\"Assertion failed: irq signal is not asserted when both TSR[7] and TCR[7] are set to 1\");",
        "sva_id": "1486_8_1_1"
    },
    {
        "sva": "property p_io_do_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        io_re == 1 |-> io_do == io_do_data;\nendproperty\nassert_p_io_do_assignment: assert property (p_io_do_assignment) else $error(\"Assertion failed: io_do does not match io_do_data when io_re is asserted\");",
        "sva_id": "1486_25_1_1"
    },
    {
        "sva": "property p_sum_round_reset;\n    @(posedge clk) disable iff (rst == 0)\n        rst == 1 |-> ##1 sum_round == 0;\nendproperty\nassert_p_sum_round_reset: assert property (p_sum_round_reset) else $error(\"Assertion failed: sum_round is not 0 one cycle after reset is asserted\");",
        "sva_id": "402_13_1_1"
    },
    {
        "sva": "property p_sign_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && a_gtet_b == 1 && fpu_op == 3'b000) |-> ##1 sign == $past(opa[63]);\nendproperty\nassert_p_sign_assignment_logic: assert property (p_sign_assignment_logic) else $error(\"Assertion failed: sign signal does not match the past value of opa[63] under the specified conditions\");",
        "sva_id": "403_5_1_1"
    },
    {
        "sva": "property p_io_do_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        io_re == 1 |-> io_do == io_do_data;\nendproperty\nassert_p_io_do_assignment: assert property (p_io_do_assignment) else $error(\"Assertion failed: io_do does not match io_do_data when io_re is asserted\");",
        "sva_id": "1486_6_1_1"
    },
    {
        "sva": "property p_subtrahend_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 subtrahend == { $past(!small_is_denorm), $past(mantissa_small), 2'b00 };\nendproperty\nassert_p_subtrahend_assignment_logic: assert property (p_subtrahend_assignment_logic) else $error(\"Assertion failed: subtrahend assignment logic is incorrect after enable signal.\");",
        "sva_id": "403_14_1_1"
    },
    {
        "sva": "property p_subtra_fraction_enable_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (small_is_nonzero == 1 && subtra_shift_nonzero == 0) |-> \n        subtra_fraction_enable == (small_is_nonzero == 1 && subtra_shift_nonzero == 0);\nendproperty\nassert_p_subtra_fraction_enable_assignment: assert property (p_subtra_fraction_enable_assignment) else $error(\"Assertion failed: subtra_fraction_enable does not reflect the correct state when small_is_nonzero is 1 and subtra_shift_nonzero is 0\");",
        "sva_id": "403_16_1_1"
    },
    {
        "sva": "property p_rs_read_counter_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 rs_read_counter == 0;\nendproperty\nassert_p_rs_read_counter_reset: assert property (p_rs_read_counter_reset) else $error(\"Assertion failed: rs_read_counter is not reset to 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1762_4_1_1"
    },
    {
        "sva": "property p_io_do_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (io_a == 2'b00 && io_re == 1) |-> (io_do == TCNT[7:0]);\nendproperty\nassert_p_io_do_assignment: assert property (p_io_do_assignment) else $error(\"Assertion failed: io_do does not match TCNT[7:0] when io_a is 2'b00 and io_re is 1\");",
        "sva_id": "1486_16_1_1"
    },
    {
        "sva": "property p_o_req_r_req;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_req == 1 |-> o_req == (r_req == 1);\nendproperty\nassert_p_o_req_r_req: assert property (p_o_req_r_req) else $error(\"Assertion failed: o_req does not match the expected value when r_req is asserted.\");",
        "sva_id": "1763_13_1_1"
    },
    {
        "sva": "property p_o_blocking_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (overflow == 1 && tcr_write == 0) |-> (o == 1);\nendproperty\nassert_p_o_blocking_assignment: assert property (p_o_blocking_assignment) else $error(\"Assertion failed: When overflow is 1 and tcr_write is 0, o should be 1\");",
        "sva_id": "1486_28_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 TTMP == $past(io_di);\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP does not correctly reflect the past value of io_di under the specified conditions\");",
        "sva_id": "1486_17_1_1"
    },
    {
        "sva": "property p_exponent_a_reset;\n    @(posedge clk) disable iff (rst==0)\n        rst == 1 |-> ##1 exponent_a == 0;\nendproperty\nassert_p_exponent_a_reset: assert property (p_exponent_a_reset) else $error(\"Assertion failed: exponent_a is not 0 one cycle after reset is asserted\");",
        "sva_id": "403_1_1_1"
    },
    {
        "sva": "property p_irq_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (TSR[7] == 1 && TCR[7] == 1) |-> (irq == 1);\nendproperty\nassert_p_irq_assignment: assert property (p_irq_assignment) else $error(\"Assertion failed: irq signal is not set when both TSR[7] and TCR[7] are high\");",
        "sva_id": "1486_24_1_1"
    },
    {
        "sva": "property p_o_overflow_tcr_write;\n    @(posedge clk) disable iff (rst == 1)\n        (overflow == 1 && tcr_write == 0) |-> (o == (overflow & ~tcr_write));\nendproperty\nassert_p_o_overflow_tcr_write: assert property (p_o_overflow_tcr_write) else $error(\"Assertion failed: 'o' signal does not match the expected value when overflow is high and tcr_write is low\");",
        "sva_id": "1486_14_1_1"
    },
    {
        "sva": "property p_PauseTimer_assignment_on_RxReset;\n    @(posedge MRxClk) disable iff (RxReset == 0)\n        RxReset == 1 |-> ##1 PauseTimer[15:0] == 16'h0;\nendproperty\nassert_p_PauseTimer_assignment_on_RxReset: assert property (p_PauseTimer_assignment_on_RxReset) else $error(\"Assertion failed: PauseTimer[15:0] is not assigned to 16'h0 one cycle after RxReset is asserted\");",
        "sva_id": "183_4_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 TTMP == $past(io_di);\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP does not match the previous cycle's io_di value under the specified conditions\");",
        "sva_id": "1486_10_1_1"
    },
    {
        "sva": "property p_irq_blocking_assign;\n    @(posedge clk) disable iff (rst == 1)\n        (TSR[7] == 1 && TCR[7] == 1) |-> irq == (TSR[7] & TCR[7]);\nendproperty\nassert_p_irq_blocking_assign: assert property (p_irq_blocking_assign) else $error(\"Assertion failed: irq signal does not reflect the correct state when TSR[7] and TCR[7] are both set to 1\");",
        "sva_id": "1486_19_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n    (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 TTMP == $past(io_di);\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP signal does not correctly reflect the past value of io_di under the specified conditions\");",
        "sva_id": "1486_4_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst)\n        (io_re == 1 && io_a == 2'b00) |-> ##1 (TTMP == $past(TCNT[15:8]));\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP does not correctly reflect the past value of TCNT[15:8] when io_re is 1 and io_a is 2'b00\");",
        "sva_id": "1486_21_1_1"
    },
    {
        "sva": "property p_tcr_write_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (io_we == 1 && io_a == 2'b10) |-> tcr_write == 1;\nendproperty\nassert_p_tcr_write_assignment: assert property (p_tcr_write_assignment) else $error(\"Assertion failed: tcr_write signal is not correctly assigned when io_we is 1 and io_a is 2'b10\");",
        "sva_id": "1486_27_1_1"
    },
    {
        "sva": "property p_TCR_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b10) |-> ##1 TCR == $past(io_di);\nendproperty\nassert_p_TCR_assignment_logic: assert property (p_TCR_assignment_logic) else $error(\"Assertion failed: TCR does not equal the previous value of io_di when rst is 0, io_we is 1, io_re is 0, and io_a is 2'b10\");",
        "sva_id": "1486_11_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 (TTMP == $past(io_di));\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP does not match the previous cycle's io_di when io_we is asserted, io_re is deasserted, and io_a is 2'b01\");",
        "sva_id": "1486_7_1_1"
    },
    {
        "sva": "property p_in_norm_out_denorm_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (exponent_large > 0 && exponent == 0) |-> in_norm_out_denorm == 1;\nendproperty\nassert_p_in_norm_out_denorm_assignment: assert property (p_in_norm_out_denorm_assignment) else $error(\"Assertion failed: in_norm_out_denorm signal is not assigned correctly when exponent_large > 0 and exponent == 0\");",
        "sva_id": "403_18_1_1"
    },
    {
        "sva": "property p_pre_prev_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && tcnt_write == 0) |-> ##1 pre_prev == {$past(prescaler[11]), $past(prescaler[7]), $past(prescaler[3])};\nendproperty\nassert_p_pre_prev_assignment: assert property (p_pre_prev_assignment) else $error(\"Assertion failed: pre_prev does not match the expected values from prescaler at the previous clock cycle\");",
        "sva_id": "1486_13_1_1"
    },
    {
        "sva": "property p_prescaler_increment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && tcnt_write == 0 && prescaler < '1) |-> ##1 prescaler == $past(prescaler) + 1;\nendproperty\nassert_p_prescaler_increment: assert property (p_prescaler_increment) else $error(\"Assertion failed: prescaler did not increment correctly when tcnt_write is 0 and prescaler < '1\");",
        "sva_id": "1486_18_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 TTMP == $past(io_di);\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP signal does not correctly reflect the past value of io_di under the specified conditions.\");",
        "sva_id": "1486_1_1_1"
    },
    {
        "sva": "property p_tcnt_write_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (io_we == 1 && io_a == 2'b00) |-> (tcnt_write == 1);\nendproperty\nassert_p_tcnt_write_assignment: assert property (p_tcnt_write_assignment) else $error(\"Assertion failed: tcnt_write signal is not set correctly when io_we is 1 and io_a is 2'b00\");",
        "sva_id": "1486_26_1_1"
    },
    {
        "sva": "property p_TTMP_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_we == 1 && io_re == 0 && io_a == 2'b01) |-> ##1 TTMP == $past(io_di);\nendproperty\nassert_p_TTMP_assignment_logic: assert property (p_TTMP_assignment_logic) else $error(\"Assertion failed: TTMP signal does not match the previous io_di value under the specified conditions\");",
        "sva_id": "1486_20_1_1"
    },
    {
        "sva": "property p_r_state_reset_init;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 r_state == $past(P_IDLE);\nendproperty\nassert_p_r_state_reset_init: assert property (p_r_state_reset_init) else $error(\"Assertion failed: r_state does not transition to P_IDLE state after reset\");",
        "sva_id": "1763_2_1_1"
    },
    {
        "sva": "property p_o_wr_r_wr;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_wr == 1 |-> o_wr == (r_wr == 1);\nendproperty\nassert_p_o_wr_r_wr: assert property (p_o_wr_r_wr) else $error(\"Assertion failed: o_wr signal does not reflect the correct state when r_wr is asserted\");",
        "sva_id": "1763_25_1_1"
    },
    {
        "sva": "property p_io_do_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_re == 1 && io_a == 2'b00) |-> (io_do == TCNT[7:0]);\nendproperty\nassert_p_io_do_assignment_logic: assert property (p_io_do_assignment_logic) else $error(\"Assertion failed: io_do does not match TCNT[7:0] when rst is 0, io_re is 1, and io_a is 2'b00\");",
        "sva_id": "1486_5_1_1"
    },
    {
        "sva": "property p_prescaler_increment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && tcnt_write == 0 && prescaler < 1) |-> ##1 prescaler == $past(prescaler) + 1;\nendproperty\nassert_p_prescaler_increment: assert property (p_prescaler_increment) else $error(\"Assertion failed: prescaler did not increment correctly when expected.\");",
        "sva_id": "1486_22_1_1"
    },
    {
        "sva": "property p_wr_ptr_reset_logic;\n    @(posedge wr_clk) disable iff (wr_reset_n == 1)\n        (wr_reset_n == 0) |-> ##1 (wr_ptr == 0);\nendproperty\nassert_p_wr_ptr_reset_logic: assert property (p_wr_ptr_reset_logic) else $error(\"Assertion failed: wr_ptr is not reset to 0 one cycle after wr_reset_n is deasserted\");",
        "sva_id": "1413_1_1_1"
    },
    {
        "sva": "property p_o_av_rd_r_rdata;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_rdata == 4'b1010 |-> o_av_rd == r_rdata;\nendproperty\nassert_p_o_av_rd_r_rdata: assert property (p_o_av_rd_r_rdata) else $error(\"Assertion failed: o_av_rd does not equal r_rdata when r_rdata is 4'b1010\");",
        "sva_id": "1763_23_1_1"
    },
    {
        "sva": "property p_r_rdata_assignment;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (rst_x == 1 && r_state == P_WAIT_ACK && i_ack == 1 && r_wr == 0 && i_rstr == 1) |-> ##1 r_rdata == $past(i_rd);\nendproperty\nassert_p_r_rdata_assignment: assert property (p_r_rdata_assignment) else $error(\"Assertion failed: r_rdata does not reflect the past value of i_rd under the specified conditions.\");",
        "sva_id": "1763_9_1_1"
    },
    {
        "sva": "property p_prescaler_increment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && tcnt_write == 0 && prescaler < 1) |-> ##1 prescaler == $past(prescaler) + 1;\nendproperty\nassert_p_prescaler_increment_logic: assert property (p_prescaler_increment_logic) else $error(\"Assertion failed: prescaler did not increment correctly when tcnt_write is 0 and prescaler is less than 1\");",
        "sva_id": "1486_12_1_1"
    },
    {
        "sva": "property p_sum_overflow_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        sum[55] == 1 |-> sum_overflow == sum[55];\nendproperty\nassert_p_sum_overflow_assignment: assert property (p_sum_overflow_assignment) else $error(\"Assertion failed: sum_overflow does not match sum[55] when sum[55] is 1\");",
        "sva_id": "399_15_1_1"
    },
    {
        "sva": "property p_o_wd_r_wd;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_wd == 32'hA5A5A5A5 |-> o_wd == r_wd;\nendproperty\nassert_p_o_wd_r_wd: assert property (p_o_wd_r_wd) else $error(\"Assertion failed: o_wd does not match r_wd when r_wd is 32'hA5A5A5A5\");",
        "sva_id": "1763_17_1_1"
    },
    {
        "sva": "property p_io_do_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && io_re == 1 && io_a == 2'b00) |-> (io_do == TCNT[7:0]);\nendproperty\nassert_p_io_do_assignment_logic: assert property (p_io_do_assignment_logic) else $error(\"Assertion failed: io_do does not match TCNT[7:0] when rst is 0, io_re is 1, and io_a is 2'b00\");",
        "sva_id": "1486_3_1_1"
    },
    {
        "sva": "property p_o_req_r_req;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_req == 1 |-> o_req == (r_req == 1);\nendproperty\nassert_p_o_req_r_req: assert property (p_o_req_r_req) else $error(\"Assertion failed: o_req signal does not correctly reflect the state of r_req signal when r_req is asserted\");",
        "sva_id": "1763_24_1_1"
    },
    {
        "sva": "property p_full_c_assignment;\n    @(posedge wr_clk) disable iff (wr_reset_n == 0)\n        wr_cnt == FULL_DP |-> full_c == 1'b1;\nendproperty\nassert_p_full_c_assignment: assert property (p_full_c_assignment) else $error(\"Assertion failed: full_c signal is not set to 1 when wr_cnt equals FULL_DP\");",
        "sva_id": "1413_9_1_1"
    },
    {
        "sva": "property p_tcnt_write_logic;\n    @(posedge clk) disable iff (rst == 1)\n        tcnt_write == 1 |-> ##1 TCNT == { $past(TTMP), $past(io_di) };\nendproperty\nassert_p_tcnt_write_logic: assert property (p_tcnt_write_logic) else $error(\"Assertion failed: TCNT does not match the expected concatenation of past TTMP and io_di values.\");",
        "sva_id": "1486_23_1_1"
    },
    {
        "sva": "property p_r_state_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 r_state == $past(P_IDLE);\nendproperty\nassert_p_r_state_assignment: assert property (p_r_state_assignment) else $error(\"Assertion failed: r_state does not equal the previous value of P_IDLE one cycle after rst_x is deasserted\");",
        "sva_id": "1763_18_1_1"
    },
    {
        "sva": "property p_o_wd_r_wd;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_wd == 32'hA5A5A5A5 |-> o_wd == r_wd;\nendproperty\nassert_p_o_wd_r_wd: assert property (p_o_wd_r_wd) else $error(\"Assertion failed: o_wd does not equal r_wd when r_wd is 32'hA5A5A5A5\");",
        "sva_id": "1763_28_1_1"
    },
    {
        "sva": "property p_afull_c_assignment;\n    @(posedge wr_clk) disable iff (wr_reset_n == 0)\n        (wr_cnt == 3) |-> (afull_c == 1'b1);\nendproperty\nassert_p_afull_c_assignment: assert property (p_afull_c_assignment) else $error(\"Assertion failed: afull_c signal is not set to 1 when wr_cnt is 3\");",
        "sva_id": "1413_10_1_1"
    },
    {
        "sva": "property p_o_av_rd_r_rdata;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        (r_rdata == 4'b1010) |-> (o_av_rd == r_rdata);\nendproperty\nassert_p_o_av_rd_r_rdata: assert property (p_o_av_rd_r_rdata) else $error(\"Assertion failed: o_av_rd does not match r_rdata when r_rdata is 4'b1010\");",
        "sva_id": "1763_11_1_1"
    },
    {
        "sva": "property p_aempty_c_assignment;\n    @(posedge rd_clk) disable iff (rd_reset_n == 0)\n        (rd_cnt == 1) |-> (aempty_c == 1'b1);\nendproperty\nassert_p_aempty_c_assignment: assert property (p_aempty_c_assignment) else $error(\"Assertion failed: aempty_c signal is not set to 1 when rd_cnt is 1\");",
        "sva_id": "1413_12_1_1"
    },
    {
        "sva": "property p_sync_wr_ptr_0_reset;\n    @(posedge rd_clk) disable iff (rd_reset_n == 1)\n        rd_reset_n == 0 |-> ##1 sync_wr_ptr_0 == 0;\nendproperty\nassert_p_sync_wr_ptr_0_reset: assert property (p_sync_wr_ptr_0_reset) else $error(\"Assertion failed: sync_wr_ptr_0 is not reset to 0 one cycle after rd_reset_n is deasserted\");",
        "sva_id": "1413_8_1_1"
    },
    {
        "sva": "property p_o_adrs_r_adrs;\n    @(posedge clk_core) disable iff (rst_x == 0)\n        r_adrs == 10'b1010101010 |-> o_adrs == r_adrs;\nendproperty\nassert_p_o_adrs_r_adrs: assert property (p_o_adrs_r_adrs) else $error(\"Assertion failed: o_adrs does not match r_adrs when r_adrs is 10'b1010101010\");",
        "sva_id": "1763_26_1_1"
    },
    {
        "sva": "property p_denorm_to_norm_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 denorm_to_norm == ($past(sum_leading_one) & $past(large_is_denorm));\nendproperty\nassert_p_denorm_to_norm_assignment: assert property (p_denorm_to_norm_assignment) else $error(\"Assertion failed: denorm_to_norm signal does not reflect the correct state based on sum_leading_one and large_is_denorm\");",
        "sva_id": "399_12_1_1"
    },
    {
        "sva": "property p_r_rdata_assignment;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 r_rdata == 0;\nendproperty\nassert_p_r_rdata_assignment: assert property (p_r_rdata_assignment) else $error(\"Assertion failed: r_rdata is not 0 one cycle after rst_x is deasserted\");",
        "sva_id": "1763_10_1_1"
    },
    {
        "sva": "property p_exponent_a_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 exponent_a == $past(opa[62:52]);\nendproperty\nassert_p_exponent_a_assignment_logic: assert property (p_exponent_a_assignment_logic) else $error(\"Assertion failed: exponent_a does not match the previous value of opa[62:52] when enabled and not in reset\");",
        "sva_id": "403_2_1_1"
    },
    {
        "sva": "property p_exponent_a_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1) |-> ##1 exponent_a == $past(opa[62:52]);\nendproperty\nassert_p_exponent_a_assignment: assert property (p_exponent_a_assignment) else $error(\"Assertion failed: exponent_a does not match the expected value from opa[62:52] after one clock cycle\");",
        "sva_id": "399_3_1_1"
    },
    {
        "sva": "property p_rd_ptr_reset;\n    @(posedge rd_clk) disable iff (rd_reset_n == 1)\n        rd_reset_n == 0 |-> ##1 rd_ptr == 0;\nendproperty\nassert_p_rd_ptr_reset: assert property (p_rd_ptr_reset) else $error(\"Assertion failed: rd_ptr is not reset to 0 one cycle after rd_reset_n is deasserted\");",
        "sva_id": "1413_6_1_1"
    },
    {
        "sva": "property p_small_shift_nonzero_assignment;\n    @(posedge clk) disable iff (rst == 1)\n        (|small_shift[55:0] == 1) |-> small_shift_nonzero == (|small_shift[55:0]);\nendproperty\nassert_p_small_shift_nonzero_assignment: assert property (p_small_shift_nonzero_assignment) else $error(\"Assertion failed: small_shift_nonzero does not reflect the non-zero state of small_shift[55:0]\");",
        "sva_id": "399_14_1_1"
    },
    {
        "sva": "property p_sync_rd_ptr_0_reset;\n    @(posedge wr_clk) disable iff (wr_reset_n == 1)\n        wr_reset_n == 0 |-> ##1 sync_rd_ptr_0 == 0;\nendproperty\nassert_p_sync_rd_ptr_0_reset: assert property (p_sync_rd_ptr_0_reset) else $error(\"Assertion failed: sync_rd_ptr_0 is not reset to 0 one cycle after wr_reset_n is deasserted\");",
        "sva_id": "1413_4_1_1"
    },
    {
        "sva": "property p_rd_data_c_assignment;\n    @(posedge rd_clk) disable iff (rd_reset_n == 0)\n        (rd_reset_n == 1 && rd_ptr >= 0 && rd_ptr < (1 << AW)) |-> rd_data_c == mem[rd_ptr[AW-1:0]];\nendproperty\nassert_p_rd_data_c_assignment: assert property (p_rd_data_c_assignment) else $error(\"Assertion failed: rd_data_c does not match the expected memory value at rd_ptr\");",
        "sva_id": "1413_7_1_1"
    },
    {
        "sva": "property p_rd_ptr_reset_logic;\n    @(posedge rd_clk) disable iff (rd_reset_n == 1)\n        rd_reset_n == 0 |-> ##1 rd_ptr == 0;\nendproperty\nassert_p_rd_ptr_reset_logic: assert property (p_rd_ptr_reset_logic) else $error(\"Assertion failed: rd_ptr is not reset to 0 one cycle after rd_reset_n is deasserted\");",
        "sva_id": "1413_5_1_1"
    },
    {
        "sva": "property p_sum_assignment_logic;\n    @(posedge clk) disable iff (rst == 1)\n        (rst == 0 && enable == 1 && (large_add < '1)) |-> ##1 sum == ($past(large_add) + $past(small_shift_3));\nendproperty\nassert_p_sum_assignment_logic: assert property (p_sum_assignment_logic) else $error(\"Assertion failed: sum does not equal the expected value based on the past values of large_add and small_shift_3\");",
        "sva_id": "399_6_1_1"
    },
    {
        "sva": "property p_wr_ptr_reset;\n    @(posedge wr_clk) disable iff (wr_reset_n == 1)\n        wr_reset_n == 0 |-> ##1 wr_ptr == 0;\nendproperty\nassert_p_wr_ptr_reset: assert property (p_wr_ptr_reset) else $error(\"Assertion failed: wr_ptr is not reset to 0 one cycle after wr_reset_n is deasserted\");",
        "sva_id": "1413_2_1_1"
    },
    {
        "sva": "property p_r_state_assignment_on_reset;\n    @(posedge clk_core) disable iff (rst_x == 1)\n        rst_x == 0 |-> ##1 r_state == P_IDLE;\nendproperty\nassert_p_r_state_assignment_on_reset: assert property (p_r_state_assignment_on_reset) else $error(\"Assertion failed: r_state is not assigned to P_IDLE one cycle after reset is deasserted\");",
        "sva_id": "1763_8_1_1"
    },
    {
        "sva": "property p_mantissa_small_assignment;\n    @(posedge clk) disable iff (rst)\n        (rst == 0 && enable == 1 && expa_gt_expb == 1) |-> ##1 mantissa_small == $past(mantissa_b);\nendproperty\nassert_p_mantissa_small_assignment: assert property (p_mantissa_small_assignment) else $error(\"Assertion failed: mantissa_small does not match the past value of mantissa_b when conditions are met\");",
        "sva_id": "399_4_1_1"
    },
    {
        "sva": "property p_disparity_reset_logic;\n    @(posedge SBYTECLK) disable iff (reset == 0)\n        reset == 1 |-> ##1 disparity == 0;\nendproperty\nassert_p_disparity_reset_logic: assert property (p_disparity_reset_logic) else $error(\"Assertion failed: disparity signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "2_5_1_1"
    },
    {
        "sva": "property p_sign_assignment_on_reset;\n    @(posedge clk) disable iff (rst==0)\n        rst == 1 |-> ##1 sign == 0;\nendproperty\nassert_p_sign_assignment_on_reset: assert property (p_sign_assignment_on_reset) else $error(\"Assertion failed: sign signal is not 0 one cycle after reset is asserted\");",
        "sva_id": "399_13_1_1"
    },
    {
        "sva": "property p_sync_wr_ptr_grey2bin;\n    @(posedge rd_clk) disable iff (rd_reset_n == 0)\n        sync_wr_ptr_1 == 4'b0101 |-> sync_wr_ptr == grey2bin(sync_wr_ptr_1);\nendproperty\nassert_p_sync_wr_ptr_grey2bin: assert property (p_sync_wr_ptr_grey2bin) else $error(\"Assertion failed: sync_wr_ptr does not match the binary conversion of sync_wr_ptr_1 when sync_wr_ptr_1 is 4'b0101\");",
        "sva_id": "1413_17_1_1"
    }
]