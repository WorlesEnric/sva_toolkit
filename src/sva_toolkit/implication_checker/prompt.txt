Project Path: implication_checker

Source Tree:

```txt
implication_checker
├── __init__.py
├── checker.py
└── cli.py

```

`implication_checker/__init__.py`:

```py
"""SVA Implication Checker module."""

from sva_toolkit.implication_checker.checker import SVAImplicationChecker

__all__ = ["SVAImplicationChecker"]

```

`implication_checker/checker.py`:

```py
"""
SVA Implication Checker - Verify implication relationships between SVA pairs.

Uses SymbiYosys for formal verification.
"""

import os
import re
import tempfile
import subprocess
import shutil
from typing import Optional, Set, List, Tuple
from dataclasses import dataclass
from enum import Enum
from pathlib import Path

from sva_toolkit.ast_parser import SVAASTParser


class ImplicationResult(Enum):
    """Result of implication check."""
    IMPLIES = "implies"  # SVA1 implies SVA2
    NOT_IMPLIES = "not_implies"  # SVA1 does not imply SVA2
    EQUIVALENT = "equivalent"  # SVA1 and SVA2 are equivalent
    ERROR = "error"  # Verification error


@dataclass
class CheckResult:
    """Result of an implication check."""
    result: ImplicationResult
    message: str
    counterexample: Optional[str] = None
    log: Optional[str] = None


class SVAImplicationChecker:
    """
    Checker for verifying implication relationships between SVA pairs.
    
    Uses SymbiYosys to formally verify whether SVA1 implies SVA2.
    The approach:
    1. Create a trivial RTL module with all relevant signals
    2. Cover SVA1 (ensure it can be satisfied)
    3. Assume SVA1 holds
    4. Assert SVA2 should hold
    
    If the assertion passes, SVA1 implies SVA2.
    """

    SBY_TEMPLATE = """[options]
mode prove
depth {depth}

[engines]
smtbmc

[script]
plugin -i slang
read_slang {module_file}
prep -top {module_name}

[files]
{module_file}
"""

    MODULE_TEMPLATE = """
module sva_checker (
    input wire clk,
    input wire rst_n,
{signal_declarations}
);

    // Free-running signals (unconstrained for formal verification)
    
    // ----------------------------------------------------------------
    // INLINE SVA WRAPPERS
    // We wrap the user strings in macros or direct text to avoid 
    // explicit 'property' blocks, which some parsers struggle with.
    // ----------------------------------------------------------------

    // 1. Assume the Antecedent (User SVA 1)
    //    We assume this property holds true to constrain the state space.
    assume_antecedent: assume property (
        @(posedge clk) disable iff (!rst_n)
        {antecedent}
    );

    // 2. Assert the Consequent (User SVA 2)
    //    We check if this holds true under the assumption above.
    assert_consequent: assert property (
        @(posedge clk) disable iff (!rst_n)
        {consequent}
    );

    // 3. Cover the Antecedent
    //    (Optional) Check if the antecedent is even possible.
    cover_antecedent: cover property (
        @(posedge clk) disable iff (!rst_n)
        {antecedent}
    );

endmodule
"""

    EQUIVALENCE_MODULE_TEMPLATE = """
module sva_equiv_checker (
    input wire clk,
    input wire rst_n,
{signal_declarations}
);

    // Property 1
    property prop1;
        @(posedge clk) disable iff (!rst_n)
        {sva1};
    endproperty

    // Property 2
    property prop2;
        @(posedge clk) disable iff (!rst_n)
        {sva2};
    endproperty

    // Cover both properties to ensure they're satisfiable
    cover_prop1: cover property (prop1);
    cover_prop2: cover property (prop2);

    // Check prop1 -> prop2
    assume_prop1: assume property (prop1);
    assert_prop2: assert property (prop2);

endmodule
"""

    def __init__(
        self,
        sby_path: Optional[str] = None,
        yosys_path: Optional[str] = None,
        work_dir: Optional[str] = None,
        depth: int = 20,
        keep_files: bool = False,
    ):
        """
        Initialize the implication checker.
        
        Args:
            sby_path: Path to sby binary (default: bundled in 3rd_party)
            yosys_path: Path to yosys binary (default: bundled in 3rd_party)
            work_dir: Working directory for verification files (default: temp dir)
            depth: Proof depth for bounded model checking
            keep_files: Keep generated files after verification
        """
        # Determine paths relative to this file
        # src/sva_toolkit/implication_checker/checker.py -> root is 4 levels up
        project_root = Path(__file__).resolve().parent.parent.parent.parent
        
        default_sby = project_root / "3rd_party" / "oss-cad-suite" / "bin" / "sby"
        default_yosys = project_root / "3rd_party" / "oss-cad-suite" / "bin" / "yosys"

        self.sby_path = sby_path if sby_path else str(default_sby)
        self.yosys_path = yosys_path if yosys_path else str(default_yosys)
        self.work_dir = work_dir
        self.depth = depth
        self.keep_files = keep_files
        self.parser = SVAASTParser()
        
        self._verify_tools()

    def _verify_tools(self) -> None:
        """Verify that required tools are accessible."""
        # Check sby
        try:
            result = subprocess.run(
                [self.sby_path, "--help"],
                capture_output=True,
                text=True,
                timeout=10
            )
        except FileNotFoundError:
            raise RuntimeError(
                f"SymbiYosys not found at '{self.sby_path}'. "
                "Please install SymbiYosys or provide the correct path."
            )
        except subprocess.TimeoutExpired:
            raise RuntimeError("SymbiYosys verification timed out.")

    def _extract_property_expression(self, sva_code: str) -> str:
        """
        Extract the property expression from SVA code.
        
        Handles both full property declarations and inline assertions.
        
        Args:
            sva_code: SVA code
            
        Returns:
            The property expression (without property/endproperty wrapper)
        """
        # Remove assert/assume/cover property wrapper
        code = re.sub(r'(assert|assume|cover)\s+property\s*\(', '', sva_code)
        code = re.sub(r'\)\s*;?\s*$', '', code)
        
        # Remove property name declaration
        code = re.sub(r'property\s+\w+\s*;?', '', code)
        code = re.sub(r'endproperty', '', code)
        
        # Remove clock specification (we'll add our own)
        code = re.sub(r'@\s*\([^)]+\)', '', code)
        
        # Remove disable iff (we'll add our own)
        code = re.sub(r'disable\s+iff\s*\([^)]+\)', '', code)
        
        return code.strip().strip(';').strip()

    def _collect_signals(self, *sva_codes: str) -> Set[str]:
        """
        Collect all signals from multiple SVA codes.
        
        Args:
            *sva_codes: SVA code strings
            
        Returns:
            Set of signal names
        """
        all_signals = set()
        for code in sva_codes:
            signals = self.parser.get_all_signals(code)
            all_signals.update(signals)
        
        # Remove common keywords that might be misidentified
        keywords = {'clk', 'rst_n', 'rst', 'reset', 'clock'}
        all_signals -= keywords
        
        return all_signals

    def _generate_signal_declarations(self, signals: Set[str]) -> str:
        """
        Generate Verilog signal declarations.
        
        Args:
            signals: Set of signal names
            
        Returns:
            Signal declarations string
        """
        if not signals:
            return "    // No additional signals"
        
        declarations = []
        for sig in sorted(signals):
            declarations.append(f"    input wire {sig}")
        
        return ",\n".join(declarations)

    def _run_sby(
        self,
        module_content: str,
        module_name: str,
        work_dir: str,
    ) -> Tuple[bool, str]:
        """
        Run SymbiYosys verification.
        
        Args:
            module_content: Verilog module content
            module_name: Name of the module
            work_dir: Working directory
            
        Returns:
            Tuple of (success, log_output)
        """
        module_file = os.path.join(work_dir, f"{module_name}.sv")
        sby_file = os.path.join(work_dir, f"{module_name}.sby")
        
        # Write module file
        with open(module_file, 'w') as f:
            f.write(module_content)
        
        print(module_content)
        # Write sby configuration
        sby_config = self.SBY_TEMPLATE.format(
            depth=self.depth,
            module_file=f"{module_name}.sv",
            module_name=module_name,
        )
        with open(sby_file, 'w') as f:
            f.write(sby_config)
        
        # Run sby
        result = subprocess.run(
            [self.sby_path, "-f", sby_file],
            cwd=work_dir,
            capture_output=True,
            text=True,
            timeout=300,  # 5 minute timeout
        )
        
        log = result.stdout + result.stderr
        success = result.returncode == 0
        
        return success, log

    def check_implication(
        self,
        antecedent: str,
        consequent: str,
    ) -> CheckResult:
        """
        Check if antecedent implies consequent.
        
        Args:
            antecedent: Antecedent SVA code
            consequent: Consequent SVA code
            
        Returns:
            CheckResult with the verification result
        """
        # Extract property expressions
        ant_expr = self._extract_property_expression(antecedent)
        cons_expr = self._extract_property_expression(consequent)
        
        # Collect signals
        signals = self._collect_signals(antecedent, consequent)
        signal_decls = self._generate_signal_declarations(signals)
        
        # Generate module
        module_content = self.MODULE_TEMPLATE.format(
            signal_declarations=signal_decls,
            antecedent=ant_expr,
            consequent=cons_expr,
        )
        
        # Create working directory
        if self.work_dir:
            work_dir = self.work_dir
            os.makedirs(work_dir, exist_ok=True)
        else:
            work_dir = tempfile.mkdtemp(prefix="sva_check_")
        
        try:
            success, log = self._run_sby(module_content, "sva_checker", work_dir)
            
            if success:
                return CheckResult(
                    result=ImplicationResult.IMPLIES,
                    message="Antecedent implies consequent (proof passed)",
                    log=log,
                )
            else:
                if "ERROR:" in log or "syntax error" in log.lower() or "rc=16" in log:
                    return CheckResult(
                        result=ImplicationResult.ERROR,
                        message="SBY/Yosys Syntax or Execution Error",
                        log=log
                    )
                
                # If it's not a tool error, it's a verification failure (Counterexample)
                counterexample = self._extract_counterexample(log)
                return CheckResult(
                    result=ImplicationResult.NOT_IMPLIES,
                    message="Antecedent does not imply consequent (counterexample found)",
                    counterexample=counterexample,
                    log=log,
                )
                
        except subprocess.TimeoutExpired:
            return CheckResult(
                result=ImplicationResult.ERROR,
                message="Verification timed out",
            )
        except Exception as e:
            return CheckResult(
                result=ImplicationResult.ERROR,
                message=f"Verification error: {str(e)}",
            )
        finally:
            if not self.keep_files and not self.work_dir:
                shutil.rmtree(work_dir, ignore_errors=True)

    def check_equivalence(self, sva1: str, sva2: str) -> CheckResult:
        """
        Check if two SVAs are equivalent (bidirectional implication).
        
        Args:
            sva1: First SVA code
            sva2: Second SVA code
            
        Returns:
            CheckResult with the verification result
        """
        # Check sva1 -> sva2
        result1 = self.check_implication(sva1, sva2)
        
        if result1.result == ImplicationResult.ERROR:
            return result1
        
        # Check sva2 -> sva1
        result2 = self.check_implication(sva2, sva1)
        
        if result2.result == ImplicationResult.ERROR:
            return result2
        
        # Both directions must hold for equivalence
        if (result1.result == ImplicationResult.IMPLIES and 
            result2.result == ImplicationResult.IMPLIES):
            return CheckResult(
                result=ImplicationResult.EQUIVALENT,
                message="SVAs are equivalent (bidirectional implication holds)",
                log=f"Forward: {result1.log}\n\nBackward: {result2.log}",
            )
        else:
            directions = []
            if result1.result == ImplicationResult.IMPLIES:
                directions.append("sva1 -> sva2")
            if result2.result == ImplicationResult.IMPLIES:
                directions.append("sva2 -> sva1")
            
            if directions:
                return CheckResult(
                    result=ImplicationResult.NOT_IMPLIES,
                    message=f"SVAs are not equivalent. Only holds: {', '.join(directions)}",
                    log=f"Forward: {result1.log}\n\nBackward: {result2.log}",
                )
            else:
                return CheckResult(
                    result=ImplicationResult.NOT_IMPLIES,
                    message="SVAs are not equivalent (neither direction holds)",
                    counterexample=result1.counterexample or result2.counterexample,
                    log=f"Forward: {result1.log}\n\nBackward: {result2.log}",
                )

    def _extract_counterexample(self, log: str) -> Optional[str]:
        """
        Extract counterexample from sby log.
        
        Args:
            log: sby log output
            
        Returns:
            Counterexample trace or None
        """
        # Look for VCD file reference or counterexample info
        lines = log.split('\n')
        cex_lines = []
        in_cex = False
        
        for line in lines:
            if 'counterexample' in line.lower() or 'failed' in line.lower():
                in_cex = True
            if in_cex:
                cex_lines.append(line)
                if len(cex_lines) > 50:  # Limit counterexample size
                    break
        
        return '\n'.join(cex_lines) if cex_lines else None

    def get_implication_relationship(
        self,
        sva1: str,
        sva2: str,
    ) -> Tuple[bool, bool]:
        """
        Determine the implication relationship between two SVAs.
        
        Args:
            sva1: First SVA code
            sva2: Second SVA code
            
        Returns:
            Tuple of (sva1_implies_sva2, sva2_implies_sva1)
        """
        result1 = self.check_implication(sva1, sva2)
        result2 = self.check_implication(sva2, sva1)
        
        return (
            result1.result == ImplicationResult.IMPLIES,
            result2.result == ImplicationResult.IMPLIES,
        )

```

`implication_checker/cli.py`:

```py
"""
CLI for SVA Implication Checker.
"""

import click
import json
from rich.console import Console
from rich.panel import Panel
from rich.markup import escape

from sva_toolkit.implication_checker.checker import (
    SVAImplicationChecker,
    ImplicationResult,
)

console = Console()


@click.group()
@click.option('--sby-path', default=None, help='Path to sby binary')
@click.option('--depth', default=20, help='Proof depth for bounded model checking')
@click.option('--work-dir', default=None, help='Working directory for verification files')
@click.option('--keep-files', is_flag=True, help='Keep generated files after verification')
@click.pass_context
def main(ctx, sby_path, depth, work_dir, keep_files):
    """SVA Implication Checker - Verify implication relationships between SVA pairs."""
    ctx.ensure_object(dict)
    ctx.obj['checker'] = SVAImplicationChecker(
        sby_path=sby_path,
        depth=depth,
        work_dir=work_dir,
        keep_files=keep_files,
    )


@main.command()
@click.option('--antecedent', '-a', required=True, help='Antecedent SVA code')
@click.option('--consequent', '-c', required=True, help='Consequent SVA code')
@click.option('--json-output', '-j', is_flag=True, help='Output as JSON')
@click.option('--verbose', '-v', is_flag=True, help='Show detailed log')
@click.pass_context
def check(ctx, antecedent, consequent, json_output, verbose):
    """Check if antecedent implies consequent."""
    checker = ctx.obj['checker']
    
    try:
        result = checker.check_implication(antecedent, consequent)
        
        if json_output:
            output = {
                "result": result.result.value,
                "implies": result.result == ImplicationResult.IMPLIES,
                "message": result.message,
            }
            if result.counterexample:
                output["counterexample"] = result.counterexample
            console.print(json.dumps(output, indent=2), markup=False)
        else:
            _display_result(result, "Implication Check", verbose)
            
            # Return exit code based on result
            if result.result == ImplicationResult.IMPLIES:
                console.print("[green]✓ Result: TRUE (antecedent implies consequent)[/green]")
            else:
                console.print("[red]✗ Result: FALSE (antecedent does not imply consequent)[/red]")
                
    except Exception as e:
        console.print(f"[red]Error during verification:[/red] {escape(str(e))}")
        raise click.Abort()


@main.command()
@click.option('--sva1', required=True, help='First SVA code')
@click.option('--sva2', required=True, help='Second SVA code')
@click.option('--json-output', '-j', is_flag=True, help='Output as JSON')
@click.option('--verbose', '-v', is_flag=True, help='Show detailed log')
@click.pass_context
def equivalent(ctx, sva1, sva2, json_output, verbose):
    """Check if two SVAs are equivalent (bidirectional implication)."""
    checker = ctx.obj['checker']
    
    try:
        result = checker.check_equivalence(sva1, sva2)
        
        if json_output:
            output = {
                "result": result.result.value,
                "equivalent": result.result == ImplicationResult.EQUIVALENT,
                "message": result.message,
            }
            if result.counterexample:
                output["counterexample"] = result.counterexample
            console.print(json.dumps(output, indent=2), markup=False)
        else:
            _display_result(result, "Equivalence Check", verbose)
            
            if result.result == ImplicationResult.EQUIVALENT:
                console.print("[green]✓ Result: TRUE (SVAs are equivalent)[/green]")
            else:
                console.print("[red]✗ Result: FALSE (SVAs are not equivalent)[/red]")
                
    except Exception as e:
        console.print(f"[red]Error during verification:[/red] {escape(str(e))}")
        raise click.Abort()


@main.command()
@click.option('--sva1', required=True, help='First SVA code')
@click.option('--sva2', required=True, help='Second SVA code')
@click.option('--json-output', '-j', is_flag=True, help='Output as JSON')
@click.pass_context
def relationship(ctx, sva1, sva2, json_output):
    """Determine the full implication relationship between two SVAs."""
    checker = ctx.obj['checker']
    
    try:
        sva1_implies_sva2, sva2_implies_sva1 = checker.get_implication_relationship(sva1, sva2)
        
        if json_output:
            output = {
                "sva1_implies_sva2": sva1_implies_sva2,
                "sva2_implies_sva1": sva2_implies_sva1,
                "equivalent": sva1_implies_sva2 and sva2_implies_sva1,
                "no_relationship": not sva1_implies_sva2 and not sva2_implies_sva1,
            }
            console.print(json.dumps(output, indent=2), markup=False)
        else:
            console.print("\n[bold]Implication Relationship Analysis[/bold]\n")
            
            console.print(f"SVA1 → SVA2: {'[green]✓ Yes[/green]' if sva1_implies_sva2 else '[red]✗ No[/red]'}")
            console.print(f"SVA2 → SVA1: {'[green]✓ Yes[/green]' if sva2_implies_sva1 else '[red]✗ No[/red]'}")
            
            console.print("\n[bold]Conclusion:[/bold]")
            if sva1_implies_sva2 and sva2_implies_sva1:
                console.print("[green]SVAs are EQUIVALENT (bidirectional implication)[/green]")
            elif sva1_implies_sva2:
                console.print("[yellow]SVA1 is STRONGER than SVA2 (SVA1 implies SVA2)[/yellow]")
            elif sva2_implies_sva1:
                console.print("[yellow]SVA2 is STRONGER than SVA1 (SVA2 implies SVA1)[/yellow]")
            else:
                console.print("[red]NO IMPLICATION RELATIONSHIP exists[/red]")
                
    except Exception as e:
        console.print(f"[red]Error during verification:[/red] {escape(str(e))}")
        raise click.Abort()


def _display_result(result, title, verbose):
    """Display a CheckResult in a formatted way."""
    color = "green" if result.result in [ImplicationResult.IMPLIES, ImplicationResult.EQUIVALENT] else "red"
    
    console.print(Panel(
        f"[bold]{escape(result.message)}[/bold]",
        title=title,
        border_style=color,
    ))
    
    if result.counterexample and verbose:
        console.print("\n[yellow]Counterexample:[/yellow]")
        console.print(escape(result.counterexample))
    
    if result.log and verbose:
        console.print("\n[dim]Verification Log:[/dim]")
        console.print(escape(result.log[:2000]))  # Limit log output


if __name__ == '__main__':
    main()

```