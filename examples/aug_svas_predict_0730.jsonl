{"id": "119_10_0884", "name": "pvt_compensation_adapt_time_non_zero", "sva": "@(posedge clk_signal)     $changed(process_mon) |-> ($past(adapt_time) > 0)", "ori_sva": "property pvt_compensation_adapt_time_non_zero;\n@(posedge clk_signal)     $changed(process_mon) |-> ($past(adapt_time) > 0);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Process_Mon_Change_Adapt_Time  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(process_mon)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(adapt_time) > 0)`  \n\n**Explanation**:  \nThis assertion checks that whenever there is a change in the `process_mon` signal (detected by `$changed`), then in the same clock cycle, the past value of `adapt_time` (from the previous clock cycle) must be greater than 0. The check occurs at every rising edge of `clk_signal` and has no disable condition.", "sva_signals": ["clk_signal", "[0:0] process_mon", "[0:0] adapt_time"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $changed(process_mon) |-> ($past(adapt_time) > 0)", "sva_name": "p_process_mon_change_check", "full_property": "property p_Process_Mon_Change_Adapt_Time;\n@(posedge clk_signal)    $changed(process_mon) |-> ($past(adapt_time) > 0)\nendproperty\nassert_p_Process_Mon_Change_Adapt_Time:assert property (p_Process_Mon_Change_Adapt_Time) else $error(\"\");", "task_id": "1_56", "predict_sva": "@(posedge clk_signal)     $changed(process_mon) |-> $past(adapt_time) > 0"}
{"id": "155_10_1180", "name": "structural_hazard", "sva": "@(posedge clk)     mem_access && div_operation |-> ##1 resource_conflict", "ori_sva": "property structural_hazard;\n@(posedge clk)     mem_access && div_operation |-> ##1 resource_conflict;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_mem_access_div_operation_conflict  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_access && div_operation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 resource_conflict`  \n\nExplanation:  \nThis assertion checks that whenever both `mem_access` and `div_operation` are true at a positive clock edge, then in the next clock cycle (`##1`), the `resource_conflict` signal must be true. The assertion does not have any disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] mem_access", "[0:0] div_operation", "[0:0] resource_conflict"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        (mem_access && div_operation) |-> ##1 resource_conflict", "sva_name": "p_mem_access_div_operation_conflict", "full_property": "property p_mem_access_div_operation_conflict;\n@(posedge clk)        (mem_access && div_operation) |-> ##1 resource_conflict\nendproperty\nassert_p_mem_access_div_operation_conflict:assert property (p_mem_access_div_operation_conflict) else $error(\"\");", "task_id": "1_183", "predict_sva": "@(posedge clk)         (mem_access && div_operation) |-> ##1 resource_conflict"}
{"id": "160_3_1237", "name": "full_condition", "sva": "@(posedge clk)     disable iff(async_rst)     (wptr == rptr - 1) |-> fifo_full", "ori_sva": "property full_condition;\n@(posedge clk)     disable iff(async_rst)     (wptr == rptr - 1) |-> fifo_full;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Full_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (async_rst)  \n**Antecedent (LHS of Implication)**: `(wptr == rptr - 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fifo_full`  \n\n### Explanation:  \nThe assertion checks that whenever the write pointer (`wptr`) is one less than the read pointer (`rptr`), the FIFO should be full (`fifo_full`). The check is performed on every rising edge of the clock (`clk`) and is disabled if an asynchronous reset (`async_rst`) is active. The implication (`|->`) ensures that the consequent (`fifo_full`) must hold true whenever the antecedent (`wptr == rptr - 1`) is true.", "sva_signals": ["clk", "async_rst", "[0:0] fifo_full", "[0:0] wptr", "[0:0] rptr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (async_rst)        (wptr == (rptr - 1)) |-> fifo_full", "sva_name": "p_fifo_full_check", "full_property": "property p_Fifo_Full_Check;\n@(posedge clk) disable iff (async_rst)        (wptr == (rptr - 1)) |-> fifo_full\nendproperty\nassert_p_Fifo_Full_Check:assert property (p_Fifo_Full_Check) else $error(\"\");", "task_id": "1_237", "predict_sva": "@(posedge clk) disable iff (async_rst)        (wptr == rptr - 1) |-> fifo_full"}
{"id": "164_4_1287", "name": "secure_access_control", "sva": "@(posedge clk) disable iff(security_override)     (auth_grant && priv_access) |-> ##1 data_access", "ori_sva": "property secure_access_control;\n@(posedge clk) disable iff(security_override)     (auth_grant && priv_access) |-> ##1 data_access;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_auth_priv_data_access  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`security_override`)  \n**Antecedent (LHS of Implication)**: `auth_grant && priv_access`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 data_access`  \n\n### Explanation:  \n1. **Property Name**: The assertion is unnamed in the given SVA, so a descriptive name (`p_auth_priv_data_access`) is assigned to reflect its purpose.  \n2. **Trigger Condition**: The property is evaluated at every positive edge of the clock signal `clk`.  \n3. **Disable Condition**: The property is disabled (ignored) if `security_override` is active (asserted).  \n4. **Antecedent**: The condition `auth_grant && priv_access` must hold true for the implication to proceed.  \n5. **Implication**: The operator `|->` ensures that if the antecedent is true, the consequent must hold in the next clock cycle (`##1`).  \n6. **Consequent**: One clock cycle after the antecedent is met, `data_access` must be asserted (true).  \n\nThis property ensures that whenever both `auth_grant` and `priv_access` are high, `data_access` must be granted in the subsequent clock cycle, unless overridden by `security_override`.", "sva_signals": ["clk", "rst_n", "[0:0] security_override", "[0:0] auth_grant", "[0:0] priv_access", "[0:0] data_access"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (security_override)        (auth_grant && priv_access) |-> ##1 data_access", "sva_name": "p_auth_grant_priv_access", "full_property": "property p_auth_priv_data_access;\n@(posedge clk) disable iff (security_override)        (auth_grant && priv_access) |-> ##1 data_access\nendproperty\nassert_p_auth_priv_data_access:assert property (p_auth_priv_data_access) else $error(\"\");", "task_id": "1_263", "predict_sva": "@(posedge clk) disable iff (security_override)         (auth_grant && priv_access) |-> ##1 data_access"}
{"id": "12_2_0092", "name": "state_unknown_check", "sva": "@(posedge clk) $isunknown(state) |-> (err_flag == 1'b1)", "ori_sva": "property state_unknown_check;\n\n    @(posedge clk) $isunknown(state) |-> (err_flag == 1'b1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Err_Flag_On_Unknown_State  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$isunknown(state)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `err_flag == 1'b1`  \n\n**Explanation**:  \nThis property checks that whenever the `state` signal contains unknown values (X or Z) at a rising clock edge, the `err_flag` must be asserted (equal to 1) in the same cycle. The assertion triggers on every clock edge and has no reset/disabling condition. The implication ensures that the error flag is raised synchronously when an unknown state is detected.", "sva_signals": ["clk", "rst_n", "[2:0] state", "[0:0] err_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $isunknown(state) |-> err_flag == 1'b1", "sva_name": "p_Unknown_State_Err_Flag", "full_property": "property p_Err_Flag_On_Unknown_State;\n@(posedge clk)    $isunknown(state) |-> err_flag == 1'b1\nendproperty\nassert_p_Err_Flag_On_Unknown_State:assert property (p_Err_Flag_On_Unknown_State) else $error(\"\");", "task_id": "1_84", "predict_sva": "@(posedge clk)        $isunknown(state) |-> err_flag == 1'b1"}
{"id": "230_9_1931", "name": "scrub_interval_non_zero", "sva": "@(posedge clk)     scrub_en |-> scrub_interval > 0", "ori_sva": "property scrub_interval_non_zero;\n@(posedge clk)     scrub_en |-> scrub_interval > 0;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_scrub_en_interval_check  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `scrub_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `scrub_interval > 0`  \n\n(Note: The property checks that whenever scrub_en is active (1), the scrub_interval must be greater than 0 at the same clock edge)", "sva_signals": ["clk", "rst_n", "[0:0] scrub_en", "[0:0] scrub_interval"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        scrub_en == 1'b1 |-> scrub_interval > 0", "sva_name": "p_scrub_interval_positive", "full_property": "property p_scrub_en_interval_check;\n@(posedge clk)        scrub_en == 1'b1 |-> scrub_interval > 0\nendproperty\nassert_p_scrub_en_interval_check:assert property (p_scrub_en_interval_check) else $error(\"\");", "task_id": "1_757", "predict_sva": "@(posedge clk)         scrub_en == 1'b1 |-> scrub_interval > 0"}
{"id": "201_10_1640", "name": "afifo_underflow_protect", "sva": "@(posedge rd_clk)     empty |-> !rd_en", "ori_sva": "property afifo_underflow_protect;\n@(posedge rd_clk)     empty |-> !rd_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Empty_NoRead  \n**Trigger Condition**: At every rising edge of the `rd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `empty`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!rd_en`  \n\n**Explanation**:  \nThe property asserts that whenever the FIFO (or buffer) is empty (`empty` is true) at a rising clock edge of `rd_clk`, the read enable signal (`rd_en`) must remain deasserted (logic low) in the same cycle. This ensures no read operation is attempted when the FIFO is empty.", "sva_signals": ["rd_clk", "[0:0] empty", "[0:0] rd_en"], "clock": "rd_clk", "attempts_left": 10, "sva_result": "@(posedge rd_clk)        empty |-> !rd_en", "sva_name": "p_FifoEmpty_NoReadEn", "full_property": "property p_Empty_NoRead;\n@(posedge rd_clk)        empty |-> !rd_en\nendproperty\nassert_p_Empty_NoRead:assert property (p_Empty_NoRead) else $error(\"\");", "task_id": "1_539", "predict_sva": "@(posedge rd_clk)        empty |-> !rd_en"}
{"id": "56_3_0405", "name": "p_se0_cycles_count", "sva": "@(posedge usb_clk)     $fell(dp) && $fell(dn) |-> se0_cycles == $past(se0_cycles) + 1", "ori_sva": "property p_se0_cycles_count;\n@(posedge usb_clk)\n    $fell(dp) && $fell(dn) |-> se0_cycles == $past(se0_cycles) + 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_SE0_Cycles_Increment  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(dp) && $fell(dn)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `se0_cycles == $past(se0_cycles) + 1`  \n\n### Explanation:  \n- The property checks that whenever both `dp` and `dn` signals fall (indicating a USB SE0 condition), the `se0_cycles` counter increments by 1 on the next clock cycle.  \n- The antecedent detects the falling edges of `dp` and `dn`.  \n- The consequent verifies that `se0_cycles` equals its previous value (`$past(se0_cycles)`) plus 1.  \n- The assertion is evaluated at every rising edge of `usb_clk` and has no disable condition.", "sva_signals": ["usb_clk", "dp", "dn", "se0_cycles"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)        ($fell(dp) && $fell(dn)) |-> (se0_cycles == ($past(se0_cycles) + 1))", "sva_name": "p_se0_detection", "full_property": "property p_SE0_Cycles_Increment;\n@(posedge usb_clk)        ($fell(dp) && $fell(dn)) |-> (se0_cycles == ($past(se0_cycles) + 1))\nendproperty\nassert_p_SE0_Cycles_Increment:assert property (p_SE0_Cycles_Increment) else $error(\"\");", "task_id": "1_1273", "predict_sva": "@(posedge usb_clk)     ($fell(dp) && $fell(dn)) |-> ##1 (se0_cycles == $past(se0_cycles) + 1)"}
{"id": "214_8_1775", "name": "bist_mem_access", "sva": "@(posedge clk_bist)     bist_mem_read |-> ##[1:2] bist_mem_ready", "ori_sva": "property bist_mem_access;\n@(posedge clk_bist)     bist_mem_read |-> ##[1:2] bist_mem_ready;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_bist_mem_read_to_ready  \n**Trigger Condition**: At every posedge of the `clk_bist`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bist_mem_read == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] bist_mem_ready == 1'b1`  \n\n**Explanation**:  \nThis property checks that whenever a memory read operation is initiated (`bist_mem_read` is high), the memory should become ready (`bist_mem_ready` should go high) within 1 to 2 clock cycles of the `clk_bist`. The check is performed at every rising edge of `clk_bist` and has no disable condition.", "sva_signals": ["clk_bist", "bist_mem_read", "bist_mem_ready"], "clock": "clk_bist", "attempts_left": 10, "sva_result": "@(posedge clk_bist)    bist_mem_read == 1'b1 |-> ##[1:2] bist_mem_ready == 1'b1", "sva_name": "p_bist_mem_read_to_ready", "full_property": "property p_bist_mem_read_to_ready;\n@(posedge clk_bist)    bist_mem_read == 1'b1 |-> ##[1:2] bist_mem_ready == 1'b1\nendproperty\nassert_p_bist_mem_read_to_ready:assert property (p_bist_mem_read_to_ready) else $error(\"\");", "task_id": "1_643", "predict_sva": "@(posedge clk_bist)     bist_mem_read == 1'b1 |-> ##[1:2] bist_mem_ready == 1'b1"}
{"id": "10_17_0322", "name": "p17", "sva": "@(negedge clk)     disable iff (!reset_n) $stable(config_reg) |-> !config_update", "ori_sva": "property p17;\n@(negedge clk)     disable iff (!reset_n) $stable(config_reg) |-> !config_update\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_config_reg_stable  \n**Trigger Condition**: At every negedge of the `clk`  \n**Disable Condition**: disable iff (!reset_n)  \n**Antecedent (LHS of Implication)**: $stable(config_reg)  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: !config_update  ", "sva_signals": ["clk", "reset_n", "config_reg", "[0:0] config_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (!reset_n)     $stable(config_reg) |-> !config_update", "sva_name": "p_Stable_Config_No_Update", "full_property": "property p_config_reg_stable;\n@(negedge clk) disable iff (!reset_n)     $stable(config_reg) |-> !config_update;\nendproperty\nassert_p_config_reg_stable:assert property (p_config_reg_stable) else $error(\"\");", "task_id": "1_1467", "predict_sva": "@(negedge clk) disable iff (!reset_n)     $stable(config_reg) |-> !config_update"}
{"id": "165_10_1302", "name": "interrupt_clear", "sva": "@(posedge apb_clk)     (int_status && int_enable) |-> ##[1:4] int_clear", "ori_sva": "property interrupt_clear;\n@(posedge apb_clk)     (int_status && int_enable) |-> ##[1:4] int_clear;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_int_clear_after_status_enable  \n**Trigger Condition**: At every posedge of the `apb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(int_status && int_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] int_clear`  \n\n### Explanation:  \nThe property checks that whenever both `int_status` and `int_enable` are true at a rising edge of `apb_clk`, the signal `int_clear` must be asserted within 1 to 4 clock cycles thereafter. The assertion does not have a disable condition.", "sva_signals": ["apb_clk", "[0:0] int_status", "[0:0] int_enable", "[0:0] int_clear"], "clock": "apb_clk", "attempts_left": 10, "sva_result": "@(posedge apb_clk)    (int_status && int_enable) |-> ##[1:4] int_clear", "sva_name": "p_int_clear_after_status", "full_property": "property p_int_clear_after_status_enable;\n@(posedge apb_clk)    (int_status && int_enable) |-> ##[1:4] int_clear\nendproperty\nassert_p_int_clear_after_status_enable:assert property (p_int_clear_after_status_enable) else $error(\"\");", "task_id": "1_267", "predict_sva": "@(posedge apb_clk)    (int_status && int_enable) |-> ##[1:4] int_clear"}
{"id": "71_5_0495", "name": "gpio_mask_non_zero", "sva": "@(posedge clk)     interrupt |-> (mask != 0)", "ori_sva": "property gpio_mask_non_zero;\n@(posedge clk)\n    interrupt |-> (mask != 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_interrupt_mask_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `interrupt`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mask != 0)`  \n\n**Explanation**:  \nThe property checks that whenever an `interrupt` occurs (antecedent), the `mask` signal must be non-zero (consequent) at the same clock edge. The assertion is evaluated on every rising edge of `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] interrupt", "[0:0] mask"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        interrupt |-> (mask != 0)", "sva_name": "p_Interrupt_With_NonZero_Mask", "full_property": "property p_interrupt_mask_check;\n@(posedge clk)        interrupt |-> (mask != 0)\nendproperty\nassert_p_interrupt_mask_check:assert property (p_interrupt_mask_check) else $error(\"\");", "task_id": "1_1350", "predict_sva": "@(posedge clk)         interrupt |-> mask != 0"}
{"id": "165_8_1288", "name": "data_integrity", "sva": "@(posedge data_clk)     disable iff (crc_reset)     data_valid |-> crc_match", "ori_sva": "property data_integrity;\n@(posedge data_clk)     disable iff (crc_reset)     data_valid |-> crc_match;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match_on_data_valid  \n**Trigger Condition**: At every rising edge of the `data_clk`  \n**Disable Condition**: `disable iff (crc_reset)`  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crc_match == 1'b1`  \n\n### Explanation:  \n1. The property checks that whenever `data_valid` is high (`1'b1`) at a rising edge of `data_clk`, the signal `crc_match` must also be high (`1'b1`) in the same clock cycle.  \n2. The assertion is disabled if `crc_reset` is active (asynchronous reset condition).  \n3. The implication (`|->`) ensures that the check is performed only when the antecedent (`data_valid`) is true.  \n4. No delay (`##1`) is specified, meaning the consequent (`crc_match`) is checked in the same cycle as the antecedent.", "sva_signals": ["data_clk", "crc_reset", "[0:0] data_valid", "[0:0] crc_match"], "clock": "data_clk", "attempts_left": 10, "sva_result": "@(posedge data_clk) disable iff (crc_reset)        data_valid == 1'b1 |-> crc_match == 1'b1", "sva_name": "p_data_valid_crc_match", "full_property": "property p_crc_match_on_data_valid;\n@(posedge data_clk) disable iff (crc_reset)        data_valid == 1'b1 |-> crc_match == 1'b1\nendproperty\nassert_p_crc_match_on_data_valid:assert property (p_crc_match_on_data_valid) else $error(\"\");", "task_id": "1_275", "predict_sva": "@(posedge data_clk) disable iff (crc_reset)    data_valid == 1'b1 |-> crc_match == 1'b1"}
{"id": "273_2_2334", "name": "p_data_capture_on_tck_rise", "sva": "@(posedge tck_clk)     (tap_state == CAPTURE_DR) |=> (data_reg == $past(input_data))", "ori_sva": "property p_data_capture_on_tck_rise;\n@(posedge tck_clk)     (tap_state == CAPTURE_DR) |=> (data_reg == $past(input_data));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_CAPTURE_DR_Data_Check  \n**Trigger Condition**: At every rising edge of the `tck_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tap_state == CAPTURE_DR`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `data_reg == $past(input_data)`  \n\n### Explanation:  \n1. The property checks that whenever `tap_state` equals `CAPTURE_DR` at a rising edge of `tck_clk`, then **on the next clock cycle** (`|=>`), the value of `data_reg` must match the sampled value of `input_data` from the previous cycle (`$past(input_data)`).  \n2. The implication `|=>` ensures the consequent is evaluated **one clock cycle after** the antecedent is true.  \n3. No reset/disabling condition is specified for this property.", "sva_signals": ["tck_clk", "tap_state", "[0:0] CAPTURE_DR", "data_reg", "input_data"], "clock": "tck_clk", "attempts_left": 10, "sva_result": "@(posedge tck_clk)        tap_state == CAPTURE_DR |=> data_reg == $past(input_data)", "sva_name": "p_CAPTURE_DR_data_reg_assignment", "full_property": "property p_CAPTURE_DR_Data_Check;\n@(posedge tck_clk)        tap_state == CAPTURE_DR |=> data_reg == $past(input_data)\nendproperty\nassert_p_CAPTURE_DR_Data_Check:assert property (p_CAPTURE_DR_Data_Check) else $error(\"\");", "task_id": "1_993", "predict_sva": "@(posedge tck_clk)     tap_state == CAPTURE_DR |-> ##1 data_reg == $past(input_data)"}
{"id": "157_10_1224", "name": "clock_domain_crossing", "sva": "@(posedge fast_clk_signal)     disable iff (test_mode)     $rose(slow_domain_signal) |-> ##[2:4] sync_signal", "ori_sva": "property clock_domain_crossing;\n@(posedge fast_clk_signal)     disable iff (test_mode)     $rose(slow_domain_signal) |-> ##[2:4] sync_signal;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_sync_signal_delay  \n**Trigger Condition**: At every rising edge of the `fast_clk_signal`  \n**Disable Condition**: disable iff (test_mode)  \n**Antecedent (LHS of Implication)**: `$rose(slow_domain_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] sync_signal`  \n\n**Explanation**:  \nThis property checks that whenever there is a rising edge on `slow_domain_signal` (detected at the rising edge of `fast_clk_signal`), then within 2 to 4 clock cycles of `fast_clk_signal`, the `sync_signal` must become active (high). The property is disabled when `test_mode` is active.", "sva_signals": ["fast_clk_signal", "[0:0] test_mode", "[0:0] slow_domain_signal", "[0:0] sync_signal"], "clock": "fast_clk_signal", "attempts_left": 10, "sva_result": "@(posedge fast_clk_signal) disable iff (test_mode)    $rose(slow_domain_signal) |-> ##[2:4] sync_signal", "sva_name": "p_SyncSignal_After_Rose", "full_property": "property p_sync_signal_delay;\n@(posedge fast_clk_signal) disable iff (test_mode)    $rose(slow_domain_signal) |-> ##[2:4] sync_signal\nendproperty\nassert_p_sync_signal_delay:assert property (p_sync_signal_delay) else $error(\"\");", "task_id": "1_204", "predict_sva": "@(posedge fast_clk_signal) disable iff (test_mode)    $rose(slow_domain_signal) |-> ##[2:4] sync_signal"}
{"id": "120_7_0893", "name": "hold_time_violation_check", "sva": "@(posedge phase2_clk)     $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))", "ori_sva": "property hold_time_violation_check;\n@(posedge phase2_clk)     $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Data_Valid_Hold_Time  \n**Trigger Condition**: At every posedge of the `phase2_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(data_valid, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (data_in >= ($past(hold_time) >> 1))`  \n\n**Explanation**:  \nThe property checks that if `data_valid` was high in the previous clock cycle (`$past(data_valid, 1)`), then in the next clock cycle (`##1`), the value of `data_in` must be greater than or equal to half the value of `hold_time` from the previous cycle (`$past(hold_time) >> 1`). The assertion is evaluated at every rising edge of `phase2_clk` and has no disable condition.", "sva_signals": ["phase2_clk", "[0:0] data_valid", "data_in", "hold_time"], "clock": "phase2_clk", "attempts_left": 10, "sva_result": "@(posedge phase2_clk)    $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))", "sva_name": "p_data_valid_to_data_in", "full_property": "property p_Data_Valid_Hold_Time;\n@(posedge phase2_clk)    $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))\nendproperty\nassert_p_Data_Valid_Hold_Time:assert property (p_Data_Valid_Hold_Time) else $error(\"\");", "task_id": "1_71", "predict_sva": "@(posedge phase2_clk)    $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))"}
{"id": "3_22_0099", "name": "p_overlap_22", "sva": "@(posedge clk)     (dram_refresh && !low_power_mode) |-> ##15 refresh_complete", "ori_sva": "property p_overlap_22;\n@(posedge clk)     (dram_refresh && !low_power_mode) |-> ##15 refresh_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Refresh_Completion  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dram_refresh && !low_power_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##15 refresh_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] dram_refresh", "[0:0] low_power_mode", "[0:0] refresh_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (dram_refresh && !low_power_mode) |-> ##15 refresh_complete", "sva_name": "p_Refresh_Completion", "full_property": "property p_Refresh_Completion;\n@(posedge clk)         (dram_refresh && !low_power_mode) |-> ##15 refresh_complete;\nendproperty\nassert_p_Refresh_Completion:assert property (p_Refresh_Completion) else $error(\"\");", "task_id": "1_1558", "predict_sva": "@(posedge clk)         (dram_refresh && !low_power_mode) |-> ##15 refresh_complete"}
{"id": "257_2_2208", "name": "dma_xfer_complete_p2", "sva": "@(posedge dma_clk)     (burst_cnt_eq_preset && !xfer_complete) |-> ##1 xfer_complete", "ori_sva": "property dma_xfer_complete_p2;\n@(posedge dma_clk)     (burst_cnt_eq_preset && !xfer_complete) |-> ##1 xfer_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Xfer_Complete_After_Burst  \n**Trigger Condition**: At every posedge of the `dma_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `burst_cnt_eq_preset && !xfer_complete`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 xfer_complete`  \n\n### Explanation:  \nThe property checks that when the antecedent condition (`burst_cnt_eq_preset && !xfer_complete`) is true at a rising edge of `dma_clk`, the signal `xfer_complete` must be asserted in the next clock cycle (`##1`). This ensures that a transfer completion is triggered immediately after the burst count reaches a preset value (`burst_cnt_eq_preset`) and no prior transfer completion (`!xfer_complete`) is pending.", "sva_signals": ["dma_clk", "burst_cnt_eq_preset", "xfer_complete"], "clock": "dma_clk", "attempts_left": 10, "sva_result": "@(posedge dma_clk)        (burst_cnt_eq_preset && !xfer_complete) |-> ##1 xfer_complete", "sva_name": "p_xfer_complete_after_burst_cnt_eq_preset", "full_property": "property p_Xfer_Complete_After_Burst;\n@(posedge dma_clk)        (burst_cnt_eq_preset && !xfer_complete) |-> ##1 xfer_complete\nendproperty\nassert_p_Xfer_Complete_After_Burst:assert property (p_Xfer_Complete_After_Burst) else $error(\"\");", "task_id": "1_931", "predict_sva": "@(posedge dma_clk)         (burst_cnt_eq_preset && !xfer_complete) |-> ##1 xfer_complete"}
{"id": "167_3_1294", "name": "afifo_empty", "sva": "@(posedge rd_clk)     disable iff(soft_reset)     fifo_empty |-> !rd_en", "ori_sva": "property afifo_empty;\n@(posedge rd_clk)     disable iff(soft_reset)     fifo_empty |-> !rd_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FifoEmpty_NoRdEn  \n**Trigger Condition**: At every rising edge of the `rd_clk`  \n**Disable Condition**: `disable iff (soft_reset)`  \n**Antecedent (LHS of Implication)**: `fifo_empty`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!rd_en`  \n\n### Explanation:  \n- The property checks that when the FIFO is empty (`fifo_empty` is true), the read enable signal (`rd_en`) must remain low (`!rd_en`) in the same clock cycle.  \n- The assertion is evaluated on every rising edge of `rd_clk`.  \n- The property is disabled if `soft_reset` is active (asynchronous reset condition).  \n- The implication (`|->`) ensures that the consequent (`!rd_en`) must hold whenever the antecedent (`fifo_empty`) is true.", "sva_signals": ["rd_clk", "soft_reset", "[0:0] fifo_empty", "[0:0] rd_en"], "clock": "rd_clk", "attempts_left": 10, "sva_result": "@(posedge rd_clk) disable iff (soft_reset)        fifo_empty |-> !rd_en", "sva_name": "p_FifoEmpty_NoRdEn", "full_property": "property p_FifoEmpty_NoRdEn;\n@(posedge rd_clk) disable iff (soft_reset)        fifo_empty |-> !rd_en\nendproperty\nassert_p_FifoEmpty_NoRdEn:assert property (p_FifoEmpty_NoRdEn) else $error(\"\");", "task_id": "1_287", "predict_sva": "@(posedge rd_clk) disable iff (soft_reset)    fifo_empty |-> !rd_en"}
{"id": "10_18_0309", "name": "p18", "sva": "@(posedge clk)     disable iff (reset) $past(valid,3) |-> current_state != ERROR", "ori_sva": "property p18;\n@(posedge clk)     disable iff (reset) $past(valid,3) |-> current_state != ERROR\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_State_Not_Error_After_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (reset)`  \n**Antecedent (LHS of Implication)**: `$past(valid, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `current_state != ERROR`  \n\n(Note: The assertion checks that if `valid` was true 3 clock cycles ago, the `current_state` must not be in the `ERROR` state at the current cycle.)", "sva_signals": ["clk", "reset", "[0:0] valid", "[0:0] current_state", "[0:0] ERROR"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reset)         $past(valid, 3) |-> current_state != ERROR", "sva_name": "p_past_valid_no_error", "full_property": "property p_State_Not_Error_After_Valid;\n@(posedge clk) disable iff (reset)         $past(valid, 3) |-> current_state != ERROR;\nendproperty\nassert_p_State_Not_Error_After_Valid:assert property (p_State_Not_Error_After_Valid) else $error(\"\");", "task_id": "1_1468", "predict_sva": "@(posedge clk) disable iff (reset)     $past(valid, 3) |-> current_state != ERROR"}
{"id": "5_11_0163", "name": "p11", "sva": "@(posedge clk)     (packet_start && crc_ok) |-> ##3 packet_end", "ori_sva": "property p11;\n@(posedge clk)     (packet_start && crc_ok) |-> ##3 packet_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_end_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_start && crc_ok`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 packet_end`  ", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] crc_ok", "[0:0] packet_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (packet_start && crc_ok) |-> ##3 packet_end", "sva_name": "p_Packet_End_After_Start_CRC_OK", "full_property": "property p_packet_end_after_start;\n@(posedge clk)         (packet_start && crc_ok) |-> ##3 packet_end;\nendproperty\nassert_p_packet_end_after_start:assert property (p_packet_end_after_start) else $error(\"\");", "task_id": "1_1622", "predict_sva": "@(posedge clk)         (packet_start && crc_ok) |-> ##3 packet_end"}
{"id": "158_8_1245", "name": "fsm_power_down_sequence", "sva": "@(posedge clk_signal)     disable iff(!init_done)     power_down_req_sig |=> state_sig == STATE_POWER_DOWN [*3] ##1 state_sig == STATE_OFF", "ori_sva": "property fsm_power_down_sequence;\n@(posedge clk_signal)     disable iff(!init_done)     power_down_req_sig |=> state_sig == STATE_POWER_DOWN [*3] ##1 state_sig == STATE_OFF;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_down_sequence  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: `disable iff (!init_done)`  \n**Antecedent (LHS of Implication)**: `power_down_req_sig`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**:  \n- `state_sig == STATE_POWER_DOWN` must hold true for **3 consecutive clock cycles** (`[*3]`), followed by  \n- `state_sig == STATE_OFF` on the **next clock cycle** (`##1`).  \n\n### Explanation:  \n1. The property checks a power-down sequence triggered by `power_down_req_sig`.  \n2. If `power_down_req_sig` is asserted, the system must:  \n   - Enter `STATE_POWER_DOWN` immediately in the **next cycle** (due to `|=>`),  \n   - Remain in `STATE_POWER_DOWN` for **3 cycles**, and then  \n   - Transition to `STATE_OFF` in the **4th cycle**.  \n3. The check is **disabled** if `init_done` is low (`!init_done`).  \n\n### Key Notes:  \n- `|=>` ensures the consequent starts evaluating **one cycle after** the antecedent is true.  \n- `[*3]` specifies a **repetition** of the condition for 3 cycles.  \n- `##1` introduces a **one-cycle delay** after the repetition.", "sva_signals": ["clk_signal", "init_done", "power_down_req_sig", "state_sig", "STATE_POWER_DOWN", "STATE_OFF"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal) disable iff (!init_done)    power_down_req_sig |=> (state_sig == STATE_POWER_DOWN)[*3] ##1 (state_sig == STATE_OFF)", "sva_name": "p_power_down_sequence", "full_property": "property p_power_down_sequence;\n@(posedge clk_signal) disable iff (!init_done)    power_down_req_sig |=> (state_sig == STATE_POWER_DOWN)[*3] ##1 (state_sig == STATE_OFF)\nendproperty\nassert_p_power_down_sequence:assert property (p_power_down_sequence) else $error(\"\");", "task_id": "1_217", "predict_sva": "@(posedge clk_signal) disable iff (!init_done)    power_down_req_sig |-> ##1 (state_sig == STATE_POWER_DOWN)[*3] ##1 (state_sig == STATE_OFF)"}
{"id": "196_6_1624", "name": "power_down_seq", "sva": "@(posedge clk)     pwr_down_req |=> ##2 pwr_down_ack", "ori_sva": "property power_down_seq;\n@(posedge clk)     pwr_down_req |=> ##2 pwr_down_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pwr_down_ack  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwr_down_req`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##2 pwr_down_ack`  \n\n### Explanation:  \n1. The property checks that whenever `pwr_down_req` is true at a rising clock edge (`posedge clk`), then **two clock cycles later** (`##2`), `pwr_down_ack` must be true.  \n2. The `|=>` operator (non-overlapping implication) ensures the consequent is evaluated in the **next cycle** after the antecedent holds. Here, the consequent (`##2 pwr_down_ack`) is delayed by 2 cycles relative to the antecedent.  \n3. No reset/disabling condition is specified (unlike `disable iff` in the examples).  \n\n### Key Notes:  \n- `|=>` vs `|->`:  \n  - `|->` checks the consequent **in the same cycle** if the antecedent holds.  \n  - `|=>` shifts the evaluation to the **next cycle** (equivalent to `|-> ##1`).  \n- `##2` in the consequent means the check occurs **2 cycles after** the antecedent's next cycle (total of 3 cycles from the initial trigger if using `|=>`).", "sva_signals": ["clk", "rst_n", "[0:0] pwr_down_req", "[0:0] pwr_down_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        pwr_down_req |=> ##2 pwr_down_ack", "sva_name": "p_pwr_down_ack_after_req", "full_property": "property p_pwr_down_ack;\n@(posedge clk)        pwr_down_req |=> ##2 pwr_down_ack\nendproperty\nassert_p_pwr_down_ack:assert property (p_pwr_down_ack) else $error(\"\");", "task_id": "1_497", "predict_sva": "@(posedge clk)        pwr_down_req |-> ##3 pwr_down_ack"}
{"id": "167_12_1324", "name": "afifo_sync_stable", "sva": "@(posedge clk)     disable iff(soft_reset)     $stable(rd_ptr_gray) |-> ##[1:3] $stable(wr_ptr_sync)", "ori_sva": "property afifo_sync_stable;\n@(posedge clk)     disable iff(soft_reset)     $stable(rd_ptr_gray) |-> ##[1:3] $stable(wr_ptr_sync);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_RdPtr_to_WrPtr_Sync  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (soft_reset)`  \n**Antecedent (LHS of Implication)**: `$stable(rd_ptr_gray)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $stable(wr_ptr_sync)`  \n\n### Explanation:  \n1. The property checks that if `rd_ptr_gray` remains stable (unchanged) at a clock edge, then within **1 to 3 clock cycles**, `wr_ptr_sync` must also remain stable.  \n2. The assertion is **disabled** if `soft_reset` is active (high).  \n3. The `$stable` function ensures no change in the signal value between consecutive clock cycles.  \n4. The `##[1:3]` delay operator specifies that the consequent must hold true **within 1 to 3 clock cycles** after the antecedent is met.", "sva_signals": ["clk", "[0:0] soft_reset", "[0:0] rd_ptr_gray", "[0:0] wr_ptr_sync"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (soft_reset)    $stable(rd_ptr_gray) |-> ##[1:3] $stable(wr_ptr_sync)", "sva_name": "p_Stable_Ptrs_After_Stable_RdPtr", "full_property": "property p_Stable_RdPtr_to_WrPtr_Sync;\n@(posedge clk) disable iff (soft_reset)    $stable(rd_ptr_gray) |-> ##[1:3] $stable(wr_ptr_sync)\nendproperty\nassert_p_Stable_RdPtr_to_WrPtr_Sync:assert property (p_Stable_RdPtr_to_WrPtr_Sync) else $error(\"\");", "task_id": "1_284", "predict_sva": "@(posedge clk) disable iff (soft_reset)    $stable(rd_ptr_gray) |-> ##[1:3] $stable(wr_ptr_sync)"}
{"id": "203_5_1665", "name": "write_leveling_cal_duration", "sva": "@(posedge dqs_clk)     cal_start |-> ##[8:12] cal_done", "ori_sva": "property write_leveling_cal_duration;\n@(posedge dqs_clk)     cal_start |-> ##[8:12] cal_done;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_cal_start_to_done  \n**Trigger Condition**: At every posedge of the `dqs_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cal_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:12] cal_done == 1'b1`  \n\n**Explanation**:  \nThis property checks that whenever `cal_start` is high at a rising edge of `dqs_clk`, the signal `cal_done` must become high within 8 to 12 clock cycles of `dqs_clk` thereafter. The assertion does not have any disable condition. The `##[8:12]` notation specifies a range of clock cycles (8 to 12) after the antecedent is true for the consequent to be evaluated.", "sva_signals": ["dqs_clk", "[0:0] cal_start", "[0:0] cal_done"], "clock": "dqs_clk", "attempts_left": 10, "sva_result": "@(posedge dqs_clk)        cal_start == 1'b1 |-> ##[8:12] cal_done == 1'b1", "sva_name": "p_cal_start_to_done", "full_property": "property p_cal_start_to_done;\n@(posedge dqs_clk)        cal_start == 1'b1 |-> ##[8:12] cal_done == 1'b1\nendproperty\nassert_p_cal_start_to_done:assert property (p_cal_start_to_done) else $error(\"\");", "task_id": "1_557", "predict_sva": "@(posedge dqs_clk)    cal_start == 1'b1 |-> ##[8:12] cal_done"}
{"id": "1_17_0061", "name": "p17", "sva": "@(posedge clk)     (parity_error && !error_mask) |-> ##1 system_halt", "ori_sva": "property p17;\n@(posedge clk)     (parity_error && !error_mask) |-> ##1 system_halt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Error_Halt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `parity_error && !error_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 system_halt`  \n\n(Note: The assertion checks that if a parity error (`parity_error`) occurs while the error is not masked (`!error_mask`), the system must halt (`system_halt`) in the next clock cycle.)", "sva_signals": ["clk", "rst_n", "[0:0] parity_error", "[0:0] error_mask", "[0:0] system_halt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (parity_error && !error_mask) |-> ##1 system_halt", "sva_name": "p_Parity_Error_Halt", "full_property": "property p_Parity_Error_Halt;\n@(posedge clk)         (parity_error && !error_mask) |-> ##1 system_halt;\nendproperty\nassert_p_Parity_Error_Halt:assert property (p_Parity_Error_Halt) else $error(\"\");", "task_id": "1_1492", "predict_sva": "@(posedge clk)         (parity_error && !error_mask) |-> ##1 system_halt"}
{"id": "1_11_0002", "name": "p11", "sva": "@(posedge clk)     (fifo_empty && read_request) |-> ##2 underflow_error", "ori_sva": "property p11;\n@(posedge clk)     (fifo_empty && read_request) |-> ##2 underflow_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Underflow_Error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_empty && read_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 underflow_error`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] read_request", "[0:0] underflow_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_empty && read_request) |-> ##2 underflow_error", "sva_name": "p_FifoUnderflowError", "full_property": "property p_Fifo_Underflow_Error;\n@(posedge clk)         (fifo_empty && read_request) |-> ##2 underflow_error;\nendproperty\nassert_p_Fifo_Underflow_Error:assert property (p_Fifo_Underflow_Error) else $error(\"\");", "task_id": "1_1486", "predict_sva": "@(posedge clk)         (fifo_empty && read_request) |-> ##2 underflow_error"}
{"id": "5_17_0180", "name": "p17", "sva": "@(posedge clk)     (security_violation && !debug_mode) |-> ##1 system_lock", "ori_sva": "property p17;\n@(posedge clk)     (security_violation && !debug_mode) |-> ##1 system_lock\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_security_violation_lock  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `security_violation && !debug_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 system_lock`  ", "sva_signals": ["clk", "rst_n", "[0:0] security_violation", "[0:0] debug_mode", "[0:0] system_lock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (security_violation && !debug_mode) |-> ##1 system_lock", "sva_name": "p_Security_Violation_Lock", "full_property": "property p_security_violation_lock;\n@(posedge clk)         (security_violation && !debug_mode) |-> ##1 system_lock;\nendproperty\nassert_p_security_violation_lock:assert property (p_security_violation_lock) else $error(\"\");", "task_id": "1_1628", "predict_sva": "@(posedge clk)         (security_violation && !debug_mode) |-> ##1 system_lock"}
{"id": "5_18_0167", "name": "p18", "sva": "@(posedge clk)     (burst_mode && address_valid) |-> ##[1:4] burst_complete", "ori_sva": "property p18;\n@(posedge clk)     (burst_mode && address_valid) |-> ##[1:4] burst_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Burst_Complete_After_Valid_Address  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `burst_mode && address_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] burst_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] burst_mode", "[0:0] address_valid", "[0:0] burst_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (burst_mode && address_valid) |-> ##[1:4] burst_complete", "sva_name": "p_burst_complete_after_valid", "full_property": "property p_Burst_Complete_After_Valid_Address;\n@(posedge clk)     (burst_mode && address_valid) |-> ##[1:4] burst_complete;\nendproperty\nassert_p_Burst_Complete_After_Valid_Address:assert property (p_Burst_Complete_After_Valid_Address) else $error(\"\");", "task_id": "1_1629", "predict_sva": "@(posedge clk)         (burst_mode && address_valid) |-> ##[1:4] burst_complete"}
{"id": "244_10_2117", "name": "fifo_underflow", "sva": "@(posedge fifo_clk)     $rose(fifo_rd_en) && fifo_empty |-> $rose(underflow_error)", "ori_sva": "property fifo_underflow;\n@(posedge fifo_clk)     $rose(fifo_rd_en) && fifo_empty |-> $rose(underflow_error);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FifoUnderflowError  \n**Trigger Condition**: At every posedge of the `fifo_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(fifo_rd_en) && fifo_empty`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$rose(underflow_error)`  \n\n### Explanation:  \n- The property checks for an underflow error when a read operation is attempted on an empty FIFO.  \n- **Trigger**: Evaluated at every rising edge of `fifo_clk`.  \n- **Antecedent**: The condition `$rose(fifo_rd_en) && fifo_empty` is true when `fifo_rd_en` transitions from low to high (indicating a read request) and the FIFO is empty (`fifo_empty == 1`).  \n- **Consequent**: The property asserts that `underflow_error` must transition from low to high (`$rose`) in the same clock cycle as the antecedent.  \n- **Purpose**: Ensures the system flags an underflow error immediately when an invalid read (on empty FIFO) is detected.  \n\n(Note: No disable condition is specified, so the property is always active unless overridden by a global disable.)", "sva_signals": ["fifo_clk", "fifo_rd_en", "fifo_empty", "underflow_error"], "clock": "fifo_clk", "attempts_left": 10, "sva_result": "@(posedge fifo_clk)        ($rose(fifo_rd_en) && fifo_empty) |-> $rose(underflow_error)", "sva_name": "p_underflow_error_flagged", "full_property": "property p_FifoUnderflowError;\n@(posedge fifo_clk)        ($rose(fifo_rd_en) && fifo_empty) |-> $rose(underflow_error)\nendproperty\nassert_p_FifoUnderflowError:assert property (p_FifoUnderflowError) else $error(\"\");", "task_id": "1_839", "predict_sva": "@(posedge fifo_clk)        ($rose(fifo_rd_en) && fifo_empty) |-> $rose(underflow_error)"}
{"id": "281_2_2373", "name": "p_header_sequence_valid", "sva": "@(posedge hdmi_clk)     data_island_period |-> ##1 header_byte_1 == 8'h84 && header_byte_2 == 8'h01", "ori_sva": "property p_header_sequence_valid;\n@(posedge hdmi_clk)     data_island_period |-> ##1 header_byte_1 == 8'h84 && header_byte_2 == 8'h01;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Data_Island_Period_Header  \n**Trigger Condition**: At every rising edge of the `hdmi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_island_period`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 header_byte_1 == 8'h84 && header_byte_2 == 8'h01`  \n\n### Explanation:  \nThe property checks that when `data_island_period` is active (antecedent), then on the next clock cycle (##1), the values of `header_byte_1` and `header_byte_2` must be `8'h84` and `8'h01`, respectively. The assertion triggers on every rising edge of `hdmi_clk` and has no disable condition.", "sva_signals": ["hdmi_clk", "[7:0] header_byte_1", "[7:0] header_byte_2", "[0:0] data_island_period"], "clock": "hdmi_clk", "attempts_left": 10, "sva_result": "@(posedge hdmi_clk)    data_island_period |-> ##1 (header_byte_1 == 8'h84 && header_byte_2 == 8'h01)", "sva_name": "p_data_island_header", "full_property": "property p_Data_Island_Period_Header;\n@(posedge hdmi_clk)    data_island_period |-> ##1 (header_byte_1 == 8'h84 && header_byte_2 == 8'h01)\nendproperty\nassert_p_Data_Island_Period_Header:assert property (p_Data_Island_Period_Header) else $error(\"\");", "task_id": "1_1028", "predict_sva": "@(posedge hdmi_clk)     data_island_period == 1'b1 |-> ##1 (header_byte_1 == 8'h84 && header_byte_2 == 8'h01)"}
{"id": "6_18_0221", "name": "p_fell_clock_gate", "sva": "@(posedge clk)     $fell(clock_gate) |-> ##1 clock_running", "ori_sva": "property p_fell_clock_gate;\n@(posedge clk)     $fell(clock_gate) |-> ##1 clock_running\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_clock_gate_fell  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clock_gate)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 clock_running`", "sva_signals": ["clk", "rst_n", "[0:0] clock_gate", "[0:0] clock_running"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(clock_gate) |-> ##1 clock_running", "sva_name": "p_ClockGate_Fell_To_Running", "full_property": "property p_clock_gate_fell;\n@(posedge clk)     $fell(clock_gate) |-> ##1 clock_running;\nendproperty\nassert_p_clock_gate_fell:assert property (p_clock_gate_fell) else $error(\"\");", "task_id": "1_1657", "predict_sva": "@(posedge clk)     $fell(clock_gate) |-> ##1 clock_running"}
{"id": "1_9_0004", "name": "p9", "sva": "@(posedge clk)     (mode_switch && !calibration_active) |-> ##2 new_mode_active", "ori_sva": "property p9;\n@(posedge clk)     (mode_switch && !calibration_active) |-> ##2 new_mode_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mode_switch_activation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mode_switch && !calibration_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 new_mode_active`  ", "sva_signals": ["clk", "rst_n", "[0:0] mode_switch", "[0:0] calibration_active", "[0:0] new_mode_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (mode_switch && !calibration_active) |-> ##2 new_mode_active", "sva_name": "p_Mode_Switch_Activation", "full_property": "property p_mode_switch_activation;\n@(posedge clk)         (mode_switch && !calibration_active) |-> ##2 new_mode_active;\nendproperty\nassert_p_mode_switch_activation:assert property (p_mode_switch_activation) else $error(\"\");", "task_id": "1_1514", "predict_sva": "@(posedge clk)         (mode_switch && !calibration_active) |-> ##2 new_mode_active"}
{"id": "262_5_2254", "name": "gated_clock_no_oscillation_after_disable", "sva": "@(posedge clk_signal)     disable iff (!enable_signal)     $changed(gated_clk) |-> enable_signal", "ori_sva": "property gated_clock_no_oscillation_after_disable;\n@(posedge clk_signal)     disable iff (!enable_signal)     $changed(gated_clk) |-> enable_signal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gated_clk_enable_check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: disable iff (!enable_signal)  \n**Antecedent (LHS of Implication)**: $changed(gated_clk)  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: enable_signal  \n\n### Explanation:  \n1. **Property Name**: The assertion is named `p_gated_clk_enable_check` for clarity.  \n2. **Trigger Condition**: The property is evaluated at every positive edge of `clk_signal`.  \n3. **Disable Condition**: The property is disabled (ignored) if `enable_signal` is low (`!enable_signal`).  \n4. **Antecedent**: The condition `$changed(gated_clk)` checks if the value of `gated_clk` has changed from its previous value.  \n5. **Implication**: The operator `|->` ensures that if the antecedent is true, the consequent must hold.  \n6. **Consequent**: The property requires `enable_signal` to be true (high) whenever `gated_clk` changes.  \n\nThis assertion ensures that `enable_signal` is always active (high) when `gated_clk` transitions, preventing unintended behavior during clock gating.", "sva_signals": ["clk_signal", "enable_signal", "[0:0] gated_clk"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal) disable iff (!enable_signal)    $changed(gated_clk) |-> enable_signal", "sva_name": "p_gated_clk_change", "full_property": "property p_gated_clk_enable_check;\n@(posedge clk_signal) disable iff (!enable_signal)    $changed(gated_clk) |-> enable_signal\nendproperty\nassert_p_gated_clk_enable_check:assert property (p_gated_clk_enable_check) else $error(\"\");", "task_id": "1_959", "predict_sva": "@(posedge clk_signal) disable iff (!enable_signal)    $changed(gated_clk) |-> enable_signal"}
{"id": "2_23_0018", "name": "p_debug_mode_entered", "sva": "@(posedge clk)     debug_request |-> ##[3:7] debug_mode_active", "ori_sva": "property p_debug_mode_entered;\n@(posedge clk)     debug_request |-> ##[3:7] debug_mode_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_debug_request_to_mode_active  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `debug_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] debug_mode_active == 1'b1`  \n\n(Note: The consequent specifies that within 3 to 7 clock cycles after the antecedent is true, `debug_mode_active` must become high.)", "sva_signals": ["clk", "rst_n", "[0:0] debug_request", "[0:0] debug_mode_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         debug_request == 1'b1 |-> ##[3:7] debug_mode_active == 1'b1", "sva_name": "p_debug_mode_activation", "full_property": "property p_debug_request_to_mode_active;\n@(posedge clk)         debug_request == 1'b1 |-> ##[3:7] debug_mode_active == 1'b1;\nendproperty\nassert_p_debug_request_to_mode_active:assert property (p_debug_request_to_mode_active) else $error(\"\");", "task_id": "1_1528", "predict_sva": "@(posedge clk)     debug_request == 1'b1 |-> ##[3:7] debug_mode_active == 1'b1"}
{"id": "90_5_0660", "name": "p_key_size_non_zero", "sva": "@(posedge clk_core)     $changed(mode) |-> $past(key_size) > 0", "ori_sva": "property p_key_size_non_zero;\n@(posedge clk_core)\n    $changed(mode) |-> $past(key_size) > 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Mode_Change_Key_Size_Check  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(key_size) > 0`  \n\n**Explanation**:  \nThis property checks that whenever the `mode` signal changes (detected by `$changed(mode)`), the value of `key_size` from the previous clock cycle (`$past(key_size)`) must be greater than 0. The assertion is evaluated at every rising edge of `clk_core` and has no disable condition.", "sva_signals": ["clk_core", "[0:0] mode", "[0:0] key_size"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)        $changed(mode) |-> $past(key_size) > 0", "sva_name": "p_mode_change_key_size", "full_property": "property p_Mode_Change_Key_Size_Check;\n@(posedge clk_core)        $changed(mode) |-> $past(key_size) > 0\nendproperty\nassert_p_Mode_Change_Key_Size_Check:assert property (p_Mode_Change_Key_Size_Check) else $error(\"\");", "task_id": "1_1435", "predict_sva": "@(posedge clk_core)    $changed(mode) |-> $past(key_size) > 0"}
{"id": "2_16_0055", "name": "p_bus_request_grant", "sva": "@(posedge clk)     bus_request |-> ##[2:8] bus_grant", "ori_sva": "property p_bus_request_grant;\n@(posedge clk)     bus_request |-> ##[2:8] bus_grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_grant_after_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bus_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:8] bus_grant == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] bus_request", "[0:0] bus_grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     bus_request == 1'b1 |-> ##[2:8] bus_grant == 1'b1", "sva_name": "p_bus_grant_after_request", "full_property": "property p_bus_grant_after_request;\n@(posedge clk)     bus_request == 1'b1 |-> ##[2:8] bus_grant == 1'b1;\nendproperty\nassert_p_bus_grant_after_request:assert property (p_bus_grant_after_request) else $error(\"\");", "task_id": "1_1521", "predict_sva": "@(posedge clk)     bus_request == 1'b1 |-> ##[2:8] bus_grant == 1'b1"}
{"id": "8_3_0037", "name": "req_change_implies_grant_change", "sva": "@(posedge clk) $changed(req_in) |-> ##1 $changed(grant_out)", "ori_sva": "property req_change_implies_grant_change;\n\n    @(posedge clk) $changed(req_in) |-> ##1 $changed(grant_out);\n\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Req_Grant_Change  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(req_in)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $changed(grant_out)`  \n\n**Explanation**:  \nThis property checks that whenever there is a change in the `req_in` signal (detected at any rising edge of `clk`), the `grant_out` signal must change in the next clock cycle. The assertion does not have any disable condition. The `$changed` function is used to detect transitions in the signals.", "sva_signals": ["clk", "rst_n", "[0:0] req_in", "[0:0] grant_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $changed(req_in) |-> ##1 $changed(grant_out)", "sva_name": "p_Req_Grant_Change", "full_property": "property p_Req_Grant_Change;\n@(posedge clk)        $changed(req_in) |-> ##1 $changed(grant_out)\nendproperty\nassert_p_Req_Grant_Change:assert property (p_Req_Grant_Change) else $error(\"\");", "task_id": "1_1425", "predict_sva": "@(posedge clk)    $changed(req_in) |-> ##1 $changed(grant_out)"}
{"id": "3_25_0291", "name": "p_voltage_threshold_monitor", "sva": "@(posedge clk)     (voltage > max_voltage) |-> shutdown", "ori_sva": "property p_voltage_threshold_monitor;\n@(posedge clk)     (voltage > max_voltage) |-> shutdown;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Shutdown_On_Overvoltage  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage > max_voltage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `shutdown`  ", "sva_signals": ["clk", "rst_n", "[0:0] shutdown", "[0:0] voltage", "[0:0] max_voltage"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         voltage > max_voltage |-> shutdown", "sva_name": "p_Voltage_Shutdown", "full_property": "property p_Shutdown_On_Overvoltage;\n@(posedge clk)         voltage > max_voltage |-> shutdown;\nendproperty\nassert_p_Shutdown_On_Overvoltage:assert property (p_Shutdown_On_Overvoltage) else $error(\"\");", "task_id": "1_1967", "predict_sva": "@(posedge clk)         voltage > max_voltage |-> shutdown"}
{"id": "5_20_0231", "name": "p20", "sva": "@(posedge clk)     (frame_sync && sample_ready) |-> ##1 data_out_valid", "ori_sva": "property p20;\n@(posedge clk)     (frame_sync && sample_ready) |-> ##1 data_out_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_out_valid_after_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_sync && sample_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 data_out_valid`  \n\n(Note: The property checks that if both `frame_sync` and `sample_ready` are high at a clock edge, then in the next cycle (`##1`), `data_out_valid` must be high.)", "sva_signals": ["clk", "rst_n", "[0:0] frame_sync", "[0:0] sample_ready", "[0:0] data_out_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (frame_sync && sample_ready) |-> ##1 data_out_valid", "sva_name": "p_Frame_Sync_Sample_Ready_Data_Valid", "full_property": "property p_data_out_valid_after_ready;\n@(posedge clk)     (frame_sync && sample_ready) |-> ##1 data_out_valid;\nendproperty\nassert_p_data_out_valid_after_ready:assert property (p_data_out_valid_after_ready) else $error(\"\");", "task_id": "1_1632", "predict_sva": "@(posedge clk)         (frame_sync && sample_ready) |-> ##1 data_out_valid"}
{"id": "24_4_0190", "name": "state_no_zero_transition", "sva": "@(posedge clk) $changed(state) && ($past(state) == 4'b0000) |-> !$onehot(state)", "ori_sva": "property state_no_zero_transition;\n\n    @(posedge clk) $changed(state) && ($past(state) == 4'b0000) |-> !$onehot(state);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_State_Transition_From_Zero  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(state) && ($past(state) == 4'b0000)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$onehot(state)`  \n\n### Explanation:  \n- The property checks that whenever the `state` signal changes (`$changed(state)`) **and** its previous value (`$past(state)`) was `4'b0000`, the new state must **not** be one-hot encoded (`!$onehot(state)`).  \n- This ensures that a transition from the all-zero state does not result in an invalid (one-hot) state encoding.", "sva_signals": ["clk", "rst_n", "[3:0] state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    ($changed(state) && ($past(state) == 4'b0000)) |-> !$onehot(state)", "sva_name": "p_State_Transition_Check", "full_property": "property p_State_Transition_From_Zero;\n@(posedge clk)    ($changed(state) && ($past(state) == 4'b0000)) |-> !$onehot(state)\nendproperty\nassert_p_State_Transition_From_Zero:assert property (p_State_Transition_From_Zero) else $error(\"\");", "task_id": "1_881", "predict_sva": "@(posedge clk)    ($changed(state) && $past(state) == 4'b0000) |-> !$onehot(state)"}
{"id": "6_27_0177", "name": "p_rose_error_flag", "sva": "@(posedge clk)     $rose(error_flag) |-> ##1 error_handler", "ori_sva": "property p_rose_error_flag;\n@(posedge clk)     $rose(error_flag) |-> ##1 error_handler\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Flag_Rise  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(error_flag)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 error_handler`  \n\n(Note: The assertion checks that whenever `error_flag` rises from 0 to 1 (`$rose`), in the next clock cycle (`##1`), `error_handler` must be active.)", "sva_signals": ["clk", "rst_n", "[0:0] error_flag", "[0:0] error_handler"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(error_flag) |-> ##1 error_handler", "sva_name": "p_Error_Handler_After_Flag_Rise", "full_property": "property p_Error_Flag_Rise;\n@(posedge clk)     $rose(error_flag) |-> ##1 error_handler;\nendproperty\nassert_p_Error_Flag_Rise:assert property (p_Error_Flag_Rise) else $error(\"\");", "task_id": "1_1667", "predict_sva": "@(posedge clk)         $rose(error_flag) |-> ##1 error_handler"}
{"id": "14_1_0577", "name": "p_data_ready_to_valid", "sva": "@(posedge clk)     data_ready |-> ##[1:8] data_valid", "ori_sva": "property p_data_ready_to_valid;\n@(posedge clk)     data_ready |-> ##[1:8] data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_valid_after_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] data_valid` (data_valid must be asserted within 1 to 8 clock cycles after data_ready is asserted)", "sva_signals": ["clk", "rst_n", "[0:0] data_ready", "[0:0] data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         data_ready == 1'b1 |-> ##[1:8] data_valid", "sva_name": "p_data_valid_after_ready", "full_property": "property p_data_valid_after_ready;\n@(posedge clk)         data_ready == 1'b1 |-> ##[1:8] data_valid;\nendproperty\nassert_p_data_valid_after_ready:assert property (p_data_valid_after_ready) else $error(\"\");", "task_id": "1_1865", "predict_sva": "@(posedge clk)     data_ready == 1'b1 |-> ##[1:8] data_valid"}
{"id": "3_26_0264", "name": "p_temperature_safety", "sva": "@(negedge clk)     (temp > critical_temp) |-> ##2 power_off", "ori_sva": "property p_temperature_safety;\n@(negedge clk)     (temp > critical_temp) |-> ##2 power_off;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Off_On_Critical_Temp  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp > critical_temp`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 power_off`  \n\n(Note: The assertion checks that if the temperature exceeds the critical temperature (`temp > critical_temp`), then after 2 clock cycles (`##2`), the `power_off` signal must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] temp", "[0:0] critical_temp", "[0:0] power_off"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     temp > critical_temp |-> ##2 power_off", "sva_name": "p_temp_critical_power_off", "full_property": "property p_Power_Off_On_Critical_Temp;\n@(negedge clk)     temp > critical_temp |-> ##2 power_off;\nendproperty\nassert_p_Power_Off_On_Critical_Temp:assert property (p_Power_Off_On_Critical_Temp) else $error(\"\");", "task_id": "1_1970", "predict_sva": "@(negedge clk)     temp > critical_temp |-> ##2 power_off"}
{"id": "8_10_0328", "name": "p_pipeline_stall", "sva": "@(posedge clk)     $past(stall, 2) |-> $past(valid, 3) == $past(valid, 4)", "ori_sva": "property p_pipeline_stall;\n@(posedge clk)     $past(stall, 2) |-> $past(valid, 3) == $past(valid, 4);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Past_Stall_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(stall, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(valid, 3) == $past(valid, 4)`", "sva_signals": ["clk", "rst_n", "[0:0] stall", "[0:0] valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(stall, 2) |-> ($past(valid, 3) == $past(valid, 4))", "sva_name": "p_Stall_Valid_Check", "full_property": "property p_Past_Stall_Valid;\n@(posedge clk)     $past(stall, 2) |-> ($past(valid, 3) == $past(valid, 4));\nendproperty\nassert_p_Past_Stall_Valid:assert property (p_Past_Stall_Valid) else $error(\"\");", "task_id": "1_1706", "predict_sva": "@(posedge clk)     $past(stall, 2) |-> $past(valid, 3) == $past(valid, 4)"}
{"id": "6_17_0329", "name": "p_time_window_17", "sva": "@(posedge clk)     (channel_active && data_available) |-> ##[5:8] (data_transferred || channel_error)", "ori_sva": "property p_time_window_17;\n@(posedge clk)     (channel_active && data_available) |-> ##[5:8] (data_transferred || channel_error);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Channel_Data_Transfer  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `channel_active && data_available`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:8] (data_transferred || channel_error)`  ", "sva_signals": ["clk", "rst_n", "[0:0] channel_active", "[0:0] data_available", "[0:0] data_transferred", "[0:0] channel_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (channel_active && data_available) |-> ##[5:8] (data_transferred || channel_error)", "sva_name": "p_channel_data_transfer", "full_property": "property p_Channel_Data_Transfer;\n@(posedge clk)         (channel_active && data_available) |-> ##[5:8] (data_transferred || channel_error);\nendproperty\nassert_p_Channel_Data_Transfer:assert property (p_Channel_Data_Transfer) else $error(\"\");", "task_id": "1_2055", "predict_sva": "@(posedge clk)         (channel_active && data_available) |-> ##[5:8] (data_transferred || channel_error)"}
{"id": "2_3_0219", "name": "p3", "sva": "@(posedge clk)     start_transfer |=> ##3 end_transfer", "ori_sva": "property p3;\n@(posedge clk)     start_transfer |=> ##3 end_transfer;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Start_Transfer_End_Transfer  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start_transfer == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##3 end_transfer == 1'b1`  \n\n(Note: The `|=>` operator implies that the consequent is checked starting from the **next clock cycle** after the antecedent holds. The `##3` denotes that `end_transfer` must be true **3 clock cycles** after the next cycle.)", "sva_signals": ["clk", "rst_n", "[0:0] start_transfer", "[0:0] end_transfer"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         start_transfer == 1'b1 |=> ##3 end_transfer == 1'b1", "sva_name": "p_Start_Transfer_End_Transfer", "full_property": "property p_Start_Transfer_End_Transfer;\n@(posedge clk)         start_transfer == 1'b1 |=> ##3 end_transfer == 1'b1;\nendproperty\nassert_p_Start_Transfer_End_Transfer:assert property (p_Start_Transfer_End_Transfer) else $error(\"\");", "task_id": "1_1926", "predict_sva": "@(posedge clk)         start_transfer == 1'b1 |-> ##1 ##3 end_transfer == 1'b1"}
{"id": "217_9_1827", "name": "reset_sequence", "sva": "@(posedge clk)     $fell(rst_n) |-> ##1 $fell(system_active) ##[1:5] $rose(rst_n) ##[1:3] $rose(system_active)", "ori_sva": "property reset_sequence;\n@(posedge clk)     $fell(rst_n) |-> ##1 $fell(system_active) ##[1:5] $rose(rst_n) ##[1:3] $rose(system_active);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_reset_sequence  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(rst_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(system_active) ##[1:5] $rose(rst_n) ##[1:3] $rose(system_active)`  \n\n**Explanation of Consequent Sequence**:  \n1. After 1 clock cycle (`##1`), `system_active` must fall (`$fell(system_active)`)  \n2. Then within 1 to 5 clock cycles (`##[1:5]`), `rst_n` must rise (`$rose(rst_n)`)  \n3. Finally, within 1 to 3 clock cycles (`##[1:3]`), `system_active` must rise (`$rose(system_active)`)  \n\nThis property checks that when a reset occurs (falling edge of rst_n), the system follows a specific sequence of events: system deactivation, reset release, and system reactivation within specified timing windows.", "sva_signals": ["clk", "rst_n", "[0:0] system_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $fell(rst_n) |-> ##1 $fell(system_active) ##[1:5] $rose(rst_n) ##[1:3] $rose(system_active)", "sva_name": "p_reset_sequence", "full_property": "property p_reset_sequence;\n@(posedge clk)    $fell(rst_n) |-> ##1 $fell(system_active) ##[1:5] $rose(rst_n) ##[1:3] $rose(system_active)\nendproperty\nassert_p_reset_sequence:assert property (p_reset_sequence) else $error(\"\");", "task_id": "1_661", "predict_sva": "@(posedge clk)    $fell(rst_n) |->     ##1 $fell(system_active) and    ##[1:5] $rose(rst_n) and    ##[1:3] $rose(system_active)"}
{"id": "2_23_0216", "name": "p23", "sva": "@(posedge clk)     (security_violation && !override_en) |-> ##1 system_halt", "ori_sva": "property p23;\n@(posedge clk)     (security_violation && !override_en) |-> ##1 system_halt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Security_Violation_Halt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(security_violation && !override_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 system_halt`  ", "sva_signals": ["clk", "rst_n", "[0:0] security_violation", "[0:0] override_en", "[0:0] system_halt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (security_violation && !override_en) |-> ##1 system_halt", "sva_name": "p_security_violation_halt", "full_property": "property p_Security_Violation_Halt;\n@(posedge clk)         (security_violation && !override_en) |-> ##1 system_halt;\nendproperty\nassert_p_Security_Violation_Halt:assert property (p_Security_Violation_Halt) else $error(\"\");", "task_id": "1_1908", "predict_sva": "@(posedge clk)         (security_violation && !override_en) |-> ##1 system_halt"}
{"id": "6_28_0364", "name": "p_time_window_28", "sva": "@(posedge clk)     (security_check && policy_enforced) |-> ##[3:7] access_granted", "ori_sva": "property p_time_window_28;\n@(posedge clk)     (security_check && policy_enforced) |-> ##[3:7] access_granted;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_access_grant_after_security_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `security_check && policy_enforced`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] access_granted`  ", "sva_signals": ["clk", "rst_n", "[0:0] security_check", "[0:0] policy_enforced", "[0:0] access_granted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (security_check && policy_enforced) |-> ##[3:7] access_granted", "sva_name": "p_Access_Grant_After_Check", "full_property": "property p_access_grant_after_security_check;\n@(posedge clk)         (security_check && policy_enforced) |-> ##[3:7] access_granted;\nendproperty\nassert_p_access_grant_after_security_check:assert property (p_access_grant_after_security_check) else $error(\"\");", "task_id": "1_2067", "predict_sva": "@(posedge clk)         (security_check && policy_enforced) |-> ##[3:7] access_granted"}
{"id": "5_15_0311", "name": "p_fixed_delay_15", "sva": "@(posedge clk)     (adc_start && ref_voltage_stable) |-> ##6 adc_done", "ori_sva": "property p_fixed_delay_15;\n@(posedge clk)     (adc_start && ref_voltage_stable) |-> ##6 adc_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_done_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `adc_start && ref_voltage_stable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 adc_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] adc_start", "[0:0] ref_voltage_stable", "[0:0] adc_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (adc_start && ref_voltage_stable) |-> ##6 adc_done", "sva_name": "p_adc_done_after_start", "full_property": "property p_adc_done_after_start;\n@(posedge clk)         (adc_start && ref_voltage_stable) |-> ##6 adc_done;\nendproperty\nassert_p_adc_done_after_start:assert property (p_adc_done_after_start) else $error(\"\");", "task_id": "1_2024", "predict_sva": "@(posedge clk)         (adc_start && ref_voltage_stable) |-> ##6 adc_done"}
{"id": "4_22_0300", "name": "p_non_overlap_11", "sva": "@(posedge clk)     calibration_start |=> ##10 calibration_done", "ori_sva": "property p_non_overlap_11;\n@(posedge clk)     calibration_start |=> ##10 calibration_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_calibration_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `calibration_start == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##10 calibration_done == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent should be checked 1 clock cycle after the antecedent is true, and then `##10` further delays the check for `calibration_done` by 10 clock cycles from that point.)", "sva_signals": ["clk", "rst_n", "[0:0] calibration_start", "[0:0] calibration_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         calibration_start == 1'b1 |=> ##10 calibration_done == 1'b1", "sva_name": "p_calibration_done_after_start", "full_property": "property p_calibration_sequence;\n@(posedge clk)         calibration_start == 1'b1 |=> ##10 calibration_done == 1'b1;\nendproperty\nassert_p_calibration_sequence:assert property (p_calibration_sequence) else $error(\"\");", "task_id": "1_2002", "predict_sva": "@(posedge clk)     calibration_start == 1'b1 |-> ##1 ##10 calibration_done == 1'b1"}
{"id": "5_6_0302", "name": "p_fixed_delay_6", "sva": "@(posedge clk)     (interrupt_pending && !int_mask) |-> ##2 int_ack", "ori_sva": "property p_fixed_delay_6;\n@(posedge clk)     (interrupt_pending && !int_mask) |-> ##2 int_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Interrupt_Acknowledge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `interrupt_pending && !int_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 int_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_pending", "[0:0] int_mask", "[0:0] int_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (interrupt_pending && !int_mask) |-> ##2 int_ack", "sva_name": "p_Interrupt_Ack", "full_property": "property p_Interrupt_Acknowledge;\n@(posedge clk)         (interrupt_pending && !int_mask) |-> ##2 int_ack;\nendproperty\nassert_p_Interrupt_Acknowledge:assert property (p_Interrupt_Acknowledge) else $error(\"\");", "task_id": "1_2045", "predict_sva": "@(posedge clk)         (interrupt_pending && !int_mask) |-> ##2 int_ack"}
{"id": "5_11_0294", "name": "p_fixed_delay_11", "sva": "@(posedge clk)     (key_pressed && !debounce_active) |-> ##3 key_valid", "ori_sva": "property p_fixed_delay_11;\n@(posedge clk)     (key_pressed && !debounce_active) |-> ##3 key_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Key_Valid_After_Press  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `key_pressed && !debounce_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 key_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] key_pressed", "[0:0] debounce_active", "[0:0] key_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (key_pressed && !debounce_active) |-> ##3 key_valid", "sva_name": "p_Key_Valid_After_Press", "full_property": "property p_Key_Valid_After_Press;\n@(posedge clk)         (key_pressed && !debounce_active) |-> ##3 key_valid;\nendproperty\nassert_p_Key_Valid_After_Press:assert property (p_Key_Valid_After_Press) else $error(\"\");", "task_id": "1_2019", "predict_sva": "@(posedge clk)         (key_pressed && !debounce_active) |-> ##3 key_valid"}
{"id": "2_19_0003", "name": "p_not_delayed_error", "sva": "@(posedge clk)     not (##3 error_flag)", "ori_sva": "property p_not_delayed_error;\n@(posedge clk)     not (##3 error_flag);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_No_Error_Flag_After_3_Cycles  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple property without an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `not (##3 error_flag)` (The property checks that `error_flag` is not asserted 3 clock cycles after the trigger condition)  ", "sva_signals": ["clk", "rst_n", "[0:0] error_flag", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     not (##3 error_flag)", "sva_name": "p_No_Error_After_3_Cycles", "full_property": "property p_No_Error_Flag_After_3_Cycles;\n@(posedge clk)     not (##3 error_flag);\nendproperty\nassert_p_No_Error_Flag_After_3_Cycles:assert property (p_No_Error_Flag_After_3_Cycles) else $error(\"\");", "task_id": "1_1899", "predict_sva": "@(posedge clk)     ##3 !error_flag"}
{"id": "8_17_0397", "name": "p_stable_uart_tx", "sva": "@(posedge clk) uart_tx_en |-> $stable(uart_tx_data)", "ori_sva": "property p_stable_uart_tx;\n@(posedge clk) uart_tx_en |-> $stable(uart_tx_data);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Uart_Tx_Data_Stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `uart_tx_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `uart_tx_data` remains stable (i.e., `$stable(uart_tx_data)` evaluates to true)  ", "sva_signals": ["clk", "rst_n", "[0:0] uart_tx_en", "[7:0] uart_tx_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     uart_tx_en == 1'b1 |-> $stable(uart_tx_data)", "sva_name": "p_UartTxStableData", "full_property": "property p_Uart_Tx_Data_Stable;\n@(posedge clk)     uart_tx_en == 1'b1 |-> $stable(uart_tx_data);\nendproperty\nassert_p_Uart_Tx_Data_Stable:assert property (p_Uart_Tx_Data_Stable) else $error(\"\");", "task_id": "1_2117", "predict_sva": "@(posedge clk)     uart_tx_en == 1'b1 |-> $stable(uart_tx_data)"}
{"id": "7_11_0382", "name": "p_fell_busy_release", "sva": "@(posedge clk) disable iff (!rst_n)     $fell(busy) |-> ##1 !bus_lock", "ori_sva": "property p_fell_busy_release;\n@(posedge clk) disable iff (!rst_n)     $fell(busy) |-> ##1 !bus_lock;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Busy_Fell_No_Bus_Lock  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$fell(busy)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !bus_lock`  ", "sva_signals": ["clk", "rst_n", "[0:0] busy", "[0:0] bus_lock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     $fell(busy) |-> ##1 !bus_lock", "sva_name": "p_Busy_Fell_No_Lock", "full_property": "property p_Busy_Fell_No_Bus_Lock;\n@(posedge clk) disable iff (!rst_n)     $fell(busy) |-> ##1 !bus_lock;\nendproperty\nassert_p_Busy_Fell_No_Bus_Lock:assert property (p_Busy_Fell_No_Bus_Lock) else $error(\"\");", "task_id": "1_2079", "predict_sva": "@(posedge clk) disable iff (!rst_n)     $fell(busy) |-> ##1 !bus_lock"}
{"id": "13_28_0578", "name": "p_repeat_28", "sva": "@(posedge clk)     (phase_lock[*4] intersect ref_clock) |-> pll_locked", "ori_sva": "property p_repeat_28;\n@(posedge clk)     (phase_lock[*4] intersect ref_clock) |-> pll_locked;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_phase_lock_to_pll_locked  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(phase_lock[*4] intersect ref_clock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pll_locked`  ", "sva_signals": ["clk", "rst_n", "[0:0] phase_lock", "[0:0] ref_clock", "[0:0] pll_locked"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (phase_lock[*4] intersect ref_clock) |-> pll_locked", "sva_name": "p_phase_lock_to_pll_locked", "full_property": "property p_phase_lock_to_pll_locked;\n@(posedge clk)     (phase_lock[*4] intersect ref_clock) |-> pll_locked;\nendproperty\nassert_p_phase_lock_to_pll_locked:assert property (p_phase_lock_to_pll_locked) else $error(\"\");", "task_id": "1_1856", "predict_sva": "@(posedge clk)     (phase_lock[*4] intersect ref_clock) |-> pll_locked"}
{"id": "9_26_0436", "name": "p_past_watchdog_refresh", "sva": "@(posedge clk)     wdt_reset |-> $past(wdt_counter, 1) != 0", "ori_sva": "property p_past_watchdog_refresh;\n@(posedge clk)     wdt_reset |-> $past(wdt_counter, 1) != 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Wdt_Reset_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wdt_reset == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(wdt_counter, 1) != 0`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] wdt_reset", "[0:0] wdt_counter"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         wdt_reset == 1'b1 |-> $past(wdt_counter, 1) != 0", "sva_name": "p_Wdt_Reset_Check", "full_property": "property p_Wdt_Reset_Check;\n@(posedge clk)         wdt_reset == 1'b1 |-> $past(wdt_counter, 1) != 0;\nendproperty\nassert_p_Wdt_Reset_Check:assert property (p_Wdt_Reset_Check) else $error(\"\");", "task_id": "1_2149", "predict_sva": "@(posedge clk)     wdt_reset == 1'b1 |-> $past(wdt_counter, 1) != '0"}
{"id": "10_17_0753", "name": "p_onehot0_or_all_zero_17", "sva": "@(posedge clk) $onehot0(counter_modes) |-> ##2 counter_valid;", "sva_description": "### Assertion description:  \n**Property Name**: p_counter_valid_after_modes  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$onehot0(counter_modes)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 counter_valid`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks if `counter_valid` is asserted 2 cycles after `counter_modes` is in a one-hot-zero state.  \n2. **Trigger Condition**: The property is evaluated at every rising edge of `clk`.  \n3. **Antecedent**: `$onehot0(counter_modes)` ensures that at most one bit in `counter_modes` is high (or none).  \n4. **Consequent**: If the antecedent holds, then `counter_valid` must be true 2 clock cycles later (`##2`).  \n5. **Implication**: The property uses a non-overlapping implication (`|->`), meaning the consequent is checked only if the antecedent is true at the same clock edge.  \n\nThis assertion ensures that whenever `counter_modes` is in a valid one-hot-zero state, the `counter_valid` signal is correctly asserted after a fixed delay.", "sva_signals": ["clk", "rst_n", "[0:0] counter_modes", "[0:0] counter_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $onehot0(counter_modes) |-> ##2 counter_valid", "sva_name": "p_counter_valid_after_onehot0", "full_property": "property p_counter_valid_after_modes;\n@(posedge clk)     $onehot0(counter_modes) |-> ##2 counter_valid\nendproperty\nassert_p_counter_valid_after_modes:assert property (p_counter_valid_after_modes) else $error(\"\");", "task_id": "1_2248", "predict_sva": "@(posedge clk)     $onehot0(counter_modes) |-> ##2 counter_valid"}
{"id": "60_7_0461", "name": "p_payload_checksum_relation", "sva": "@(posedge clk_mipi)     (packet_valid && $past(packet_valid)) |-> (checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0])))", "ori_sva": "property p_payload_checksum_relation;\n@(posedge clk_mipi)\n    (packet_valid && $past(packet_valid)) |-> (checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0])));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Checksum_Valid  \n**Trigger Condition**: At every posedge of the `clk_mipi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_valid && $past(packet_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0]))`  \n\n### Explanation:  \n1. The property checks that whenever `packet_valid` is high for two consecutive clock cycles (current and previous cycle), the `checksum` signal must equal the sum of the upper byte (`payload_data >> 8`) and lower byte (`payload_data[7:0]`) of the `payload_data` from **two cycles earlier**.  \n2. The `$past` operator is used to reference values from previous clock cycles:  \n   - `$past(packet_valid)` checks the value of `packet_valid` in the immediately preceding cycle.  \n   - The consequent uses nested `$past` to compute the checksum from `payload_data` values **two cycles back** (due to `$past($past(...))`).  \n3. No reset/disabling condition is specified for this property.", "sva_signals": ["clk_mipi", "packet_valid", "[0:0] checksum", "[15:0] payload_data"], "clock": "clk_mipi", "attempts_left": 10, "sva_result": "@(posedge clk_mipi)    (packet_valid && $past(packet_valid)) |->     checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0]))", "sva_name": "p_checksum_after_valid", "full_property": "property p_Checksum_Valid;\n@(posedge clk_mipi)    (packet_valid && $past(packet_valid)) |->     checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0]))\nendproperty\nassert_p_Checksum_Valid:assert property (p_Checksum_Valid) else $error(\"\");", "task_id": "1_1300", "predict_sva": "@(posedge clk_mipi)    (packet_valid && $past(packet_valid)) |->     checksum == $past(($past(payload_data) >> 8) + $past(payload_data[7:0]))"}
{"id": "10_8_0779", "name": "p_onehot0_or_all_zero_8", "sva": "@(posedge clk) error_condition |=> $onehot0(error_flags);", "sva_description": "### Assertion description:  \n**Property Name**: p_error_flags_onehot0  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_condition`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$onehot0(error_flags)`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks that `error_flags` follows a one-hot-zero encoding (at most one bit set) after `error_condition` is true.  \n2. **Trigger**: Evaluated on every rising edge of `clk`.  \n3. **Implication**: `|=>` (non-overlapping implication) ensures the consequent (`$onehot0(error_flags)`) is checked **one clock cycle after** the antecedent (`error_condition`) holds.  \n4. **Consequent**: `$onehot0(error_flags)` asserts that no more than one bit in `error_flags` is high (or all bits are low).  \n\n### Key Notes:  \n- If `error_condition` is true at a clock edge, `error_flags` must satisfy `$onehot0` at the **next** clock edge.  \n- No reset/disabling condition is specified; the property is always active.", "sva_signals": ["clk", "rst_n", "[0:0] error_condition", "[0:0] error_flags"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         error_condition |=> $onehot0(error_flags)", "sva_name": "p_error_flags_onehot0", "full_property": "property p_error_flags_onehot0;\n@(posedge clk)         error_condition |=> $onehot0(error_flags)\nendproperty\nassert_p_error_flags_onehot0:assert property (p_error_flags_onehot0) else $error(\"\");", "task_id": "1_2326", "predict_sva": "@(posedge clk)         error_condition |=> $onehot0(error_flags)"}
{"id": "8_29_0274", "name": "p_boot_sequence", "sva": "@(posedge clk)     $past(boot_stage, 1) != boot_stage |-> $past(boot_done, 2)", "ori_sva": "property p_boot_sequence;\n@(posedge clk)     $past(boot_stage, 1) != boot_stage |-> $past(boot_done, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Boot_Stage_Change  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(boot_stage, 1) != boot_stage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(boot_done, 2)`  ", "sva_signals": ["clk", "rst_n", "[0:0] boot_stage", "[0:0] boot_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(boot_stage, 1) != boot_stage) |-> $past(boot_done, 2)", "sva_name": "p_Boot_Stage_Change_After_Done", "full_property": "property p_Boot_Stage_Change;\n@(posedge clk)         ($past(boot_stage, 1) != boot_stage) |-> $past(boot_done, 2);\nendproperty\nassert_p_Boot_Stage_Change:assert property (p_Boot_Stage_Change) else $error(\"\");", "task_id": "1_1724", "predict_sva": "@(posedge clk)    ($past(boot_stage, 1) != boot_stage) |-> $past(boot_done, 2)"}
{"id": "10_34_0802", "name": "p_onehot0_or_all_zero_34", "sva": "@(posedge clk) sensor_trigger |=> $onehot0(sensor_select);", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_trigger_onehot0  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_trigger == 1'b1`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$onehot0(sensor_select)`  \n\n### Explanation:  \n- The property checks that **one clock cycle after `sensor_trigger` is asserted**, the `sensor_select` signal must satisfy `$onehot0` (i.e., it must have **zero or exactly one bit set to 1**).  \n- The `|=>` operator ensures the consequent is evaluated **on the next clock cycle** after the antecedent holds.  \n- No reset condition is specified (`disable iff` is absent).  \n\n(Note: `$onehot0` returns true if the signal is all zeros or has exactly one bit high, distinguishing it from `$onehot`, which requires exactly one bit high.)", "sva_signals": ["clk", "rst_n", "[0:0] sensor_trigger", "[0:0] sensor_select"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sensor_trigger == 1'b1 |=> $onehot0(sensor_select)", "sva_name": "p_sensor_trigger_to_onehot0", "full_property": "property p_sensor_trigger_onehot0;\n@(posedge clk)         sensor_trigger == 1'b1 |=> $onehot0(sensor_select)\nendproperty\nassert_p_sensor_trigger_onehot0:assert property (p_sensor_trigger_onehot0) else $error(\"\");", "task_id": "1_2264", "predict_sva": "@(posedge clk)     sensor_trigger == 1'b1 |=> $onehot0(sensor_select)"}
{"id": "10_78_0852", "name": "p_onehot0_or_all_zero_78", "sva": "@(posedge clk) encryption_mode |=> $onehot0(cipher_suites);", "sva_description": "### Assertion description:  \n**Property Name**: p_encryption_mode_cipher_suites  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_mode == 1'b1`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$onehot0(cipher_suites)`  \n\n**Explanation**:  \nThe property checks that in the next clock cycle after `encryption_mode` is asserted (`|=>`), the `cipher_suites` signal must satisfy the `$onehot0` condition (i.e., at most one bit can be set to 1, or none). This ensures the cipher suite selection is valid during encryption mode.", "sva_signals": ["clk", "rst_n", "[0:0] encryption_mode", "[0:0] cipher_suites"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     encryption_mode == 1'b1 |=> $onehot0(cipher_suites)", "sva_name": "p_encryption_mode_cipher_suites", "full_property": "property p_encryption_mode_cipher_suites;\n@(posedge clk)     encryption_mode == 1'b1 |=> $onehot0(cipher_suites)\nendproperty\nassert_p_encryption_mode_cipher_suites:assert property (p_encryption_mode_cipher_suites) else $error(\"\");", "task_id": "1_2312", "predict_sva": "@(posedge clk)     encryption_mode == 1'b1 |=> $onehot0(cipher_suites)"}
{"id": "0_92_0085", "name": "p92", "sva": "@(posedge clk)      (start && (mode == SLOW)) |-> ##[10:15] done && !timeout", "sva_description": "### Assertion description:  \n**Property Name**: p_start_slow_mode_done  \n**Trigger Condition**: At every evaluation point (implicitly triggered by the assertion context)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(start && (mode == SLOW))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:15] done && !timeout`  \n\n**Explanation of Consequent**:  \nThe consequent specifies that within 10 to 15 clock cycles after the antecedent is true, the signal `done` must be asserted (`done == 1`) and the signal `timeout` must remain deasserted (`timeout == 0`). The `##[10:15]` denotes a time range for the occurrence of the condition.", "sva_signals": ["clk", "rst_n", "[0:0] start", "[0:0] mode", "[0:0] done", "[0:0] timeout", "[0:0] SLOW"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (start && (mode == SLOW)) |-> ##[10:15] (done && !timeout)", "sva_name": "p_Start_Mode_Slow_Done_Timeout", "full_property": "property p_start_slow_mode_done;\n@(posedge clk)     (start && (mode == SLOW)) |-> ##[10:15] (done && !timeout)\nendproperty\nassert_p_start_slow_mode_done:assert property (p_start_slow_mode_done) else $error(\"\");", "task_id": "1_2234", "predict_sva": "@(posedge clk)     (start && (mode == SLOW)) |-> ##[10:15] (done && !timeout)"}
{"id": "17_63_1484", "name": "p_multi_clock_63", "sva": "@(posedge clk_x) x_str |-> @(posedge clk_y) y_cmp", "sva_description": "### Assertion description:\n**Property Name**: (Not specified in the given SVA)\n**Trigger Condition**: At every posedge of the `clk_x`\n**Disable Condition**: None\n**Antecedent (LHS of Implication)**: `x_str`\n**Implication Operator**: `|->`\n**Consequent (RHS of Implication)**: At the next posedge of `clk_y`, `y_cmp` must be true\n\nNote: This is a multi-clock assertion where the antecedent is evaluated at the rising edge of `clk_x` and the consequent is evaluated at the subsequent rising edge of `clk_y`. The property checks that whenever `x_str` is true at a `clk_x` rising edge, then at the immediately following `clk_y` rising edge, `y_cmp` must be true.", "sva_signals": ["clk", "rst_n", "[0:0] x_str", "[0:0] y_cmp", "clk_x", "clk_y"], "clock": "clk_x", "attempts_left": 10, "sva_result": "@(posedge clk_x)     x_str |-> @(posedge clk_y) y_cmp", "sva_name": "p_x_str_to_y_cmp", "full_property": "property p_x_str_to_y_cmp;\n@(posedge clk_x)     x_str |-> @(posedge clk_y) y_cmp\nendproperty\nassert_p_x_str_to_y_cmp:assert property (p_x_str_to_y_cmp) else $error(\"\");", "task_id": "1_2570", "predict_sva": "@(posedge clk_x) x_str |-> @(posedge clk_y) y_cmp"}
{"sva": "@(negedge clock) disable iff(reset) page_fault |-> (tlb_miss ? page_walk : access_ok)", "sva_description": "### Assertion description:\n**Property Name**: p_page_fault_response  \n**Trigger Condition**: At every negedge of the `clock`  \n**Disable Condition**: disable iff (reset)  \n**Antecedent (LHS of Implication)**: `page_fault`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(tlb_miss ? page_walk : access_ok)`  \n\n### Explanation:\n1. The property checks the system's response to a `page_fault` condition.  \n2. When `page_fault` occurs (antecedent), the system must respond with either:  \n   - `page_walk` if `tlb_miss` is true (TLB miss detected), or  \n   - `access_ok` if `tlb_miss` is false (no TLB miss).  \n3. The check is evaluated at every falling edge of `clock` and is disabled when `reset` is active.", "sva_signals": ["clock", "reset", "[0:0] page_fault", "[0:0] tlb_miss", "[0:0] page_walk", "[0:0] access_ok"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (reset)    page_fault |-> (tlb_miss ? page_walk : access_ok)", "sva_name": "p_page_fault_check", "id": "0079", "full_property": "property p_page_fault_response;\n@(negedge clock) disable iff (reset)    page_fault |-> (tlb_miss ? page_walk : access_ok)\nendproperty\nassert_p_page_fault_response:assert property (p_page_fault_response) else $error(\"\");", "task_id": "1_2944", "predict_sva": "@(negedge clock) disable iff (reset)    page_fault |-> (tlb_miss ? page_walk : access_ok)"}
{"id": "10_61_0834", "name": "p_onehot0_or_all_zero_61", "sva": "@(posedge clk) $onehot0(wifi_channels) |-> ##3 wifi_connected;", "sva_description": "### Assertion description:  \n**Property Name**: p_wifi_connection_check  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$onehot0(wifi_channels)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 wifi_connected`  \n\n### Explanation:  \n- **$onehot0(wifi_channels)**: Checks that at most one bit in `wifi_channels` is set to 1 (or none, as `onehot0` allows all zeros).  \n- **##3 wifi_connected**: After 3 clock cycles from the trigger, `wifi_connected` must be true.  \n- The property asserts that if `wifi_channels` has at most one bit set, then `wifi_connected` must be high 3 cycles later.", "sva_signals": ["clk", "rst_n", "[0:0] wifi_channels", "[0:0] wifi_connected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $onehot0(wifi_channels) |-> ##3 wifi_connected", "sva_name": "p_wifi_connected_after_onehot0", "full_property": "property p_wifi_connection_check;\n@(posedge clk)         $onehot0(wifi_channels) |-> ##3 wifi_connected\nendproperty\nassert_p_wifi_connection_check:assert property (p_wifi_connection_check) else $error(\"\");", "task_id": "1_2295", "predict_sva": "@(posedge clk)     $onehot0(wifi_channels) |-> ##3 wifi_connected"}
{"sva": "@(negedge clk) disable iff(!enable) mutex_req |-> (resource_free ? lock_grant : wait_q)", "sva_description": "### Assertion description:  \n**Property Name**: p_mutex_req_check  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: disable iff (!enable)  \n**Antecedent (LHS of Implication)**: `mutex_req`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(resource_free ? lock_grant : wait_q)`  \n\n### Explanation:  \n- The property checks the behavior of a mutex request (`mutex_req`) at every negative edge of the clock (`negedge clk`).  \n- The assertion is disabled if the `enable` signal is low (`disable iff (!enable)`).  \n- If `mutex_req` is asserted (antecedent), then (implication `|->`):  \n  - If `resource_free` is true, `lock_grant` must be true.  \n  - If `resource_free` is false, the request must be placed in a wait queue (`wait_q`).  \n- The consequent uses a conditional operator (`?:`) to specify the expected behavior based on `resource_free`.", "sva_signals": ["clk", "enable", "[0:0] mutex_req", "[0:0] resource_free", "[0:0] lock_grant", "[0:0] wait_q"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (!enable)    mutex_req |-> (resource_free ? lock_grant : wait_q)", "sva_name": "p_mutex_req_response", "id": "0077", "full_property": "property p_mutex_req_check;\n@(negedge clk) disable iff (!enable)    mutex_req |-> (resource_free ? lock_grant : wait_q)\nendproperty\nassert_p_mutex_req_check:assert property (p_mutex_req_check) else $error(\"\");", "task_id": "1_2942", "predict_sva": "@(negedge clk) disable iff (!enable)    mutex_req |-> (resource_free ? lock_grant : wait_q)"}
{"sva": "@(negedge clock) disable iff(!power_on) bus_grant |-> (master_req ? data_xfer : bus_idle)", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_grant_behavior  \n**Trigger Condition**: At every negedge of the `clock`  \n**Disable Condition**: disable iff (!power_on)  \n**Antecedent (LHS of Implication)**: `bus_grant == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(master_req ? data_xfer : bus_idle)`  \n\n### Explanation:  \n- The property checks the behavior of the system when `bus_grant` is asserted (logic high).  \n- The check is performed on every falling edge of `clock`, unless the system is not powered on (`!power_on`).  \n- If `bus_grant` is high (`LHS`), then (`|->`) the system must either:  \n  - Transfer data (`data_xfer`) if `master_req` is true, or  \n  - Remain idle (`bus_idle`) if `master_req` is false.  \n- The ternary operator (`? :`) dynamically selects the expected behavior based on `master_req`.  \n\n### Notes:  \n- The assertion ensures correct bus arbitration logic.  \n- If `power_on` is low, the assertion is disabled (asynchronous reset or power-down scenario).  \n- The check is edge-sensitive (`negedge clock`), meaning it evaluates once per clock falling edge.", "sva_signals": ["clock", "power_on", "[0:0] bus_grant", "[0:0] master_req", "[0:0] data_xfer", "[0:0] bus_idle"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (!power_on)    bus_grant == 1'b1 |-> (master_req ? data_xfer : bus_idle)", "sva_name": "p_bus_grant_condition", "id": "0053", "full_property": "property p_bus_grant_behavior;\n@(negedge clock) disable iff (!power_on)    bus_grant == 1'b1 |-> (master_req ? data_xfer : bus_idle)\nendproperty\nassert_p_bus_grant_behavior:assert property (p_bus_grant_behavior) else $error(\"\");", "task_id": "1_2919", "predict_sva": "@(negedge clock) disable iff (!power_on)    bus_grant == 1'b1 |-> (master_req ? data_xfer : bus_idle)"}
{"id": "17_100_1523", "name": "p_multi_clock_100", "sva": "@(posedge clk_x) x_p |-> @(posedge clk_y) y_t", "sva_description": "### Assertion description:\n**Property Name**: p_x_p_to_y_t  \n**Trigger Condition**: At every posedge of the `clk_x`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `x_p == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: At the next posedge of `clk_y`, `y_t` must be true  \n\nNote: This is a multi-clock assertion where the consequent is evaluated at the next occurrence of `clk_y` after the antecedent is true at a `clk_x` edge. The property checks that whenever `x_p` is true at a `clk_x` rising edge, then at the immediately following `clk_y` rising edge, `y_t` must be true.", "sva_signals": ["clk", "rst_n", "[0:0] x_p", "[0:0] y_t", "clk_x", "clk_y"], "clock": "clk_x", "attempts_left": 10, "sva_result": "@(posedge clk_x) x_p == 1'b1 |-> @(posedge clk_y) y_t == 1'b1", "sva_name": "p_x_p_to_y_t", "full_property": "property p_x_p_to_y_t;\n@(posedge clk_x) x_p == 1'b1 |-> @(posedge clk_y) y_t == 1'b1\nendproperty\nassert_p_x_p_to_y_t:assert property (p_x_p_to_y_t) else $error(\"\");", "task_id": "1_2514", "predict_sva": "@(posedge clk_x) x_p == 1'b1 |-> @(posedge clk_y) y_t == 1'b1"}
{"id": "13_92_1161", "name": "p_overflow_check", "sva": "@(posedge clk)      math_op |-> (overflow_possible |-> ##1 overflow_flag);", "sva_description": "### Assertion description:\n**Property Name**: p_math_op_overflow\n**Trigger Condition**: At every posedge of the clock (implicit from context)\n**Disable Condition**: None\n**Antecedent (LHS of Implication)**: `math_op == 1'b1`\n**Implication Operator**: `|->`\n**Consequent (RHS of Implication)**: `(overflow_possible |-> ##1 overflow_flag)`\n\n**Nested Implication Explanation**:\n1. When `math_op` is true, then:\n2. If `overflow_possible` is also true (`overflow_possible` acts as antecedent for nested implication),\n3. Then in the next clock cycle (`##1`), `overflow_flag` must be true (consequent of nested implication)\n\nNote: This is a nested implication where the consequent itself contains another implication. The property checks that when a math operation is performed, if overflow is possible, then the overflow flag should be set in the next cycle.", "sva_signals": ["clk", "rst_n", "[0:0] math_op", "[0:0] overflow_possible", "[0:0] overflow_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         math_op == 1'b1 |-> (overflow_possible |-> ##1 overflow_flag)", "sva_name": "p_Math_Op_Overflow", "full_property": "property p_math_op_overflow;\n@(posedge clk)         math_op == 1'b1 |-> (overflow_possible |-> ##1 overflow_flag)\nendproperty\nassert_p_math_op_overflow:assert property (p_math_op_overflow) else $error(\"\");", "task_id": "1_2504", "predict_sva": "@(posedge clk)     math_op == 1'b1 |-> (overflow_possible |=> overflow_flag)"}
{"sva": "@(posedge bus_clk) disable iff(system_halt) address_decode |-> (address[31:28] == 4'hF ? peripheral_select : memory_select)", "sva_description": "### Assertion description:\n**Property Name**: p_address_decode  \n**Trigger Condition**: At every rising edge of the `bus_clk`  \n**Disable Condition**: disable iff (system_halt)  \n**Antecedent (LHS of Implication)**: `address_decode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(address[31:28] == 4'hF ? peripheral_select : memory_select)`  \n\nThe property checks that whenever `address_decode` is true at a rising clock edge of `bus_clk` (and the system is not halted), the address bus's upper 4 bits determine the selection: if they equal 4'hF, `peripheral_select` must be active; otherwise, `memory_select` must be active. The check is disabled if `system_halt` is asserted.", "sva_signals": ["bus_clk", "system_halt", "[31:0] address", "[0:0] address_decode", "[0:0] peripheral_select", "[0:0] memory_select"], "clock": "bus_clk", "attempts_left": 10, "sva_result": "@(posedge bus_clk) disable iff (system_halt)    address_decode |-> (address[31:28] == 4'hF ? peripheral_select : memory_select)", "sva_name": "p_address_decode_check", "id": "0110", "full_property": "property p_address_decode;\n@(posedge bus_clk) disable iff (system_halt)    address_decode |-> (address[31:28] == 4'hF ? peripheral_select : memory_select)\nendproperty\nassert_p_address_decode:assert property (p_address_decode) else $error(\"\");", "task_id": "1_2975", "predict_sva": "@(posedge bus_clk) disable iff (system_halt)    address_decode |-> (address[31:28] == 4'hF ? peripheral_select : memory_select)"}
{"sva": "@(posedge telemetry_clk) disable iff(comm_failure) data_packetize |-> (priority_level[2:0] ? urgent_packet : routine_packet)", "sva_description": "### Assertion description:\n**Property Name**: p_data_packetize_priority  \n**Trigger Condition**: At every rising edge of the `telemetry_clk`  \n**Disable Condition**: disable iff (comm_failure)  \n**Antecedent (LHS of Implication)**: `data_packetize`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(priority_level[2:0] ? urgent_packet : routine_packet)`  \n\n**Explanation**:  \nThis assertion checks that whenever `data_packetize` is true at a rising edge of `telemetry_clk` (unless disabled by `comm_failure`), the output packet type must match the priority level. If any bit in `priority_level[2:0]` is set ( 0), the packet must be `urgent_packet`; otherwise, it must be `routine_packet`. The check is synchronous to the clock and aborts if `comm_failure` occurs.", "sva_signals": ["telemetry_clk", "[0:0] comm_failure", "[0:0] data_packetize", "[2:0] priority_level", "[0:0] urgent_packet", "[0:0] routine_packet"], "clock": "telemetry_clk", "attempts_left": 10, "sva_result": "@(posedge telemetry_clk) disable iff (comm_failure)    data_packetize |-> (priority_level[2:0] ? urgent_packet : routine_packet)", "sva_name": "p_data_packetize_priority", "id": "0150", "full_property": "property p_data_packetize_priority;\n@(posedge telemetry_clk) disable iff (comm_failure)    data_packetize |-> (priority_level[2:0] ? urgent_packet : routine_packet)\nendproperty\nassert_p_data_packetize_priority:assert property (p_data_packetize_priority) else $error(\"\");", "task_id": "1_3015", "predict_sva": "@(posedge telemetry_clk) disable iff (comm_failure)    data_packetize |-> (|priority_level[2:0] ? urgent_packet : routine_packet)"}
{"sva": "@(posedge domain_clk) disable iff(isolation_active) clock_gating |-> (activity_counter[7:0] == 8'h00 ? gate_clock : keep_running)", "sva_description": "### Assertion description:  \n**Property Name**: p_clock_gating_condition  \n**Trigger Condition**: At every rising edge of `domain_clk`  \n**Disable Condition**: `disable iff (isolation_active)`  \n**Antecedent (LHS of Implication)**: `clock_gating`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(activity_counter[7:0] == 8'h00 ? gate_clock : keep_running)`  \n\n### Explanation:  \n1. The property checks the clock gating behavior based on the value of `activity_counter`.  \n2. When `clock_gating` is active (antecedent), the consequent evaluates:  \n   - If `activity_counter[7:0]` equals `8'h00`, the output should be `gate_clock`.  \n   - Otherwise, the output should be `keep_running`.  \n3. The assertion is disabled if `isolation_active` is asserted.", "sva_signals": ["domain_clk", "isolation_active", "[0:0] clock_gating", "[7:0] activity_counter", "[0:0] gate_clock", "[0:0] keep_running"], "clock": "domain_clk", "attempts_left": 10, "sva_result": "@(posedge domain_clk) disable iff (isolation_active)    clock_gating |-> (activity_counter[7:0] == 8'h00 ? gate_clock : keep_running)", "sva_name": "p_clock_gating_check", "id": "0151", "full_property": "property p_clock_gating_condition;\n@(posedge domain_clk) disable iff (isolation_active)    clock_gating |-> (activity_counter[7:0] == 8'h00 ? gate_clock : keep_running)\nendproperty\nassert_p_clock_gating_condition:assert property (p_clock_gating_condition) else $error(\"\");", "task_id": "1_3016", "predict_sva": "@(posedge domain_clk) disable iff (isolation_active)    clock_gating |-> ((activity_counter[7:0] == 8'h00) ? gate_clock : keep_running)"}
{"sva": "@(negedge protocol_clk) disable iff(!stack_active) layer_process |-> (packet_type[3:0] == 4'h7 ? application_layer : transport_layer)", "sva_description": "### Assertion description:\n**Property Name**: p_layer_process_check  \n**Trigger Condition**: At every negedge of the `protocol_clk`  \n**Disable Condition**: disable iff (!stack_active)  \n**Antecedent (LHS of Implication)**: `layer_process`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(packet_type[3:0] == 4'h7 ? application_layer : transport_layer)`  \n\n**Explanation**:  \nThis assertion checks that whenever `layer_process` is true at the falling edge of `protocol_clk` (and while `stack_active` is high), the correct layer output is selected based on `packet_type[3:0]`. If `packet_type[3:0]` equals 4'h7, `application_layer` should be the output; otherwise, `transport_layer` should be the output. The check is disabled if `stack_active` is low.", "sva_signals": ["protocol_clk", "stack_active", "[0:0] layer_process", "[3:0] packet_type", "[0:0] application_layer", "[0:0] transport_layer"], "clock": "protocol_clk", "attempts_left": 10, "sva_result": "@(negedge protocol_clk) disable iff (!stack_active)    layer_process |-> (packet_type[3:0] == 4'h7 ? application_layer : transport_layer)", "sva_name": "p_layer_process_check", "id": "0128", "full_property": "property p_layer_process_check;\n@(negedge protocol_clk) disable iff (!stack_active)    layer_process |-> (packet_type[3:0] == 4'h7 ? application_layer : transport_layer)\nendproperty\nassert_p_layer_process_check:assert property (p_layer_process_check) else $error(\"\");", "task_id": "1_2993", "predict_sva": "@(negedge protocol_clk) disable iff (!stack_active)    layer_process |-> (packet_type[3:0] == 4'h7 ? application_layer : transport_layer)"}
{"sva": "@(posedge retire_clk) disable iff(rollback_active) commit_stage |-> (precise_exception ? architectural_state : speculative_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_commit_stage_state  \n**Trigger Condition**: At every rising edge of the `retire_clk`  \n**Disable Condition**: `disable iff (rollback_active)`  \n**Antecedent (LHS of Implication)**: `commit_stage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(precise_exception ? architectural_state : speculative_state)`  \n\n### Explanation:  \n- The property checks that whenever `commit_stage` is true at a rising edge of `retire_clk` (and `rollback_active` is not asserted), the state should be either `architectural_state` (if `precise_exception` is true) or `speculative_state` (if `precise_exception` is false).  \n- The assertion is disabled if `rollback_active` is high.  \n- The implication ensures that the correct state is selected based on the condition (`precise_exception`).", "sva_signals": ["retire_clk", "rollback_active", "[0:0] commit_stage", "[0:0] precise_exception", "architectural_state", "speculative_state"], "clock": "retire_clk", "attempts_left": 10, "sva_result": "@(posedge retire_clk) disable iff (rollback_active)    commit_stage |-> (precise_exception ? architectural_state : speculative_state)", "sva_name": "p_commit_stage_check", "id": "0221", "full_property": "property p_commit_stage_state;\n@(posedge retire_clk) disable iff (rollback_active)    commit_stage |-> (precise_exception ? architectural_state : speculative_state)\nendproperty\nassert_p_commit_stage_state:assert property (p_commit_stage_state) else $error(\"\");", "task_id": "1_3085", "predict_sva": "@(posedge retire_clk) disable iff (rollback_active)    commit_stage |-> (precise_exception ? architectural_state : speculative_state)"}
{"sva": "@(negedge clock_domain) disable iff(emergency_stop) memory_access |-> !$past(conflict_detected) && $past(arbitration_grant)", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_access_safety  \n**Trigger Condition**: At every negedge of the `clock_domain`  \n**Disable Condition**: `disable iff (emergency_stop)`  \n**Antecedent (LHS of Implication)**: `memory_access == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(conflict_detected) && $past(arbitration_grant)`  ", "sva_signals": ["clock_domain", "[0:0] emergency_stop", "[0:0] memory_access", "[0:0] conflict_detected", "[0:0] arbitration_grant"], "clock": "clock_domain", "attempts_left": 10, "sva_result": "@(negedge clock_domain) disable iff (emergency_stop)     memory_access == 1'b1 |-> !$past(conflict_detected) && $past(arbitration_grant)", "sva_name": "p_Memory_Access_Safety", "id": "0004", "full_property": "property p_memory_access_safety;\n@(negedge clock_domain) disable iff (emergency_stop)     memory_access == 1'b1 |-> !$past(conflict_detected) && $past(arbitration_grant)\nendproperty\nassert_p_memory_access_safety:assert property (p_memory_access_safety) else $error(\"\");", "task_id": "1_3837", "predict_sva": "@(negedge clock_domain) disable iff (emergency_stop)     memory_access == 1'b1 |-> !$past(conflict_detected) && $past(arbitration_grant)"}
{"sva": "@(posedge clk_core) disable iff(!power_on_rst) branch_taken |-> $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))", "sva_description": "### Assertion description:  \n**Property Name**: p_Branch_Taken_Condition  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: `disable iff (!power_on_rst)`  \n**Antecedent (LHS of Implication)**: `branch_taken == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))`  ", "sva_signals": ["clk_core", "power_on_rst", "[0:0] branch_taken", "[0:0] condition_met", "[0:0] prediction_valid", "[0:0] speculative_exec"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |->      $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))", "sva_name": "p_branch_taken_condition", "id": "0032", "full_property": "property p_Branch_Taken_Condition;\n@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |->      $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))\nendproperty\nassert_p_Branch_Taken_Condition:assert property (p_Branch_Taken_Condition) else $error(\"\");", "task_id": "1_3864", "predict_sva": "@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |-> $past(condition_met) && ($past(prediction_valid) || !$past(speculative_exec))"}
{"sva": "@(posedge surgical_clk) disable iff(safety_violated) robotic_surgeon |-> (precision_required ? micro_movement : coarse_adjustment)", "sva_description": "### Assertion description:  \n**Property Name**: p_Robotic_Surgeon_Action  \n**Trigger Condition**: At every rising edge of the `surgical_clk`  \n**Disable Condition**: `disable iff (safety_violated)`  \n**Antecedent (LHS of Implication)**: `robotic_surgeon`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(precision_required ? micro_movement : coarse_adjustment)`  \n\n### Explanation:  \nThe property checks that whenever the `robotic_surgeon` signal is active (antecedent), the system must respond with either `micro_movement` if `precision_required` is true, or `coarse_adjustment` otherwise (consequent). The check occurs at every rising edge of `surgical_clk` and is disabled if `safety_violated` is asserted. The ternary operator (`?:`) dynamically selects the expected action based on `precision_required`.", "sva_signals": ["surgical_clk", "safety_violated", "[0:0] robotic_surgeon", "[0:0] precision_required", "[0:0] micro_movement", "[0:0] coarse_adjustment"], "clock": "surgical_clk", "attempts_left": 10, "sva_result": "@(posedge surgical_clk) disable iff (safety_violated)    robotic_surgeon |-> (precision_required ? micro_movement : coarse_adjustment)", "sva_name": "p_Robotic_Surgeon_Movement", "id": "0184", "full_property": "property p_Robotic_Surgeon_Action;\n@(posedge surgical_clk) disable iff (safety_violated)    robotic_surgeon |-> (precision_required ? micro_movement : coarse_adjustment)\nendproperty\nassert_p_Robotic_Surgeon_Action:assert property (p_Robotic_Surgeon_Action) else $error(\"\");", "task_id": "1_3048", "predict_sva": "@(posedge surgical_clk) disable iff (safety_violated)    robotic_surgeon |-> (precision_required ? micro_movement : coarse_adjustment)"}
{"sva": "@(posedge packaging_clk) disable iff(!label_printer_ready) product_wrapper |-> (barcode_valid ? apply_label : error_notification)", "sva_description": "### Assertion description:\n**Property Name**: p_product_wrapper_condition  \n**Trigger Condition**: At every rising edge of the `packaging_clk`  \n**Disable Condition**: disable iff (!label_printer_ready)  \n**Antecedent (LHS of Implication)**: `product_wrapper`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(barcode_valid ? apply_label : error_notification)`  \n\n### Explanation:\n- The property checks that whenever `product_wrapper` is true at a rising edge of `packaging_clk`, then in the same cycle:  \n  - If `barcode_valid` is true, `apply_label` must be true.  \n  - If `barcode_valid` is false, `error_notification` must be true.  \n- The assertion is disabled if `label_printer_ready` is low (active-low reset condition).", "sva_signals": ["packaging_clk", "label_printer_ready", "[0:0] product_wrapper", "[0:0] barcode_valid", "[0:0] apply_label", "[0:0] error_notification"], "clock": "packaging_clk", "attempts_left": 10, "sva_result": "@(posedge packaging_clk) disable iff (!label_printer_ready)    product_wrapper |-> (barcode_valid ? apply_label : error_notification)", "sva_name": "p_product_wrapper_check", "id": "0262", "full_property": "property p_product_wrapper_condition;\n@(posedge packaging_clk) disable iff (!label_printer_ready)    product_wrapper |-> (barcode_valid ? apply_label : error_notification)\nendproperty\nassert_p_product_wrapper_condition:assert property (p_product_wrapper_condition) else $error(\"\");", "task_id": "1_3126", "predict_sva": "@(posedge packaging_clk) disable iff (!label_printer_ready)    product_wrapper |-> (barcode_valid ? apply_label : error_notification)"}
{"sva": "@(posedge core_clock) disable iff(!system_rst_n) branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_predictor_mispredict  \n**Trigger Condition**: At every rising edge of the `core_clock`  \n**Disable Condition**: `disable iff (!system_rst_n)`  \n**Antecedent (LHS of Implication)**: `branch_predictor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)`  \n\n### Explanation:  \n- The property checks the behavior of the branch predictor when active (`branch_predictor` is true).  \n- If the `mispredict_rate[7:0]` exceeds `8'd15`, the system should `flush_frontend`; otherwise, it should `continue_fetch`.  \n- The assertion is disabled when `system_rst_n` is low (asynchronous reset condition).  \n- The check occurs at every positive edge of `core_clock`.", "sva_signals": ["core_clock", "system_rst_n", "[0:0] branch_predictor", "[7:0] mispredict_rate", "[0:0] flush_frontend", "[0:0] continue_fetch"], "clock": "core_clock", "attempts_left": 10, "sva_result": "@(posedge core_clock) disable iff (!system_rst_n)    branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)", "sva_name": "p_branch_predictor_mispredict", "id": "0204", "full_property": "property p_branch_predictor_mispredict;\n@(posedge core_clock) disable iff (!system_rst_n)    branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)\nendproperty\nassert_p_branch_predictor_mispredict:assert property (p_branch_predictor_mispredict) else $error(\"\");", "task_id": "1_3068", "predict_sva": "@(posedge core_clock) disable iff (!system_rst_n)    branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)"}
{"sva": "@(posedge rehabilitation_clk) disable iff(therapy_paused) physical_trainer |-> (muscle_response[7:0] ? increase_resistance : reduce_load)", "sva_description": "### Assertion description:\n**Property Name**: p_Physical_Trainer_Response  \n**Trigger Condition**: At every rising edge of the `rehabilitation_clk`  \n**Disable Condition**: disable iff (`therapy_paused`)  \n**Antecedent (LHS of Implication)**: `physical_trainer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(muscle_response[7:0] ? increase_resistance : reduce_load)`  \n\n### Explanation:\n- The property checks the response of a physical trainer system during rehabilitation.  \n- When `physical_trainer` is active (antecedent), the system must respond appropriately based on `muscle_response[7:0]`:  \n  - If `muscle_response[7:0]` is non-zero (true), the action `increase_resistance` should occur.  \n  - If `muscle_response[7:0]` is zero (false), the action `reduce_load` should occur.  \n- The check is disabled if `therapy_paused` is asserted (disable condition).  \n- The evaluation happens at every rising edge of `rehabilitation_clk`.", "sva_signals": ["rehabilitation_clk", "therapy_paused", "[0:0] physical_trainer", "[7:0] muscle_response", "[0:0] increase_resistance", "[0:0] reduce_load"], "clock": "rehabilitation_clk", "attempts_left": 10, "sva_result": "@(posedge rehabilitation_clk) disable iff (therapy_paused)    physical_trainer |-> (muscle_response[7:0] ? increase_resistance : reduce_load)", "sva_name": "p_physical_trainer_response", "id": "0205", "full_property": "property p_Physical_Trainer_Response;\n@(posedge rehabilitation_clk) disable iff (therapy_paused)    physical_trainer |-> (muscle_response[7:0] ? increase_resistance : reduce_load)\nendproperty\nassert_p_Physical_Trainer_Response:assert property (p_Physical_Trainer_Response) else $error(\"\");", "task_id": "1_3069", "predict_sva": "@(posedge rehabilitation_clk) disable iff (therapy_paused)    physical_trainer |-> (muscle_response[7:0] ? increase_resistance : reduce_load)"}
{"sva": "@(posedge consciousness_clk) disable iff(!upload_protocol_active) mind_transfer |-> (neural_mapping_complete ? consciousness_upload : preserve_biological)", "sva_description": "### Assertion description:  \n**Property Name**: p_Mind_Transfer_Check  \n**Trigger Condition**: At every rising edge of the `consciousness_clk`  \n**Disable Condition**: disable iff (!upload_protocol_active)  \n**Antecedent (LHS of Implication)**: `mind_transfer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(neural_mapping_complete ? consciousness_upload : preserve_biological)`  \n\n### Explanation:  \nThe property checks that whenever `mind_transfer` is asserted (antecedent), the consequent must hold:  \n- If `neural_mapping_complete` is true, `consciousness_upload` must occur.  \n- If `neural_mapping_complete` is false, `preserve_biological` must occur.  \nThe check is performed at every rising edge of `consciousness_clk` and is disabled if `upload_protocol_active` is low.", "sva_signals": ["consciousness_clk", "upload_protocol_active", "[0:0] mind_transfer", "[0:0] neural_mapping_complete", "[0:0] consciousness_upload", "[0:0] preserve_biological"], "clock": "consciousness_clk", "attempts_left": 10, "sva_result": "@(posedge consciousness_clk) disable iff (!upload_protocol_active)    mind_transfer |-> (neural_mapping_complete ? consciousness_upload : preserve_biological)", "sva_name": "p_mind_transfer_condition", "id": "0371", "full_property": "property p_Mind_Transfer_Check;\n@(posedge consciousness_clk) disable iff (!upload_protocol_active)    mind_transfer |-> (neural_mapping_complete ? consciousness_upload : preserve_biological)\nendproperty\nassert_p_Mind_Transfer_Check:assert property (p_Mind_Transfer_Check) else $error(\"\");", "task_id": "1_3234", "predict_sva": "@(posedge consciousness_clk) disable iff (!upload_protocol_active)    mind_transfer |-> (neural_mapping_complete ? consciousness_upload : preserve_biological)"}
{"sva": "@(negedge cache_clk) disable iff(!coherence_enable) snoop_controller |-> (shared_state ? invalidate_line : exclusive_access)", "sva_description": "### Assertion description:  \n**Property Name**: p_snoop_controller_check  \n**Trigger Condition**: At every negedge of the `cache_clk`  \n**Disable Condition**: disable iff (!coherence_enable)  \n**Antecedent (LHS of Implication)**: `snoop_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(shared_state ? invalidate_line : exclusive_access)`  \n\n### Explanation:  \nThe property checks that whenever `snoop_controller` is active (antecedent), the consequent behavior must follow based on the value of `shared_state`:  \n- If `shared_state` is true, `invalidate_line` should occur.  \n- If `shared_state` is false, `exclusive_access` should occur.  \nThe check is evaluated at every falling edge of `cache_clk` and is disabled when `coherence_enable` is low.", "sva_signals": ["cache_clk", "[0:0] coherence_enable", "[0:0] snoop_controller", "[0:0] shared_state", "[0:0] invalidate_line", "[0:0] exclusive_access"], "clock": "cache_clk", "attempts_left": 10, "sva_result": "@(negedge cache_clk) disable iff (!coherence_enable)    snoop_controller |-> (shared_state ? invalidate_line : exclusive_access)", "sva_name": "p_Snoop_Controller_Check", "id": "0207", "full_property": "property p_snoop_controller_check;\n@(negedge cache_clk) disable iff (!coherence_enable)    snoop_controller |-> (shared_state ? invalidate_line : exclusive_access)\nendproperty\nassert_p_snoop_controller_check:assert property (p_snoop_controller_check) else $error(\"\");", "task_id": "1_3071", "predict_sva": "@(negedge cache_clk) disable iff (!coherence_enable)    snoop_controller |-> (shared_state ? invalidate_line : exclusive_access)"}
{"sva": "@(posedge neural_clk) disable iff(synapse_blocked) brain_interface |-> (spike_frequency[9:0] > 10'd500 ? thought_detected : baseline_activity)", "sva_description": "### Assertion description:  \n**Property Name**: p_thought_detection  \n**Trigger Condition**: At every rising edge of `neural_clk`  \n**Disable Condition**: disable iff (`synapse_blocked`)  \n**Antecedent (LHS of Implication)**: `brain_interface`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`spike_frequency[9:0] > 10'd500 ? thought_detected : baseline_activity`)  \n\n### Explanation:  \nThe property checks that whenever `brain_interface` is active (antecedent), the consequent evaluates based on the value of `spike_frequency[9:0]`:  \n- If `spike_frequency[9:0]` exceeds `10'd500`, the property expects `thought_detected` to be true.  \n- Otherwise, it expects `baseline_activity` to hold.  \nThe assertion is disabled if `synapse_blocked` is asserted. The evaluation occurs at every positive edge of `neural_clk`.", "sva_signals": ["neural_clk", "[0:0] synapse_blocked", "[0:0] brain_interface", "[9:0] spike_frequency", "[0:0] thought_detected", "[0:0] baseline_activity"], "clock": "neural_clk", "attempts_left": 10, "sva_result": "@(posedge neural_clk) disable iff (synapse_blocked)    brain_interface |-> (spike_frequency[9:0] > 10'd500 ? thought_detected : baseline_activity)", "sva_name": "p_brain_interface_spike_frequency", "id": "0200", "full_property": "property p_thought_detection;\n@(posedge neural_clk) disable iff (synapse_blocked)    brain_interface |-> (spike_frequency[9:0] > 10'd500 ? thought_detected : baseline_activity)\nendproperty\nassert_p_thought_detection:assert property (p_thought_detection) else $error(\"\");", "task_id": "1_3064", "predict_sva": "@(posedge neural_clk) disable iff (synapse_blocked)    brain_interface |-> ((spike_frequency[9:0] > 10'd500) ? thought_detected : baseline_activity)"}
{"sva": "@(posedge clk_core) disable iff(!power_on_rst) branch_taken |-> $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))", "sva_description": "### Assertion description:  \n**Property Name**: p_Branch_Taken_Condition  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: `disable iff (!power_on_rst)`  \n**Antecedent (LHS of Implication)**: `branch_taken == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))`  ", "sva_signals": ["clk_core", "power_on_rst", "[0:0] branch_taken", "[0:0] condition_met", "[0:0] prediction_valid", "[0:0] speculative_exec"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |->      $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))", "sva_name": "p_Branch_Taken_After_Condition", "id": "0024", "full_property": "property p_Branch_Taken_Condition;\n@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |->      $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))\nendproperty\nassert_p_Branch_Taken_Condition:assert property (p_Branch_Taken_Condition) else $error(\"\");", "task_id": "1_3856", "predict_sva": "@(posedge clk_core) disable iff (!power_on_rst)     branch_taken == 1'b1 |-> $past(condition_met) && ($past(prediction_valid, 1) || !$past(speculative_exec))"}
{"sva": "@(posedge monitoring_clk) disable iff(telemetry_off) performance_counter |-> (threshold_exceeded[9:0] ? trigger_interrupt : accumulate_stats)", "sva_description": "### Assertion description:  \n**Property Name**: p_performance_counter_check  \n**Trigger Condition**: At every rising edge of the `monitoring_clk`  \n**Disable Condition**: `disable iff (telemetry_off)`  \n**Antecedent (LHS of Implication)**: `performance_counter`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(threshold_exceeded[9:0] ? trigger_interrupt : accumulate_stats)`  \n\n### Explanation:  \nThe property checks that whenever `performance_counter` is active (true), the following must hold:  \n- If any bit in `threshold_exceeded[9:0]` is set (non-zero), `trigger_interrupt` must occur.  \n- If `threshold_exceeded[9:0]` is zero, `accumulate_stats` must be active instead.  \nThe check is disabled when `telemetry_off` is asserted.", "sva_signals": ["monitoring_clk", "telemetry_off", "[0:0] performance_counter", "[9:0] threshold_exceeded", "[0:0] trigger_interrupt", "[0:0] accumulate_stats"], "clock": "monitoring_clk", "attempts_left": 10, "sva_result": "@(posedge monitoring_clk) disable iff (telemetry_off)    performance_counter |-> (|threshold_exceeded[9:0] ? trigger_interrupt : accumulate_stats)", "sva_name": "p_performance_counter_trigger", "id": "0220", "full_property": "property p_performance_counter_check;\n@(posedge monitoring_clk) disable iff (telemetry_off)    performance_counter |-> (|threshold_exceeded[9:0] ? trigger_interrupt : accumulate_stats)\nendproperty\nassert_p_performance_counter_check:assert property (p_performance_counter_check) else $error(\"\");", "task_id": "1_3084", "predict_sva": "@(posedge monitoring_clk) disable iff (telemetry_off)    performance_counter |-> (threshold_exceeded[9:0] ? trigger_interrupt : accumulate_stats)"}
{"sva": "@(negedge mem_clk) disable iff(mem_reset) refresh_req |-> $past(refresh_timer) && !($past(row_active, 2) || $past(precharge_wait))", "sva_description": "### Assertion description:  \n**Property Name**: p_refresh_req_check  \n**Trigger Condition**: At every negedge of the `mem_clk`  \n**Disable Condition**: disable iff (mem_reset)  \n**Antecedent (LHS of Implication)**: `refresh_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(refresh_timer) && !($past(row_active, 2) || $past(precharge_wait))`  ", "sva_signals": ["mem_clk", "mem_reset", "[0:0] refresh_req", "[0:0] refresh_timer", "[0:0] row_active", "[0:0] precharge_wait"], "clock": "mem_clk", "attempts_left": 10, "sva_result": "@(negedge mem_clk) disable iff (mem_reset)     refresh_req == 1'b1 |->          $past(refresh_timer) && !($past(row_active, 2) || $past(precharge_wait))", "sva_name": "p_refresh_req_check", "id": "0114", "full_property": "property p_refresh_req_check;\n@(negedge mem_clk) disable iff (mem_reset)     refresh_req == 1'b1 |->          $past(refresh_timer) && !($past(row_active, 2) || $past(precharge_wait))\nendproperty\nassert_p_refresh_req_check:assert property (p_refresh_req_check) else $error(\"\");", "task_id": "1_3940", "predict_sva": "@(negedge mem_clk) disable iff (mem_reset)     refresh_req == 1'b1 |-> $past(refresh_timer) && !($past(row_active, 2) || $past(precharge_wait))"}
{"sva": "@(posedge clk_100m) disable iff(!hard_reset) cache_match |-> $past(tag_valid) && ($past(cache_active, 1) || $past(bypass_flag))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_match_condition  \n**Trigger Condition**: At every rising edge of the `clk_100m`  \n**Disable Condition**: `disable iff (!hard_reset)`  \n**Antecedent (LHS of Implication)**: `cache_match == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tag_valid) && ($past(cache_active, 1) || $past(bypass_flag))`  ", "sva_signals": ["clk_100m", "hard_reset", "[0:0] cache_match", "[0:0] tag_valid", "[0:0] cache_active", "[0:0] bypass_flag"], "clock": "clk_100m", "attempts_left": 10, "sva_result": "@(posedge clk_100m) disable iff (!hard_reset)     cache_match == 1'b1 |-> $past(tag_valid) && ($past(cache_active, 1) || $past(bypass_flag))", "sva_name": "p_cache_match_after_valid", "id": "0112", "full_property": "property p_cache_match_condition;\n@(posedge clk_100m) disable iff (!hard_reset)     cache_match == 1'b1 |-> $past(tag_valid) && ($past(cache_active, 1) || $past(bypass_flag))\nendproperty\nassert_p_cache_match_condition:assert property (p_cache_match_condition) else $error(\"\");", "task_id": "1_3938", "predict_sva": "@(posedge clk_100m) disable iff (!hard_reset)     cache_match == 1'b1 |-> $past(tag_valid) && ($past(cache_active, 1) || $past(bypass_flag))"}
{"sva": "@(posedge clk) disable iff(!rst) timer_expired |-> $past(counter_enable) && ($past(reload_value) > 0)", "sva_description": "### Assertion description:  \n**Property Name**: p_Timer_Expired_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst)`  \n**Antecedent (LHS of Implication)**: `timer_expired`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(counter_enable) && ($past(reload_value) > 0)`", "sva_signals": ["clk", "rst", "[0:0] timer_expired", "[0:0] counter_enable", "[0:0] reload_value"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst)         timer_expired |-> ($past(counter_enable) && ($past(reload_value) > 0))", "sva_name": "p_timer_expired_check", "id": "0038", "full_property": "property p_Timer_Expired_Check;\n@(posedge clk) disable iff (!rst)         timer_expired |-> ($past(counter_enable) && ($past(reload_value) > 0))\nendproperty\nassert_p_Timer_Expired_Check:assert property (p_Timer_Expired_Check) else $error(\"\");", "task_id": "1_3869", "predict_sva": "@(posedge clk) disable iff (!rst)     timer_expired |-> $past(counter_enable, 1) && ($past(reload_value) > 0)"}
{"sva": "@(posedge clk_core) disable iff(!power_rst) branch_exec |-> $past(condition_true) && ($past(predict_ok, 1) || !$past(spec_mode))", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_exec_condition  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: `disable iff (!power_rst)`  \n**Antecedent (LHS of Implication)**: `branch_exec == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(condition_true) && ($past(predict_ok, 1) || !$past(spec_mode))`  ", "sva_signals": ["clk_core", "power_rst", "[0:0] branch_exec", "[0:0] condition_true", "[0:0] predict_ok", "[0:0] spec_mode"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core) disable iff (!power_rst)     branch_exec == 1'b1 |-> $past(condition_true) && ($past(predict_ok, 1) || !$past(spec_mode))", "sva_name": "p_branch_exec_condition", "id": "0142", "full_property": "property p_branch_exec_condition;\n@(posedge clk_core) disable iff (!power_rst)     branch_exec == 1'b1 |-> $past(condition_true) && ($past(predict_ok, 1) || !$past(spec_mode))\nendproperty\nassert_p_branch_exec_condition:assert property (p_branch_exec_condition) else $error(\"\");", "task_id": "1_3968", "predict_sva": "@(posedge clk_core) disable iff (!power_rst)     branch_exec == 1'b1 |-> $past(condition_true) && ($past(predict_ok, 1) || !$past(spec_mode))"}
{"sva": "@(posedge insurance_clk) disable iff(!actuarial_data_valid) risk_assessment |-> (claim_history[9:0] ? premium_adjustment : standard_rate)", "sva_description": "### Assertion description:  \n**Property Name**: p_Risk_Assessment_Claim  \n**Trigger Condition**: At every rising edge of the `insurance_clk`  \n**Disable Condition**: `disable iff (!actuarial_data_valid)`  \n**Antecedent (LHS of Implication)**: `risk_assessment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(claim_history[9:0] ? premium_adjustment : standard_rate)`  \n\n### Explanation:  \n1. The property evaluates **risk_assessment** as the trigger condition (antecedent).  \n2. If **risk_assessment** is true, the consequent checks whether **claim_history[9:0]** is non-zero:  \n   - If true, **premium_adjustment** is the expected output.  \n   - If false, **standard_rate** is the expected output.  \n3. The assertion is **disabled** if **actuarial_data_valid** is low (active-low reset condition).  \n4. The check occurs synchronously at every positive edge of **insurance_clk**.", "sva_signals": ["insurance_clk", "actuarial_data_valid", "[0:0] risk_assessment", "[9:0] claim_history", "[0:0] premium_adjustment", "[0:0] standard_rate"], "clock": "insurance_clk", "attempts_left": 10, "sva_result": "@(posedge insurance_clk) disable iff (!actuarial_data_valid)    risk_assessment |-> (claim_history[9:0] ? premium_adjustment : standard_rate)", "sva_name": "p_risk_assessment_premium", "id": "0336", "full_property": "property p_Risk_Assessment_Claim;\n@(posedge insurance_clk) disable iff (!actuarial_data_valid)    risk_assessment |-> (claim_history[9:0] ? premium_adjustment : standard_rate)\nendproperty\nassert_p_Risk_Assessment_Claim:assert property (p_Risk_Assessment_Claim) else $error(\"\");", "task_id": "1_3199", "predict_sva": "@(posedge insurance_clk) disable iff (!actuarial_data_valid)    risk_assessment |-> (claim_history[9:0] ? premium_adjustment : standard_rate)"}
{"sva": "@(negedge ocean_clk) disable iff(!buoy_connected) wave_monitor |-> (wave_height[9:0] ? tsunami_risk : normal_surf)", "sva_description": "### Assertion description:  \n**Property Name**: p_wave_monitor_alert  \n**Trigger Condition**: At every negedge of the `ocean_clk`  \n**Disable Condition**: disable iff (!buoy_connected)  \n**Antecedent (LHS of Implication)**: `wave_monitor == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(wave_height[9:0] ? tsunami_risk : normal_surf)`  \n\n### Explanation:  \n1. The property evaluates on the falling edge of `ocean_clk`.  \n2. The assertion is disabled if `buoy_connected` is low (active-low reset condition).  \n3. If `wave_monitor` is high (antecedent), the consequent checks whether:  \n   - If any bit in `wave_height[9:0]` is non-zero, `tsunami_risk` is evaluated.  \n   - Otherwise, `normal_surf` is evaluated.  \n4. The ternary operator (`? :`) acts as a conditional selector for the consequent output.  \n\n(Note: The exact semantics of `tsunami_risk` and `normal_surf` depend on their definitions in the design context.)", "sva_signals": ["ocean_clk", "buoy_connected", "[0:0] wave_monitor", "[9:0] wave_height", "[0:0] tsunami_risk", "[0:0] normal_surf"], "clock": "ocean_clk", "attempts_left": 10, "sva_result": "@(negedge ocean_clk) disable iff (!buoy_connected)    wave_monitor == 1'b1 |-> (wave_height[9:0] ? tsunami_risk : normal_surf)", "sva_name": "p_wave_monitor_check", "id": "0180", "full_property": "property p_wave_monitor_alert;\n@(negedge ocean_clk) disable iff (!buoy_connected)    wave_monitor == 1'b1 |-> (wave_height[9:0] ? tsunami_risk : normal_surf)\nendproperty\nassert_p_wave_monitor_alert:assert property (p_wave_monitor_alert) else $error(\"\");", "task_id": "1_3044", "predict_sva": "@(negedge ocean_clk) disable iff (!buoy_connected)    wave_monitor == 1'b1 |-> (wave_height[9:0] ? tsunami_risk : normal_surf)"}
{"sva": "@(posedge clk_core) disable iff(!power_on_reset) branch_predict |-> $past(condition_code) && ($past(prediction_bit, 1) || !$past(speculative_flag))", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_predict  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: disable iff (!power_on_reset)  \n**Antecedent (LHS of Implication)**: `branch_predict`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(condition_code) && ($past(prediction_bit, 1) || !$past(speculative_flag))`  ", "sva_signals": ["clk_core", "power_on_reset", "[0:0] branch_predict", "[0:0] condition_code", "[0:0] prediction_bit", "[0:0] speculative_flag"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core) disable iff (!power_on_reset)     branch_predict |-> ($past(condition_code) && ($past(prediction_bit, 1) || !$past(speculative_flag)))", "sva_name": "p_branch_prediction", "id": "0245", "full_property": "property p_branch_predict;\n@(posedge clk_core) disable iff (!power_on_reset)     branch_predict |-> ($past(condition_code) && ($past(prediction_bit, 1) || !$past(speculative_flag)))\nendproperty\nassert_p_branch_predict:assert property (p_branch_predict) else $error(\"\");", "task_id": "1_4064", "predict_sva": "@(posedge clk_core) disable iff (!power_on_reset)     branch_predict |-> $past(condition_code) && ($past(prediction_bit, 1) || !$past(speculative_flag))"}
{"sva": "@(negedge clk_display) disable iff(display_sleep) pixel_generation |-> $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_Pixel_Generation_Check  \n**Trigger Condition**: At every falling edge of the `clk_display`  \n**Disable Condition**: `disable iff (display_sleep)`  \n**Antecedent (LHS of Implication)**: `pixel_generation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))`  ", "sva_signals": ["clk_display", "display_sleep", "[0:0] pixel_generation", "[0:0] timing_reference", "[0:0] color_correction", "[0:0] brightness_control"], "clock": "clk_display", "attempts_left": 10, "sva_result": "@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))", "sva_name": "p_pixel_generation_check", "id": "0191", "full_property": "property p_Pixel_Generation_Check;\n@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))\nendproperty\nassert_p_Pixel_Generation_Check:assert property (p_Pixel_Generation_Check) else $error(\"\");", "task_id": "1_4011", "predict_sva": "@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))"}
{"id": "17_42_1464", "name": "p_multi_clock_42", "sva": "@(posedge clk_a) a_trigger |-> @(posedge clk_b) b_response", "sva_description": "### Assertion description:  \n**Property Name**: p_a_trigger_b_response  \n**Trigger Condition**: At every posedge of `clk_a`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `a_trigger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `@(posedge clk_b) b_response`  \n\n**Note**: This is a multi-clock assertion where the antecedent is evaluated at the rising edge of `clk_a`, and the consequent is evaluated at the subsequent rising edge of `clk_b`. The property checks that whenever `a_trigger` is true at a `clk_a` posedge, `b_response` must be true at the next `clk_b` posedge.", "sva_signals": ["clk_a", "clk_b", "[0:0] a_trigger", "[0:0] b_response"], "clock": "clk_a", "attempts_left": 10, "sva_result": "@(posedge clk_a)     a_trigger |-> @(posedge clk_b) b_response", "sva_name": "p_a_trigger_to_b_response", "full_property": "property p_a_trigger_b_response;\n@(posedge clk_a)     a_trigger |-> @(posedge clk_b) b_response\nendproperty\nassert_p_a_trigger_b_response:assert property (p_a_trigger_b_response) else $error(\"\");", "task_id": "1_2548", "predict_sva": "@(posedge clk_a) a_trigger |-> @(posedge clk_b) b_response"}
{"sva": "@(posedge clk) disable iff(watchdog_rst) cpu_pipeline |-> $past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush))", "sva_description": "### Assertion description:  \n**Property Name**: p_cpu_pipeline_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (watchdog_rst)`  \n**Antecedent (LHS of Implication)**: `cpu_pipeline == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush))`  ", "sva_signals": ["clk", "watchdog_rst", "cpu_pipeline", "[0:0] pc_increment", "[0:0] pipeline_stall", "[0:0] exception_flush"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (watchdog_rst)     cpu_pipeline == 1'b1 |-> ($past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush)))", "sva_name": "p_cpu_pipeline_check", "id": "0217", "full_property": "property p_cpu_pipeline_check;\n@(posedge clk) disable iff (watchdog_rst)     cpu_pipeline == 1'b1 |-> ($past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush)))\nendproperty\nassert_p_cpu_pipeline_check:assert property (p_cpu_pipeline_check) else $error(\"\");", "task_id": "1_4036", "predict_sva": "@(posedge clk) disable iff (watchdog_rst)     cpu_pipeline == 1'b1 |-> $past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush))"}
{"sva": "@(posedge clk_pcie) disable iff(!pcie_reset_n) packet_layer |-> $past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Layer_Flow_Control  \n**Trigger Condition**: At every rising edge of `clk_pcie`  \n**Disable Condition**: `disable iff (!pcie_reset_n)`  \n**Antecedent (LHS of Implication)**: `packet_layer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))`", "sva_signals": ["clk_pcie", "pcie_reset_n", "[0:0] packet_layer", "[0:0] flow_control", "[0:0] link_layer_ready", "[0:0] credits_available"], "clock": "clk_pcie", "attempts_left": 10, "sva_result": "@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> $past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))", "sva_name": "p_Packet_Layer_Conditions", "id": "0195", "full_property": "property p_Packet_Layer_Flow_Control;\n@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> $past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))\nendproperty\nassert_p_Packet_Layer_Flow_Control:assert property (p_Packet_Layer_Flow_Control) else $error(\"\");", "task_id": "1_4015", "predict_sva": "@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2)))"}
{"sva": "@(posedge teleportation_clk) disable iff(!quantum_entanglement_verified) matter_transporter |-> (coherence_maintained ? successful_transport : reconstruction_error)", "sva_description": "### Assertion description:  \n**Property Name**: p_matter_transport_check  \n**Trigger Condition**: At every rising edge of the `teleportation_clk`  \n**Disable Condition**: disable iff (`!quantum_entanglement_verified`)  \n**Antecedent (LHS of Implication)**: `matter_transporter`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(coherence_maintained ? successful_transport : reconstruction_error)`  \n\n### Explanation:  \n- The property checks the behavior of the matter transporter system triggered by the `teleportation_clk`.  \n- The assertion is disabled if `quantum_entanglement_verified` is false (`!quantum_entanglement_verified`).  \n- If `matter_transporter` is active (antecedent), then (implication) the system must ensure:  \n  - If `coherence_maintained` is true, `successful_transport` must occur.  \n  - Otherwise (`coherence_maintained` is false), a `reconstruction_error` must be detected.", "sva_signals": ["teleportation_clk", "quantum_entanglement_verified", "[0:0] matter_transporter", "[0:0] coherence_maintained", "[0:0] successful_transport", "[0:0] reconstruction_error"], "clock": "teleportation_clk", "attempts_left": 10, "sva_result": "@(posedge teleportation_clk) disable iff (!quantum_entanglement_verified)    matter_transporter |-> (coherence_maintained ? successful_transport : reconstruction_error)", "sva_name": "p_Matter_Transporter_Check", "id": "0375", "full_property": "property p_matter_transport_check;\n@(posedge teleportation_clk) disable iff (!quantum_entanglement_verified)    matter_transporter |-> (coherence_maintained ? successful_transport : reconstruction_error)\nendproperty\nassert_p_matter_transport_check:assert property (p_matter_transport_check) else $error(\"\");", "task_id": "1_3238", "predict_sva": "@(posedge teleportation_clk) disable iff (!quantum_entanglement_verified)    matter_transporter |-> (coherence_maintained ? successful_transport : reconstruction_error)"}
{"sva": "@(posedge propulsion_clk) disable iff(!engine_operational) thrust_controller |-> (fuel_efficiency[7:0] > 8'd75 ? optimal_burn : rich_mixture)", "sva_description": "### Assertion description:  \n**Property Name**: p_Thrust_Controller_Fuel_Efficiency  \n**Trigger Condition**: At every rising edge of the `propulsion_clk`  \n**Disable Condition**: disable iff (!engine_operational)  \n**Antecedent (LHS of Implication)**: `thrust_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(fuel_efficiency[7:0] > 8'd75 ? optimal_burn : rich_mixture)`  \n\n### Explanation:  \n1. The property checks the relationship between the `thrust_controller` signal and fuel efficiency.  \n2. When `thrust_controller` is active (antecedent), the consequent evaluates whether:  \n   - If `fuel_efficiency[7:0]` is greater than `8'd75`, the system should select `optimal_burn`.  \n   - Otherwise, it should select `rich_mixture`.  \n3. The check is performed at every rising edge of `propulsion_clk` but is disabled if `engine_operational` is low (`!engine_operational`).", "sva_signals": ["propulsion_clk", "engine_operational", "[0:0] thrust_controller", "[7:0] fuel_efficiency", "[0:0] optimal_burn", "[0:0] rich_mixture"], "clock": "propulsion_clk", "attempts_left": 10, "sva_result": "@(posedge propulsion_clk) disable iff (!engine_operational)    thrust_controller |-> (fuel_efficiency[7:0] > 8'd75 ? optimal_burn : rich_mixture)", "sva_name": "p_thrust_controller_fuel_efficiency", "id": "0253", "full_property": "property p_Thrust_Controller_Fuel_Efficiency;\n@(posedge propulsion_clk) disable iff (!engine_operational)    thrust_controller |-> (fuel_efficiency[7:0] > 8'd75 ? optimal_burn : rich_mixture)\nendproperty\nassert_p_Thrust_Controller_Fuel_Efficiency:assert property (p_Thrust_Controller_Fuel_Efficiency) else $error(\"\");", "task_id": "1_3117", "predict_sva": "@(posedge propulsion_clk) disable iff (!engine_operational)    thrust_controller |-> (fuel_efficiency[7:0] > 8'd75 ? optimal_burn : rich_mixture)"}
{"sva": "@(negedge clk_comp) disable iff(!comparator_on) threshold_detection |-> $past(input_signal, 1) && ($past(hysteresis_band) && !$past(noise_filter_active, 3))", "sva_description": "### Assertion description:  \n**Property Name**: p_threshold_detection  \n**Trigger Condition**: At every falling edge of the `clk_comp`  \n**Disable Condition**: disable iff (`!comparator_on`)  \n**Antecedent (LHS of Implication)**: `threshold_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(input_signal, 1) && ($past(hysteresis_band) && !$past(noise_filter_active, 3))`  \n\n", "sva_signals": ["clk", "comparator_on", "threshold_detection", "[0:0] input_signal", "[0:0] hysteresis_band", "[0:0] noise_filter_active", "clk_comp"], "clock": "clk_comp", "attempts_left": 10, "sva_result": "@(negedge clk_comp) disable iff (!comparator_on)     threshold_detection |->          $past(input_signal, 1) &&          ($past(hysteresis_band, 1) && !$past(noise_filter_active, 3))", "sva_name": "p_threshold_detection_check", "id": "0285", "full_property": "property p_threshold_detection;\n@(negedge clk_comp) disable iff (!comparator_on)     threshold_detection |->          $past(input_signal, 1) &&          ($past(hysteresis_band, 1) && !$past(noise_filter_active, 3))\nendproperty\nassert_p_threshold_detection:assert property (p_threshold_detection) else $error(\"\");", "task_id": "1_4102", "predict_sva": "@(negedge clk_comp) disable iff (!comparator_on)     threshold_detection |-> $past(input_signal, 1) && ($past(hysteresis_band) && !$past(noise_filter_active, 3))"}
{"sva": "@(posedge clk) disable iff(!rst_n) data_ready |-> $past(addr_bus[31:0]) == prev_address", "sva_description": "### Assertion description:  \n**Property Name**: p_Data_Ready_Address_Match  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst_n)`  \n**Antecedent (LHS of Implication)**: `data_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(addr_bus[31:0]) == prev_address`  ", "sva_signals": ["clk", "rst_n", "[0:0] data_ready", "[31:0] addr_bus", "[31:0] prev_address"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)         data_ready == 1'b1 |-> $past(addr_bus[31:0]) == prev_address", "sva_name": "p_data_ready_address_match", "id": "0148", "full_property": "property p_Data_Ready_Address_Match;\n@(posedge clk) disable iff (!rst_n)         data_ready == 1'b1 |-> $past(addr_bus[31:0]) == prev_address\nendproperty\nassert_p_Data_Ready_Address_Match:assert property (p_Data_Ready_Address_Match) else $error(\"\");", "task_id": "1_3973", "predict_sva": "@(posedge clk) disable iff (!rst_n)     data_ready == 1'b1 |-> $past(addr_bus[31:0]) == prev_address"}
{"sva": "@(posedge clk_sys) req_signal |-> $past(ack_flag) && ($past(state_counter) == 8'hA5)", "sva_description": "### Assertion description:  \n**Property Name**: p_Req_Signal_Ack_State  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req_signal == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ack_flag) && ($past(state_counter) == 8'hA5)`  ", "sva_signals": ["clk_sys", "ack_flag", "[0:0] req_signal", "[7:0] state_counter"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     req_signal == 1'b1 |-> $past(ack_flag) && ($past(state_counter) == 8'hA5)", "sva_name": "p_Req_Signal_Ack_State", "id": "0141", "full_property": "property p_Req_Signal_Ack_State;\n@(posedge clk_sys)     req_signal == 1'b1 |-> $past(ack_flag) && ($past(state_counter) == 8'hA5)\nendproperty\nassert_p_Req_Signal_Ack_State:assert property (p_Req_Signal_Ack_State) else $error(\"\");", "task_id": "1_3967", "predict_sva": "@(posedge clk_sys)     req_signal == 1'b1 |-> $past(ack_flag, 1) && ($past(state_counter) == 8'hA5)"}
{"sva": "@(posedge marine_clk) disable iff(!ballast_system_ready) vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)", "sva_description": "### Assertion description:  \n**Property Name**: p_vessel_stability_check  \n**Trigger Condition**: At every rising edge of the `marine_clk`  \n**Disable Condition**: `disable iff (!ballast_system_ready)`  \n**Antecedent (LHS of Implication)**: `vessel_stability`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)`  \n\n### Explanation:  \n- The property checks the vessel stability condition (`vessel_stability`) at every rising edge of `marine_clk`.  \n- If the ballast system is not ready (`!ballast_system_ready`), the property is disabled.  \n- When `vessel_stability` is true, the implication requires that:  \n  - If the `list_angle[7:0]` is greater than `8'd15`, the system should activate `counter_ballast`.  \n  - Otherwise, it should maintain the trim (`maintain_trim`).", "sva_signals": ["marine_clk", "ballast_system_ready", "[7:0] list_angle", "counter_ballast", "maintain_trim", "vessel_stability"], "clock": "marine_clk", "attempts_left": 10, "sva_result": "@(posedge marine_clk) disable iff (!ballast_system_ready)    vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)", "sva_name": "p_vessel_stability_check", "id": "0267", "full_property": "property p_vessel_stability_check;\n@(posedge marine_clk) disable iff (!ballast_system_ready)    vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)\nendproperty\nassert_p_vessel_stability_check:assert property (p_vessel_stability_check) else $error(\"\");", "task_id": "1_3131", "predict_sva": "@(posedge marine_clk) disable iff (!ballast_system_ready)    vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)"}
{"sva": "@(negedge clk_audio) disable iff(!audio_enable) sample_output |-> $past(dac_ready, 1) && ($past(volume_control) != 8'h00)", "sva_description": "### Assertion description:  \n**Property Name**: p_sample_output_condition  \n**Trigger Condition**: At every falling edge of the `clk_audio`  \n**Disable Condition**: `disable iff (!audio_enable)`  \n**Antecedent (LHS of Implication)**: `sample_output`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(dac_ready, 1) && ($past(volume_control) != 8'h00)`  ", "sva_signals": ["clk_audio", "audio_enable", "[0:0] sample_output", "dac_ready", "[7:0] volume_control"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(negedge clk_audio) disable iff (!audio_enable)     sample_output |-> $past(dac_ready, 1) && ($past(volume_control) != 8'h00)", "sva_name": "p_sample_output_condition", "id": "0072", "full_property": "property p_sample_output_condition;\n@(negedge clk_audio) disable iff (!audio_enable)     sample_output |-> $past(dac_ready, 1) && ($past(volume_control) != 8'h00)\nendproperty\nassert_p_sample_output_condition:assert property (p_sample_output_condition) else $error(\"\");", "task_id": "1_3901", "predict_sva": "@(negedge clk_audio) disable iff (!audio_enable)     sample_output |-> $past(dac_ready, 1) && ($past(volume_control) != 8'h00)"}
{"sva": "@(negedge clock) disable iff(reset) enable_ctrl |-> $past(status_reg[7:0], 2) != current_status", "sva_description": "### Assertion description:  \n**Property Name**: p_Enable_Ctrl_Status_Check  \n**Trigger Condition**: At every falling edge of the `clock`  \n**Disable Condition**: `disable iff (reset)`  \n**Antecedent (LHS of Implication)**: `enable_ctrl == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(status_reg[7:0], 2) != current_status`  ", "sva_signals": ["clock", "reset", "[0:0] enable_ctrl", "[7:0] status_reg", "[7:0] current_status"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (reset)     enable_ctrl == 1'b1 |-> $past(status_reg[7:0], 2) != current_status", "sva_name": "p_enable_ctrl_status_check", "id": "0188", "full_property": "property p_Enable_Ctrl_Status_Check;\n@(negedge clock) disable iff (reset)     enable_ctrl == 1'b1 |-> $past(status_reg[7:0], 2) != current_status\nendproperty\nassert_p_Enable_Ctrl_Status_Check:assert property (p_Enable_Ctrl_Status_Check) else $error(\"\");", "task_id": "1_4009", "predict_sva": "@(negedge clock) disable iff (reset)     enable_ctrl == 1'b1 |-> $past(status_reg[7:0], 2) != current_status"}
{"sva": "@(posedge dimensional_clk) disable iff(!portal_stabilized) interdimensional_gateway |-> (dimensional_barrier[11:0] ? maintain_portal : emergency_closure)", "sva_description": "### Assertion description:  \n**Property Name**: p_Interdimensional_Gateway_Check  \n**Trigger Condition**: At every rising edge of the `dimensional_clk`  \n**Disable Condition**: `disable iff (!portal_stabilized)`  \n**Antecedent (LHS of Implication)**: `interdimensional_gateway`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(dimensional_barrier[11:0] ? maintain_portal : emergency_closure)`  \n\n### Explanation:  \n- The property checks that whenever `interdimensional_gateway` is true at a rising edge of `dimensional_clk`, the following condition must hold:  \n  - If any bit in `dimensional_barrier[11:0]` is high, `maintain_portal` must be true.  \n  - If all bits in `dimensional_barrier[11:0]` are low, `emergency_closure` must be true.  \n- The assertion is disabled if `portal_stabilized` is not true (`!portal_stabilized`).", "sva_signals": ["dimensional_clk", "portal_stabilized", "[11:0] dimensional_barrier", "[0:0] interdimensional_gateway", "[0:0] maintain_portal", "[0:0] emergency_closure"], "clock": "dimensional_clk", "attempts_left": 10, "sva_result": "@(posedge dimensional_clk) disable iff (!portal_stabilized)    interdimensional_gateway |->         (|dimensional_barrier[11:0] ? maintain_portal : emergency_closure)", "sva_name": "p_interdimensional_gateway_check", "id": "0381", "full_property": "property p_Interdimensional_Gateway_Check;\n@(posedge dimensional_clk) disable iff (!portal_stabilized)    interdimensional_gateway |->         (|dimensional_barrier[11:0] ? maintain_portal : emergency_closure)\nendproperty\nassert_p_Interdimensional_Gateway_Check:assert property (p_Interdimensional_Gateway_Check) else $error(\"\");", "task_id": "1_3244", "predict_sva": "@(posedge dimensional_clk) disable iff (!portal_stabilized)    interdimensional_gateway |-> (dimensional_barrier[11:0] ? maintain_portal : emergency_closure)"}
{"sva": "@(posedge emergence_clk) disable iff(complexity_reduced) complex_system |-> (phase_transition[7:0] ? new_behavior : stable_pattern)", "sva_description": "### Assertion description:  \n**Property Name**: p_complex_system_behavior  \n**Trigger Condition**: At every rising edge of the `emergence_clk`  \n**Disable Condition**: disable iff (complexity_reduced)  \n**Antecedent (LHS of Implication)**: `complex_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(phase_transition[7:0] ? new_behavior : stable_pattern)`  \n\n### Explanation:  \n- The property checks the behavior of a complex system triggered by the rising edge of `emergence_clk`.  \n- The assertion is **disabled** when `complexity_reduced` is true.  \n- If `complex_system` is active (antecedent), then (implication `|->`) the system must exhibit:  \n  - `new_behavior` if any bit in `phase_transition[7:0]` is high (non-zero).  \n  - `stable_pattern` if `phase_transition[7:0]` is all zeros.  \n- The consequent uses a conditional operator (`?:`) to select between two outcomes based on `phase_transition`.", "sva_signals": ["emergence_clk", "complexity_reduced", "[0:0] complex_system", "[7:0] phase_transition", "[0:0] new_behavior", "[0:0] stable_pattern"], "clock": "emergence_clk", "attempts_left": 10, "sva_result": "@(posedge emergence_clk) disable iff (complexity_reduced)    complex_system |-> (|phase_transition[7:0] ? new_behavior : stable_pattern)", "sva_name": "p_complex_system_behavior", "id": "0251", "full_property": "property p_complex_system_behavior;\n@(posedge emergence_clk) disable iff (complexity_reduced)    complex_system |-> (|phase_transition[7:0] ? new_behavior : stable_pattern)\nendproperty\nassert_p_complex_system_behavior:assert property (p_complex_system_behavior) else $error(\"\");", "task_id": "1_3115", "predict_sva": "@(posedge emergence_clk) disable iff (complexity_reduced)    complex_system |-> (phase_transition[7:0] ? new_behavior : stable_pattern)"}
{"sva": "@(posedge clk_mesh) disable iff(mesh_reset) topology_routing |-> ($past(x_coordinate, 2) && $past(y_coordinate)) |=> !$past(routing_congestion)", "sva_description": "### Assertion description:  \n**Property Name**: p_Topology_Routing_Congestion  \n**Trigger Condition**: At every rising edge of the `clk_mesh`  \n**Disable Condition**: `disable iff (mesh_reset)`  \n**Antecedent (LHS of Implication)**: `topology_routing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(x_coordinate, 2) && $past(y_coordinate)) |=> !$past(routing_congestion)`  \n\n", "sva_signals": ["clk_mesh", "mesh_reset", "[0:0] topology_routing", "[0:0] x_coordinate", "[0:0] y_coordinate", "[0:0] routing_congestion"], "clock": "clk_mesh", "attempts_left": 10, "sva_result": "@(posedge clk_mesh) disable iff (mesh_reset)     topology_routing |-> ($past(x_coordinate, 2) && $past(y_coordinate)) |=> !$past(routing_congestion)", "sva_name": "p_topology_routing_check", "id": "0363", "full_property": "property p_Topology_Routing_Congestion;\n@(posedge clk_mesh) disable iff (mesh_reset)     topology_routing |-> ($past(x_coordinate, 2) && $past(y_coordinate)) |=> !$past(routing_congestion)\nendproperty\nassert_p_Topology_Routing_Congestion:assert property (p_Topology_Routing_Congestion) else $error(\"\");", "task_id": "1_4177", "predict_sva": "@(posedge clk_mesh) disable iff (mesh_reset)     topology_routing |-> ($past(x_coordinate, 2) && $past(y_coordinate)) |=> !$past(routing_congestion)"}
{"sva": "@(negedge clk_modulator) disable iff(modulation_off) carrier_modulation |-> $past(baseband_signal, 2) && ($past(carrier_frequency) && !$past(spurious_emission, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_carrier_modulation_check  \n**Trigger Condition**: At every falling edge of the `clk_modulator`  \n**Disable Condition**: disable iff (modulation_off)  \n**Antecedent (LHS of Implication)**: `carrier_modulation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(baseband_signal, 2) && ($past(carrier_frequency) && !$past(spurious_emission, 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] modulation_off", "[0:0] carrier_modulation", "[0:0] baseband_signal", "[0:0] carrier_frequency", "[0:0] spurious_emission", "clk_modulator"], "clock": "clk_modulator", "attempts_left": 10, "sva_result": "@(negedge clk_modulator) disable iff (modulation_off)     carrier_modulation == 1'b1 |->      $past(baseband_signal, 2) && ($past(carrier_frequency) && !$past(spurious_emission, 1))", "sva_name": "p_carrier_modulation_check", "id": "0320", "full_property": "property p_carrier_modulation_check;\n@(negedge clk_modulator) disable iff (modulation_off)     carrier_modulation == 1'b1 |->      $past(baseband_signal, 2) && ($past(carrier_frequency) && !$past(spurious_emission, 1))\nendproperty\nassert_p_carrier_modulation_check:assert property (p_carrier_modulation_check) else $error(\"\");", "task_id": "1_4136", "predict_sva": "@(negedge clk_modulator) disable iff (modulation_off)     carrier_modulation == 1'b1 |->      $past(baseband_signal, 2) && ($past(carrier_frequency) && !$past(spurious_emission))"}
{"sva": "@(posedge clk_mixer) disable iff(mixer_off) frequency_conversion |-> ($past(local_oscillator, 1) && $past(rf_input, 2)) && !$past(spurious_response, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Frequency_Conversion_Check  \n**Trigger Condition**: At every rising edge of the `clk_mixer`  \n**Disable Condition**: `disable iff (mixer_off)`  \n**Antecedent (LHS of Implication)**: `frequency_conversion`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(local_oscillator, 1) && $past(rf_input, 2)) && !$past(spurious_response, 3)`  ", "sva_signals": ["clk_mixer", "mixer_off", "[0:0] frequency_conversion", "[0:0] local_oscillator", "[0:0] rf_input", "[0:0] spurious_response"], "clock": "clk_mixer", "attempts_left": 10, "sva_result": "@(posedge clk_mixer) disable iff (mixer_off)     frequency_conversion |-> ($past(local_oscillator, 1) && $past(rf_input, 2)) && !$past(spurious_response, 3)", "sva_name": "p_frequency_conversion_check", "id": "0362", "full_property": "property p_Frequency_Conversion_Check;\n@(posedge clk_mixer) disable iff (mixer_off)     frequency_conversion |-> ($past(local_oscillator, 1) && $past(rf_input, 2)) && !$past(spurious_response, 3)\nendproperty\nassert_p_Frequency_Conversion_Check:assert property (p_Frequency_Conversion_Check) else $error(\"\");", "task_id": "1_4176", "predict_sva": "@(posedge clk_mixer) disable iff (mixer_off)     frequency_conversion |-> $past(local_oscillator, 1) && ($past(rf_input, 2) && !$past(spurious_response, 3))"}
{"sva": "@(posedge clk) disable iff(magnetic_fault) hall_sensor_interface |-> $past(magnetic_field, 1) && ($past(sensor_bias, 2) && $past(amplification_stage))", "sva_description": "### Assertion description:  \n**Property Name**: p_hall_sensor_interface_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (magnetic_fault)`  \n**Antecedent (LHS of Implication)**: `hall_sensor_interface`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(magnetic_field, 1) && ($past(sensor_bias, 2) && $past(amplification_stage))`  ", "sva_signals": ["clk", "[0:0] magnetic_fault", "[0:0] hall_sensor_interface", "[0:0] magnetic_field", "[0:0] sensor_bias", "[0:0] amplification_stage"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (magnetic_fault)     hall_sensor_interface |->          $past(magnetic_field, 1) && ($past(sensor_bias, 2) && $past(amplification_stage))", "sva_name": "p_hall_sensor_interface_check", "id": "0373", "full_property": "property p_hall_sensor_interface_check;\n@(posedge clk) disable iff (magnetic_fault)     hall_sensor_interface |->          $past(magnetic_field, 1) && ($past(sensor_bias, 2) && $past(amplification_stage))\nendproperty\nassert_p_hall_sensor_interface_check:assert property (p_hall_sensor_interface_check) else $error(\"\");", "task_id": "1_4186", "predict_sva": "@(posedge clk) disable iff (magnetic_fault)     hall_sensor_interface |->          $past(magnetic_field, 1) &&          ($past(sensor_bias, 2) && $past(amplification_stage))"}
{"sva": "@(negedge pipeline_clk) disable iff(leak_detected) flow_monitor |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)", "sva_description": "### Assertion description:  \n**Property Name**: p_flow_monitor_check  \n**Trigger Condition**: At every negedge of the `pipeline_clk`  \n**Disable Condition**: disable iff (leak_detected)  \n**Antecedent (LHS of Implication)**: `flow_monitor == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(pressure_differential[11:0] ? isolation_valve : maintain_flow)`  \n\n### Explanation:  \n1. The property evaluates on every **falling edge** of `pipeline_clk`.  \n2. The check is **disabled** if `leak_detected` is asserted (active-high).  \n3. If `flow_monitor` is high (**antecedent**), the **consequent** must hold:  \n   - If `pressure_differential[11:0]` is non-zero, `isolation_valve` is the expected output.  \n   - Otherwise, `maintain_flow` is the expected output.  \n4. The ternary operator (`? :`) acts as a conditional selector in the consequent.  \n\n### Key Notes:  \n- The assertion ensures correct valve control (isolation/maintenance) based on pressure readings when flow monitoring is active.  \n- The **disable condition** prioritizes safety (disabling checks during leaks).  \n- The **negedge trigger** suggests this check aligns with a specific phase of the pipeline operation.", "sva_signals": ["pipeline_clk", "leak_detected", "[0:0] flow_monitor", "[11:0] pressure_differential", "isolation_valve", "maintain_flow"], "clock": "pipeline_clk", "attempts_left": 10, "sva_result": "@(negedge pipeline_clk) disable iff (leak_detected)    flow_monitor == 1'b1 |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)", "sva_name": "p_flow_monitor_check", "id": "0272", "full_property": "property p_flow_monitor_check;\n@(negedge pipeline_clk) disable iff (leak_detected)    flow_monitor == 1'b1 |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)\nendproperty\nassert_p_flow_monitor_check:assert property (p_flow_monitor_check) else $error(\"\");", "task_id": "1_3136", "predict_sva": "@(negedge pipeline_clk) disable iff (leak_detected == 1'b1)    flow_monitor == 1'b1 |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)"}
{"sva": "@(negedge sqrt_clk) disable iff(negative_input) square_root_unit |-> (input_zero ? zero_result : (perfect_square_detected ? integer_root : fractional_approximation))", "sva_description": "### Assertion description:  \n**Property Name**: p_square_root_check  \n**Trigger Condition**: At every negedge of the `sqrt_clk`  \n**Disable Condition**: disable iff (negative_input)  \n**Antecedent (LHS of Implication)**: `square_root_unit`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(input_zero ? zero_result : (perfect_square_detected ? integer_root : fractional_approximation))`  \n\n### Explanation:  \n1. The property is evaluated on every falling edge of `sqrt_clk`.  \n2. The assertion is disabled if `negative_input` is true (active-high reset condition).  \n3. The antecedent checks if `square_root_unit` is true (non-zero).  \n4. If the antecedent holds, the consequent must evaluate to:  \n   - `zero_result` if `input_zero` is true,  \n   - `integer_root` if `perfect_square_detected` is true,  \n   - `fractional_approximation` otherwise.  \n\nThe assertion ensures the square root unit's output matches the expected result based on the input conditions.", "sva_signals": ["sqrt_clk", "negative_input", "[0:0] input_zero", "[0:0] perfect_square_detected", "[0:0] zero_result", "[0:0] integer_root", "[0:0] fractional_approximation", "[0:0] square_root_unit"], "clock": "sqrt_clk", "attempts_left": 10, "sva_result": "@(negedge sqrt_clk) disable iff (negative_input)    square_root_unit |->         (input_zero ? zero_result :             (perfect_square_detected ? integer_root : fractional_approximation))", "sva_name": "p_SquareRootUnitCheck", "id": "0465", "full_property": "property p_square_root_check;\n@(negedge sqrt_clk) disable iff (negative_input)    square_root_unit |->         (input_zero ? zero_result :             (perfect_square_detected ? integer_root : fractional_approximation))\nendproperty\nassert_p_square_root_check:assert property (p_square_root_check) else $error(\"\");", "task_id": "1_3326", "predict_sva": "@(negedge sqrt_clk) disable iff (negative_input)    square_root_unit |->         (input_zero ? zero_result :             (perfect_square_detected ? integer_root : fractional_approximation))"}
{"id": "17_92_1522", "name": "p_multi_clock_92", "sva": "@(posedge clk_1) p_t |-> @(posedge clk_2) p_p", "sva_description": "### Assertion description:  \n**Property Name**: (Not specified in the given SVA, but can be named as `p_cross_clock_implication` for reference)  \n**Trigger Condition**: At every posedge of `clk_1` (initial trigger)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `p_t` evaluates to true at the rising edge of `clk_1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `p_p` must evaluate to true at the **next subsequent rising edge of `clk_2`** after the antecedent is satisfied.  \n\n### Key Notes:  \n1. **Cross-Clock Behavior**: The assertion spans two clock domains (`clk_1` and `clk_2`). The antecedent (`p_t`) is evaluated on `clk_1`, while the consequent (`p_p`) is checked on the **immediately following** `posedge clk_2` (not necessarily the next cycle of `clk_1`).  \n2. **Temporal Relationship**: The `##1` in the implication is implicitly tied to the next `posedge clk_2`, not a fixed number of `clk_1` cycles.  \n3. **Disable Condition**: Absent in the given SVA, so the property is always active unless embedded in a context with a global reset.  \n\n### Example Interpretation:  \nIf `p_t` is true at `posedge clk_1` (time T), then `p_p` must be true at the **first** `posedge clk_2` occurring after time T. The clocks (`clk_1` and `clk_2`) can have any phase or frequency relationship.", "sva_signals": ["clk_1", "clk_2", "[0:0] p_t", "[0:0] p_p"], "clock": "clk_1", "attempts_left": 10, "sva_result": "@(posedge clk_1) p_t |-> @(posedge clk_2) p_p", "sva_name": "p_cross_clock_trigger", "full_property": "property p_cross_clock_implication;\n@(posedge clk_1) p_t |-> @(posedge clk_2) p_p\nendproperty\nassert_p_cross_clock_implication:assert property (p_cross_clock_implication) else $error(\"\");", "task_id": "1_2601", "predict_sva": "@(posedge clk_1) p_t |-> @(posedge clk_2) p_p"}
{"sva": "@(posedge recommendation_clk) disable iff(!user_preferences_known) collaborative_filtering |-> (content_based ? (item_features_available ? feature_matching : popularity_based) : user_similarity)", "sva_description": "### Assertion description:  \n**Property Name**: p_Collaborative_Filtering_Recommendation  \n**Trigger Condition**: At every rising edge of the `recommendation_clk`  \n**Disable Condition**: `disable iff (!user_preferences_known)`  \n**Antecedent (LHS of Implication)**: `collaborative_filtering`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(content_based ? (item_features_available ? feature_matching : popularity_based) : user_similarity)`  \n\n### Explanation of the Consequent:  \nThe consequent is a conditional (ternary) expression that selects one of three outcomes based on the following logic:  \n1. If `content_based` is true:  \n   - Further checks if `item_features_available` is true:  \n     - If true, selects `feature_matching`.  \n     - If false, selects `popularity_based`.  \n2. If `content_based` is false, selects `user_similarity`.  \n\nThis property asserts that when `collaborative_filtering` is active, the recommendation method must follow the described conditional logic. The assertion is disabled if `user_preferences_known` is false.", "sva_signals": ["recommendation_clk", "[0:0] user_preferences_known", "[0:0] collaborative_filtering", "[0:0] content_based", "[0:0] item_features_available", "[0:0] feature_matching", "[0:0] popularity_based", "[0:0] user_similarity"], "clock": "recommendation_clk", "attempts_left": 10, "sva_result": "@(posedge recommendation_clk) disable iff (!user_preferences_known)    collaborative_filtering |->         (content_based ? (item_features_available ? feature_matching : popularity_based) : user_similarity)", "sva_name": "p_Collaborative_Filtering_Recommendation", "id": "0503", "full_property": "property p_Collaborative_Filtering_Recommendation;\n@(posedge recommendation_clk) disable iff (!user_preferences_known)    collaborative_filtering |->         (content_based ? (item_features_available ? feature_matching : popularity_based) : user_similarity)\nendproperty\nassert_p_Collaborative_Filtering_Recommendation:assert property (p_Collaborative_Filtering_Recommendation) else $error(\"\");", "task_id": "1_3363", "predict_sva": "@(posedge recommendation_clk) disable iff (!user_preferences_known)    collaborative_filtering |->         (content_based ? (item_features_available ? feature_matching : popularity_based) : user_similarity)"}
{"id": "17_86_1513", "name": "p_multi_clock_86", "sva": "@(posedge clk_a) a_d |-> @(posedge clk_b) b_y", "sva_description": "### Assertion description:  \n**Property Name**: p_a_d_to_b_y  \n**Trigger Condition**: At every posedge of `clk_a`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `a_d == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: At the next posedge of `clk_b`, `b_y` must be true (1'b1)  \n\n### Explanation:  \n1. The property checks a cross-clock domain implication where the antecedent (`a_d`) is evaluated at the rising edge of `clk_a`.  \n2. If `a_d` is true (1'b1), the consequent requires that `b_y` must be true (1'b1) at the **next subsequent rising edge** of `clk_b`.  \n3. The assertion does not have a disable condition (`disable iff`).  \n4. The property implicitly assumes `a_d` and `b_y` are single-bit signals (hence `a_d` and `b_y` are treated as Boolean conditions).  \n\n### Note:  \n- The property describes a **synchronization requirement** between two clock domains (`clk_a` and `clk_b`).  \n- The time between `a_d` being true and `b_y` being checked is determined by the arrival of the next `clk_b` edge after the `clk_a` edge where `a_d` is sampled.  \n- If `clk_b` is slower than `clk_a`, multiple `clk_a` edges may occur before the consequent is evaluated.", "sva_signals": ["clk_a", "clk_b", "[0:0] a_d", "[0:0] b_y"], "clock": "clk_a", "attempts_left": 10, "sva_result": "@(posedge clk_a)     a_d == 1'b1 |-> @(posedge clk_b) b_y == 1'b1", "sva_name": "p_a_d_to_b_y", "full_property": "property p_a_d_to_b_y;\n@(posedge clk_a)     a_d == 1'b1 |-> @(posedge clk_b) b_y == 1'b1\nendproperty\nassert_p_a_d_to_b_y:assert property (p_a_d_to_b_y) else $error(\"\");", "task_id": "1_2594", "predict_sva": "@(posedge clk_a)     a_d == 1'b1 |-> @(posedge clk_b) b_y == 1'b1"}
{"sva": "@(posedge fabric_clk) disable iff(!loom_operational) textile_weaver |-> (thread_tension[7:0] > 8'd120 ? (pattern_error ? emergency_stop : reduce_speed) : normal_weaving)", "sva_description": "### Assertion description:  \n**Property Name**: p_Textile_Weaver_Safety  \n**Trigger Condition**: At every rising edge of `fabric_clk`  \n**Disable Condition**: `disable iff (!loom_operational)`  \n**Antecedent (LHS of Implication)**: `textile_weaver`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(thread_tension[7:0] > 8'd120) ? (pattern_error ? emergency_stop : reduce_speed) : normal_weaving`  \n\n### Explanation:  \n1. The property checks the safety logic of a textile loom during weaving.  \n2. When `textile_weaver` is active (antecedent), the system must respond as follows (consequent):  \n   - If `thread_tension` exceeds `120` (8-bit value), further actions depend on `pattern_error`:  \n     - If `pattern_error` is true, trigger `emergency_stop`.  \n     - Else, activate `reduce_speed`.  \n   - If `thread_tension` is  `120`, continue `normal_weaving`.  \n3. The check is disabled if `loom_operational` is false (safety override).", "sva_signals": ["fabric_clk", "loom_operational", "[0:0] textile_weaver", "[7:0] thread_tension", "[0:0] pattern_error", "[0:0] emergency_stop", "[0:0] reduce_speed", "[0:0] normal_weaving"], "clock": "fabric_clk", "attempts_left": 10, "sva_result": "@(posedge fabric_clk) disable iff (!loom_operational)    textile_weaver |-> (        (thread_tension[7:0] > 8'd120) ?             (pattern_error ? emergency_stop : reduce_speed) :             normal_weaving    )", "sva_name": "p_textile_loom_safety_check", "id": "0509", "full_property": "property p_Textile_Weaver_Safety;\n@(posedge fabric_clk) disable iff (!loom_operational)    textile_weaver |-> (        (thread_tension[7:0] > 8'd120) ?             (pattern_error ? emergency_stop : reduce_speed) :             normal_weaving    )\nendproperty\nassert_p_Textile_Weaver_Safety:assert property (p_Textile_Weaver_Safety) else $error(\"\");", "task_id": "1_3369", "predict_sva": "@(posedge fabric_clk) disable iff (!loom_operational)    textile_weaver |->         (thread_tension[7:0] > 8'd120 ?             (pattern_error ? emergency_stop : reduce_speed) :             normal_weaving)"}
{"sva": "@(posedge clk_retail) disable iff(customer_service_fault) retail_robotics |-> ($past(product_recommendation, 1) && $past(inventory_management, 2)) && !$past(customer_dissatisfaction, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Retail_Robotics_Check  \n**Trigger Condition**: At every rising edge of `clk_retail`  \n**Disable Condition**: `disable iff (customer_service_fault)`  \n**Antecedent (LHS of Implication)**: `retail_robotics == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(product_recommendation, 1) && $past(inventory_management, 2)) && !$past(customer_dissatisfaction, 3)`  ", "sva_signals": ["clk_retail", "customer_service_fault", "[0:0] retail_robotics", "[0:0] product_recommendation", "[0:0] inventory_management", "[0:0] customer_dissatisfaction"], "clock": "clk_retail", "attempts_left": 10, "sva_result": "@(posedge clk_retail) disable iff (customer_service_fault)     retail_robotics == 1'b1 |->          ($past(product_recommendation, 1) && $past(inventory_management, 2)) &&          !$past(customer_dissatisfaction, 3)", "sva_name": "p_Retail_Robotics_Check", "id": "0503", "full_property": "property p_Retail_Robotics_Check;\n@(posedge clk_retail) disable iff (customer_service_fault)     retail_robotics == 1'b1 |->          ($past(product_recommendation, 1) && $past(inventory_management, 2)) &&          !$past(customer_dissatisfaction, 3)\nendproperty\nassert_p_Retail_Robotics_Check:assert property (p_Retail_Robotics_Check) else $error(\"\");", "task_id": "1_4310", "predict_sva": "@(posedge clk_retail) disable iff (customer_service_fault)     retail_robotics == 1'b1 |->      ($past(product_recommendation, 1) && $past(inventory_management, 2)) &&      !$past(customer_dissatisfaction, 3)"}
{"sva": "@(negedge sampling_clk) disable iff(!rst_async) adc_sample |-> $past(input_stable) && ($past(reference_voltage, 2) && $past(converter_ready))", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_sample_condition  \n**Trigger Condition**: At every falling edge of the `sampling_clk`  \n**Disable Condition**: disable iff (!rst_async)  \n**Antecedent (LHS of Implication)**: `adc_sample == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(input_stable)` must be true (i.e., `input_stable` was true in the previous cycle), AND  \n- `$past(reference_voltage, 2)` must be true (i.e., `reference_voltage` was true two cycles ago), AND  \n- `$past(converter_ready)` must be true (i.e., `converter_ready` was true in the previous cycle).  \n\n### Notes:  \n1. The assertion checks that when `adc_sample` is active (1), the conditions `input_stable`, `reference_voltage` (delayed by 2 cycles), and `converter_ready` (delayed by 1 cycle) must have been met in the past.  \n2. The assertion is asynchronously disabled if `rst_async` is low (`!rst_async`).  \n3. The evaluation occurs at the **negedge** of `sampling_clk`.", "sva_signals": ["sampling_clk", "rst_async", "[0:0] adc_sample", "[0:0] input_stable", "[0:0] reference_voltage", "[0:0] converter_ready"], "clock": "sampling_clk", "attempts_left": 10, "sva_result": "@(negedge sampling_clk) disable iff (!rst_async)     adc_sample == 1'b1 |->          $past(input_stable) &&          $past(reference_voltage, 2) &&          $past(converter_ready)", "sva_name": "p_adc_sample_condition", "id": "0218", "full_property": "property p_adc_sample_condition;\n@(negedge sampling_clk) disable iff (!rst_async)     adc_sample == 1'b1 |->          $past(input_stable) &&          $past(reference_voltage, 2) &&          $past(converter_ready)\nendproperty\nassert_p_adc_sample_condition:assert property (p_adc_sample_condition) else $error(\"\");", "task_id": "1_4037", "predict_sva": "@(negedge sampling_clk) disable iff (!rst_async)     adc_sample == 1'b1 |-> $past(input_stable, 1) && ($past(reference_voltage, 2) && $past(converter_ready))"}
{"sva": "@(posedge clk_skyrmion) disable iff(skyrmion_annihilation) topological_spin_texture |-> ($past(dzyaloshinskii_moriya_interaction, 1) && $past(magnetic_anisotropy, 3)) && $past(topological_charge)", "sva_description": "### Assertion description:  \n**Property Name**: p_Topological_Spin_Texture_Check  \n**Trigger Condition**: At every rising edge of the `clk_skyrmion`  \n**Disable Condition**: `disable iff (skyrmion_annihilation)`  \n**Antecedent (LHS of Implication)**: `topological_spin_texture`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(dzyaloshinskii_moriya_interaction, 1) && $past(magnetic_anisotropy, 3)) && $past(topological_charge)`  ", "sva_signals": ["clk_skyrmion", "skyrmion_annihilation", "[0:0] topological_spin_texture", "[0:0] dzyaloshinskii_moriya_interaction", "[0:0] magnetic_anisotropy", "[0:0] topological_charge"], "clock": "clk_skyrmion", "attempts_left": 10, "sva_result": "@(posedge clk_skyrmion) disable iff (skyrmion_annihilation)     topological_spin_texture |->          ($past(dzyaloshinskii_moriya_interaction, 1) && $past(magnetic_anisotropy, 3)) && $past(topological_charge)", "sva_name": "p_topological_spin_texture_check", "id": "0456", "full_property": "property p_Topological_Spin_Texture_Check;\n@(posedge clk_skyrmion) disable iff (skyrmion_annihilation)     topological_spin_texture |->          ($past(dzyaloshinskii_moriya_interaction, 1) && $past(magnetic_anisotropy, 3)) && $past(topological_charge)\nendproperty\nassert_p_Topological_Spin_Texture_Check:assert property (p_Topological_Spin_Texture_Check) else $error(\"\");", "task_id": "1_4265", "predict_sva": "@(posedge clk_skyrmion) disable iff (skyrmion_annihilation)     topological_spin_texture |->          $past(dzyaloshinskii_moriya_interaction, 1) &&          ($past(magnetic_anisotropy, 3) && $past(topological_charge))"}
{"sva": "@(posedge clk_brain_interface) disable iff(neural_noise_high) thought_controlled_computing |-> ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Thought_Controlled_Computing  \n**Trigger Condition**: At every rising edge of the `clk_brain_interface`  \n**Disable Condition**: `disable iff (neural_noise_high)`  \n**Antecedent (LHS of Implication)**: `thought_controlled_computing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)`  ", "sva_signals": ["clk_brain_interface", "neural_noise_high", "thought_controlled_computing", "[0:0] eeg_signal_processing", "[0:0] motor_imagery", "[0:0] classification_accuracy"], "clock": "clk_brain_interface", "attempts_left": 10, "sva_result": "@(posedge clk_brain_interface) disable iff (neural_noise_high)     thought_controlled_computing |->          ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)", "sva_name": "p_Thought_Controlled_Computing", "id": "0538", "full_property": "property p_Thought_Controlled_Computing;\n@(posedge clk_brain_interface) disable iff (neural_noise_high)     thought_controlled_computing |->          ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)\nendproperty\nassert_p_Thought_Controlled_Computing:assert property (p_Thought_Controlled_Computing) else $error(\"\");", "task_id": "1_4342", "predict_sva": "@(posedge clk_brain_interface) disable iff (neural_noise_high)     thought_controlled_computing |->          ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)"}
{"sva": "@(posedge mixing_clk) disable iff(!ingredients_measured) chemical_reactor |-> (reaction_temperature[11:0] ? (catalyst_active ? accelerated_reaction : thermal_reaction) : preheat_mixture)", "sva_description": "### Assertion description:\n**Property Name**: p_chemical_reactor_reaction  \n**Trigger Condition**: At every rising edge of the `mixing_clk`  \n**Disable Condition**: disable iff (!ingredients_measured)  \n**Antecedent (LHS of Implication)**: `chemical_reactor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(reaction_temperature[11:0] ? (catalyst_active ? accelerated_reaction : thermal_reaction) : preheat_mixture)`  \n\n**Consequent Explanation**:  \nThe consequent is a nested ternary operation that checks:  \n1. If `reaction_temperature[11:0]` is non-zero:  \n   - Then check `catalyst_active`:  \n     - If true: proceed with `accelerated_reaction`  \n     - If false: proceed with `thermal_reaction`  \n2. If `reaction_temperature[11:0]` is zero: proceed with `preheat_mixture`  \n\n**Note**: The assertion verifies that when the chemical reactor is active (`chemical_reactor` is true), the reaction type must match the expected behavior based on the current temperature and catalyst status. The check is disabled if ingredients are not measured (`!ingredients_measured`).", "sva_signals": ["mixing_clk", "ingredients_measured", "chemical_reactor", "[11:0] reaction_temperature", "catalyst_active", "accelerated_reaction", "thermal_reaction", "preheat_mixture"], "clock": "mixing_clk", "attempts_left": 10, "sva_result": "@(posedge mixing_clk) disable iff (!ingredients_measured)    chemical_reactor |-> (reaction_temperature[11:0] ? (catalyst_active ? accelerated_reaction : thermal_reaction) : preheat_mixture)", "sva_name": "p_chemical_reactor_check", "id": "0532", "full_property": "property p_chemical_reactor_reaction;\n@(posedge mixing_clk) disable iff (!ingredients_measured)    chemical_reactor |-> (reaction_temperature[11:0] ? (catalyst_active ? accelerated_reaction : thermal_reaction) : preheat_mixture)\nendproperty\nassert_p_chemical_reactor_reaction:assert property (p_chemical_reactor_reaction) else $error(\"\");", "task_id": "1_3392", "predict_sva": "@(posedge mixing_clk) disable iff (!ingredients_measured)    chemical_reactor |->         (reaction_temperature[11:0] ?             (catalyst_active ? accelerated_reaction : thermal_reaction) :             preheat_mixture)"}
{"sva": "@(negedge clk_display) disable iff(display_sleep) pixel_generation |-> $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_Pixel_Generation_Check  \n**Trigger Condition**: At every falling edge of the `clk_display`  \n**Disable Condition**: `disable iff (display_sleep)`  \n**Antecedent (LHS of Implication)**: `pixel_generation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))`  ", "sva_signals": ["clk_display", "display_sleep", "[0:0] pixel_generation", "[0:0] timing_reference", "[0:0] color_correction", "[0:0] brightness_control"], "clock": "clk_display", "attempts_left": 10, "sva_result": "@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))", "sva_name": "p_pixel_generation_check", "id": "0257", "full_property": "property p_Pixel_Generation_Check;\n@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      $past(timing_reference, 1) && ($past(color_correction) && $past(brightness_control, 2))\nendproperty\nassert_p_Pixel_Generation_Check:assert property (p_Pixel_Generation_Check) else $error(\"\");", "task_id": "1_4075", "predict_sva": "@(negedge clk_display) disable iff (display_sleep)     pixel_generation == 1'b1 |->      ($past(timing_reference, 1) && $past(color_correction)) && $past(brightness_control, 2)"}
{"sva": "@(posedge lcd_clk) disable iff(!display_power) lcd_controller |-> (refresh_needed ? (vsync_active ? start_refresh : wait_vsync) : display_stable)", "sva_description": "### Assertion description:  \n**Property Name**: p_LCD_Controller_Behavior  \n**Trigger Condition**: At every rising edge of the `lcd_clk`  \n**Disable Condition**: `disable iff (!display_power)`  \n**Antecedent (LHS of Implication)**: `lcd_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(refresh_needed ? (vsync_active ? start_refresh : wait_vsync) : display_stable)`  \n\n### Explanation:  \nThe property checks the behavior of the LCD controller based on the following conditions:  \n1. If `refresh_needed` is true:  \n   - If `vsync_active` is true, the controller should transition to `start_refresh`.  \n   - If `vsync_active` is false, the controller should transition to `wait_vsync`.  \n2. If `refresh_needed` is false, the controller should remain in `display_stable`.  \n\nThe assertion is disabled when `display_power` is low (`!display_power`).", "sva_signals": ["lcd_clk", "[0:0] display_power", "[0:0] lcd_controller", "[0:0] refresh_needed", "[0:0] vsync_active", "[0:0] start_refresh", "[0:0] wait_vsync", "[0:0] display_stable"], "clock": "lcd_clk", "attempts_left": 10, "sva_result": "@(posedge lcd_clk) disable iff (!display_power)    lcd_controller |-> (refresh_needed ? (vsync_active ? start_refresh : wait_vsync) : display_stable)", "sva_name": "p_lcd_controller_behavior", "id": "0881", "full_property": "property p_LCD_Controller_Behavior;\n@(posedge lcd_clk) disable iff (!display_power)    lcd_controller |-> (refresh_needed ? (vsync_active ? start_refresh : wait_vsync) : display_stable)\nendproperty\nassert_p_LCD_Controller_Behavior:assert property (p_LCD_Controller_Behavior) else $error(\"\");", "task_id": "1_3720", "predict_sva": "@(posedge lcd_clk) disable iff (!display_power)    lcd_controller |-> (refresh_needed ? (vsync_active ? start_refresh : wait_vsync) : display_stable)"}
{"sva": "@(posedge clk_library_access) disable iff(resource_misuse) academic_authentication |-> ($past(student_library_card, 1) && $past(research_database_access, 3)) && $past(usage_tracking)", "sva_description": "### Assertion description:  \n**Property Name**: p_academic_authentication  \n**Trigger Condition**: At every rising edge of the `clk_library_access`  \n**Disable Condition**: disable iff (resource_misuse)  \n**Antecedent (LHS of Implication)**: `academic_authentication`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(student_library_card, 1) && $past(research_database_access, 3)) && $past(usage_tracking)`  ", "sva_signals": ["clk_library_access", "resource_misuse", "[0:0] academic_authentication", "[0:0] student_library_card", "[0:0] research_database_access", "[0:0] usage_tracking"], "clock": "clk_library_access", "attempts_left": 10, "sva_result": "@(posedge clk_library_access) disable iff (resource_misuse)     academic_authentication |-> ($past(student_library_card, 1) && $past(research_database_access, 3)) && $past(usage_tracking)", "sva_name": "p_Academic_Authentication_Check", "id": "0645", "full_property": "property p_academic_authentication;\n@(posedge clk_library_access) disable iff (resource_misuse)     academic_authentication |-> ($past(student_library_card, 1) && $past(research_database_access, 3)) && $past(usage_tracking)\nendproperty\nassert_p_academic_authentication:assert property (p_academic_authentication) else $error(\"\");", "task_id": "1_4442", "predict_sva": "@(posedge clk_library_access) disable iff (resource_misuse)     academic_authentication |->          $past(student_library_card, 1) &&          ($past(research_database_access, 3) && $past(usage_tracking))"}
{"sva": "@(posedge clk) disable iff(system_rst) cache_miss && $past(cache_access) |-> memory_request", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_miss_memory_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (system_rst)`  \n**Antecedent (LHS of Implication)**: `cache_miss && $past(cache_access)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `memory_request`", "sva_signals": ["clk", "system_rst", "[0:0] cache_miss", "[0:0] cache_access", "[0:0] memory_request"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (system_rst)         cache_miss && $past(cache_access) |-> memory_request", "sva_name": "p_cache_miss_memory_request", "id": "1048", "full_property": "property p_cache_miss_memory_request;\n@(posedge clk) disable iff (system_rst)         cache_miss && $past(cache_access) |-> memory_request\nendproperty\nassert_p_cache_miss_memory_request:assert property (p_cache_miss_memory_request) else $error(\"\");", "task_id": "1_4815", "predict_sva": "@(posedge clk) disable iff (system_rst)         (cache_miss && $past(cache_access)) |-> memory_request"}
{"sva": "@(posedge clk_avalon) disable iff(!avalon_rst_n) burst_transfer |-> $past(burst_count, 1) && ($past(waitrequest) == 1'b0) && $past(address_increment, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_burst_transfer_check  \n**Trigger Condition**: At every rising edge of the `clk_avalon`  \n**Disable Condition**: disable iff (`!avalon_rst_n`)  \n**Antecedent (LHS of Implication)**: `burst_transfer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(burst_count, 1) && ($past(waitrequest) == 1'b0) && $past(address_increment, 2)`  ", "sva_signals": ["clk_avalon", "avalon_rst_n", "[0:0] burst_transfer", "[0:0] burst_count", "[0:0] waitrequest", "[0:0] address_increment"], "clock": "clk_avalon", "attempts_left": 10, "sva_result": "@(posedge clk_avalon) disable iff (!avalon_rst_n)     burst_transfer |-> ($past(burst_count, 1) && ($past(waitrequest) == 1'b0) && $past(address_increment, 2))", "sva_name": "p_burst_transfer_check", "id": "0341", "full_property": "property p_burst_transfer_check;\n@(posedge clk_avalon) disable iff (!avalon_rst_n)     burst_transfer |-> ($past(burst_count, 1) && ($past(waitrequest) == 1'b0) && $past(address_increment, 2))\nendproperty\nassert_p_burst_transfer_check:assert property (p_burst_transfer_check) else $error(\"\");", "task_id": "1_4155", "predict_sva": "@(posedge clk_avalon) disable iff (!avalon_rst_n)     burst_transfer |-> ($past(burst_count, 1) && !$past(waitrequest) && $past(address_increment, 2))"}
{"sva": "@(negedge clk) uart_transmit && $past(tx_buffer_loaded) |-> tx_shift_reg != 8'h00", "sva_description": "### Assertion description:  \n**Property Name**: p_Uart_Transmit_NonZero  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `uart_transmit && $past(tx_buffer_loaded)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tx_shift_reg != 8'h00`", "sva_signals": ["clk", "rst_n", "[0:0] uart_transmit", "[0:0] tx_buffer_loaded", "[7:0] tx_shift_reg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (uart_transmit && $past(tx_buffer_loaded)) |-> (tx_shift_reg != 8'h00)", "sva_name": "p_Uart_Transmit_Check", "id": "1033", "full_property": "property p_Uart_Transmit_NonZero;\n@(negedge clk)     (uart_transmit && $past(tx_buffer_loaded)) |-> (tx_shift_reg != 8'h00)\nendproperty\nassert_p_Uart_Transmit_NonZero:assert property (p_Uart_Transmit_NonZero) else $error(\"\");", "task_id": "1_4800", "predict_sva": "@(negedge clk)     (uart_transmit && $past(tx_buffer_loaded)) |-> (tx_shift_reg != 8'h00)"}
{"sva": "@(posedge clk) disable iff(!exoplanet_detection_active) transit_photometry |-> $past(stellar_brightness_variation, 2) && ($past(periodic_dimming) && $past(planet_radius_calculation, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_TransitPhotometryCheck  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!exoplanet_detection_active)`  \n**Antecedent (LHS of Implication)**: `transit_photometry == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(stellar_brightness_variation, 2) && ($past(periodic_dimming) && $past(planet_radius_calculation, 1))`  ", "sva_signals": ["clk", "exoplanet_detection_active", "[0:0] transit_photometry", "[0:0] stellar_brightness_variation", "[0:0] periodic_dimming", "[0:0] planet_radius_calculation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!exoplanet_detection_active)     transit_photometry == 1'b1 |->          $past(stellar_brightness_variation, 2) &&          ($past(periodic_dimming) && $past(planet_radius_calculation, 1))", "sva_name": "p_transit_photometry_check", "id": "0562", "full_property": "property p_TransitPhotometryCheck;\n@(posedge clk) disable iff (!exoplanet_detection_active)     transit_photometry == 1'b1 |->          $past(stellar_brightness_variation, 2) &&          ($past(periodic_dimming) && $past(planet_radius_calculation, 1))\nendproperty\nassert_p_TransitPhotometryCheck:assert property (p_TransitPhotometryCheck) else $error(\"\");", "task_id": "1_4366", "predict_sva": "@(posedge clk) disable iff (!exoplanet_detection_active)     transit_photometry == 1'b1 |->      $past(stellar_brightness_variation, 2) &&      ($past(periodic_dimming) && $past(planet_radius_calculation, 1))"}
{"sva": "@(negedge clk_supernova) disable iff(explosion_modeling_error) stellar_death |-> $past(core_collapse_simulation, 3) && ($past(neutrino_emission) || $past(heavy_element_synthesis, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_stellar_death_sequence  \n**Trigger Condition**: At every falling edge of the `clk_supernova`  \n**Disable Condition**: disable iff (`explosion_modeling_error`)  \n**Antecedent (LHS of Implication)**: `stellar_death`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(core_collapse_simulation, 3) && ($past(neutrino_emission) || $past(heavy_element_synthesis, 1))`  ", "sva_signals": ["clk_supernova", "explosion_modeling_error", "[0:0] stellar_death", "[0:0] core_collapse_simulation", "[0:0] neutrino_emission", "[0:0] heavy_element_synthesis"], "clock": "clk_supernova", "attempts_left": 10, "sva_result": "@(negedge clk_supernova) disable iff (explosion_modeling_error)     stellar_death |-> $past(core_collapse_simulation, 3) &&                       ($past(neutrino_emission) || $past(heavy_element_synthesis, 1))", "sva_name": "p_Stellar_Death_Condition", "id": "0583", "full_property": "property p_stellar_death_sequence;\n@(negedge clk_supernova) disable iff (explosion_modeling_error)     stellar_death |-> $past(core_collapse_simulation, 3) &&                       ($past(neutrino_emission) || $past(heavy_element_synthesis, 1))\nendproperty\nassert_p_stellar_death_sequence:assert property (p_stellar_death_sequence) else $error(\"\");", "task_id": "1_4385", "predict_sva": "@(negedge clk_supernova) disable iff (explosion_modeling_error)     stellar_death |-> $past(core_collapse_simulation, 3) &&                           ($past(neutrino_emission) || $past(heavy_element_synthesis, 1))"}
{"sva": "@(posedge clock) flash_program && $past(erase_complete) && $past(data_ready) |-> program_start", "sva_description": "### Assertion description:  \n**Property Name**: p_Program_Start_Condition  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flash_program && $past(erase_complete) && $past(data_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `program_start`", "sva_signals": ["clock", "[0:0] flash_program", "[0:0] erase_complete", "[0:0] data_ready", "[0:0] program_start"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock)         flash_program && $past(erase_complete) && $past(data_ready) |-> program_start", "sva_name": "p_flash_program_trigger", "id": "1050", "full_property": "property p_Program_Start_Condition;\n@(posedge clock)         flash_program && $past(erase_complete) && $past(data_ready) |-> program_start\nendproperty\nassert_p_Program_Start_Condition:assert property (p_Program_Start_Condition) else $error(\"\");", "task_id": "1_4817", "predict_sva": "@(posedge clock)         (flash_program && $past(erase_complete) && $past(data_ready)) |-> program_start"}
{"sva": "@(posedge clk) disable iff(!environmental_data_integration) information_system_interoperability |-> $past(data_standardization_protocol, 2) && ($past(metadata_quality) && $past(system_integration_success, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Information_System_Interoperability  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!environmental_data_integration)`  \n**Antecedent (LHS of Implication)**: `information_system_interoperability == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(data_standardization_protocol, 2) && ($past(metadata_quality) && $past(system_integration_success, 1))`  ", "sva_signals": ["clk", "[0:0] environmental_data_integration", "[0:0] information_system_interoperability", "[0:0] data_standardization_protocol", "[0:0] metadata_quality", "[0:0] system_integration_success"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!environmental_data_integration)     information_system_interoperability == 1'b1 |->          $past(data_standardization_protocol, 2) &&          ($past(metadata_quality) && $past(system_integration_success, 1))", "sva_name": "p_information_system_interoperability_check", "id": "0708", "full_property": "property p_Information_System_Interoperability;\n@(posedge clk) disable iff (!environmental_data_integration)     information_system_interoperability == 1'b1 |->          $past(data_standardization_protocol, 2) &&          ($past(metadata_quality) && $past(system_integration_success, 1))\nendproperty\nassert_p_Information_System_Interoperability:assert property (p_Information_System_Interoperability) else $error(\"\");", "task_id": "1_4501", "predict_sva": "@(posedge clk) disable iff (!environmental_data_integration)     information_system_interoperability == 1'b1 |->      $past(data_standardization_protocol, 2) &&      ($past(metadata_quality) && $past(system_integration_success, 1))"}
{"sva": "@(posedge detector_clk) disable iff(!signal_present) envelope_detector |-> (carrier_frequency[15:0] ? (modulation_depth_adequate ? demodulated_signal : weak_modulation) : carrier_detection)", "sva_description": "### Assertion description:  \n**Property Name**: p_envelope_detector_check  \n**Trigger Condition**: At every rising edge of the `detector_clk`  \n**Disable Condition**: disable iff (!signal_present)  \n**Antecedent (LHS of Implication)**: `envelope_detector`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(carrier_frequency[15:0] ? (modulation_depth_adequate ? demodulated_signal : weak_modulation) : carrier_detection)`  \n\n**Explanation of Consequent**:  \nThe consequent is a conditional expression that checks:  \n1. If `carrier_frequency[15:0]` is non-zero (true), then:  \n   - If `modulation_depth_adequate` is true, the expected output is `demodulated_signal`.  \n   - Else, the expected output is `weak_modulation`.  \n2. If `carrier_frequency[15:0]` is zero (false), the expected output is `carrier_detection`.  \n\nThis property ensures that the envelope detector's output follows the specified logic based on the carrier frequency and modulation depth conditions.", "sva_signals": ["detector_clk", "signal_present", "[0:0] envelope_detector", "[15:0] carrier_frequency", "[0:0] modulation_depth_adequate", "[0:0] demodulated_signal", "[0:0] weak_modulation", "[0:0] carrier_detection"], "clock": "detector_clk", "attempts_left": 10, "sva_result": "@(posedge detector_clk) disable iff (!signal_present)    envelope_detector |->         (carrier_frequency[15:0] ?             (modulation_depth_adequate ? demodulated_signal : weak_modulation) :             carrier_detection)", "sva_name": "p_envelope_detector_check", "id": "0663", "full_property": "property p_envelope_detector_check;\n@(posedge detector_clk) disable iff (!signal_present)    envelope_detector |->         (carrier_frequency[15:0] ?             (modulation_depth_adequate ? demodulated_signal : weak_modulation) :             carrier_detection)\nendproperty\nassert_p_envelope_detector_check:assert property (p_envelope_detector_check) else $error(\"\");", "task_id": "1_3521", "predict_sva": "@(posedge detector_clk) disable iff (!signal_present)    envelope_detector |->         (carrier_frequency[15:0] ?             (modulation_depth_adequate ? demodulated_signal : weak_modulation) :             carrier_detection)"}
{"sva": "@(posedge clock) disable iff(!reset_n) memory_write && $past(write_enable) |-> addr_stable", "sva_description": "### Assertion description:  \n**Property Name**: p_addr_stable_after_write  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: disable iff (!reset_n)  \n**Antecedent (LHS of Implication)**: `memory_write && $past(write_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `addr_stable`", "sva_signals": ["clock", "reset_n", "[0:0] memory_write", "[0:0] write_enable", "[0:0] addr_stable"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!reset_n)     (memory_write && $past(write_enable)) |-> addr_stable", "sva_name": "p_memory_write_addr_stable", "id": "1057", "full_property": "property p_addr_stable_after_write;\n@(posedge clock) disable iff (!reset_n)     (memory_write && $past(write_enable)) |-> addr_stable\nendproperty\nassert_p_addr_stable_after_write:assert property (p_addr_stable_after_write) else $error(\"\");", "task_id": "1_4823", "predict_sva": "@(posedge clock) disable iff (!reset_n)         memory_write && $past(write_enable) |-> addr_stable"}
{"sva": "@(negedge clk) jpeg_decode && $past(header_valid) && $past(huffman_ready) |-> decode_block_start", "sva_description": "### Assertion description:  \n**Property Name**: p_Decode_Block_Start  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `jpeg_decode && $past(header_valid) && $past(huffman_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `decode_block_start`", "sva_signals": ["clk", "rst_n", "[0:0] jpeg_decode", "[0:0] header_valid", "[0:0] huffman_ready", "[0:0] decode_block_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (jpeg_decode && $past(header_valid) && $past(huffman_ready)) |-> decode_block_start", "sva_name": "p_jpeg_decode_start", "id": "1062", "full_property": "property p_Decode_Block_Start;\n@(negedge clk)     (jpeg_decode && $past(header_valid) && $past(huffman_ready)) |-> decode_block_start\nendproperty\nassert_p_Decode_Block_Start:assert property (p_Decode_Block_Start) else $error(\"\");", "task_id": "1_4828", "predict_sva": "@(negedge clk)     (jpeg_decode && $past(header_valid) && $past(huffman_ready)) |-> decode_block_start"}
{"sva": "@(negedge clk_biomarker) disable iff(!diagnostic_assay_validated) disease_detection |-> $past(sensitivity_specificity_optimization, 3) && ($past(clinical_utility_demonstration) || $past(regulatory_approval, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Disease_Detection_Validation  \n**Trigger Condition**: At every falling edge of the `clk_biomarker`  \n**Disable Condition**: `disable iff (!diagnostic_assay_validated)`  \n**Antecedent (LHS of Implication)**: `disease_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sensitivity_specificity_optimization, 3) && ($past(clinical_utility_demonstration) || $past(regulatory_approval, 1))`  ", "sva_signals": ["clk_biomarker", "diagnostic_assay_validated", "[0:0] disease_detection", "[0:0] sensitivity_specificity_optimization", "[0:0] clinical_utility_demonstration", "[0:0] regulatory_approval"], "clock": "clk_biomarker", "attempts_left": 10, "sva_result": "@(negedge clk_biomarker) disable iff (!diagnostic_assay_validated)     disease_detection |-> $past(sensitivity_specificity_optimization, 3) &&                           ($past(clinical_utility_demonstration) || $past(regulatory_approval, 1))", "sva_name": "p_disease_detection_check", "id": "0732", "full_property": "property p_Disease_Detection_Validation;\n@(negedge clk_biomarker) disable iff (!diagnostic_assay_validated)     disease_detection |-> $past(sensitivity_specificity_optimization, 3) &&                           ($past(clinical_utility_demonstration) || $past(regulatory_approval, 1))\nendproperty\nassert_p_Disease_Detection_Validation:assert property (p_Disease_Detection_Validation) else $error(\"\");", "task_id": "1_4523", "predict_sva": "@(negedge clk_biomarker) disable iff (!diagnostic_assay_validated)     disease_detection |->          $past(sensitivity_specificity_optimization, 3) &&          ($past(clinical_utility_demonstration) || $past(regulatory_approval, 1))"}
{"sva": "@(negedge clk_equalizer) disable iff(filter_instability) parametric_equalization |-> $past(frequency_band_isolation, 3) && ($past(gain_adjustment) || $past(q_factor_control, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Parametric_Equalization_Check  \n**Trigger Condition**: At every falling edge of the `clk_equalizer`  \n**Disable Condition**: disable iff (`filter_instability`)  \n**Antecedent (LHS of Implication)**: `parametric_equalization == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(frequency_band_isolation, 3) && ($past(gain_adjustment) || $past(q_factor_control, 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] filter_instability", "[0:0] parametric_equalization", "[0:0] frequency_band_isolation", "[0:0] gain_adjustment", "[0:0] q_factor_control", "clk_equalizer"], "clock": "clk_equalizer", "attempts_left": 10, "sva_result": "@(negedge clk_equalizer) disable iff (filter_instability)     parametric_equalization == 1'b1 |->          $past(frequency_band_isolation, 3) &&          ($past(gain_adjustment) || $past(q_factor_control, 1))", "sva_name": "p_parametric_equalization_check", "id": "0801", "full_property": "property p_Parametric_Equalization_Check;\n@(negedge clk_equalizer) disable iff (filter_instability)     parametric_equalization == 1'b1 |->          $past(frequency_band_isolation, 3) &&          ($past(gain_adjustment) || $past(q_factor_control, 1))\nendproperty\nassert_p_Parametric_Equalization_Check:assert property (p_Parametric_Equalization_Check) else $error(\"\");", "task_id": "1_4591", "predict_sva": "@(negedge clk_equalizer) disable iff (filter_instability)     parametric_equalization == 1'b1 |->      $past(frequency_band_isolation, 3) && ($past(gain_adjustment) || $past(q_factor_control, 1))"}
{"sva": "@(posedge clock) disable iff(system_down) ethernet_tx && $past(mac_ready) |-> phy_tx_enable", "sva_description": "### Assertion description:  \n**Property Name**: p_ethernet_tx_enable  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (system_down)`  \n**Antecedent (LHS of Implication)**: `ethernet_tx && $past(mac_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `phy_tx_enable`", "sva_signals": ["clock", "system_down", "[0:0] ethernet_tx", "[0:0] mac_ready", "[0:0] phy_tx_enable"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (system_down)         (ethernet_tx && $past(mac_ready)) |-> phy_tx_enable", "sva_name": "p_ethernet_tx_phy_tx_enable", "id": "1063", "full_property": "property p_ethernet_tx_enable;\n@(posedge clock) disable iff (system_down)         (ethernet_tx && $past(mac_ready)) |-> phy_tx_enable\nendproperty\nassert_p_ethernet_tx_enable:assert property (p_ethernet_tx_enable) else $error(\"\");", "task_id": "1_4829", "predict_sva": "@(posedge clock) disable iff (system_down)         (ethernet_tx && $past(mac_ready)) |-> phy_tx_enable"}
{"sva": "@(negedge navigation_clk) disable iff(gps_signal_weak) route_guidance |-> (traffic_data_current ? (alternate_route_faster ? reroute_suggestion : stay_course) : estimated_time)", "sva_description": "### Assertion description:  \n**Property Name**: p_Route_Guidance_Check  \n**Trigger Condition**: At every negedge of the `navigation_clk`  \n**Disable Condition**: disable iff (`gps_signal_weak`)  \n**Antecedent (LHS of Implication)**: `route_guidance`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(traffic_data_current ? (alternate_route_faster ? reroute_suggestion : stay_course) : estimated_time)`  \n\n### Explanation:  \n- The property checks the behavior of route guidance logic when triggered on the falling edge of `navigation_clk`.  \n- The assertion is **disabled** if `gps_signal_weak` is true (indicating unreliable GPS signals).  \n- **Antecedent**: If `route_guidance` is active (true), the **consequent** evaluates a nested conditional:  \n  - If `traffic_data_current` is true:  \n    - Checks `alternate_route_faster` to decide between `reroute_suggestion` (if true) or `stay_course` (if false).  \n  - If `traffic_data_current` is false, the output should be `estimated_time`.  \n- The property ensures the system responds correctly to real-time traffic conditions during route guidance.", "sva_signals": ["navigation_clk", "[0:0] gps_signal_weak", "[0:0] route_guidance", "[0:0] traffic_data_current", "[0:0] alternate_route_faster", "[0:0] reroute_suggestion", "[0:0] stay_course", "[0:0] estimated_time"], "clock": "navigation_clk", "attempts_left": 10, "sva_result": "@(negedge navigation_clk) disable iff (gps_signal_weak)    route_guidance |-> (traffic_data_current ? (alternate_route_faster ? reroute_suggestion : stay_course) : estimated_time)", "sva_name": "p_Route_Guidance_Traffic", "id": "0574", "full_property": "property p_Route_Guidance_Check;\n@(negedge navigation_clk) disable iff (gps_signal_weak)    route_guidance |-> (traffic_data_current ? (alternate_route_faster ? reroute_suggestion : stay_course) : estimated_time)\nendproperty\nassert_p_Route_Guidance_Check:assert property (p_Route_Guidance_Check) else $error(\"\");", "task_id": "1_3433", "predict_sva": "@(negedge navigation_clk) disable iff (gps_signal_weak)    route_guidance |->         (traffic_data_current ?             (alternate_route_faster ? reroute_suggestion : stay_course)             : estimated_time)"}
{"sva": "@(negedge clock) disable iff(emergency_stop) servo_position_update |-> $past(encoder_feedback) && position_error < tolerance", "sva_description": "### Assertion description:  \n**Property Name**: p_servo_position_update  \n**Trigger Condition**: At every falling edge of the `clock`  \n**Disable Condition**: disable iff (`emergency_stop`)  \n**Antecedent (LHS of Implication)**: `servo_position_update`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(encoder_feedback) && position_error < tolerance`", "sva_signals": ["clock", "[0:0] emergency_stop", "[0:0] servo_position_update", "[0:0] encoder_feedback", "[0:0] position_error", "[0:0] tolerance"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (emergency_stop)     servo_position_update |-> $past(encoder_feedback) && (position_error < tolerance)", "sva_name": "p_servo_position_update", "id": "1079", "full_property": "property p_servo_position_update;\n@(negedge clock) disable iff (emergency_stop)     servo_position_update |-> $past(encoder_feedback) && (position_error < tolerance)\nendproperty\nassert_p_servo_position_update:assert property (p_servo_position_update) else $error(\"\");", "task_id": "1_4845", "predict_sva": "@(negedge clock) disable iff (emergency_stop)     servo_position_update |-> $past(encoder_feedback) && (position_error < tolerance)"}
{"sva": "@(negedge compression_clock) disable iff(decompression_latency_critical) memory_compression |-> (compression_ratio[7:0] > 8'd150 ? (bandwidth_savings_significant ? enable_compression : compression_overhead) : uncompressed_storage)", "sva_description": "### Assertion description:  \n**Property Name**: p_compression_check  \n**Trigger Condition**: At every negedge of the `compression_clock`  \n**Disable Condition**: `disable iff (decompression_latency_critical)`  \n**Antecedent (LHS of Implication)**: `memory_compression`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(compression_ratio[7:0] > 8'd150) ? (bandwidth_savings_significant ? enable_compression : compression_overhead) : uncompressed_storage`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional expression:  \n1. If `compression_ratio[7:0] > 8'd150` (compression ratio exceeds 150), then:  \n   - If `bandwidth_savings_significant` is true, the result is `enable_compression`.  \n   - Else, the result is `compression_overhead`.  \n2. If `compression_ratio[7:0] <= 8'd150`, the result is `uncompressed_storage`.  \n\nThis property asserts that when `memory_compression` is active, the system must behave according to the specified compression logic based on the `compression_ratio` and `bandwidth_savings_significant` signals. The check is disabled if `decompression_latency_critical` is asserted.", "sva_signals": ["compression_clock", "decompression_latency_critical", "memory_compression", "[7:0] compression_ratio", "bandwidth_savings_significant", "enable_compression", "compression_overhead", "uncompressed_storage"], "clock": "compression_clock", "attempts_left": 10, "sva_result": "disable iff (decompression_latency_critical)    @(negedge compression_clock)    memory_compression |-> (        (compression_ratio[7:0] > 8'd150) ?             (bandwidth_savings_significant ? enable_compression : compression_overhead) :             uncompressed_storage    )", "sva_name": "p_memory_compression_check", "id": "0719", "full_property": "property p_compression_check;\ndisable iff (decompression_latency_critical)    @(negedge compression_clock)    memory_compression |-> (        (compression_ratio[7:0] > 8'd150) ?             (bandwidth_savings_significant ? enable_compression : compression_overhead) :             uncompressed_storage    )\nendproperty\nassert_p_compression_check:assert property (p_compression_check) else $error(\"\");", "task_id": "1_3574", "predict_sva": "@(negedge compression_clock) disable iff (decompression_latency_critical)    memory_compression |->         (compression_ratio[7:0] > 8'd150 ?             (bandwidth_savings_significant ? enable_compression : compression_overhead) :             uncompressed_storage)"}
{"sva": "@(negedge powerlink_clk) disable iff(safety_violation) deterministic_ethernet |-> (isochronous_phase ? (slot_assignment ? transmit_data : listen_mode) : asynchronous_communication)", "sva_description": "### Assertion description:  \n**Property Name**: p_deterministic_ethernet_behavior  \n**Trigger Condition**: At every negedge of the `powerlink_clk`  \n**Disable Condition**: `disable iff (safety_violation)`  \n**Antecedent (LHS of Implication)**: `deterministic_ethernet`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(isochronous_phase ? (slot_assignment ? transmit_data : listen_mode) : asynchronous_communication)`  \n\n### Explanation:  \n1. The property checks behavior triggered on the **falling edge** of `powerlink_clk`.  \n2. The assertion is **disabled** if `safety_violation` is active (acts as an asynchronous reset).  \n3. When `deterministic_ethernet` is true (antecedent), the consequent evaluates a nested conditional:  \n   - If `isochronous_phase` is true:  \n     - Further checks `slot_assignment`: if true, expects `transmit_data`; otherwise, expects `listen_mode`.  \n   - If `isochronous_phase` is false, expects `asynchronous_communication`.  \n\nThis ensures deterministic Ethernet operation adheres to the specified phase and slot assignment rules.", "sva_signals": ["powerlink_clk", "safety_violation", "[0:0] deterministic_ethernet", "[0:0] isochronous_phase", "[0:0] slot_assignment", "[0:0] transmit_data", "[0:0] listen_mode", "[0:0] asynchronous_communication"], "clock": "powerlink_clk", "attempts_left": 10, "sva_result": "@(negedge powerlink_clk) disable iff (safety_violation)    deterministic_ethernet |->         (isochronous_phase ? (slot_assignment ? transmit_data : listen_mode) : asynchronous_communication)", "sva_name": "p_deterministic_ethernet_behavior", "id": "0419", "full_property": "property p_deterministic_ethernet_behavior;\n@(negedge powerlink_clk) disable iff (safety_violation)    deterministic_ethernet |->         (isochronous_phase ? (slot_assignment ? transmit_data : listen_mode) : asynchronous_communication)\nendproperty\nassert_p_deterministic_ethernet_behavior:assert property (p_deterministic_ethernet_behavior) else $error(\"\");", "task_id": "1_3282", "predict_sva": "@(negedge powerlink_clk) disable iff (safety_violation)    deterministic_ethernet |->         (isochronous_phase ? (slot_assignment ? transmit_data : listen_mode) : asynchronous_communication)"}
{"sva": "@(posedge clock) disable iff(radiation_upset) space_grade_memory_scrub |-> $past(ecc_error_detect) && correction_applied", "sva_description": "### Assertion description:  \n**Property Name**: p_Space_Grade_Memory_Scrub  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: disable iff (`radiation_upset`)  \n**Antecedent (LHS of Implication)**: `space_grade_memory_scrub == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ecc_error_detect) && correction_applied`  ", "sva_signals": ["clock", "[0:0] radiation_upset", "[0:0] space_grade_memory_scrub", "[0:0] ecc_error_detect", "[0:0] correction_applied"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (radiation_upset)     space_grade_memory_scrub == 1'b1 |-> $past(ecc_error_detect) && correction_applied", "sva_name": "p_space_grade_memory_scrub", "id": "1078", "full_property": "property p_Space_Grade_Memory_Scrub;\n@(posedge clock) disable iff (radiation_upset)     space_grade_memory_scrub == 1'b1 |-> $past(ecc_error_detect) && correction_applied\nendproperty\nassert_p_Space_Grade_Memory_Scrub:assert property (p_Space_Grade_Memory_Scrub) else $error(\"\");", "task_id": "1_4844", "predict_sva": "@(posedge clock) disable iff (radiation_upset)     space_grade_memory_scrub |-> $past(ecc_error_detect) && correction_applied"}
{"sva": "@(posedge clock) disable iff(power_management_mode) lcd_pixel_write && $past(display_enable) |-> backlight_control", "sva_description": "### Assertion description:  \n**Property Name**: p_lcd_backlight_control  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (power_management_mode)`  \n**Antecedent (LHS of Implication)**: `lcd_pixel_write && $past(display_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `backlight_control`", "sva_signals": ["clock", "[0:0] power_management_mode", "[0:0] lcd_pixel_write", "[0:0] display_enable", "[0:0] backlight_control"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (power_management_mode)         lcd_pixel_write && $past(display_enable) |-> backlight_control", "sva_name": "p_lcd_pixel_write_backlight_control", "id": "1083", "full_property": "property p_lcd_backlight_control;\n@(posedge clock) disable iff (power_management_mode)         lcd_pixel_write && $past(display_enable) |-> backlight_control\nendproperty\nassert_p_lcd_backlight_control:assert property (p_lcd_backlight_control) else $error(\"\");", "task_id": "1_4849", "predict_sva": "@(posedge clock) disable iff (power_management_mode)         lcd_pixel_write && $past(display_enable) |-> backlight_control"}
{"sva": "@(posedge consciousness_clk) disable iff(!observer_effect_calibrated) quantum_mind |-> (wave_function_collapse[7:0] ? (conscious_observation ? measurement_induced : decoherence_driven) : superposition_maintained)", "sva_description": "### Assertion description:\n**Property Name**: p_quantum_mind_behavior  \n**Trigger Condition**: At every rising edge of the `consciousness_clk`  \n**Disable Condition**: disable iff (!observer_effect_calibrated)  \n**Antecedent (LHS of Implication)**: `quantum_mind`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(wave_function_collapse[7:0] ? (conscious_observation ? measurement_induced : decoherence_driven) : superposition_maintained)`  \n\n**Detailed Consequent Breakdown**:  \n- If `wave_function_collapse[7:0]` is non-zero:  \n  - If `conscious_observation` is true, result is `measurement_induced`  \n  - Else, result is `decoherence_driven`  \n- Else (if `wave_function_collapse[7:0]` is zero), result is `superposition_maintained`  \n\n**Note**: The consequent uses nested ternary operators to model quantum behavior based on collapse state and observation conditions.", "sva_signals": ["consciousness_clk", "observer_effect_calibrated", "[0:0] quantum_mind", "[7:0] wave_function_collapse", "[0:0] conscious_observation", "[0:0] measurement_induced", "[0:0] decoherence_driven", "[0:0] superposition_maintained"], "clock": "consciousness_clk", "attempts_left": 10, "sva_result": "@(posedge consciousness_clk) disable iff (!observer_effect_calibrated)    quantum_mind |-> (        wave_function_collapse[7:0] ?             (conscious_observation ? measurement_induced : decoherence_driven) :             superposition_maintained    )", "sva_name": "p_quantum_mind_check", "id": "0660", "full_property": "property p_quantum_mind_behavior;\n@(posedge consciousness_clk) disable iff (!observer_effect_calibrated)    quantum_mind |-> (        wave_function_collapse[7:0] ?             (conscious_observation ? measurement_induced : decoherence_driven) :             superposition_maintained    )\nendproperty\nassert_p_quantum_mind_behavior:assert property (p_quantum_mind_behavior) else $error(\"\");", "task_id": "1_3518", "predict_sva": "@(posedge consciousness_clk) disable iff (!observer_effect_calibrated)    quantum_mind |->         (wave_function_collapse[7:0] ?             (conscious_observation ? measurement_induced : decoherence_driven) :             superposition_maintained)"}
{"sva": "@(posedge clk) disable iff(!traceability_system_functional) food_supply_chain |-> $past(batch_identification_tracking, 1) && ($past(temperature_logger_data, 3) && $past(quality_assurance_checkpoint))", "sva_description": "### Assertion description:  \n**Property Name**: p_Food_Supply_Chain_Tracking  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!traceability_system_functional)`  \n**Antecedent (LHS of Implication)**: `food_supply_chain == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(batch_identification_tracking, 1) && ($past(temperature_logger_data, 3) && $past(quality_assurance_checkpoint))`  ", "sva_signals": ["clk", "traceability_system_functional", "[0:0] food_supply_chain", "batch_identification_tracking", "temperature_logger_data", "[0:0] quality_assurance_checkpoint"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!traceability_system_functional)     food_supply_chain == 1'b1 |->          $past(batch_identification_tracking, 1) &&          ($past(temperature_logger_data, 3) && $past(quality_assurance_checkpoint))", "sva_name": "p_Food_Supply_Chain_Traceability", "id": "0911", "full_property": "property p_Food_Supply_Chain_Tracking;\n@(posedge clk) disable iff (!traceability_system_functional)     food_supply_chain == 1'b1 |->          $past(batch_identification_tracking, 1) &&          ($past(temperature_logger_data, 3) && $past(quality_assurance_checkpoint))\nendproperty\nassert_p_Food_Supply_Chain_Tracking:assert property (p_Food_Supply_Chain_Tracking) else $error(\"\");", "task_id": "1_4691", "predict_sva": "@(posedge clk) disable iff (!traceability_system_functional)     food_supply_chain == 1'b1 |->      $past(batch_identification_tracking, 1) &&      ($past(temperature_logger_data, 3) && $past(quality_assurance_checkpoint))"}
{"sva": "@(negedge mystery_clk) disable iff(complete_knowledge_achieved) unknown_explorer |-> (mystery_depth[15:0] ? preserve_wonder : eliminate_uncertainty)", "sva_description": "### Assertion description:  \n**Property Name**: p_UnknownExplorer  \n**Trigger Condition**: At every negedge of the `mystery_clk`  \n**Disable Condition**: disable iff (`complete_knowledge_achieved`)  \n**Antecedent (LHS of Implication)**: `unknown_explorer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`mystery_depth[15:0] ? preserve_wonder : eliminate_uncertainty`)  \n\n### Explanation:  \n1. The property checks the behavior of an \"unknown explorer\" on the falling edge of `mystery_clk`.  \n2. The assertion is disabled if `complete_knowledge_achieved` is true.  \n3. If `unknown_explorer` is true (antecedent), then:  \n   - If `mystery_depth[15:0]` is non-zero, `preserve_wonder` must hold.  \n   - Otherwise (`mystery_depth[15:0]` is zero), `eliminate_uncertainty` must hold.  \n4. The ternary operator (`? :`) selects the expected outcome based on `mystery_depth[15:0]`.", "sva_signals": ["mystery_clk", "complete_knowledge_achieved", "[0:0] unknown_explorer", "[15:0] mystery_depth", "[0:0] preserve_wonder", "[0:0] eliminate_uncertainty"], "clock": "mystery_clk", "attempts_left": 10, "sva_result": "@(negedge mystery_clk) disable iff (complete_knowledge_achieved)    unknown_explorer |-> (mystery_depth[15:0] ? preserve_wonder : eliminate_uncertainty)", "sva_name": "p_unknown_explorer_check", "id": "0401", "full_property": "property p_UnknownExplorer;\n@(negedge mystery_clk) disable iff (complete_knowledge_achieved)    unknown_explorer |-> (mystery_depth[15:0] ? preserve_wonder : eliminate_uncertainty)\nendproperty\nassert_p_UnknownExplorer:assert property (p_UnknownExplorer) else $error(\"\");", "task_id": "1_3264", "predict_sva": "@(negedge mystery_clk) disable iff (complete_knowledge_achieved)    unknown_explorer |-> (mystery_depth[15:0] ? preserve_wonder : eliminate_uncertainty)"}
{"sva": "@(negedge singularity_clk) disable iff(ai_alignment_uncertain) superintelligence |-> (human_value_preservation[7:0] ? benevolent_ai : containment_protocol)", "sva_description": "### Assertion description:  \n**Property Name**: p_Superintelligence_Check  \n**Trigger Condition**: At every negedge of the `singularity_clk`  \n**Disable Condition**: disable iff (ai_alignment_uncertain)  \n**Antecedent (LHS of Implication)**: `superintelligence`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(human_value_preservation[7:0] ? benevolent_ai : containment_protocol)`  \n\n### Explanation:  \n1. The property is evaluated on the **falling edge** of `singularity_clk`.  \n2. The assertion is **disabled** if `ai_alignment_uncertain` is true (asynchronous reset condition).  \n3. The **antecedent** (`superintelligence`) triggers the implication. If true, the **consequent** must hold.  \n4. The **consequent** checks:  \n   - If any bit in `human_value_preservation[7:0]` is high, `benevolent_ai` must be true.  \n   - Otherwise, `containment_protocol` must be true.  \n\n### Key Notes:  \n- The ternary operator (`? :`) acts as a conditional selector in the consequent.  \n- The property ensures AI behavior aligns with human values or enforces containment if alignment is uncertain.", "sva_signals": ["singularity_clk", "[0:0] ai_alignment_uncertain", "[0:0] superintelligence", "[7:0] human_value_preservation", "[0:0] benevolent_ai", "[0:0] containment_protocol"], "clock": "singularity_clk", "attempts_left": 10, "sva_result": "@(negedge singularity_clk) disable iff (ai_alignment_uncertain)    superintelligence |-> (|human_value_preservation[7:0] ? benevolent_ai : containment_protocol)", "sva_name": "p_Superintelligence_Check", "id": "0390", "full_property": "property p_Superintelligence_Check;\n@(negedge singularity_clk) disable iff (ai_alignment_uncertain)    superintelligence |-> (|human_value_preservation[7:0] ? benevolent_ai : containment_protocol)\nendproperty\nassert_p_Superintelligence_Check:assert property (p_Superintelligence_Check) else $error(\"\");", "task_id": "1_3253", "predict_sva": "@(negedge singularity_clk) disable iff (ai_alignment_uncertain)    superintelligence |-> (|human_value_preservation[7:0] ? benevolent_ai : containment_protocol)"}
{"sva": "@(posedge clk) disable iff(repatriation_claim_unresolved) indigenous_heritage_management |-> $past(community_consultation_process, 2) && ($past(cultural_protocol_respect) && $past(traditional_knowledge_acknowledgment, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Indigenous_Heritage_Management  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (repatriation_claim_unresolved)`  \n**Antecedent (LHS of Implication)**: `indigenous_heritage_management == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(community_consultation_process, 2) && ($past(cultural_protocol_respect) && $past(traditional_knowledge_acknowledgment, 1))`  ", "sva_signals": ["clk", "[0:0] repatriation_claim_unresolved", "[0:0] indigenous_heritage_management", "[0:0] community_consultation_process", "[0:0] cultural_protocol_respect", "[0:0] traditional_knowledge_acknowledgment"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (repatriation_claim_unresolved)     indigenous_heritage_management == 1'b1 |->      $past(community_consultation_process, 2) &&      ($past(cultural_protocol_respect) && $past(traditional_knowledge_acknowledgment, 1))", "sva_name": "p_Indigenous_Heritage_Management", "id": "1008", "full_property": "property p_Indigenous_Heritage_Management;\n@(posedge clk) disable iff (repatriation_claim_unresolved)     indigenous_heritage_management == 1'b1 |->      $past(community_consultation_process, 2) &&      ($past(cultural_protocol_respect) && $past(traditional_knowledge_acknowledgment, 1))\nendproperty\nassert_p_Indigenous_Heritage_Management:assert property (p_Indigenous_Heritage_Management) else $error(\"\");", "task_id": "1_4778", "predict_sva": "@(posedge clk) disable iff (repatriation_claim_unresolved)     indigenous_heritage_management |->          $past(community_consultation_process, 2) &&          ($past(cultural_protocol_respect) && $past(traditional_knowledge_acknowledgment, 1))"}
{"sva": "@(negedge clk) medical_device_alarm && $past(patient_parameter_threshold) && $past(sensor_validity_check) |-> emergency_notification", "sva_description": "### Assertion description:  \n**Property Name**: p_Emergency_Notification  \n**Trigger Condition**: At every falling edge of the `clk`;  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `medical_device_alarm && $past(patient_parameter_threshold) && $past(sensor_validity_check)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `emergency_notification`", "sva_signals": ["clk", "rst_n", "[0:0] medical_device_alarm", "[0:0] patient_parameter_threshold", "[0:0] sensor_validity_check", "[0:0] emergency_notification"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (medical_device_alarm && $past(patient_parameter_threshold) && $past(sensor_validity_check)) |-> emergency_notification", "sva_name": "p_Medical_Device_Alarm_Emergency_Notification", "id": "1100", "full_property": "property p_Emergency_Notification;\n@(negedge clk)     (medical_device_alarm && $past(patient_parameter_threshold) && $past(sensor_validity_check)) |-> emergency_notification\nendproperty\nassert_p_Emergency_Notification:assert property (p_Emergency_Notification) else $error(\"\");", "task_id": "1_4866", "predict_sva": "@(negedge clk)     medical_device_alarm && $past(patient_parameter_threshold) && $past(sensor_validity_check) |-> emergency_notification"}
{"sva": "@(posedge clock) disable iff(!hw_reset) ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete", "sva_description": "### Assertion description:  \n**Property Name**: p_Range_Calculation_Complete  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (!hw_reset)`  \n**Antecedent (LHS of Implication)**: `ultrasonic_distance_measure && $past(echo_time_capture)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `range_calculation_complete`", "sva_signals": ["clock", "hw_reset", "[0:0] ultrasonic_distance_measure", "[0:0] echo_time_capture", "[0:0] range_calculation_complete"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!hw_reset)         ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete", "sva_name": "p_Ultrasonic_Range_Completion", "id": "1134", "full_property": "property p_Range_Calculation_Complete;\n@(posedge clock) disable iff (!hw_reset)         ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete\nendproperty\nassert_p_Range_Calculation_Complete:assert property (p_Range_Calculation_Complete) else $error(\"\");", "task_id": "1_4898", "predict_sva": "@(posedge clock) disable iff (!hw_reset)     ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete"}
{"sva": "@(posedge clk) disable iff(!ethnoarchaeology_analogy_validated) behavioral_inference |-> $past(ethnographic_parallel_documentation, 2) && ($past(cross_cultural_comparison) && $past(analogical_reasoning_justification, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Behavioral_Inference_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!ethnoarchaeology_analogy_validated)`  \n**Antecedent (LHS of Implication)**: `behavioral_inference == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(ethnographic_parallel_documentation, 2) && ($past(cross_cultural_comparison) && $past(analogical_reasoning_justification, 1))`  ", "sva_signals": ["clk", "ethnoarchaeology_analogy_validated", "behavioral_inference", "ethnographic_parallel_documentation", "cross_cultural_comparison", "analogical_reasoning_justification"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!ethnoarchaeology_analogy_validated)     behavioral_inference == 1'b1 |->     $past(ethnographic_parallel_documentation, 2) &&      ($past(cross_cultural_comparison) && $past(analogical_reasoning_justification, 1))", "sva_name": "p_Behavioral_Inference_Check", "id": "0997", "full_property": "property p_Behavioral_Inference_Check;\n@(posedge clk) disable iff (!ethnoarchaeology_analogy_validated)     behavioral_inference == 1'b1 |->     $past(ethnographic_parallel_documentation, 2) &&      ($past(cross_cultural_comparison) && $past(analogical_reasoning_justification, 1))\nendproperty\nassert_p_Behavioral_Inference_Check:assert property (p_Behavioral_Inference_Check) else $error(\"\");", "task_id": "1_4768", "predict_sva": "@(posedge clk) disable iff (!ethnoarchaeology_analogy_validated)     behavioral_inference == 1'b1 |->      $past(ethnographic_parallel_documentation, 2) &&      ($past(cross_cultural_comparison) && $past(analogical_reasoning_justification, 1))"}
{"sva": "@(posedge network_clk) disable iff(rst_chip == 1'b1) tcp_segment_reassembly && $past(sequence_number_validation) |-> receive_buffer_insertion", "sva_description": "### Assertion description:  \n**Property Name**: p_Tcp_Segment_Reassembly_Validation  \n**Trigger Condition**: At every rising edge of the `network_clk`  \n**Disable Condition**: `disable iff (rst_chip == 1'b1)`  \n**Antecedent (LHS of Implication)**: `tcp_segment_reassembly && $past(sequence_number_validation)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `receive_buffer_insertion`  ", "sva_signals": ["network_clk", "[0:0] rst_chip", "[0:0] tcp_segment_reassembly", "[0:0] sequence_number_validation", "[0:0] receive_buffer_insertion"], "clock": "network_clk", "attempts_left": 10, "sva_result": "@(posedge network_clk) disable iff (rst_chip == 1'b1)     (tcp_segment_reassembly && $past(sequence_number_validation)) |-> receive_buffer_insertion", "sva_name": "p_tcp_segment_reassembly", "id": "1169", "full_property": "property p_Tcp_Segment_Reassembly_Validation;\n@(posedge network_clk) disable iff (rst_chip == 1'b1)     (tcp_segment_reassembly && $past(sequence_number_validation)) |-> receive_buffer_insertion\nendproperty\nassert_p_Tcp_Segment_Reassembly_Validation:assert property (p_Tcp_Segment_Reassembly_Validation) else $error(\"\");", "task_id": "1_4933", "predict_sva": "@(posedge network_clk) disable iff (rst_chip)     tcp_segment_reassembly && $past(sequence_number_validation) |-> receive_buffer_insertion"}
{"sva": "@(posedge clock) disable iff(!rst) fusion_plasma_confinement && $past(magnetic_bottle_stable) |-> deuterium_injection_control", "sva_description": "### Assertion description:  \n**Property Name**: p_Fusion_Plasma_Confinement_Control  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: disable iff (`!rst`)  \n**Antecedent (LHS of Implication)**: `fusion_plasma_confinement && $past(magnetic_bottle_stable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `deuterium_injection_control`  ", "sva_signals": ["clock", "rst", "[0:0] fusion_plasma_confinement", "[0:0] magnetic_bottle_stable", "[0:0] deuterium_injection_control"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!rst)     fusion_plasma_confinement && $past(magnetic_bottle_stable) |-> deuterium_injection_control", "sva_name": "p_Fusion_Plasma_Confinement", "id": "1128", "full_property": "property p_Fusion_Plasma_Confinement_Control;\n@(posedge clock) disable iff (!rst)     fusion_plasma_confinement && $past(magnetic_bottle_stable) |-> deuterium_injection_control\nendproperty\nassert_p_Fusion_Plasma_Confinement_Control:assert property (p_Fusion_Plasma_Confinement_Control) else $error(\"\");", "task_id": "1_4893", "predict_sva": "@(posedge clock) disable iff (!rst)         fusion_plasma_confinement && $past(magnetic_bottle_stable) |-> deuterium_injection_control"}
{"sva": "@(posedge clk) disable iff(rst_n == 1'b0) cryptocurrency_wallet_auth && $past(private_key_derivation) |-> digital_signature_generate", "sva_description": "### Assertion description:  \n**Property Name**: p_cryptocurrency_wallet_auth  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (rst_n == 1'b0)`  \n**Antecedent (LHS of Implication)**: `cryptocurrency_wallet_auth && $past(private_key_derivation)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `digital_signature_generate`", "sva_signals": ["clk", "rst_n", "[0:0] cryptocurrency_wallet_auth", "[0:0] private_key_derivation", "[0:0] digital_signature_generate"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst_n == 1'b0)         (cryptocurrency_wallet_auth && $past(private_key_derivation)) |-> digital_signature_generate", "sva_name": "p_cryptocurrency_wallet_auth_signature", "id": "1152", "full_property": "property p_cryptocurrency_wallet_auth;\n@(posedge clk) disable iff (rst_n == 1'b0)         (cryptocurrency_wallet_auth && $past(private_key_derivation)) |-> digital_signature_generate\nendproperty\nassert_p_cryptocurrency_wallet_auth:assert property (p_cryptocurrency_wallet_auth) else $error(\"\");", "task_id": "1_4916", "predict_sva": "@(posedge clk) disable iff (rst_n == 1'b0)         (cryptocurrency_wallet_auth && $past(private_key_derivation)) |-> digital_signature_generate"}
{"sva": "@(posedge clk_geoarchaeology) disable iff(site_formation_process_misunderstood) landscape_archaeology |-> ($past(sedimentological_analysis, 1) && $past(geomorphological_mapping, 3)) && $past(human_environment_interaction)", "sva_description": "### Assertion description:  \n**Property Name**: p_Landscape_Archaeology_Check  \n**Trigger Condition**: At every rising edge of the `clk_geoarchaeology`  \n**Disable Condition**: disable iff (`site_formation_process_misunderstood`)  \n**Antecedent (LHS of Implication)**: `landscape_archaeology == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`$past(sedimentological_analysis, 1) && $past(geomorphological_mapping, 3)`) && `$past(human_environment_interaction)`  ", "sva_signals": ["clk_geoarchaeology", "site_formation_process_misunderstood", "[0:0] landscape_archaeology", "[0:0] sedimentological_analysis", "[0:0] geomorphological_mapping", "[0:0] human_environment_interaction"], "clock": "clk_geoarchaeology", "attempts_left": 10, "sva_result": "@(posedge clk_geoarchaeology) disable iff (site_formation_process_misunderstood)     landscape_archaeology == 1'b1 |->          ($past(sedimentological_analysis, 1) && $past(geomorphological_mapping, 3)) &&          $past(human_environment_interaction)", "sva_name": "p_Landscape_Archaeology_Check", "id": "1018", "full_property": "property p_Landscape_Archaeology_Check;\n@(posedge clk_geoarchaeology) disable iff (site_formation_process_misunderstood)     landscape_archaeology == 1'b1 |->          ($past(sedimentological_analysis, 1) && $past(geomorphological_mapping, 3)) &&          $past(human_environment_interaction)\nendproperty\nassert_p_Landscape_Archaeology_Check:assert property (p_Landscape_Archaeology_Check) else $error(\"\");", "task_id": "1_4787", "predict_sva": "@(posedge clk_geoarchaeology) disable iff (site_formation_process_misunderstood)     landscape_archaeology == 1'b1 |->      $past(sedimentological_analysis, 1) &&      ($past(geomorphological_mapping, 3) && $past(human_environment_interaction))"}
{"sva": "@(posedge sys_clk) disable iff(rst == 1'b1) mass_spectrometer_ionize && $past(sample_vaporization_complete) |-> ion_acceleration_start", "sva_description": "### Assertion description:  \n**Property Name**: p_ion_acceleration_start  \n**Trigger Condition**: At every rising edge of `sys_clk`  \n**Disable Condition**: `disable iff (rst == 1'b1)`  \n**Antecedent (LHS of Implication)**: `mass_spectrometer_ionize && $past(sample_vaporization_complete)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ion_acceleration_start`", "sva_signals": ["sys_clk", "[0:0] rst", "[0:0] mass_spectrometer_ionize", "[0:0] sample_vaporization_complete", "[0:0] ion_acceleration_start"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk) disable iff (rst == 1'b1)         (mass_spectrometer_ionize && $past(sample_vaporization_complete)) |-> ion_acceleration_start", "sva_name": "p_ion_acceleration_start", "id": "1153", "full_property": "property p_ion_acceleration_start;\n@(posedge sys_clk) disable iff (rst == 1'b1)         (mass_spectrometer_ionize && $past(sample_vaporization_complete)) |-> ion_acceleration_start\nendproperty\nassert_p_ion_acceleration_start:assert property (p_ion_acceleration_start) else $error(\"\");", "task_id": "1_4917", "predict_sva": "@(posedge sys_clk) disable iff (rst == 1'b1)         mass_spectrometer_ionize && $past(sample_vaporization_complete) |-> ion_acceleration_start"}
{"sva": "@(posedge dh_clk) disable iff(!prime_verified) diffie_hellman |-> (shared_secret[1023:0] && key_exchange_phase ? (public_key_valid ? compute_shared : key_generation) : protocol_error)", "sva_description": "### Assertion description:  \n**Property Name**: p_Diffie_Hellman_Protocol  \n**Trigger Condition**: At every rising edge of the `dh_clk`  \n**Disable Condition**: `disable iff (!prime_verified)`  \n**Antecedent (LHS of Implication)**: `diffie_hellman`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(shared_secret[1023:0] && key_exchange_phase) ? (public_key_valid ? compute_shared : key_generation) : protocol_error`  \n\n### Explanation of Consequent Logic:  \n1. **Condition Check**:  \n   - If `shared_secret[1023:0]` is non-zero **AND** `key_exchange_phase` is true:  \n     - Nested condition:  \n       - If `public_key_valid` is true, execute `compute_shared`.  \n       - Else, execute `key_generation`.  \n   - Else (if either `shared_secret[1023:0]` is zero or `key_exchange_phase` is false), trigger `protocol_error`.  \n\n### Key Notes:  \n- The property validates the Diffie-Hellman protocol flow, ensuring correct state transitions (`compute_shared`, `key_generation`, or `protocol_error`) based on conditions (`shared_secret`, `key_exchange_phase`, and `public_key_valid`).  \n- The assertion is disabled if `prime_verified` is false (reset condition).  \n- The check is edge-triggered on `dh_clk`.", "sva_signals": ["dh_clk", "prime_verified", "[0:0] diffie_hellman", "[1023:0] shared_secret", "[0:0] key_exchange_phase", "[0:0] public_key_valid", "[0:0] compute_shared", "[0:0] key_generation", "[0:0] protocol_error"], "clock": "dh_clk", "attempts_left": 10, "sva_result": "@(posedge dh_clk) disable iff (!prime_verified)    diffie_hellman |-> (        (shared_secret[1023:0] && key_exchange_phase) ?             (public_key_valid ? compute_shared : key_generation) :             protocol_error    )", "sva_name": "p_Diffie_Hellman_Protocol_Check", "id": "0949", "full_property": "property p_Diffie_Hellman_Protocol;\n@(posedge dh_clk) disable iff (!prime_verified)    diffie_hellman |-> (        (shared_secret[1023:0] && key_exchange_phase) ?             (public_key_valid ? compute_shared : key_generation) :             protocol_error    )\nendproperty\nassert_p_Diffie_Hellman_Protocol:assert property (p_Diffie_Hellman_Protocol) else $error(\"\");", "task_id": "1_3782", "predict_sva": "@(posedge dh_clk) disable iff (!prime_verified)    diffie_hellman |->         ((shared_secret[1023:0] && key_exchange_phase) ?             (public_key_valid ? compute_shared : key_generation) :             protocol_error)"}
{"sva": "@(posedge sys_clk) disable iff(!hw_rst_signal) quantum_dot_laser && $past(carrier_injection_rate, 7) |-> photon_emission_coherence", "sva_description": "### Assertion description:  \n**Property Name**: p_Photon_Emission_Coherence  \n**Trigger Condition**: At every rising edge of `sys_clk`  \n**Disable Condition**: `disable iff (!hw_rst_signal)`  \n**Antecedent (LHS of Implication)**: `quantum_dot_laser && $past(carrier_injection_rate, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `photon_emission_coherence`  ", "sva_signals": ["sys_clk", "hw_rst_signal", "[0:0] quantum_dot_laser", "[0:0] carrier_injection_rate", "[0:0] photon_emission_coherence"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk) disable iff (!hw_rst_signal)         (quantum_dot_laser && $past(carrier_injection_rate, 7)) |-> photon_emission_coherence", "sva_name": "p_quantum_dot_laser_photon_emission", "id": "1141", "full_property": "property p_Photon_Emission_Coherence;\n@(posedge sys_clk) disable iff (!hw_rst_signal)         (quantum_dot_laser && $past(carrier_injection_rate, 7)) |-> photon_emission_coherence\nendproperty\nassert_p_Photon_Emission_Coherence:assert property (p_Photon_Emission_Coherence) else $error(\"\");", "task_id": "1_4905", "predict_sva": "@(posedge sys_clk) disable iff (!hw_rst_signal)     quantum_dot_laser && $past(carrier_injection_rate, 7) |-> photon_emission_coherence"}
{"sva": "@(posedge clk_fast) disable iff(!rst_sync_n) error_correction_decode && $past(syndrome_polynomial_calculation, 11) |-> error_location_identification", "sva_description": "### Assertion description:  \n**Property Name**: p_error_location_identification  \n**Trigger Condition**: At every rising edge of `clk_fast`  \n**Disable Condition**: `disable iff (!rst_sync_n)`  \n**Antecedent (LHS of Implication)**: `error_correction_decode && $past(syndrome_polynomial_calculation, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_location_identification`  ", "sva_signals": ["clk_fast", "rst_sync_n", "[0:0] error_correction_decode", "[0:0] syndrome_polynomial_calculation", "[0:0] error_location_identification"], "clock": "clk_fast", "attempts_left": 10, "sva_result": "@(posedge clk_fast) disable iff (!rst_sync_n)     (error_correction_decode && $past(syndrome_polynomial_calculation, 11)) |-> error_location_identification", "sva_name": "p_error_location_identification", "id": "1200", "full_property": "property p_error_location_identification;\n@(posedge clk_fast) disable iff (!rst_sync_n)     (error_correction_decode && $past(syndrome_polynomial_calculation, 11)) |-> error_location_identification\nendproperty\nassert_p_error_location_identification:assert property (p_error_location_identification) else $error(\"\");", "task_id": "1_4962", "predict_sva": "@(posedge clk_fast) disable iff (!rst_sync_n)     error_correction_decode && $past(syndrome_polynomial_calculation, 11) |-> error_location_identification"}
{"sva": "@(posedge clk) disable iff(rst == 1'b1) x_ray_crystallography && $past(diffraction_pattern_capture) |-> crystal_structure_analysis", "sva_description": "### Assertion description:  \n**Property Name**: p_x_ray_crystallography_analysis  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`rst == 1'b1`)  \n**Antecedent (LHS of Implication)**: `x_ray_crystallography && $past(diffraction_pattern_capture)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crystal_structure_analysis`", "sva_signals": ["clk", "rst", "[0:0] x_ray_crystallography", "[0:0] diffraction_pattern_capture", "[0:0] crystal_structure_analysis"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst == 1'b1)         x_ray_crystallography && $past(diffraction_pattern_capture) |-> crystal_structure_analysis", "sva_name": "p_x_ray_crystallography_analysis", "id": "1154", "full_property": "property p_x_ray_crystallography_analysis;\n@(posedge clk) disable iff (rst == 1'b1)         x_ray_crystallography && $past(diffraction_pattern_capture) |-> crystal_structure_analysis\nendproperty\nassert_p_x_ray_crystallography_analysis:assert property (p_x_ray_crystallography_analysis) else $error(\"\");", "task_id": "1_4918", "predict_sva": "@(posedge clk) disable iff (rst == 1'b1)         x_ray_crystallography && $past(diffraction_pattern_capture) |-> crystal_structure_analysis"}
{"sva": "@(negedge clk_sensor) disable iff(!reset_subsystem) gyroscope_drift_compensation |-> $past(temperature_coefficient_calibration, 12) && bias_correction_apply", "sva_description": "### Assertion description:  \n**Property Name**: p_gyroscope_drift_compensation  \n**Trigger Condition**: At every falling edge of the `clk_sensor`  \n**Disable Condition**: disable iff `(!reset_subsystem)`  \n**Antecedent (LHS of Implication)**: `gyroscope_drift_compensation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(temperature_coefficient_calibration, 12) && bias_correction_apply`", "sva_signals": ["clk_sensor", "reset_subsystem", "[0:0] gyroscope_drift_compensation", "[0:0] temperature_coefficient_calibration", "[0:0] bias_correction_apply"], "clock": "clk_sensor", "attempts_left": 10, "sva_result": "@(negedge clk_sensor) disable iff (!reset_subsystem)     gyroscope_drift_compensation |-> $past(temperature_coefficient_calibration, 12) && bias_correction_apply", "sva_name": "p_gyroscope_drift_compensation", "id": "1177", "full_property": "property p_gyroscope_drift_compensation;\n@(negedge clk_sensor) disable iff (!reset_subsystem)     gyroscope_drift_compensation |-> $past(temperature_coefficient_calibration, 12) && bias_correction_apply\nendproperty\nassert_p_gyroscope_drift_compensation:assert property (p_gyroscope_drift_compensation) else $error(\"\");", "task_id": "1_4940", "predict_sva": "@(negedge clk_sensor) disable iff (!reset_subsystem)     gyroscope_drift_compensation |-> $past(temperature_coefficient_calibration, 12) && bias_correction_apply"}
{"sva": "@(posedge interface_clk) disable iff(!module_rst_n) protocol_state_machine && $past(handshake_sequence_complete, 4) |-> next_transaction_initiate", "sva_description": "### Assertion description:  \n**Property Name**: p_protocol_state_machine_handshake  \n**Trigger Condition**: At every rising edge of the `interface_clk`  \n**Disable Condition**: disable iff (!module_rst_n)  \n**Antecedent (LHS of Implication)**: `protocol_state_machine && $past(handshake_sequence_complete, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `next_transaction_initiate`  ", "sva_signals": ["interface_clk", "module_rst_n", "[0:0] protocol_state_machine", "[0:0] handshake_sequence_complete", "[0:0] next_transaction_initiate"], "clock": "interface_clk", "attempts_left": 10, "sva_result": "@(posedge interface_clk) disable iff (!module_rst_n)     protocol_state_machine && $past(handshake_sequence_complete, 4) |-> next_transaction_initiate", "sva_name": "p_protocol_state_machine_next_transaction", "id": "1211", "full_property": "property p_protocol_state_machine_handshake;\n@(posedge interface_clk) disable iff (!module_rst_n)     protocol_state_machine && $past(handshake_sequence_complete, 4) |-> next_transaction_initiate\nendproperty\nassert_p_protocol_state_machine_handshake:assert property (p_protocol_state_machine_handshake) else $error(\"\");", "task_id": "1_4973", "predict_sva": "@(posedge interface_clk) disable iff (!module_rst_n)     protocol_state_machine && $past(handshake_sequence_complete, 4) |-> next_transaction_initiate"}
{"sva": "@(posedge clock) disable iff(thermal_shutdown) switching_regulator_enable |-> $past(feedback_stable, 3) && output_in_regulation", "sva_description": "### Assertion description:  \n**Property Name**: p_switching_regulator_enable_check  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (thermal_shutdown)`  \n**Antecedent (LHS of Implication)**: `switching_regulator_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(feedback_stable, 3) && output_in_regulation`  \n\n(Note: The assertion checks that whenever `switching_regulator_enable` is high, the feedback signal must have been stable 3 clock cycles prior (`$past(feedback_stable, 3)`) and the output must currently be in regulation (`output_in_regulation`). The check is disabled during `thermal_shutdown`.)", "sva_signals": ["clock", "[0:0] thermal_shutdown", "[0:0] switching_regulator_enable", "[0:0] feedback_stable", "[0:0] output_in_regulation"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (thermal_shutdown)     switching_regulator_enable == 1'b1 |-> $past(feedback_stable, 3) && output_in_regulation", "sva_name": "p_switching_regulator_enable_check", "id": "1077", "full_property": "property p_switching_regulator_enable_check;\n@(posedge clock) disable iff (thermal_shutdown)     switching_regulator_enable == 1'b1 |-> $past(feedback_stable, 3) && output_in_regulation\nendproperty\nassert_p_switching_regulator_enable_check:assert property (p_switching_regulator_enable_check) else $error(\"\");", "task_id": "1_4843", "predict_sva": "@(posedge clock) disable iff (thermal_shutdown)     switching_regulator_enable == 1'b1 |-> $past(feedback_stable, 3) && output_in_regulation"}
{"sva": "@(posedge clk_electron_microscopy) disable iff(!high_voltage_reset) scanning_transmission_mode && $past(electron_beam_focus_convergence, 11) |-> atomic_resolution_imaging", "sva_description": "### Assertion description:  \n**Property Name**: p_atomic_resolution_imaging  \n**Trigger Condition**: At every rising edge of the `clk_electron_microscopy`  \n**Disable Condition**: disable iff (!high_voltage_reset)  \n**Antecedent (LHS of Implication)**: `scanning_transmission_mode && $past(electron_beam_focus_convergence, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `atomic_resolution_imaging`", "sva_signals": ["clk_electron_microscopy", "high_voltage_reset", "[0:0] scanning_transmission_mode", "[0:0] electron_beam_focus_convergence", "[0:0] atomic_resolution_imaging"], "clock": "clk_electron_microscopy", "attempts_left": 10, "sva_result": "@(posedge clk_electron_microscopy) disable iff (!high_voltage_reset)     scanning_transmission_mode && $past(electron_beam_focus_convergence, 11) |-> atomic_resolution_imaging", "sva_name": "p_atomic_resolution_imaging", "id": "1279", "full_property": "property p_atomic_resolution_imaging;\n@(posedge clk_electron_microscopy) disable iff (!high_voltage_reset)     scanning_transmission_mode && $past(electron_beam_focus_convergence, 11) |-> atomic_resolution_imaging\nendproperty\nassert_p_atomic_resolution_imaging:assert property (p_atomic_resolution_imaging) else $error(\"\");", "task_id": "1_5039", "predict_sva": "@(posedge clk_electron_microscopy) disable iff (!high_voltage_reset)     scanning_transmission_mode && $past(electron_beam_focus_convergence, 11) |-> atomic_resolution_imaging"}
{"sva": "@(negedge clk_bandwidth_monitor) disable iff(!traffic_analysis_reset) congestion_control_algorithm && $past(network_utilization_measurement, 6) |-> flow_rate_adjustment", "sva_description": "### Assertion description:  \n**Property Name**: p_congestion_control_flow_adjustment  \n**Trigger Condition**: At every falling edge of `clk_bandwidth_monitor`  \n**Disable Condition**: `disable iff (!traffic_analysis_reset)`  \n**Antecedent (LHS of Implication)**: `congestion_control_algorithm && $past(network_utilization_measurement, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `flow_rate_adjustment`  ", "sva_signals": ["clk_bandwidth_monitor", "traffic_analysis_reset", "[0:0] congestion_control_algorithm", "[0:0] network_utilization_measurement", "[0:0] flow_rate_adjustment"], "clock": "clk_bandwidth_monitor", "attempts_left": 10, "sva_result": "@(negedge clk_bandwidth_monitor) disable iff (!traffic_analysis_reset)     (congestion_control_algorithm && $past(network_utilization_measurement, 6)) |-> flow_rate_adjustment", "sva_name": "p_congestion_control_flow_rate", "id": "1302", "full_property": "property p_congestion_control_flow_adjustment;\n@(negedge clk_bandwidth_monitor) disable iff (!traffic_analysis_reset)     (congestion_control_algorithm && $past(network_utilization_measurement, 6)) |-> flow_rate_adjustment\nendproperty\nassert_p_congestion_control_flow_adjustment:assert property (p_congestion_control_flow_adjustment) else $error(\"\");", "task_id": "1_5062", "predict_sva": "@(negedge clk_bandwidth_monitor) disable iff (!traffic_analysis_reset)     congestion_control_algorithm && $past(network_utilization_measurement, 6) |-> flow_rate_adjustment"}
{"sva": "@(posedge clk_fermentation) disable iff(ph_level_imbalance) controlled_fermentation |-> ($past(microbial_culture_introduction, 1) && $past(anaerobic_environment, 2)) && $past(metabolic_byproduct, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_controlled_fermentation_check  \n**Trigger Condition**: At every rising edge of the `clk_fermentation`  \n**Disable Condition**: disable iff (`ph_level_imbalance`)  \n**Antecedent (LHS of Implication)**: `controlled_fermentation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n(`$past(microbial_culture_introduction, 1) && $past(anaerobic_environment, 2)`) && `$past(metabolic_byproduct, 3)`  ", "sva_signals": ["clk_fermentation", "ph_level_imbalance", "[0:0] controlled_fermentation", "[0:0] microbial_culture_introduction", "[0:0] anaerobic_environment", "[0:0] metabolic_byproduct"], "clock": "clk_fermentation", "attempts_left": 10, "sva_result": "@(posedge clk_fermentation) disable iff (ph_level_imbalance)     controlled_fermentation == 1'b1 |->     ($past(microbial_culture_introduction, 1) && $past(anaerobic_environment, 2)) &&      $past(metabolic_byproduct, 3)", "sva_name": "p_Controlled_Fermentation_Check", "id": "0872", "full_property": "property p_controlled_fermentation_check;\n@(posedge clk_fermentation) disable iff (ph_level_imbalance)     controlled_fermentation == 1'b1 |->     ($past(microbial_culture_introduction, 1) && $past(anaerobic_environment, 2)) &&      $past(metabolic_byproduct, 3)\nendproperty\nassert_p_controlled_fermentation_check:assert property (p_controlled_fermentation_check) else $error(\"\");", "task_id": "1_4655", "predict_sva": "@(posedge clk_fermentation) disable iff (ph_level_imbalance)     controlled_fermentation == 1'b1 |->      ($past(microbial_culture_introduction, 1) && $past(anaerobic_environment, 2)) && $past(metabolic_byproduct, 3)"}
{"sva": "@(negedge clk_decimation) disable iff(rst_downsampling) multirate_signal_processing && $past(anti_aliasing_filter_response, 9) |-> sample_rate_reduction", "sva_description": "### Assertion description:  \n**Property Name**: p_multirate_signal_processing  \n**Trigger Condition**: At every falling edge of the `clk_decimation`  \n**Disable Condition**: disable iff (rst_downsampling)  \n**Antecedent (LHS of Implication)**: `multirate_signal_processing && $past(anti_aliasing_filter_response, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sample_rate_reduction`", "sva_signals": ["clk_decimation", "rst_downsampling", "[0:0] multirate_signal_processing", "[0:0] anti_aliasing_filter_response", "[0:0] sample_rate_reduction"], "clock": "clk_decimation", "attempts_left": 10, "sva_result": "@(negedge clk_decimation) disable iff (rst_downsampling)         multirate_signal_processing && $past(anti_aliasing_filter_response, 9) |-> sample_rate_reduction", "sva_name": "p_sample_rate_reduction", "id": "1311", "full_property": "property p_multirate_signal_processing;\n@(negedge clk_decimation) disable iff (rst_downsampling)         multirate_signal_processing && $past(anti_aliasing_filter_response, 9) |-> sample_rate_reduction\nendproperty\nassert_p_multirate_signal_processing:assert property (p_multirate_signal_processing) else $error(\"\");", "task_id": "1_5071", "predict_sva": "@(negedge clk_decimation) disable iff (rst_downsampling)         (multirate_signal_processing && $past(anti_aliasing_filter_response, 9)) |-> sample_rate_reduction"}
{"sva": "@(posedge optical_clk) disable iff(!laser_stable) photonic_processor |-> (wavelength_division[31:0] & optical_routing[31:0] ? (interference_constructive ? optical_logic : (phase_mismatch ? realign_phase : destructive_interference)) : no_photons)", "sva_description": "### Assertion description:  \n**Property Name**: p_photonic_processor_behavior  \n**Trigger Condition**: At every rising edge of `optical_clk`  \n**Disable Condition**: `disable iff (!laser_stable)`  \n**Antecedent (LHS of Implication)**: `photonic_processor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(wavelength_division[31:0] & optical_routing[31:0] ? (interference_constructive ? optical_logic : (phase_mismatch ? realign_phase : destructive_interference)) : no_photons)`  \n\n### Explanation of Consequent Logic:  \nThe consequent is a nested ternary conditional expression that evaluates as follows:  \n1. **Primary Condition**: If `wavelength_division[31:0] & optical_routing[31:0]` is true (bitwise AND result is non-zero), proceed to evaluate the inner ternary expressions. Otherwise, the result is `no_photons`.  \n2. **Secondary Condition**: If `interference_constructive` is true, the result is `optical_logic`.  \n3. **Tertiary Condition**: If `interference_constructive` is false but `phase_mismatch` is true, the result is `realign_phase`.  \n4. **Final Default**: If neither `interference_constructive` nor `phase_mismatch` is true, the result is `destructive_interference`.  \n\n### Summary:  \nThe property asserts that whenever `photonic_processor` is active (antecedent), the system must behave according to the complex photonic logic described in the consequent, subject to the stability of `laser_stable`. The evaluation is clocked at `optical_clk` edges.", "sva_signals": ["optical_clk", "laser_stable", "[0:0] photonic_processor", "[31:0] wavelength_division", "[31:0] optical_routing", "[0:0] interference_constructive", "[0:0] optical_logic", "[0:0] phase_mismatch", "[0:0] realign_phase", "[0:0] destructive_interference", "[0:0] no_photons"], "clock": "optical_clk", "attempts_left": 10, "sva_result": "@(posedge optical_clk) disable iff (!laser_stable)    photonic_processor |->         (wavelength_division[31:0] & optical_routing[31:0]) ?             (interference_constructive ? optical_logic :                 (phase_mismatch ? realign_phase : destructive_interference))             : no_photons", "sva_name": "p_photonic_processor_check", "id": "0793", "full_property": "property p_photonic_processor_behavior;\n@(posedge optical_clk) disable iff (!laser_stable)    photonic_processor |->         (wavelength_division[31:0] & optical_routing[31:0]) ?             (interference_constructive ? optical_logic :                 (phase_mismatch ? realign_phase : destructive_interference))             : no_photons\nendproperty\nassert_p_photonic_processor_behavior:assert property (p_photonic_processor_behavior) else $error(\"\");", "task_id": "1_3637", "predict_sva": "@(posedge optical_clk) disable iff (!laser_stable)    photonic_processor |->         ((wavelength_division[31:0] & optical_routing[31:0]) ?             (interference_constructive ? optical_logic :                 (phase_mismatch ? realign_phase : destructive_interference))         : no_photons)"}
{"sva": "@(posedge clk_quantum_cryptography) disable iff(rst_photon_detector == 1'b1) bb84_protocol_implementation |-> $past(polarization_basis_reconciliation, 16) && key_distillation_process", "sva_description": "### Assertion description:  \n**Property Name**: p_bb84_protocol_implementation  \n**Trigger Condition**: At every rising edge of the `clk_quantum_cryptography`  \n**Disable Condition**: `disable iff (rst_photon_detector == 1'b1)`  \n**Antecedent (LHS of Implication)**: `bb84_protocol_implementation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(polarization_basis_reconciliation, 16) && key_distillation_process`  ", "sva_signals": ["clk_quantum_cryptography", "rst_photon_detector", "[0:0] bb84_protocol_implementation", "[0:0] polarization_basis_reconciliation", "[0:0] key_distillation_process"], "clock": "clk_quantum_cryptography", "attempts_left": 10, "sva_result": "@(posedge clk_quantum_cryptography) disable iff (rst_photon_detector == 1'b1)     bb84_protocol_implementation |-> ($past(polarization_basis_reconciliation, 16) && key_distillation_process)", "sva_name": "p_bb84_protocol_implementation", "id": "1275", "full_property": "property p_bb84_protocol_implementation;\n@(posedge clk_quantum_cryptography) disable iff (rst_photon_detector == 1'b1)     bb84_protocol_implementation |-> ($past(polarization_basis_reconciliation, 16) && key_distillation_process)\nendproperty\nassert_p_bb84_protocol_implementation:assert property (p_bb84_protocol_implementation) else $error(\"\");", "task_id": "1_5035", "predict_sva": "@(posedge clk_quantum_cryptography) disable iff (rst_photon_detector == 1'b1)     bb84_protocol_implementation |-> $past(polarization_basis_reconciliation, 16) && key_distillation_process"}
{"sva": "@(posedge clk_network_interface) disable iff(rst_packet_engine) zero_copy_data_transfer && $past(direct_memory_access_setup, 9) |-> kernel_bypass_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_zero_copy_dma_to_kernel_bypass  \n**Trigger Condition**: At every rising edge of the `clk_network_interface`  \n**Disable Condition**: `disable iff (rst_packet_engine)`  \n**Antecedent (LHS of Implication)**: `zero_copy_data_transfer && $past(direct_memory_access_setup, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `kernel_bypass_optimization`  ", "sva_signals": ["clk_network_interface", "rst_packet_engine", "[0:0] zero_copy_data_transfer", "[0:0] direct_memory_access_setup", "[0:0] kernel_bypass_optimization"], "clock": "clk_network_interface", "attempts_left": 10, "sva_result": "@(posedge clk_network_interface) disable iff (rst_packet_engine)     zero_copy_data_transfer && $past(direct_memory_access_setup, 9) |-> kernel_bypass_optimization", "sva_name": "p_zero_copy_data_transfer", "id": "1313", "full_property": "property p_zero_copy_dma_to_kernel_bypass;\n@(posedge clk_network_interface) disable iff (rst_packet_engine)     zero_copy_data_transfer && $past(direct_memory_access_setup, 9) |-> kernel_bypass_optimization\nendproperty\nassert_p_zero_copy_dma_to_kernel_bypass:assert property (p_zero_copy_dma_to_kernel_bypass) else $error(\"\");", "task_id": "1_5073", "predict_sva": "@(posedge clk_network_interface) disable iff (rst_packet_engine)     zero_copy_data_transfer && $past(direct_memory_access_setup, 9) |-> kernel_bypass_optimization"}
{"sva": "@(negedge clk_store_buffer) disable iff(!memory_ordering_reset) store_to_load_forwarding && $past(address_comparison_logic, 5) |-> memory_consistency_maintenance", "sva_description": "### Assertion description:  \n**Property Name**: p_store_to_load_forwarding_consistency  \n**Trigger Condition**: At every falling edge of `clk_store_buffer`  \n**Disable Condition**: `disable iff (!memory_ordering_reset)`  \n**Antecedent (LHS of Implication)**: `store_to_load_forwarding && $past(address_comparison_logic, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `memory_consistency_maintenance`  ", "sva_signals": ["clk", "memory_ordering_reset", "store_to_load_forwarding", "[0:0] address_comparison_logic", "memory_consistency_maintenance", "clk_store_buffer"], "clock": "clk_store_buffer", "attempts_left": 10, "sva_result": "@(negedge clk_store_buffer) disable iff (!memory_ordering_reset)         store_to_load_forwarding && $past(address_comparison_logic, 5) |-> memory_consistency_maintenance", "sva_name": "p_StoreToLoadForwarding", "id": "1333", "full_property": "property p_store_to_load_forwarding_consistency;\n@(negedge clk_store_buffer) disable iff (!memory_ordering_reset)         store_to_load_forwarding && $past(address_comparison_logic, 5) |-> memory_consistency_maintenance\nendproperty\nassert_p_store_to_load_forwarding_consistency:assert property (p_store_to_load_forwarding_consistency) else $error(\"\");", "task_id": "1_5092", "predict_sva": "@(negedge clk_store_buffer) disable iff (!memory_ordering_reset)     store_to_load_forwarding && $past(address_comparison_logic, 5) |-> memory_consistency_maintenance"}
{"sva": "@(posedge clk_space_telescope) disable iff(rst_optics == 1'b1) adaptive_optics_wavefront_correction && $past(guide_star_centroid_measurement, 8) |-> deformable_mirror_actuation", "sva_description": "### Assertion description:  \n**Property Name**: p_adaptive_optics_wavefront_correction  \n**Trigger Condition**: At every rising edge of the `clk_space_telescope`  \n**Disable Condition**: `disable iff (rst_optics == 1'b1)`  \n**Antecedent (LHS of Implication)**: `adaptive_optics_wavefront_correction && $past(guide_star_centroid_measurement, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `deformable_mirror_actuation`", "sva_signals": ["clk_space_telescope", "rst_optics", "[0:0] adaptive_optics_wavefront_correction", "[0:0] guide_star_centroid_measurement", "[0:0] deformable_mirror_actuation"], "clock": "clk_space_telescope", "attempts_left": 10, "sva_result": "@(posedge clk_space_telescope) disable iff (rst_optics == 1'b1)     (adaptive_optics_wavefront_correction && $past(guide_star_centroid_measurement, 8)) |-> deformable_mirror_actuation", "sva_name": "p_adaptive_optics_wavefront_correction", "id": "1294", "full_property": "property p_adaptive_optics_wavefront_correction;\n@(posedge clk_space_telescope) disable iff (rst_optics == 1'b1)     (adaptive_optics_wavefront_correction && $past(guide_star_centroid_measurement, 8)) |-> deformable_mirror_actuation\nendproperty\nassert_p_adaptive_optics_wavefront_correction:assert property (p_adaptive_optics_wavefront_correction) else $error(\"\");", "task_id": "1_5054", "predict_sva": "@(posedge clk_space_telescope) disable iff (rst_optics == 1'b1)     adaptive_optics_wavefront_correction && $past(guide_star_centroid_measurement, 8) |-> deformable_mirror_actuation"}
{"sva": "@(negedge clk_cognitive_radio) disable iff(!spectrum_sensing_reset) dynamic_spectrum_access && $past(primary_user_detection_algorithm, 11) |-> opportunistic_transmission_opportunity", "sva_description": "### Assertion description:  \n**Property Name**: p_Opportunistic_Transmission_Opportunity  \n**Trigger Condition**: At every falling edge of the `clk_cognitive_radio`  \n**Disable Condition**: `disable iff (!spectrum_sensing_reset)`  \n**Antecedent (LHS of Implication)**: `dynamic_spectrum_access && $past(primary_user_detection_algorithm, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `opportunistic_transmission_opportunity`", "sva_signals": ["clk_cognitive_radio", "spectrum_sensing_reset", "[0:0] dynamic_spectrum_access", "[0:0] primary_user_detection_algorithm", "[0:0] opportunistic_transmission_opportunity"], "clock": "clk_cognitive_radio", "attempts_left": 10, "sva_result": "@(negedge clk_cognitive_radio) disable iff (!spectrum_sensing_reset)     (dynamic_spectrum_access && $past(primary_user_detection_algorithm, 11)) |-> opportunistic_transmission_opportunity", "sva_name": "p_dynamic_spectrum_access", "id": "1356", "full_property": "property p_Opportunistic_Transmission_Opportunity;\n@(negedge clk_cognitive_radio) disable iff (!spectrum_sensing_reset)     (dynamic_spectrum_access && $past(primary_user_detection_algorithm, 11)) |-> opportunistic_transmission_opportunity\nendproperty\nassert_p_Opportunistic_Transmission_Opportunity:assert property (p_Opportunistic_Transmission_Opportunity) else $error(\"\");", "task_id": "1_5114", "predict_sva": "@(negedge clk_cognitive_radio) disable iff (!spectrum_sensing_reset)     dynamic_spectrum_access && $past(primary_user_detection_algorithm, 11) |-> opportunistic_transmission_opportunity"}
{"sva": "@(posedge love_clk) disable iff(!heart_opening) universal_love |-> (~separation_illusion[15:0] & unity_recognition[15:0] ? (unconditional_love ? divine_connection : (conditional_love ? personal_attachment : emotional_numbness)) : fear_based_consciousness)", "sva_description": "### Assertion description:  \n**Property Name**: p_Universal_Love_Check  \n**Trigger Condition**: At every rising edge of the `love_clk`  \n**Disable Condition**: `disable iff (!heart_opening)`  \n**Antecedent (LHS of Implication)**: `universal_love`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(~separation_illusion[15:0] & unity_recognition[15:0] ? (unconditional_love ? divine_connection : (conditional_love ? personal_attachment : emotional_numbness)) : fear_based_consciousness)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary expression that evaluates as follows:  \n1. If `(~separation_illusion[15:0] & unity_recognition[15:0])` is true:  \n   - If `unconditional_love` is true, the result is `divine_connection`.  \n   - Else, if `conditional_love` is true, the result is `personal_attachment`.  \n   - Else, the result is `emotional_numbness`.  \n2. If `(~separation_illusion[15:0] & unity_recognition[15:0])` is false, the result is `fear_based_consciousness`.  \n\n### Summary:  \nThe property checks that whenever `universal_love` is true at a rising edge of `love_clk` (and `heart_opening` is not disabled), the consequent evaluates to one of the specified outputs based on the conditions of `separation_illusion`, `unity_recognition`, `unconditional_love`, and `conditional_love`.", "sva_signals": ["love_clk", "heart_opening", "[0:0] universal_love", "[15:0] separation_illusion", "[15:0] unity_recognition", "[0:0] unconditional_love", "[0:0] divine_connection", "[0:0] conditional_love", "[0:0] personal_attachment", "[0:0] emotional_numbness", "[0:0] fear_based_consciousness"], "clock": "love_clk", "attempts_left": 10, "sva_result": "@(posedge love_clk) disable iff (!heart_opening)    universal_love |->         (~separation_illusion[15:0] & unity_recognition[15:0] ?             (unconditional_love ? divine_connection :                 (conditional_love ? personal_attachment : emotional_numbness))         : fear_based_consciousness)", "sva_name": "p_Universal_Love_Check", "id": "0803", "full_property": "property p_Universal_Love_Check;\n@(posedge love_clk) disable iff (!heart_opening)    universal_love |->         (~separation_illusion[15:0] & unity_recognition[15:0] ?             (unconditional_love ? divine_connection :                 (conditional_love ? personal_attachment : emotional_numbness))         : fear_based_consciousness)\nendproperty\nassert_p_Universal_Love_Check:assert property (p_Universal_Love_Check) else $error(\"\");", "task_id": "1_3646", "predict_sva": "@(posedge love_clk) disable iff (!heart_opening)    universal_love |->         ((~separation_illusion[15:0]) & unity_recognition[15:0]) ?             (unconditional_love ? divine_connection :                 (conditional_love ? personal_attachment : emotional_numbness))            : fear_based_consciousness"}
{"sva": "@(negedge clk_thermal) disable iff(!thermal_sensor_valid) dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition", "sva_description": "### Assertion description:  \n**Property Name**: p_dynamic_voltage_frequency_scaling_check  \n**Trigger Condition**: At every falling edge of the `clk_thermal`  \n**Disable Condition**: disable iff (`!thermal_sensor_valid`)  \n**Antecedent (LHS of Implication)**: `dynamic_voltage_frequency_scaling`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(workload_prediction_model, 9) && power_state_transition`  \n\n(Note: The property checks that whenever `dynamic_voltage_frequency_scaling` is active, the value of `workload_prediction_model` from 9 cycles ago must be true, and `power_state_transition` must also be true at the current cycle.)", "sva_signals": ["clk_thermal", "thermal_sensor_valid", "[0:0] dynamic_voltage_frequency_scaling", "[0:0] workload_prediction_model", "[0:0] power_state_transition"], "clock": "clk_thermal", "attempts_left": 10, "sva_result": "@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition", "sva_name": "p_dynamic_voltage_frequency_scaling", "id": "1202", "full_property": "property p_dynamic_voltage_frequency_scaling_check;\n@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition\nendproperty\nassert_p_dynamic_voltage_frequency_scaling_check:assert property (p_dynamic_voltage_frequency_scaling_check) else $error(\"\");", "task_id": "1_4964", "predict_sva": "@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition"}
{"sva": "@(posedge clk_sustainable_ai) disable iff(carbon_budget_exceeded) green_computing |-> ($past(energy_efficient_architecture, 1) && $past(model_compression, 2)) && $past(renewable_energy_usage, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Green_Computing_Check  \n**Trigger Condition**: At every rising edge of the `clk_sustainable_ai`  \n**Disable Condition**: `disable iff (carbon_budget_exceeded)`  \n**Antecedent (LHS of Implication)**: `green_computing == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe logical AND of:  \n1. The value of `energy_efficient_architecture` from **1 clock cycle ago** (`$past(energy_efficient_architecture, 1)`),  \n2. The value of `model_compression` from **2 clock cycles ago** (`$past(model_compression, 2)`), and  \n3. The value of `renewable_energy_usage` from **3 clock cycles ago** (`$past(renewable_energy_usage, 3)`).  \n\nThe assertion checks that when `green_computing` is active, the past states of energy efficiency, model compression, and renewable energy usage must all have been active at their respective historical time points.", "sva_signals": ["clk_sustainable_ai", "carbon_budget_exceeded", "[0:0] green_computing", "[0:0] energy_efficient_architecture", "[0:0] model_compression", "[0:0] renewable_energy_usage"], "clock": "clk_sustainable_ai", "attempts_left": 10, "sva_result": "@(posedge clk_sustainable_ai) disable iff (carbon_budget_exceeded)     green_computing == 1'b1 |->     $past(energy_efficient_architecture, 1) &&     $past(model_compression, 2) &&     $past(renewable_energy_usage, 3)", "sva_name": "p_Green_Computing_Check", "id": "0558", "full_property": "property p_Green_Computing_Check;\n@(posedge clk_sustainable_ai) disable iff (carbon_budget_exceeded)     green_computing == 1'b1 |->     $past(energy_efficient_architecture, 1) &&     $past(model_compression, 2) &&     $past(renewable_energy_usage, 3)\nendproperty\nassert_p_Green_Computing_Check:assert property (p_Green_Computing_Check) else $error(\"\");", "task_id": "1_4362", "predict_sva": "@(posedge clk_sustainable_ai) disable iff (carbon_budget_exceeded)     green_computing == 1'b1 |->      $past(energy_efficient_architecture, 1) &&      $past(model_compression, 2) &&      $past(renewable_energy_usage, 3)"}
{"sva": "@(posedge clk_machine_type) disable iff(rst_iot_communication) massive_machine_type_communication && $past(random_access_procedure_optimization, 10) |-> connection_density_scalability", "sva_description": "### Assertion description:  \n**Property Name**: p_machine_type_communication  \n**Trigger Condition**: At every rising edge of `clk_machine_type`  \n**Disable Condition**: `disable iff (rst_iot_communication)`  \n**Antecedent (LHS of Implication)**: `massive_machine_type_communication && $past(random_access_procedure_optimization, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `connection_density_scalability`", "sva_signals": ["clk_machine_type", "rst_iot_communication", "[0:0] massive_machine_type_communication", "[0:0] random_access_procedure_optimization", "[0:0] connection_density_scalability"], "clock": "clk_machine_type", "attempts_left": 10, "sva_result": "@(posedge clk_machine_type) disable iff (rst_iot_communication)         massive_machine_type_communication && $past(random_access_procedure_optimization, 10) |-> connection_density_scalability", "sva_name": "p_massive_machine_type_communication", "id": "1349", "full_property": "property p_machine_type_communication;\n@(posedge clk_machine_type) disable iff (rst_iot_communication)         massive_machine_type_communication && $past(random_access_procedure_optimization, 10) |-> connection_density_scalability\nendproperty\nassert_p_machine_type_communication:assert property (p_machine_type_communication) else $error(\"\");", "task_id": "1_5108", "predict_sva": "@(posedge clk_machine_type) disable iff (rst_iot_communication)         massive_machine_type_communication && $past(random_access_procedure_optimization, 10) |-> connection_density_scalability"}
{"sva": "@(posedge clk_edge_computing) disable iff(!mobile_edge_reset) computation_offloading_decision && $past(latency_energy_tradeoff_analysis, 9) |-> task_execution_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_Task_Execution_Optimization_After_Analysis  \n**Trigger Condition**: At every rising edge of `clk_edge_computing`  \n**Disable Condition**: `disable iff (!mobile_edge_reset)`  \n**Antecedent (LHS of Implication)**: `computation_offloading_decision && $past(latency_energy_tradeoff_analysis, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `task_execution_optimization`  ", "sva_signals": ["clk", "mobile_edge_reset", "[0:0] computation_offloading_decision", "[0:0] latency_energy_tradeoff_analysis", "[0:0] task_execution_optimization", "clk_edge_computing"], "clock": "clk_edge_computing", "attempts_left": 10, "sva_result": "@(posedge clk_edge_computing) disable iff (!mobile_edge_reset)     computation_offloading_decision && $past(latency_energy_tradeoff_analysis, 9) |-> task_execution_optimization", "sva_name": "p_Task_Execution_Optimization", "id": "1363", "full_property": "property p_Task_Execution_Optimization_After_Analysis;\n@(posedge clk_edge_computing) disable iff (!mobile_edge_reset)     computation_offloading_decision && $past(latency_energy_tradeoff_analysis, 9) |-> task_execution_optimization\nendproperty\nassert_p_Task_Execution_Optimization_After_Analysis:assert property (p_Task_Execution_Optimization_After_Analysis) else $error(\"\");", "task_id": "1_5121", "predict_sva": "@(posedge clk_edge_computing) disable iff (!mobile_edge_reset)         computation_offloading_decision && $past(latency_energy_tradeoff_analysis, 9) |-> task_execution_optimization"}
{"sva": "@(posedge clk_memory_bandwidth_partitioning) disable iff(!quality_service_reset) memory_request_throttling && $past(bandwidth_utilization_monitor, 12) |-> fair_share_allocation", "sva_description": "### Assertion description:  \n**Property Name**: p_Fair_Share_Allocation  \n**Trigger Condition**: At every rising edge of the `clk_memory_bandwidth_partitioning`  \n**Disable Condition**: `disable iff (!quality_service_reset)`  \n**Antecedent (LHS of Implication)**: `memory_request_throttling && $past(bandwidth_utilization_monitor, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fair_share_allocation`  ", "sva_signals": ["clk_memory_bandwidth_partitioning", "quality_service_reset", "[0:0] memory_request_throttling", "[0:0] bandwidth_utilization_monitor", "[0:0] fair_share_allocation"], "clock": "clk_memory_bandwidth_partitioning", "attempts_left": 10, "sva_result": "@(posedge clk_memory_bandwidth_partitioning) disable iff (!quality_service_reset)         memory_request_throttling && $past(bandwidth_utilization_monitor, 12) |-> fair_share_allocation", "sva_name": "p_Fair_Share_Allocation_After_Throttling", "id": "1305", "full_property": "property p_Fair_Share_Allocation;\n@(posedge clk_memory_bandwidth_partitioning) disable iff (!quality_service_reset)         memory_request_throttling && $past(bandwidth_utilization_monitor, 12) |-> fair_share_allocation\nendproperty\nassert_p_Fair_Share_Allocation:assert property (p_Fair_Share_Allocation) else $error(\"\");", "task_id": "1_5065", "predict_sva": "@(posedge clk_memory_bandwidth_partitioning) disable iff (!quality_service_reset)         memory_request_throttling && $past(bandwidth_utilization_monitor, 12) |-> fair_share_allocation"}
{"sva": "@(posedge clk_nutrition) disable iff(nutritional_degradation) nutrient_retention |-> ($past(vitamin_stability_maintenance, 2) && $past(mineral_bioavailability)) |=> !$past(nutrient_loss_excessive)", "sva_description": "### Assertion description:  \n**Property Name**: p_nutrient_retention_check  \n**Trigger Condition**: At every rising edge of the `clk_nutrition`  \n**Disable Condition**: `disable iff (nutritional_degradation)`  \n**Antecedent (LHS of Implication)**: `nutrient_retention == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(vitamin_stability_maintenance, 2) && $past(mineral_bioavailability)) |=> !$past(nutrient_loss_excessive)`  \n\n**Explanation of Consequent**:  \n1. The consequent checks two past conditions:  \n   - `vitamin_stability_maintenance` from **two clock cycles ago** (`$past(..., 2)`).  \n   - `mineral_bioavailability` from **one clock cycle ago** (`$past(...)`).  \n2. If both past conditions are true (`&&`), the assertion then checks (using `|=>`) that in the **next clock cycle**, `nutrient_loss_excessive` from **one cycle prior** (`$past(...)`) is **not** true (`!`).  \n\n**Note**: The `|=>` operator ensures the check on `!$past(nutrient_loss_excessive)` occurs **one clock cycle after** the evaluation of the `$past` conditions.", "sva_signals": ["clk", "nutritional_degradation", "[0:0] nutrient_retention", "[0:0] vitamin_stability_maintenance", "[0:0] mineral_bioavailability", "[0:0] nutrient_loss_excessive", "clk_nutrition"], "clock": "clk_nutrition", "attempts_left": 10, "sva_result": "@(posedge clk_nutrition) disable iff (nutritional_degradation)     nutrient_retention == 1'b1 |->     ($past(vitamin_stability_maintenance, 2) && $past(mineral_bioavailability)) |=>      !$past(nutrient_loss_excessive)", "sva_name": "p_nutrient_retention_check", "id": "0867", "full_property": "property p_nutrient_retention_check;\n@(posedge clk_nutrition) disable iff (nutritional_degradation)     nutrient_retention == 1'b1 |->     ($past(vitamin_stability_maintenance, 2) && $past(mineral_bioavailability)) |=>      !$past(nutrient_loss_excessive)\nendproperty\nassert_p_nutrient_retention_check:assert property (p_nutrient_retention_check) else $error(\"\");", "task_id": "1_4651", "predict_sva": "@(posedge clk_nutrition) disable iff (nutritional_degradation)     nutrient_retention == 1'b1 |->      ($past(vitamin_stability_maintenance, 2) && $past(mineral_bioavailability)) |=> !$past(nutrient_loss_excessive)"}
{"sva": "@(negedge clk_asset_management) disable iff(!lifecycle_management_reset) equipment_health_index_calculation && $past(condition_based_maintenance_trigger, 10) |-> asset_replacement_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_asset_replacement_optimization  \n**Trigger Condition**: At every falling edge of the `clk_asset_management`  \n**Disable Condition**: `disable iff (!lifecycle_management_reset)`  \n**Antecedent (LHS of Implication)**: `equipment_health_index_calculation && $past(condition_based_maintenance_trigger, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `asset_replacement_optimization`", "sva_signals": ["clk_asset_management", "lifecycle_management_reset", "[0:0] equipment_health_index_calculation", "[0:0] condition_based_maintenance_trigger", "[0:0] asset_replacement_optimization"], "clock": "clk_asset_management", "attempts_left": 10, "sva_result": "@(negedge clk_asset_management) disable iff (!lifecycle_management_reset)         (equipment_health_index_calculation && $past(condition_based_maintenance_trigger, 10)) |-> asset_replacement_optimization", "sva_name": "p_Asset_Replacement_Optimization", "id": "1469", "full_property": "property p_asset_replacement_optimization;\n@(negedge clk_asset_management) disable iff (!lifecycle_management_reset)         (equipment_health_index_calculation && $past(condition_based_maintenance_trigger, 10)) |-> asset_replacement_optimization\nendproperty\nassert_p_asset_replacement_optimization:assert property (p_asset_replacement_optimization) else $error(\"\");", "task_id": "1_5227", "predict_sva": "@(negedge clk_asset_management) disable iff (!lifecycle_management_reset)         (equipment_health_index_calculation && $past(condition_based_maintenance_trigger, 10)) |-> asset_replacement_optimization"}
{"sva": "@(negedge clk_pumped_hydro) disable iff(rst_pumped_storage) upper_lower_reservoir_management && $past(water_elevation_difference, 10) |-> gravitational_potential_energy_storage", "sva_description": "### Assertion description:  \n**Property Name**: p_gravitational_potential_energy_storage  \n**Trigger Condition**: At every falling edge of `clk_pumped_hydro`  \n**Disable Condition**: `disable iff (rst_pumped_storage)`  \n**Antecedent (LHS of Implication)**: `upper_lower_reservoir_management && $past(water_elevation_difference, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gravitational_potential_energy_storage`  ", "sva_signals": ["clk_pumped_hydro", "rst_pumped_storage", "[0:0] upper_lower_reservoir_management", "[0:0] gravitational_potential_energy_storage", "[0:0] water_elevation_difference"], "clock": "clk_pumped_hydro", "attempts_left": 10, "sva_result": "@(negedge clk_pumped_hydro) disable iff (rst_pumped_storage)         upper_lower_reservoir_management && $past(water_elevation_difference, 10) |->          gravitational_potential_energy_storage", "sva_name": "p_Gravitational_Potential_Energy_Storage", "id": "1449", "full_property": "property p_gravitational_potential_energy_storage;\n@(negedge clk_pumped_hydro) disable iff (rst_pumped_storage)         upper_lower_reservoir_management && $past(water_elevation_difference, 10) |->          gravitational_potential_energy_storage\nendproperty\nassert_p_gravitational_potential_energy_storage:assert property (p_gravitational_potential_energy_storage) else $error(\"\");", "task_id": "1_5207", "predict_sva": "@(negedge clk_pumped_hydro) disable iff (rst_pumped_storage)         (upper_lower_reservoir_management && $past(water_elevation_difference, 10))          |-> gravitational_potential_energy_storage"}
{"sva": "@(posedge clk_interoperability) disable iff(rst_communication_protocol) iec61850_standard_compliance && $past(semantic_data_model_validation, 5) |-> multi_vendor_system_integration", "sva_description": "### Assertion description:  \n**Property Name**: p_iec61850_compliance_with_validation  \n**Trigger Condition**: At every rising edge of `clk_interoperability`  \n**Disable Condition**: `disable iff (rst_communication_protocol)`  \n**Antecedent (LHS of Implication)**: `iec61850_standard_compliance && $past(semantic_data_model_validation, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `multi_vendor_system_integration`  ", "sva_signals": ["clk_interoperability", "rst_communication_protocol", "[0:0] iec61850_standard_compliance", "[0:0] semantic_data_model_validation", "[0:0] multi_vendor_system_integration"], "clock": "clk_interoperability", "attempts_left": 10, "sva_result": "@(posedge clk_interoperability) disable iff (rst_communication_protocol)         (iec61850_standard_compliance && $past(semantic_data_model_validation, 5)) |-> multi_vendor_system_integration", "sva_name": "p_iec61850_standard_compliance", "id": "1455", "full_property": "property p_iec61850_compliance_with_validation;\n@(posedge clk_interoperability) disable iff (rst_communication_protocol)         (iec61850_standard_compliance && $past(semantic_data_model_validation, 5)) |-> multi_vendor_system_integration\nendproperty\nassert_p_iec61850_compliance_with_validation:assert property (p_iec61850_compliance_with_validation) else $error(\"\");", "task_id": "1_5213", "predict_sva": "@(posedge clk_interoperability) disable iff (rst_communication_protocol)     iec61850_standard_compliance && $past(semantic_data_model_validation, 5) |-> multi_vendor_system_integration"}
{"sva": "@(negedge clk_carbon_footprint) disable iff(rst_emission_monitoring == 1'b1) greenhouse_gas_accounting |-> $past(renewable_energy_certificate_tracking, 4) && carbon_neutrality_verification", "sva_description": "### Assertion description:  \n**Property Name**: p_greenhouse_gas_accounting  \n**Trigger Condition**: At every falling edge of `clk_carbon_footprint`  \n**Disable Condition**: `disable iff (rst_emission_monitoring == 1'b1)`  \n**Antecedent (LHS of Implication)**: `greenhouse_gas_accounting`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(renewable_energy_certificate_tracking, 4) && carbon_neutrality_verification`  ", "sva_signals": ["clk_carbon_footprint", "rst_emission_monitoring", "[0:0] greenhouse_gas_accounting", "[0:0] renewable_energy_certificate_tracking", "[0:0] carbon_neutrality_verification"], "clock": "clk_carbon_footprint", "attempts_left": 10, "sva_result": "@(negedge clk_carbon_footprint) disable iff (rst_emission_monitoring == 1'b1)     greenhouse_gas_accounting |-> $past(renewable_energy_certificate_tracking, 4) && carbon_neutrality_verification", "sva_name": "p_greenhouse_gas_accounting", "id": "1468", "full_property": "property p_greenhouse_gas_accounting;\n@(negedge clk_carbon_footprint) disable iff (rst_emission_monitoring == 1'b1)     greenhouse_gas_accounting |-> $past(renewable_energy_certificate_tracking, 4) && carbon_neutrality_verification\nendproperty\nassert_p_greenhouse_gas_accounting:assert property (p_greenhouse_gas_accounting) else $error(\"\");", "task_id": "1_5226", "predict_sva": "@(negedge clk_carbon_footprint) disable iff (rst_emission_monitoring == 1'b1)     greenhouse_gas_accounting |-> $past(renewable_energy_certificate_tracking, 4) && carbon_neutrality_verification"}
{"sva": "@(posedge clk_grid_modernization) disable iff(rst_smart_infrastructure) advanced_metering_infrastructure && $past(two_way_communication_establishment, 9) |-> intelligent_grid_operation", "sva_description": "### Assertion description:  \n**Property Name**: p_advanced_metering_intelligent_grid  \n**Trigger Condition**: At every rising edge of the `clk_grid_modernization`  \n**Disable Condition**: `disable iff (rst_smart_infrastructure)`  \n**Antecedent (LHS of Implication)**: `advanced_metering_infrastructure && $past(two_way_communication_establishment, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `intelligent_grid_operation`  ", "sva_signals": ["clk_grid_modernization", "rst_smart_infrastructure", "[0:0] advanced_metering_infrastructure", "[0:0] two_way_communication_establishment", "[0:0] intelligent_grid_operation"], "clock": "clk_grid_modernization", "attempts_left": 10, "sva_result": "@(posedge clk_grid_modernization) disable iff (rst_smart_infrastructure)     advanced_metering_infrastructure && $past(two_way_communication_establishment, 9) |-> intelligent_grid_operation", "sva_name": "p_intelligent_grid_operation", "id": "1480", "full_property": "property p_advanced_metering_intelligent_grid;\n@(posedge clk_grid_modernization) disable iff (rst_smart_infrastructure)     advanced_metering_infrastructure && $past(two_way_communication_establishment, 9) |-> intelligent_grid_operation\nendproperty\nassert_p_advanced_metering_intelligent_grid:assert property (p_advanced_metering_intelligent_grid) else $error(\"\");", "task_id": "1_5238", "predict_sva": "@(posedge clk_grid_modernization) disable iff (rst_smart_infrastructure)         advanced_metering_infrastructure && $past(two_way_communication_establishment, 9) |-> intelligent_grid_operation"}
{"sva": "@(posedge clk_generative_ai) disable iff(mode_collapse_detected) content_generation |-> ($past(latent_space_sampling, 2) && $past(adversarial_training)) |=> !$past(generated_content_bias)", "sva_description": "### Assertion description:  \n**Property Name**: p_Content_Generation_Check  \n**Trigger Condition**: At every rising edge of the `clk_generative_ai`  \n**Disable Condition**: `disable iff (mode_collapse_detected)`  \n**Antecedent (LHS of Implication)**: `content_generation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(latent_space_sampling, 2) && $past(adversarial_training)) |=> !$past(generated_content_bias)`  \n\n**Explanation of Consequent**:  \n1. The first part checks if `latent_space_sampling` was true **two cycles ago** (`$past(latent_space_sampling, 2)`) **AND** `adversarial_training` was true **one cycle ago** (`$past(adversarial_training)`).  \n2. The result of this check then triggers the **overlapping implication** (`|=>`), which ensures that in the **next cycle**, `generated_content_bias` must have been **false** one cycle prior (`!$past(generated_content_bias)`).  \n\n**Key Notes**:  \n- The assertion is **disabled** if `mode_collapse_detected` is active.  \n- The check combines **multi-cycle past values** (`$past` with depth 2) and a **temporal implication** (`|=>`).  \n- The final condition (`!$past(generated_content_bias)`) is evaluated **one cycle after** the combined check on `latent_space_sampling` and `adversarial_training`.", "sva_signals": ["clk_generative_ai", "mode_collapse_detected", "[0:0] content_generation", "latent_space_sampling", "adversarial_training", "generated_content_bias"], "clock": "clk_generative_ai", "attempts_left": 10, "sva_result": "@(posedge clk_generative_ai) disable iff (mode_collapse_detected)     content_generation |->          ($past(latent_space_sampling, 2) && $past(adversarial_training)) |=>          !$past(generated_content_bias)", "sva_name": "p_Content_Generation_Check", "id": "0555", "full_property": "property p_Content_Generation_Check;\n@(posedge clk_generative_ai) disable iff (mode_collapse_detected)     content_generation |->          ($past(latent_space_sampling, 2) && $past(adversarial_training)) |=>          !$past(generated_content_bias)\nendproperty\nassert_p_Content_Generation_Check:assert property (p_Content_Generation_Check) else $error(\"\");", "task_id": "1_4359", "predict_sva": "@(posedge clk_generative_ai) disable iff (mode_collapse_detected)     content_generation |->      ($past(latent_space_sampling, 2) && $past(adversarial_training)) |=> !$past(generated_content_bias)"}
{"sva": "@(posedge clk_regenerative_medicine) disable iff(immune_rejection_risk) stem_cell_therapy |-> ($past(pluripotency_marker_expression, 1) && $past(directed_differentiation, 2)) && $past(safety_assessment, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Stem_Cell_Therapy_Safety  \n**Trigger Condition**: At every rising edge of the `clk_regenerative_medicine`  \n**Disable Condition**: `disable iff (immune_rejection_risk)`  \n**Antecedent (LHS of Implication)**: `stem_cell_therapy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe expression evaluates to true if:  \n1. The value of `pluripotency_marker_expression` from **1 clock cycle ago** (`$past(pluripotency_marker_expression, 1)`) is true, **AND**  \n2. The value of `directed_differentiation` from **2 clock cycles ago** (`$past(directed_differentiation, 2)`) is true, **AND**  \n3. The value of `safety_assessment` from **3 clock cycles ago** (`$past(safety_assessment, 3)`) is true.  \n\nThe property ensures that when `stem_cell_therapy` is active, the required biological markers (`pluripotency_marker_expression`, `directed_differentiation`) and `safety_assessment` were valid in the specified past cycles. The check is disabled if `immune_rejection_risk` is asserted.", "sva_signals": ["clk_regenerative_medicine", "immune_rejection_risk", "[0:0] stem_cell_therapy", "[0:0] pluripotency_marker_expression", "[0:0] directed_differentiation", "[0:0] safety_assessment"], "clock": "clk_regenerative_medicine", "attempts_left": 10, "sva_result": "@(posedge clk_regenerative_medicine) disable iff (immune_rejection_risk)     stem_cell_therapy == 1'b1 |->      $past(pluripotency_marker_expression, 1) &&      $past(directed_differentiation, 2) &&      $past(safety_assessment, 3)", "sva_name": "p_Stem_Cell_Therapy_Check", "id": "0723", "full_property": "property p_Stem_Cell_Therapy_Safety;\n@(posedge clk_regenerative_medicine) disable iff (immune_rejection_risk)     stem_cell_therapy == 1'b1 |->      $past(pluripotency_marker_expression, 1) &&      $past(directed_differentiation, 2) &&      $past(safety_assessment, 3)\nendproperty\nassert_p_Stem_Cell_Therapy_Safety:assert property (p_Stem_Cell_Therapy_Safety) else $error(\"\");", "task_id": "1_4515", "predict_sva": "@(posedge clk_regenerative_medicine) disable iff (immune_rejection_risk)     stem_cell_therapy == 1'b1 |->      $past(pluripotency_marker_expression, 1) &&      $past(directed_differentiation, 2) &&      $past(safety_assessment, 3)"}
{"sva": "@(negedge clk_radiation_monitor) disable iff(rst_nuclear_detection) gamma_ray_spectroscopy && $past(background_radiation_baseline, 11) |-> radioactive_contamination_mapping", "sva_description": "### Assertion description:  \n**Property Name**: p_radioactive_contamination_mapping  \n**Trigger Condition**: At every falling edge of `clk_radiation_monitor`  \n**Disable Condition**: `disable iff (rst_nuclear_detection)`  \n**Antecedent (LHS of Implication)**: `gamma_ray_spectroscopy && $past(background_radiation_baseline, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `radioactive_contamination_mapping`  ", "sva_signals": ["clk_radiation_monitor", "rst_nuclear_detection", "[0:0] gamma_ray_spectroscopy", "[0:0] background_radiation_baseline", "[0:0] radioactive_contamination_mapping"], "clock": "clk_radiation_monitor", "attempts_left": 10, "sva_result": "@(negedge clk_radiation_monitor) disable iff (rst_nuclear_detection)     gamma_ray_spectroscopy && $past(background_radiation_baseline, 11) |-> radioactive_contamination_mapping", "sva_name": "p_radioactive_contamination_mapping", "id": "1503", "full_property": "property p_radioactive_contamination_mapping;\n@(negedge clk_radiation_monitor) disable iff (rst_nuclear_detection)     gamma_ray_spectroscopy && $past(background_radiation_baseline, 11) |-> radioactive_contamination_mapping\nendproperty\nassert_p_radioactive_contamination_mapping:assert property (p_radioactive_contamination_mapping) else $error(\"\");", "task_id": "1_5261", "predict_sva": "@(negedge clk_radiation_monitor) disable iff (rst_nuclear_detection)         (gamma_ray_spectroscopy && $past(background_radiation_baseline, 11)) |-> radioactive_contamination_mapping"}
{"sva": "@(posedge clk_water_cycle) disable iff(hydrological_disruption) freshwater_management |-> ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=> !$past(water_scarcity_crisis)", "sva_description": "### Assertion description:  \n**Property Name**: p_Freshwater_Management_Impact  \n**Trigger Condition**: At every rising edge of the `clk_water_cycle`  \n**Disable Condition**: `disable iff (hydrological_disruption)`  \n**Antecedent (LHS of Implication)**: `freshwater_management == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=> !$past(water_scarcity_crisis)`  \n\n**Explanation of Consequent**:  \n- The consequent checks that **if** the logical AND of:  \n  1. Value of `precipitation_pattern` **two cycles ago** (`$past(precipitation_pattern, 2)`)  \n  2. Value of `groundwater_depletion` **one cycle ago** (`$past(groundwater_depletion)`)  \n  **is true**, then **in the next cycle** (`|=>`), the value of `water_scarcity_crisis` **one cycle ago** (`$past(water_scarcity_crisis)`) must be **false** (`!`).  \n\n**Key Notes**:  \n- The `|=>` operator enforces a **next-cycle** relationship between the past conditions and the expected outcome.  \n- Temporal checks rely on historical values (`$past`) to evaluate the impact of `freshwater_management`.  \n- Assertion is **disabled** during `hydrological_disruption` to ignore invalid states.", "sva_signals": ["clk_water_cycle", "hydrological_disruption", "[0:0] freshwater_management", "[0:0] precipitation_pattern", "[0:0] groundwater_depletion", "[0:0] water_scarcity_crisis"], "clock": "clk_water_cycle", "attempts_left": 10, "sva_result": "@(posedge clk_water_cycle) disable iff (hydrological_disruption)     freshwater_management == 1'b1 |->      ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=>      !$past(water_scarcity_crisis)", "sva_name": "p_Freshwater_Management_Check", "id": "0674", "full_property": "property p_Freshwater_Management_Impact;\n@(posedge clk_water_cycle) disable iff (hydrological_disruption)     freshwater_management == 1'b1 |->      ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=>      !$past(water_scarcity_crisis)\nendproperty\nassert_p_Freshwater_Management_Impact:assert property (p_Freshwater_Management_Impact) else $error(\"\");", "task_id": "1_4468", "predict_sva": "@(posedge clk_water_cycle) disable iff (hydrological_disruption)     freshwater_management == 1'b1 |->      ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=> !$past(water_scarcity_crisis)"}
{"sva": "@(negedge clk_autonomous_vehicle) disable iff(rst_self_driving) lidar_point_cloud_processing && $past(object_detection_confidence, 4) |-> path_planning_decision_making", "sva_description": "### Assertion description:  \n**Property Name**: p_Lidar_Processing_To_Path_Planning  \n**Trigger Condition**: At every falling edge of the `clk_autonomous_vehicle`  \n**Disable Condition**: `disable iff (rst_self_driving)`  \n**Antecedent (LHS of Implication)**: `lidar_point_cloud_processing && $past(object_detection_confidence, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `path_planning_decision_making`  ", "sva_signals": ["clk_autonomous_vehicle", "rst_self_driving", "[0:0] lidar_point_cloud_processing", "[0:0] object_detection_confidence", "[0:0] path_planning_decision_making"], "clock": "clk_autonomous_vehicle", "attempts_left": 10, "sva_result": "@(negedge clk_autonomous_vehicle) disable iff (rst_self_driving)     (lidar_point_cloud_processing && $past(object_detection_confidence, 4)) |-> path_planning_decision_making", "sva_name": "p_lidar_point_cloud_processing_to_path_planning", "id": "1495", "full_property": "property p_Lidar_Processing_To_Path_Planning;\n@(negedge clk_autonomous_vehicle) disable iff (rst_self_driving)     (lidar_point_cloud_processing && $past(object_detection_confidence, 4)) |-> path_planning_decision_making\nendproperty\nassert_p_Lidar_Processing_To_Path_Planning:assert property (p_Lidar_Processing_To_Path_Planning) else $error(\"\");", "task_id": "1_5253", "predict_sva": "@(negedge clk_autonomous_vehicle) disable iff (rst_self_driving)         lidar_point_cloud_processing && $past(object_detection_confidence, 4) |-> path_planning_decision_making"}
{"sva": "@(posedge clk_underwater_archaeology) disable iff(marine_environment_deterioration) shipwreck_excavation |-> ($past(site_formation_process_understanding, 1) && $past(artifact_conservation_planning, 3)) && $past(environmental_impact_minimization)", "sva_description": "### Assertion description:  \n**Property Name**: p_Shipwreck_Excavation_Requirements  \n**Trigger Condition**: At every rising edge of the `clk_underwater_archaeology`  \n**Disable Condition**: `disable iff (marine_environment_deterioration)`  \n**Antecedent (LHS of Implication)**: `shipwreck_excavation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The current value of `site_formation_process_understanding` from 1 clock cycle ago (`$past(site_formation_process_understanding, 1)`) must be true, AND  \n- The current value of `artifact_conservation_planning` from 3 clock cycles ago (`$past(artifact_conservation_planning, 3)`) must be true, AND  \n- The current value of `environmental_impact_minimization` from 1 clock cycle ago (`$past(environmental_impact_minimization)`) must be true.  \n\n(Note: The `$past(environmental_impact_minimization)` without a specified depth implies a default depth of 1 clock cycle.)", "sva_signals": ["clk_underwater_archaeology", "marine_environment_deterioration", "[0:0] shipwreck_excavation", "[0:0] site_formation_process_understanding", "[0:0] artifact_conservation_planning", "[0:0] environmental_impact_minimization"], "clock": "clk_underwater_archaeology", "attempts_left": 10, "sva_result": "@(posedge clk_underwater_archaeology) disable iff (marine_environment_deterioration)     shipwreck_excavation == 1'b1 |->      $past(site_formation_process_understanding, 1) &&      $past(artifact_conservation_planning, 3) &&      $past(environmental_impact_minimization)", "sva_name": "p_Shipwreck_Excavation_Check", "id": "0998", "full_property": "property p_Shipwreck_Excavation_Requirements;\n@(posedge clk_underwater_archaeology) disable iff (marine_environment_deterioration)     shipwreck_excavation == 1'b1 |->      $past(site_formation_process_understanding, 1) &&      $past(artifact_conservation_planning, 3) &&      $past(environmental_impact_minimization)\nendproperty\nassert_p_Shipwreck_Excavation_Requirements:assert property (p_Shipwreck_Excavation_Requirements) else $error(\"\");", "task_id": "1_4769", "predict_sva": "@(posedge clk_underwater_archaeology) disable iff (marine_environment_deterioration)     shipwreck_excavation == 1'b1 |->      $past(site_formation_process_understanding, 1) &&      $past(artifact_conservation_planning, 3) &&      $past(environmental_impact_minimization)"}
{"sva": "@(posedge clk_maritime_navigation) disable iff(rst_vessel_tracking) automatic_identification_system && $past(gps_compass_heading_fusion, 9) |-> collision_risk_assessment", "sva_description": "### Assertion description:  \n**Property Name**: p_Collision_Risk_Assessment  \n**Trigger Condition**: At every rising edge of the `clk_maritime_navigation`  \n**Disable Condition**: `disable iff (rst_vessel_tracking)`  \n**Antecedent (LHS of Implication)**: `automatic_identification_system && $past(gps_compass_heading_fusion, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `collision_risk_assessment`  ", "sva_signals": ["clk_maritime_navigation", "rst_vessel_tracking", "[0:0] automatic_identification_system", "[0:0] gps_compass_heading_fusion", "[0:0] collision_risk_assessment"], "clock": "clk_maritime_navigation", "attempts_left": 10, "sva_result": "@(posedge clk_maritime_navigation) disable iff (rst_vessel_tracking)         automatic_identification_system && $past(gps_compass_heading_fusion, 9) |-> collision_risk_assessment", "sva_name": "p_Collision_Risk_After_Identification", "id": "1504", "full_property": "property p_Collision_Risk_Assessment;\n@(posedge clk_maritime_navigation) disable iff (rst_vessel_tracking)         automatic_identification_system && $past(gps_compass_heading_fusion, 9) |-> collision_risk_assessment\nendproperty\nassert_p_Collision_Risk_Assessment:assert property (p_Collision_Risk_Assessment) else $error(\"\");", "task_id": "1_5262", "predict_sva": "@(posedge clk_maritime_navigation) disable iff (rst_vessel_tracking)         automatic_identification_system && $past(gps_compass_heading_fusion, 9) |-> collision_risk_assessment"}
{"sva": "@(negedge clk_electrocardiograph) disable iff(rst_cardiac_monitoring == 1'b1) qrs_complex_detection |-> $past(baseline_wander_correction, 3) && arrhythmia_identification", "sva_description": "### Assertion description:  \n**Property Name**: p_qrs_complex_detection_check  \n**Trigger Condition**: At every falling edge of the `clk_electrocardiograph`  \n**Disable Condition**: `disable iff (rst_cardiac_monitoring == 1'b1)`  \n**Antecedent (LHS of Implication)**: `qrs_complex_detection == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(baseline_wander_correction, 3) && arrhythmia_identification`  \n\n(Note: The property checks that whenever a QRS complex is detected (`qrs_complex_detection` is high), it implies that 3 clock cycles earlier, baseline wander correction was active (`baseline_wander_correction` was high) and arrhythmia identification is currently active (`arrhythmia_identification` is high). The check is disabled during reset.)", "sva_signals": ["clk_electrocardiograph", "rst_cardiac_monitoring", "[0:0] qrs_complex_detection", "[0:0] baseline_wander_correction", "[0:0] arrhythmia_identification"], "clock": "clk_electrocardiograph", "attempts_left": 10, "sva_result": "@(negedge clk_electrocardiograph) disable iff (rst_cardiac_monitoring == 1'b1)     qrs_complex_detection == 1'b1 |-> $past(baseline_wander_correction, 3) && arrhythmia_identification", "sva_name": "p_qrs_complex_detection_check", "id": "1385", "full_property": "property p_qrs_complex_detection_check;\n@(negedge clk_electrocardiograph) disable iff (rst_cardiac_monitoring == 1'b1)     qrs_complex_detection == 1'b1 |-> $past(baseline_wander_correction, 3) && arrhythmia_identification\nendproperty\nassert_p_qrs_complex_detection_check:assert property (p_qrs_complex_detection_check) else $error(\"\");", "task_id": "1_5143", "predict_sva": "@(negedge clk_electrocardiograph) disable iff (rst_cardiac_monitoring == 1'b1)     qrs_complex_detection == 1'b1 |-> $past(baseline_wander_correction, 3) && arrhythmia_identification"}
{"sva": "@(negedge clk_resilience_planning) disable iff(rst_disaster_recovery == 1'b1) power_system_resilience_enhancement |-> $past(natural_disaster_vulnerability_assessment, 12) && recovery_time_minimization", "sva_description": "### Assertion description:  \n**Property Name**: p_power_system_resilience_enhancement  \n**Trigger Condition**: At every falling edge of `clk_resilience_planning`  \n**Disable Condition**: `disable iff (rst_disaster_recovery == 1'b1)`  \n**Antecedent (LHS of Implication)**: `power_system_resilience_enhancement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(natural_disaster_vulnerability_assessment, 12) && recovery_time_minimization`", "sva_signals": ["clk_resilience_planning", "rst_disaster_recovery", "[0:0] power_system_resilience_enhancement", "[0:0] natural_disaster_vulnerability_assessment", "[0:0] recovery_time_minimization"], "clock": "clk_resilience_planning", "attempts_left": 10, "sva_result": "@(negedge clk_resilience_planning) disable iff (rst_disaster_recovery == 1'b1)     power_system_resilience_enhancement |->          $past(natural_disaster_vulnerability_assessment, 12) && recovery_time_minimization", "sva_name": "p_power_system_resilience_enhancement", "id": "1471", "full_property": "property p_power_system_resilience_enhancement;\n@(negedge clk_resilience_planning) disable iff (rst_disaster_recovery == 1'b1)     power_system_resilience_enhancement |->          $past(natural_disaster_vulnerability_assessment, 12) && recovery_time_minimization\nendproperty\nassert_p_power_system_resilience_enhancement:assert property (p_power_system_resilience_enhancement) else $error(\"\");", "task_id": "1_5229", "predict_sva": "@(negedge clk_resilience_planning) disable iff (rst_disaster_recovery == 1'b1)     power_system_resilience_enhancement |->          $past(natural_disaster_vulnerability_assessment, 12) && recovery_time_minimization"}
{"sva": "@(posedge clk_digital_humanities) disable iff(metadata_standard_non_compliance) digital_archive |-> ($past(data_migration_strategy, 2) && $past(long_term_preservation_planning)) |=> !$past(digital_obsolescence)", "sva_description": "### Assertion description:  \n**Property Name**: p_Digital_Archive_Compliance  \n**Trigger Condition**: At every rising edge of the `clk_digital_humanities`  \n**Disable Condition**: `disable iff (metadata_standard_non_compliance)`  \n**Antecedent (LHS of Implication)**: `digital_archive == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(data_migration_strategy, 2) && $past(long_term_preservation_planning)) |=> !$past(digital_obsolescence)`  \n\n**Explanation of Consequent**:  \n1. The expression checks that two cycles ago (`$past(..., 2)`), `data_migration_strategy` was active, and one cycle ago (`$past(...)`), `long_term_preservation_planning` was active.  \n2. The `|=>` operator ensures that in the **next cycle** after these conditions are met, `digital_obsolescence` must **not** have been active in the **previous cycle** (`!$past(digital_obsolescence)`).  \n\n**Summary**:  \nIf `digital_archive` is active, it implies that:  \n- Two cycles prior, a `data_migration_strategy` was in place,  \n- One cycle prior, `long_term_preservation_planning` was active,  \n- And in the following cycle, `digital_obsolescence` was not observed in the past.  \n\nThis ensures compliance with preservation standards unless metadata is non-compliant (`metadata_standard_non_compliance` disables the check).", "sva_signals": ["clk_digital_humanities", "metadata_standard_non_compliance", "[0:0] digital_archive", "[0:0] data_migration_strategy", "[0:0] long_term_preservation_planning", "[0:0] digital_obsolescence"], "clock": "clk_digital_humanities", "attempts_left": 10, "sva_result": "@(posedge clk_digital_humanities) disable iff (metadata_standard_non_compliance)     digital_archive == 1'b1 |->      ($past(data_migration_strategy, 2) && $past(long_term_preservation_planning)) |=>      !$past(digital_obsolescence)", "sva_name": "p_digital_archive_check", "id": "0974", "full_property": "property p_Digital_Archive_Compliance;\n@(posedge clk_digital_humanities) disable iff (metadata_standard_non_compliance)     digital_archive == 1'b1 |->      ($past(data_migration_strategy, 2) && $past(long_term_preservation_planning)) |=>      !$past(digital_obsolescence)\nendproperty\nassert_p_Digital_Archive_Compliance:assert property (p_Digital_Archive_Compliance) else $error(\"\");", "task_id": "1_4750", "predict_sva": "@(posedge clk_digital_humanities) disable iff (metadata_standard_non_compliance)     digital_archive == 1'b1 |->      ($past(data_migration_strategy, 2) && $past(long_term_preservation_planning)) |=> !$past(digital_obsolescence)"}
{"sva": "@(negedge clk_renewable_resource) disable iff(rst_resource_assessment) wind_solar_resource_mapping && $past(meteorological_data_validation, 4) |-> renewable_energy_potential_evaluation", "sva_description": "### Assertion description:  \n**Property Name**: p_renewable_energy_potential_evaluation  \n**Trigger Condition**: At every falling edge of the `clk_renewable_resource`  \n**Disable Condition**: disable iff (rst_resource_assessment)  \n**Antecedent (LHS of Implication)**: `wind_solar_resource_mapping && $past(meteorological_data_validation, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `renewable_energy_potential_evaluation`", "sva_signals": ["clk_renewable_resource", "rst_resource_assessment", "[0:0] wind_solar_resource_mapping", "[0:0] meteorological_data_validation", "[0:0] renewable_energy_potential_evaluation"], "clock": "clk_renewable_resource", "attempts_left": 10, "sva_result": "@(negedge clk_renewable_resource) disable iff (rst_resource_assessment)         (wind_solar_resource_mapping && $past(meteorological_data_validation, 4)) |-> renewable_energy_potential_evaluation", "sva_name": "p_renewable_energy_potential_evaluation", "id": "1509", "full_property": "property p_renewable_energy_potential_evaluation;\n@(negedge clk_renewable_resource) disable iff (rst_resource_assessment)         (wind_solar_resource_mapping && $past(meteorological_data_validation, 4)) |-> renewable_energy_potential_evaluation\nendproperty\nassert_p_renewable_energy_potential_evaluation:assert property (p_renewable_energy_potential_evaluation) else $error(\"\");", "task_id": "1_5267", "predict_sva": "@(negedge clk_renewable_resource) disable iff (rst_resource_assessment)         (wind_solar_resource_mapping && $past(meteorological_data_validation, 4)) |-> renewable_energy_potential_evaluation"}
{"sva": "@(posedge clk_wildfire_detection) disable iff(rst_forest_monitoring == 1'b1) infrared_thermal_imaging |-> $past(vegetation_moisture_content, 6) && fire_risk_assessment_model", "sva_description": "### Assertion description:  \n**Property Name**: p_infrared_thermal_imaging_fire_risk  \n**Trigger Condition**: At every rising edge of the `clk_wildfire_detection`  \n**Disable Condition**: `disable iff (rst_forest_monitoring == 1'b1)`  \n**Antecedent (LHS of Implication)**: `infrared_thermal_imaging == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(vegetation_moisture_content, 6) && fire_risk_assessment_model`  ", "sva_signals": ["clk_wildfire_detection", "rst_forest_monitoring", "[0:0] infrared_thermal_imaging", "[0:0] vegetation_moisture_content", "[0:0] fire_risk_assessment_model"], "clock": "clk_wildfire_detection", "attempts_left": 10, "sva_result": "@(posedge clk_wildfire_detection) disable iff (rst_forest_monitoring == 1'b1)     infrared_thermal_imaging == 1'b1 |-> $past(vegetation_moisture_content, 6) && fire_risk_assessment_model", "sva_name": "p_fire_risk_assessment", "id": "1477", "full_property": "property p_infrared_thermal_imaging_fire_risk;\n@(posedge clk_wildfire_detection) disable iff (rst_forest_monitoring == 1'b1)     infrared_thermal_imaging == 1'b1 |-> $past(vegetation_moisture_content, 6) && fire_risk_assessment_model\nendproperty\nassert_p_infrared_thermal_imaging_fire_risk:assert property (p_infrared_thermal_imaging_fire_risk) else $error(\"\");", "task_id": "1_5235", "predict_sva": "@(posedge clk_wildfire_detection) disable iff (rst_forest_monitoring == 1'b1)     infrared_thermal_imaging == 1'b1 |-> $past(vegetation_moisture_content, 6) && fire_risk_assessment_model"}
{"sva": "@(negedge clk_warehouse_automation) disable iff(rst_logistics_robot) automated_guided_vehicle && $past(fleet_management_optimization, 10) |-> inventory_handling_efficiency", "sva_description": "### Assertion description:  \n**Property Name**: p_Inventory_Handling_Efficiency  \n**Trigger Condition**: At every falling edge of the `clk_warehouse_automation`  \n**Disable Condition**: `disable iff (rst_logistics_robot)`  \n**Antecedent (LHS of Implication)**: `automated_guided_vehicle && $past(fleet_management_optimization, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `inventory_handling_efficiency`", "sva_signals": ["clk_warehouse_automation", "rst_logistics_robot", "[0:0] automated_guided_vehicle", "[0:0] fleet_management_optimization", "[0:0] inventory_handling_efficiency"], "clock": "clk_warehouse_automation", "attempts_left": 10, "sva_result": "@(negedge clk_warehouse_automation) disable iff (rst_logistics_robot)         (automated_guided_vehicle && $past(fleet_management_optimization, 10)) |-> inventory_handling_efficiency", "sva_name": "p_Inventory_Handling_Efficiency", "id": "1530", "full_property": "property p_Inventory_Handling_Efficiency;\n@(negedge clk_warehouse_automation) disable iff (rst_logistics_robot)         (automated_guided_vehicle && $past(fleet_management_optimization, 10)) |-> inventory_handling_efficiency\nendproperty\nassert_p_Inventory_Handling_Efficiency:assert property (p_Inventory_Handling_Efficiency) else $error(\"\");", "task_id": "1_5288", "predict_sva": "@(negedge clk_warehouse_automation) disable iff (rst_logistics_robot)         automated_guided_vehicle && $past(fleet_management_optimization, 10) |-> inventory_handling_efficiency"}
{"sva": "@(posedge clk_design_for_test) disable iff(rst_testability == 1'b1) scan_chain_insertion |-> $past(fault_coverage_analysis, 11) && manufacturing_test_quality", "sva_description": "### Assertion description:  \n**Property Name**: p_scan_chain_insertion_quality  \n**Trigger Condition**: At every rising edge of the `clk_design_for_test`  \n**Disable Condition**: `disable iff (rst_testability == 1'b1)`  \n**Antecedent (LHS of Implication)**: `scan_chain_insertion`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(fault_coverage_analysis, 11) && manufacturing_test_quality`  ", "sva_signals": ["clk_design_for_test", "rst_testability", "[0:0] scan_chain_insertion", "[0:0] fault_coverage_analysis", "[0:0] manufacturing_test_quality"], "clock": "clk_design_for_test", "attempts_left": 10, "sva_result": "@(posedge clk_design_for_test) disable iff (rst_testability == 1'b1)     scan_chain_insertion |-> ($past(fault_coverage_analysis, 11) && manufacturing_test_quality)", "sva_name": "p_scan_chain_insertion_check", "id": "1591", "full_property": "property p_scan_chain_insertion_quality;\n@(posedge clk_design_for_test) disable iff (rst_testability == 1'b1)     scan_chain_insertion |-> ($past(fault_coverage_analysis, 11) && manufacturing_test_quality)\nendproperty\nassert_p_scan_chain_insertion_quality:assert property (p_scan_chain_insertion_quality) else $error(\"\");", "task_id": "1_5348", "predict_sva": "@(posedge clk_design_for_test) disable iff (rst_testability == 1'b1)     scan_chain_insertion |-> $past(fault_coverage_analysis, 11) && manufacturing_test_quality"}
{"sva": "@(posedge clk_marine_conservation) disable iff(rst_ocean_monitoring) coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy", "sva_description": "### Assertion description:  \n**Property Name**: p_coral_reef_restoration  \n**Trigger Condition**: At every rising edge of the `clk_marine_conservation`  \n**Disable Condition**: `disable iff (rst_ocean_monitoring)`  \n**Antecedent (LHS of Implication)**: `coral_reef_health_assessment && $past(water_chemistry_analysis, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecosystem_restoration_strategy`  ", "sva_signals": ["clk_marine_conservation", "rst_ocean_monitoring", "[0:0] coral_reef_health_assessment", "[0:0] water_chemistry_analysis", "[0:0] ecosystem_restoration_strategy"], "clock": "clk_marine_conservation", "attempts_left": 10, "sva_result": "@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy", "sva_name": "p_Coral_Reef_Health_Assessment", "id": "1520", "full_property": "property p_coral_reef_restoration;\n@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy\nendproperty\nassert_p_coral_reef_restoration:assert property (p_coral_reef_restoration) else $error(\"\");", "task_id": "1_5278", "predict_sva": "@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy"}
{"sva": "@(negedge clk_micro_robot) disable iff(rst_miniaturized_system) microfluidic_manipulation && $past(surface_tension_force_modeling, 11) |-> cellular_level_operation", "sva_description": "### Assertion description:  \n**Property Name**: p_microfluidic_to_cellular_operation  \n**Trigger Condition**: At every falling edge of the `clk_micro_robot`  \n**Disable Condition**: disable iff (`rst_miniaturized_system`)  \n**Antecedent (LHS of Implication)**: `microfluidic_manipulation && $past(surface_tension_force_modeling, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cellular_level_operation`", "sva_signals": ["clk_micro_robot", "rst_miniaturized_system", "[0:0] microfluidic_manipulation", "[0:0] surface_tension_force_modeling", "[0:0] cellular_level_operation"], "clock": "clk_micro_robot", "attempts_left": 10, "sva_result": "@(negedge clk_micro_robot) disable iff (rst_miniaturized_system)         (microfluidic_manipulation && $past(surface_tension_force_modeling, 11)) |-> cellular_level_operation", "sva_name": "p_microfluidic_manipulation_cellular_operation", "id": "1568", "full_property": "property p_microfluidic_to_cellular_operation;\n@(negedge clk_micro_robot) disable iff (rst_miniaturized_system)         (microfluidic_manipulation && $past(surface_tension_force_modeling, 11)) |-> cellular_level_operation\nendproperty\nassert_p_microfluidic_to_cellular_operation:assert property (p_microfluidic_to_cellular_operation) else $error(\"\");", "task_id": "1_5326", "predict_sva": "@(negedge clk_micro_robot) disable iff (rst_miniaturized_system)         (microfluidic_manipulation && $past(surface_tension_force_modeling, 11)) |-> cellular_level_operation"}
{"sva": "@(posedge clk_physical_design) disable iff(rst_place_route) floorplan_optimization_engine && $past(congestion_hotspot_analysis, 4) |-> routing_resource_allocation", "sva_description": "### Assertion description:  \n**Property Name**: p_floorplan_optimization_engine_trigger  \n**Trigger Condition**: At every rising edge of the `clk_physical_design`  \n**Disable Condition**: `disable iff (rst_place_route)`  \n**Antecedent (LHS of Implication)**: `floorplan_optimization_engine && $past(congestion_hotspot_analysis, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `routing_resource_allocation`  ", "sva_signals": ["clk_physical_design", "rst_place_route", "[0:0] floorplan_optimization_engine", "[0:0] congestion_hotspot_analysis", "[0:0] routing_resource_allocation"], "clock": "clk_physical_design", "attempts_left": 10, "sva_result": "@(posedge clk_physical_design) disable iff (rst_place_route)     (floorplan_optimization_engine && $past(congestion_hotspot_analysis, 4)) |-> routing_resource_allocation", "sva_name": "p_routing_resource_allocation_after_congestion_analysis", "id": "1605", "full_property": "property p_floorplan_optimization_engine_trigger;\n@(posedge clk_physical_design) disable iff (rst_place_route)     (floorplan_optimization_engine && $past(congestion_hotspot_analysis, 4)) |-> routing_resource_allocation\nendproperty\nassert_p_floorplan_optimization_engine_trigger:assert property (p_floorplan_optimization_engine_trigger) else $error(\"\");", "task_id": "1_5361", "predict_sva": "@(posedge clk_physical_design) disable iff (rst_place_route)         (floorplan_optimization_engine && $past(congestion_hotspot_analysis, 4)) |-> routing_resource_allocation"}
{"sva": "@(posedge clk_thermal_management) disable iff(!junction_temperature_reset) heat_sink_optimization && $past(thermal_resistance_modeling, 12) |-> reliability_enhancement", "sva_description": "### Assertion description:  \n**Property Name**: p_heat_sink_optimization_reliability  \n**Trigger Condition**: At every rising edge of the `clk_thermal_management`  \n**Disable Condition**: `disable iff (!junction_temperature_reset)`  \n**Antecedent (LHS of Implication)**: `heat_sink_optimization && $past(thermal_resistance_modeling, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `reliability_enhancement`", "sva_signals": ["clk_thermal_management", "junction_temperature_reset", "[0:0] heat_sink_optimization", "[0:0] thermal_resistance_modeling", "[0:0] reliability_enhancement"], "clock": "clk_thermal_management", "attempts_left": 10, "sva_result": "@(posedge clk_thermal_management) disable iff (!junction_temperature_reset)     heat_sink_optimization && $past(thermal_resistance_modeling, 12) |-> reliability_enhancement", "sva_name": "p_Heat_Sink_Optimization_Reliability", "id": "1594", "full_property": "property p_heat_sink_optimization_reliability;\n@(posedge clk_thermal_management) disable iff (!junction_temperature_reset)     heat_sink_optimization && $past(thermal_resistance_modeling, 12) |-> reliability_enhancement\nendproperty\nassert_p_heat_sink_optimization_reliability:assert property (p_heat_sink_optimization_reliability) else $error(\"\");", "task_id": "1_5350", "predict_sva": "@(posedge clk_thermal_management) disable iff (!junction_temperature_reset)         heat_sink_optimization && $past(thermal_resistance_modeling, 12) |-> reliability_enhancement"}
{"sva": "@(posedge clk_design_for_manufacturability) disable iff(rst_dfm_optimization) optical_proximity_correction && $past(mask_manufacturing_constraint, 8) |-> lithography_friendly_design", "sva_description": "### Assertion description:  \n**Property Name**: p_lithography_friendly_design  \n**Trigger Condition**: At every rising edge of the `clk_design_for_manufacturability`  \n**Disable Condition**: disable iff (rst_dfm_optimization)  \n**Antecedent (LHS of Implication)**: `optical_proximity_correction && $past(mask_manufacturing_constraint, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `lithography_friendly_design`", "sva_signals": ["clk_design_for_manufacturability", "rst_dfm_optimization", "[0:0] optical_proximity_correction", "[0:0] mask_manufacturing_constraint", "[0:0] lithography_friendly_design"], "clock": "clk_design_for_manufacturability", "attempts_left": 10, "sva_result": "@(posedge clk_design_for_manufacturability) disable iff (rst_dfm_optimization)         (optical_proximity_correction && $past(mask_manufacturing_constraint, 8)) |-> lithography_friendly_design", "sva_name": "p_optical_proximity_correction", "id": "1603", "full_property": "property p_lithography_friendly_design;\n@(posedge clk_design_for_manufacturability) disable iff (rst_dfm_optimization)         (optical_proximity_correction && $past(mask_manufacturing_constraint, 8)) |-> lithography_friendly_design\nendproperty\nassert_p_lithography_friendly_design:assert property (p_lithography_friendly_design) else $error(\"\");", "task_id": "1_5359", "predict_sva": "@(posedge clk_design_for_manufacturability) disable iff (rst_dfm_optimization)         (optical_proximity_correction && $past(mask_manufacturing_constraint, 8)) |-> lithography_friendly_design"}
{"sva": "@(posedge clk_process_design_kit) disable iff(!foundry_technology_reset) design_rule_deck_validation && $past(technology_file_characterization, 12) |-> manufacturing_readiness_verification", "sva_description": "### Assertion description:  \n**Property Name**: p_manufacturing_readiness_verification  \n**Trigger Condition**: At every rising edge of the `clk_process_design_kit`  \n**Disable Condition**: disable iff (`!foundry_technology_reset`)  \n**Antecedent (LHS of Implication)**: `design_rule_deck_validation && $past(technology_file_characterization, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `manufacturing_readiness_verification`", "sva_signals": ["clk", "foundry_technology_reset", "[0:0] design_rule_deck_validation", "[0:0] technology_file_characterization", "[0:0] manufacturing_readiness_verification", "clk_process_design_kit"], "clock": "clk_process_design_kit", "attempts_left": 10, "sva_result": "@(posedge clk_process_design_kit) disable iff (!foundry_technology_reset)     design_rule_deck_validation && $past(technology_file_characterization, 12) |-> manufacturing_readiness_verification", "sva_name": "p_manufacturing_readiness_verification", "id": "1643", "full_property": "property p_manufacturing_readiness_verification;\n@(posedge clk_process_design_kit) disable iff (!foundry_technology_reset)     design_rule_deck_validation && $past(technology_file_characterization, 12) |-> manufacturing_readiness_verification\nendproperty\nassert_p_manufacturing_readiness_verification:assert property (p_manufacturing_readiness_verification) else $error(\"\");", "task_id": "1_5399", "predict_sva": "@(posedge clk_process_design_kit) disable iff (!foundry_technology_reset)         (design_rule_deck_validation && $past(technology_file_characterization, 12)) |-> manufacturing_readiness_verification"}
{"sva": "@(negedge clk_vision_system) disable iff(rst_image_processing == 1'b1) object_recognition_algorithm |-> $past(feature_extraction_convergence, 6) && classification_confidence_threshold", "sva_description": "### Assertion description:  \n**Property Name**: p_object_recognition_with_confidence  \n**Trigger Condition**: At every falling edge of the `clk_vision_system`  \n**Disable Condition**: disable iff (`rst_image_processing == 1'b1`)  \n**Antecedent (LHS of Implication)**: `object_recognition_algorithm`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(feature_extraction_convergence, 6) && classification_confidence_threshold`  ", "sva_signals": ["clk_vision_system", "rst_image_processing", "[0:0] object_recognition_algorithm", "[0:0] feature_extraction_convergence", "[0:0] classification_confidence_threshold"], "clock": "clk_vision_system", "attempts_left": 10, "sva_result": "@(negedge clk_vision_system) disable iff (rst_image_processing == 1'b1)     object_recognition_algorithm |-> $past(feature_extraction_convergence, 6) && classification_confidence_threshold", "sva_name": "p_object_recognition_with_confidence", "id": "1538", "full_property": "property p_object_recognition_with_confidence;\n@(negedge clk_vision_system) disable iff (rst_image_processing == 1'b1)     object_recognition_algorithm |-> $past(feature_extraction_convergence, 6) && classification_confidence_threshold\nendproperty\nassert_p_object_recognition_with_confidence:assert property (p_object_recognition_with_confidence) else $error(\"\");", "task_id": "1_5296", "predict_sva": "@(negedge clk_vision_system) disable iff (rst_image_processing == 1'b1)     object_recognition_algorithm |-> $past(feature_extraction_convergence, 6) && classification_confidence_threshold"}
{"sva": "@(posedge clk_dark_matter_search) disable iff(!cryogenic_detector_reset) weakly_interacting_particle && $past(background_noise_characterization, 4) |-> rare_event_identification", "sva_description": "### Assertion description:  \n**Property Name**: p_WeaklyInteractingParticle_RareEvent  \n**Trigger Condition**: At every rising edge of the `clk_dark_matter_search`  \n**Disable Condition**: `disable iff (!cryogenic_detector_reset)`  \n**Antecedent (LHS of Implication)**: `weakly_interacting_particle && $past(background_noise_characterization, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `rare_event_identification`  ", "sva_signals": ["clk_dark_matter_search", "cryogenic_detector_reset", "[0:0] weakly_interacting_particle", "[0:0] background_noise_characterization", "[0:0] rare_event_identification"], "clock": "clk_dark_matter_search", "attempts_left": 10, "sva_result": "@(posedge clk_dark_matter_search) disable iff (!cryogenic_detector_reset)     weakly_interacting_particle && $past(background_noise_characterization, 4) |-> rare_event_identification", "sva_name": "p_rare_event_identification", "id": "1671", "full_property": "property p_WeaklyInteractingParticle_RareEvent;\n@(posedge clk_dark_matter_search) disable iff (!cryogenic_detector_reset)     weakly_interacting_particle && $past(background_noise_characterization, 4) |-> rare_event_identification\nendproperty\nassert_p_WeaklyInteractingParticle_RareEvent:assert property (p_WeaklyInteractingParticle_RareEvent) else $error(\"\");", "task_id": "1_5427", "predict_sva": "@(posedge clk_dark_matter_search) disable iff (!cryogenic_detector_reset)     (weakly_interacting_particle && $past(background_noise_characterization, 4)) |-> rare_event_identification"}
{"sva": "@(posedge clk_orbital_mechanics) disable iff(!perturbation_analysis_reset) gravitational_anomaly_correction && $past(multi_body_dynamics_calculation, 9) |-> orbit_determination_accuracy", "sva_description": "### Assertion description:  \n**Property Name**: p_Gravitational_Anomaly_Correction_Orbit_Accuracy  \n**Trigger Condition**: At every rising edge of the `clk_orbital_mechanics`  \n**Disable Condition**: `disable iff (!perturbation_analysis_reset)`  \n**Antecedent (LHS of Implication)**: `gravitational_anomaly_correction && $past(multi_body_dynamics_calculation, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `orbit_determination_accuracy`", "sva_signals": ["clk_orbital_mechanics", "perturbation_analysis_reset", "[0:0] gravitational_anomaly_correction", "[0:0] multi_body_dynamics_calculation", "[0:0] orbit_determination_accuracy"], "clock": "clk_orbital_mechanics", "attempts_left": 10, "sva_result": "@(posedge clk_orbital_mechanics) disable iff (!perturbation_analysis_reset)     gravitational_anomaly_correction && $past(multi_body_dynamics_calculation, 9) |-> orbit_determination_accuracy", "sva_name": "p_gravitational_anomaly_correction", "id": "1658", "full_property": "property p_Gravitational_Anomaly_Correction_Orbit_Accuracy;\n@(posedge clk_orbital_mechanics) disable iff (!perturbation_analysis_reset)     gravitational_anomaly_correction && $past(multi_body_dynamics_calculation, 9) |-> orbit_determination_accuracy\nendproperty\nassert_p_Gravitational_Anomaly_Correction_Orbit_Accuracy:assert property (p_Gravitational_Anomaly_Correction_Orbit_Accuracy) else $error(\"\");", "task_id": "1_5414", "predict_sva": "@(posedge clk_orbital_mechanics) disable iff (!perturbation_analysis_reset)     gravitational_anomaly_correction && $past(multi_body_dynamics_calculation, 9) |-> orbit_determination_accuracy"}
{"sva": "@(negedge clk_risk_management) disable iff(rst_portfolio_analysis == 1'b1) value_at_risk_calculation |-> $past(monte_carlo_simulation_convergence, 7) && regulatory_capital_requirement", "sva_description": "### Assertion description:  \n**Property Name**: p_value_at_risk_calculation  \n**Trigger Condition**: At every falling edge of the `clk_risk_management`  \n**Disable Condition**: `disable iff (rst_portfolio_analysis == 1'b1)`  \n**Antecedent (LHS of Implication)**: `value_at_risk_calculation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(monte_carlo_simulation_convergence, 7) && regulatory_capital_requirement`", "sva_signals": ["clk_risk_management", "rst_portfolio_analysis", "[0:0] value_at_risk_calculation", "[0:0] monte_carlo_simulation_convergence", "[0:0] regulatory_capital_requirement"], "clock": "clk_risk_management", "attempts_left": 10, "sva_result": "@(negedge clk_risk_management) disable iff (rst_portfolio_analysis == 1'b1)     value_at_risk_calculation |-> $past(monte_carlo_simulation_convergence, 7) && regulatory_capital_requirement", "sva_name": "p_Value_At_Risk_Calculation", "id": "1674", "full_property": "property p_value_at_risk_calculation;\n@(negedge clk_risk_management) disable iff (rst_portfolio_analysis == 1'b1)     value_at_risk_calculation |-> $past(monte_carlo_simulation_convergence, 7) && regulatory_capital_requirement\nendproperty\nassert_p_value_at_risk_calculation:assert property (p_value_at_risk_calculation) else $error(\"\");", "task_id": "1_5430", "predict_sva": "@(negedge clk_risk_management) disable iff (rst_portfolio_analysis == 1'b1)     value_at_risk_calculation |-> $past(monte_carlo_simulation_convergence, 7) && regulatory_capital_requirement"}
{"sva": "@(posedge clk_all_wheel_drive) disable iff(!torque_vectoring_reset) differential_control_system && $past(wheel_slip_detection_threshold, 4) |-> traction_distribution_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_differential_control_with_wheel_slip  \n**Trigger Condition**: At every rising edge of `clk_all_wheel_drive`  \n**Disable Condition**: `disable iff (!torque_vectoring_reset)`  \n**Antecedent (LHS of Implication)**: `differential_control_system && $past(wheel_slip_detection_threshold, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `traction_distribution_optimization`  ", "sva_signals": ["clk_all_wheel_drive", "torque_vectoring_reset", "[0:0] differential_control_system", "[0:0] wheel_slip_detection_threshold", "[0:0] traction_distribution_optimization"], "clock": "clk_all_wheel_drive", "attempts_left": 10, "sva_result": "@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)         (differential_control_system && $past(wheel_slip_detection_threshold, 4)) |-> traction_distribution_optimization", "sva_name": "p_differential_control_with_wheel_slip", "id": "1756", "full_property": "property p_differential_control_with_wheel_slip;\n@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)         (differential_control_system && $past(wheel_slip_detection_threshold, 4)) |-> traction_distribution_optimization\nendproperty\nassert_p_differential_control_with_wheel_slip:assert property (p_differential_control_with_wheel_slip) else $error(\"\");", "task_id": "1_5509", "predict_sva": "@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)     differential_control_system && $past(wheel_slip_detection_threshold, 4) |-> traction_distribution_optimization"}
{"sva": "@(posedge clk_climate_research) disable iff(rst_atmospheric_study == 1'b1) greenhouse_gas_concentration |-> $past(ice_core_paleoclimate_data, 14) && climate_model_validation", "sva_description": "### Assertion description:  \n**Property Name**: p_greenhouse_gas_concentration_trigger  \n**Trigger Condition**: At every rising edge of the `clk_climate_research`  \n**Disable Condition**: `disable iff (rst_atmospheric_study == 1'b1)`  \n**Antecedent (LHS of Implication)**: `greenhouse_gas_concentration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ice_core_paleoclimate_data, 14) && climate_model_validation`  ", "sva_signals": ["clk_climate_research", "rst_atmospheric_study", "[0:0] greenhouse_gas_concentration", "[0:0] ice_core_paleoclimate_data", "[0:0] climate_model_validation"], "clock": "clk_climate_research", "attempts_left": 10, "sva_result": "@(posedge clk_climate_research) disable iff (rst_atmospheric_study == 1'b1)     greenhouse_gas_concentration |-> ($past(ice_core_paleoclimate_data, 14) && climate_model_validation)", "sva_name": "p_greenhouse_gas_concentration_check", "id": "1542", "full_property": "property p_greenhouse_gas_concentration_trigger;\n@(posedge clk_climate_research) disable iff (rst_atmospheric_study == 1'b1)     greenhouse_gas_concentration |-> ($past(ice_core_paleoclimate_data, 14) && climate_model_validation)\nendproperty\nassert_p_greenhouse_gas_concentration_trigger:assert property (p_greenhouse_gas_concentration_trigger) else $error(\"\");", "task_id": "1_5300", "predict_sva": "@(posedge clk_climate_research) disable iff (rst_atmospheric_study == 1'b1)     greenhouse_gas_concentration |-> ($past(ice_core_paleoclimate_data, 14) && climate_model_validation)"}
{"sva": "@(negedge clk_lane_keeping_assist) disable iff(rst_camera_vision == 1'b1) lane_boundary_detection |-> $past(steering_torque_overlay_calibration, 6) && lane_departure_prevention", "sva_description": "### Assertion description:  \n**Property Name**: p_lane_boundary_detection_trigger  \n**Trigger Condition**: At every falling edge of `clk_lane_keeping_assist`  \n**Disable Condition**: `disable iff (rst_camera_vision == 1'b1)`  \n**Antecedent (LHS of Implication)**: `lane_boundary_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(steering_torque_overlay_calibration, 6) && lane_departure_prevention`  ", "sva_signals": ["clk_lane_keeping_assist", "rst_camera_vision", "[0:0] lane_boundary_detection", "[0:0] steering_torque_overlay_calibration", "[0:0] lane_departure_prevention"], "clock": "clk_lane_keeping_assist", "attempts_left": 10, "sva_result": "@(negedge clk_lane_keeping_assist) disable iff (rst_camera_vision == 1'b1)     lane_boundary_detection |-> $past(steering_torque_overlay_calibration, 6) && lane_departure_prevention", "sva_name": "p_lane_boundary_detection_trigger", "id": "1784", "full_property": "property p_lane_boundary_detection_trigger;\n@(negedge clk_lane_keeping_assist) disable iff (rst_camera_vision == 1'b1)     lane_boundary_detection |-> $past(steering_torque_overlay_calibration, 6) && lane_departure_prevention\nendproperty\nassert_p_lane_boundary_detection_trigger:assert property (p_lane_boundary_detection_trigger) else $error(\"\");", "task_id": "1_5537", "predict_sva": "@(negedge clk_lane_keeping_assist) disable iff (rst_camera_vision == 1'b1)     lane_boundary_detection |-> $past(steering_torque_overlay_calibration, 6) && lane_departure_prevention"}
{"sva": "@(posedge clk_parking_assistance) disable iff(rst_ultrasonic_sensor) automated_parking_maneuver && $past(parking_space_measurement_validation, 9) |-> collision_free_trajectory_generation", "sva_description": "### Assertion description:  \n**Property Name**: p_Automated_Parking_Collision_Free  \n**Trigger Condition**: At every rising edge of the `clk_parking_assistance`  \n**Disable Condition**: `disable iff (rst_ultrasonic_sensor)`  \n**Antecedent (LHS of Implication)**: `automated_parking_maneuver && $past(parking_space_measurement_validation, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `collision_free_trajectory_generation`  ", "sva_signals": ["clk_parking_assistance", "rst_ultrasonic_sensor", "[0:0] automated_parking_maneuver", "[0:0] parking_space_measurement_validation", "[0:0] collision_free_trajectory_generation"], "clock": "clk_parking_assistance", "attempts_left": 10, "sva_result": "@(posedge clk_parking_assistance) disable iff (rst_ultrasonic_sensor)         (automated_parking_maneuver && $past(parking_space_measurement_validation, 9)) |-> collision_free_trajectory_generation", "sva_name": "p_collision_free_trajectory_generation", "id": "1803", "full_property": "property p_Automated_Parking_Collision_Free;\n@(posedge clk_parking_assistance) disable iff (rst_ultrasonic_sensor)         (automated_parking_maneuver && $past(parking_space_measurement_validation, 9)) |-> collision_free_trajectory_generation\nendproperty\nassert_p_Automated_Parking_Collision_Free:assert property (p_Automated_Parking_Collision_Free) else $error(\"\");", "task_id": "1_5556", "predict_sva": "@(posedge clk_parking_assistance) disable iff (rst_ultrasonic_sensor)         automated_parking_maneuver && $past(parking_space_measurement_validation, 9) |-> collision_free_trajectory_generation"}
{"sva": "@(posedge clk_texture_streaming) disable iff(!memory_bandwidth_reset) mipmap_level_selection && $past(distance_based_lod_calculation, 6) |-> visual_quality_performance_balance", "sva_description": "### Assertion description:  \n**Property Name**: p_Visual_Quality_Performance_Balance  \n**Trigger Condition**: At every rising edge of the `clk_texture_streaming`  \n**Disable Condition**: `disable iff (!memory_bandwidth_reset)`  \n**Antecedent (LHS of Implication)**: `mipmap_level_selection && $past(distance_based_lod_calculation, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `visual_quality_performance_balance`  ", "sva_signals": ["clk", "memory_bandwidth_reset", "clk_texture_streaming", "[0:0] mipmap_level_selection", "[0:0] distance_based_lod_calculation", "[0:0] visual_quality_performance_balance"], "clock": "clk_texture_streaming", "attempts_left": 10, "sva_result": "@(posedge clk_texture_streaming) disable iff (!memory_bandwidth_reset)     mipmap_level_selection && $past(distance_based_lod_calculation, 6) |-> visual_quality_performance_balance", "sva_name": "p_mipmap_level_selection_quality", "id": "1816", "full_property": "property p_Visual_Quality_Performance_Balance;\n@(posedge clk_texture_streaming) disable iff (!memory_bandwidth_reset)     mipmap_level_selection && $past(distance_based_lod_calculation, 6) |-> visual_quality_performance_balance\nendproperty\nassert_p_Visual_Quality_Performance_Balance:assert property (p_Visual_Quality_Performance_Balance) else $error(\"\");", "task_id": "1_5569", "predict_sva": "@(posedge clk_texture_streaming) disable iff (!memory_bandwidth_reset)     mipmap_level_selection && $past(distance_based_lod_calculation, 6) |-> visual_quality_performance_balance"}
{"sva": "@(negedge clk_vehicle_dynamics_control) disable iff(rst_yaw_stability == 1'b1) understeer_oversteer_mitigation |-> $past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement", "sva_description": "### Assertion description:  \n**Property Name**: p_UndersteerOversteerMitigation  \n**Trigger Condition**: At every falling edge of `clk_vehicle_dynamics_control`  \n**Disable Condition**: `disable iff (rst_yaw_stability == 1'b1)`  \n**Antecedent (LHS of Implication)**: `understeer_oversteer_mitigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement`", "sva_signals": ["clk_vehicle_dynamics_control", "rst_yaw_stability", "[0:0] understeer_oversteer_mitigation", "[0:0] lateral_acceleration_measurement", "[0:0] handling_characteristic_enhancement"], "clock": "clk_vehicle_dynamics_control", "attempts_left": 10, "sva_result": "@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability == 1'b1)     understeer_oversteer_mitigation |-> $past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement", "sva_name": "p_understeer_oversteeer_mitigation", "id": "1760", "full_property": "property p_UndersteerOversteerMitigation;\n@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability == 1'b1)     understeer_oversteer_mitigation |-> $past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement\nendproperty\nassert_p_UndersteerOversteerMitigation:assert property (p_UndersteerOversteerMitigation) else $error(\"\");", "task_id": "1_5513", "predict_sva": "@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability)     understeer_oversteer_mitigation |->          $past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement"}
{"sva": "@(posedge clk_adaptive_cruise_control) disable iff(!radar_sensor_reset) following_distance_regulation && $past(relative_velocity_measurement, 7) |-> comfortable_acceleration_profile", "sva_description": "### Assertion description:  \n**Property Name**: p_Comfortable_Acceleration_Profile  \n**Trigger Condition**: At every rising edge of `clk_adaptive_cruise_control`  \n**Disable Condition**: `disable iff (!radar_sensor_reset)`  \n**Antecedent (LHS of Implication)**: `following_distance_regulation && $past(relative_velocity_measurement, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `comfortable_acceleration_profile`", "sva_signals": ["clk_adaptive_cruise_control", "radar_sensor_reset", "[0:0] following_distance_regulation", "[0:0] relative_velocity_measurement", "[0:0] comfortable_acceleration_profile"], "clock": "clk_adaptive_cruise_control", "attempts_left": 10, "sva_result": "@(posedge clk_adaptive_cruise_control) disable iff (!radar_sensor_reset)         (following_distance_regulation && $past(relative_velocity_measurement, 7)) |-> comfortable_acceleration_profile", "sva_name": "p_Comfortable_Acceleration_Profile", "id": "1814", "full_property": "property p_Comfortable_Acceleration_Profile;\n@(posedge clk_adaptive_cruise_control) disable iff (!radar_sensor_reset)         (following_distance_regulation && $past(relative_velocity_measurement, 7)) |-> comfortable_acceleration_profile\nendproperty\nassert_p_Comfortable_Acceleration_Profile:assert property (p_Comfortable_Acceleration_Profile) else $error(\"\");", "task_id": "1_5567", "predict_sva": "@(posedge clk_adaptive_cruise_control) disable iff (!radar_sensor_reset)         (following_distance_regulation && $past(relative_velocity_measurement, 7)) |-> comfortable_acceleration_profile"}
{"sva": "@(posedge clk_all_wheel_drive) disable iff(!torque_vectoring_reset) differential_control_system && $past(wheel_slip_detection_threshold, 4) |-> traction_distribution_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_differential_control_with_slip_detection  \n**Trigger Condition**: At every rising edge of the `clk_all_wheel_drive`  \n**Disable Condition**: disable iff (`!torque_vectoring_reset`)  \n**Antecedent (LHS of Implication)**: `differential_control_system && $past(wheel_slip_detection_threshold, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `traction_distribution_optimization`  ", "sva_signals": ["clk_all_wheel_drive", "torque_vectoring_reset", "[0:0] differential_control_system", "[0:0] wheel_slip_detection_threshold", "[0:0] traction_distribution_optimization"], "clock": "clk_all_wheel_drive", "attempts_left": 10, "sva_result": "@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)         (differential_control_system && $past(wheel_slip_detection_threshold, 4)) |-> traction_distribution_optimization", "sva_name": "p_differential_control_with_past_wheel_slip", "id": "1817", "full_property": "property p_differential_control_with_slip_detection;\n@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)         (differential_control_system && $past(wheel_slip_detection_threshold, 4)) |-> traction_distribution_optimization\nendproperty\nassert_p_differential_control_with_slip_detection:assert property (p_differential_control_with_slip_detection) else $error(\"\");", "task_id": "1_5570", "predict_sva": "@(posedge clk_all_wheel_drive) disable iff (!torque_vectoring_reset)     differential_control_system && $past(wheel_slip_detection_threshold, 4) |-> traction_distribution_optimization"}
{"sva": "@(posedge clk_traffic_light_communication) disable iff(!infrastructure_connectivity_reset) signal_phase_timing && $past(intersection_approach_optimization, 5) |-> green_light_optimal_speed", "sva_description": "### Assertion description:  \n**Property Name**: p_green_light_optimal_speed  \n**Trigger Condition**: At every rising edge of the `clk_traffic_light_communication`  \n**Disable Condition**: disable iff (`!infrastructure_connectivity_reset`)  \n**Antecedent (LHS of Implication)**: `signal_phase_timing && $past(intersection_approach_optimization, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `green_light_optimal_speed`", "sva_signals": ["clk_traffic_light_communication", "infrastructure_connectivity_reset", "[0:0] signal_phase_timing", "[0:0] intersection_approach_optimization", "[0:0] green_light_optimal_speed"], "clock": "clk_traffic_light_communication", "attempts_left": 10, "sva_result": "@(posedge clk_traffic_light_communication) disable iff (!infrastructure_connectivity_reset)         (signal_phase_timing && $past(intersection_approach_optimization, 5)) |-> green_light_optimal_speed", "sva_name": "p_green_light_optimal_speed", "id": "1829", "full_property": "property p_green_light_optimal_speed;\n@(posedge clk_traffic_light_communication) disable iff (!infrastructure_connectivity_reset)         (signal_phase_timing && $past(intersection_approach_optimization, 5)) |-> green_light_optimal_speed\nendproperty\nassert_p_green_light_optimal_speed:assert property (p_green_light_optimal_speed) else $error(\"\");", "task_id": "1_5582", "predict_sva": "@(posedge clk_traffic_light_communication) disable iff (!infrastructure_connectivity_reset)     signal_phase_timing && $past(intersection_approach_optimization, 5) |-> green_light_optimal_speed"}
{"sva": "@(negedge clk_driver_monitoring) disable iff(!biometric_sensor_reset) drowsiness_detection_algorithm && $past(eye_tracking_calibration, 10) |-> driver_alertness_assessment", "sva_description": "### Assertion description:  \n**Property Name**: p_Driver_Alertness_After_Drowsiness  \n**Trigger Condition**: At every falling edge of the `clk_driver_monitoring`  \n**Disable Condition**: disable iff (!biometric_sensor_reset)  \n**Antecedent (LHS of Implication)**: `drowsiness_detection_algorithm && $past(eye_tracking_calibration, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `driver_alertness_assessment`  ", "sva_signals": ["clk_driver_monitoring", "biometric_sensor_reset", "[0:0] drowsiness_detection_algorithm", "[0:0] eye_tracking_calibration", "[0:0] driver_alertness_assessment"], "clock": "clk_driver_monitoring", "attempts_left": 10, "sva_result": "@(negedge clk_driver_monitoring) disable iff (!biometric_sensor_reset)     (drowsiness_detection_algorithm && $past(eye_tracking_calibration, 10)) |-> driver_alertness_assessment", "sva_name": "p_Driver_Alertness_Assessment", "id": "1821", "full_property": "property p_Driver_Alertness_After_Drowsiness;\n@(negedge clk_driver_monitoring) disable iff (!biometric_sensor_reset)     (drowsiness_detection_algorithm && $past(eye_tracking_calibration, 10)) |-> driver_alertness_assessment\nendproperty\nassert_p_Driver_Alertness_After_Drowsiness:assert property (p_Driver_Alertness_After_Drowsiness) else $error(\"\");", "task_id": "1_5574", "predict_sva": "@(negedge clk_driver_monitoring) disable iff (!biometric_sensor_reset)         (drowsiness_detection_algorithm && $past(eye_tracking_calibration, 10)) |-> driver_alertness_assessment"}
{"sva": "@(posedge clk_monetization_system) disable iff(rst_microtransaction_processing) virtual_economy_balance && $past(player_spending_pattern_analysis, 6) |-> revenue_optimization_strategy", "sva_description": "### Assertion description:  \n**Property Name**: p_virtual_economy_revenue_optimization  \n**Trigger Condition**: At every rising edge of the `clk_monetization_system`  \n**Disable Condition**: `disable iff (rst_microtransaction_processing)`  \n**Antecedent (LHS of Implication)**: `virtual_economy_balance && $past(player_spending_pattern_analysis, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `revenue_optimization_strategy`  ", "sva_signals": ["clk_monetization_system", "rst_microtransaction_processing", "[0:0] virtual_economy_balance", "[0:0] player_spending_pattern_analysis", "[0:0] revenue_optimization_strategy"], "clock": "clk_monetization_system", "attempts_left": 10, "sva_result": "@(posedge clk_monetization_system) disable iff (rst_microtransaction_processing)         (virtual_economy_balance && $past(player_spending_pattern_analysis, 6)) |-> revenue_optimization_strategy", "sva_name": "p_revenue_optimization_strategy", "id": "1835", "full_property": "property p_virtual_economy_revenue_optimization;\n@(posedge clk_monetization_system) disable iff (rst_microtransaction_processing)         (virtual_economy_balance && $past(player_spending_pattern_analysis, 6)) |-> revenue_optimization_strategy\nendproperty\nassert_p_virtual_economy_revenue_optimization:assert property (p_virtual_economy_revenue_optimization) else $error(\"\");", "task_id": "1_5588", "predict_sva": "@(posedge clk_monetization_system) disable iff (rst_microtransaction_processing)         virtual_economy_balance && $past(player_spending_pattern_analysis, 6) |-> revenue_optimization_strategy"}
{"sva": "@(posedge clk_collision_mitigation) disable iff(rst_pre_crash_system) airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_airbag_deployment_timing  \n**Trigger Condition**: At every rising edge of the `clk_collision_mitigation`  \n**Disable Condition**: `disable iff (rst_pre_crash_system)`  \n**Antecedent (LHS of Implication)**: `airbag_deployment_timing && $past(crash_severity_assessment, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `occupant_protection_optimization`  ", "sva_signals": ["clk_collision_mitigation", "rst_pre_crash_system", "[0:0] airbag_deployment_timing", "[0:0] crash_severity_assessment", "[0:0] occupant_protection_optimization"], "clock": "clk_collision_mitigation", "attempts_left": 10, "sva_result": "@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)         airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization", "sva_name": "p_airbag_deployment_timing", "id": "1834", "full_property": "property p_airbag_deployment_timing;\n@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)         airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization\nendproperty\nassert_p_airbag_deployment_timing:assert property (p_airbag_deployment_timing) else $error(\"\");", "task_id": "1_5587", "predict_sva": "@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)     airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization"}
{"sva": "@(posedge clk_cybersecurity_module) disable iff(rst_intrusion_detection == 1'b1) hardware_security_module |-> $past(cryptographic_key_rotation, 12) && secure_communication_channel", "sva_description": "### Assertion description:  \n**Property Name**: p_hardware_security_check  \n**Trigger Condition**: At every rising edge of the `clk_cybersecurity_module`  \n**Disable Condition**: `disable iff (rst_intrusion_detection == 1'b1)`  \n**Antecedent (LHS of Implication)**: `hardware_security_module`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cryptographic_key_rotation, 12) && secure_communication_channel`  ", "sva_signals": ["clk_cybersecurity_module", "rst_intrusion_detection", "[0:0] hardware_security_module", "[0:0] cryptographic_key_rotation", "[0:0] secure_communication_channel"], "clock": "clk_cybersecurity_module", "attempts_left": 10, "sva_result": "@(posedge clk_cybersecurity_module) disable iff (rst_intrusion_detection == 1'b1)         hardware_security_module |-> $past(cryptographic_key_rotation, 12) && secure_communication_channel", "sva_name": "p_hardware_security_check", "id": "1731", "full_property": "property p_hardware_security_check;\n@(posedge clk_cybersecurity_module) disable iff (rst_intrusion_detection == 1'b1)         hardware_security_module |-> $past(cryptographic_key_rotation, 12) && secure_communication_channel\nendproperty\nassert_p_hardware_security_check:assert property (p_hardware_security_check) else $error(\"\");", "task_id": "1_5484", "predict_sva": "@(posedge clk_cybersecurity_module) disable iff (rst_intrusion_detection == 1'b1)     hardware_security_module |-> $past(cryptographic_key_rotation, 12) && secure_communication_channel"}
{"sva": "@(posedge clk_magnetosphere_study) disable iff(rst_plasma_physics == 1'b1) particle_precipitation_analysis |-> $past(magnetic_reconnection_event, 8) && auroral_phenomenon_correlation", "sva_description": "### Assertion description:  \n**Property Name**: p_particle_precipitation_analysis  \n**Trigger Condition**: At every rising edge of the `clk_magnetosphere_study`  \n**Disable Condition**: `disable iff (rst_plasma_physics == 1'b1)`  \n**Antecedent (LHS of Implication)**: `particle_precipitation_analysis`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(magnetic_reconnection_event, 8) && auroral_phenomenon_correlation`  ", "sva_signals": ["clk_magnetosphere_study", "rst_plasma_physics", "[0:0] particle_precipitation_analysis", "[0:0] magnetic_reconnection_event", "[0:0] auroral_phenomenon_correlation"], "clock": "clk_magnetosphere_study", "attempts_left": 10, "sva_result": "@(posedge clk_magnetosphere_study) disable iff (rst_plasma_physics == 1'b1)     particle_precipitation_analysis |-> $past(magnetic_reconnection_event, 8) && auroral_phenomenon_correlation", "sva_name": "p_particle_precipitation_analysis", "id": "1681", "full_property": "property p_particle_precipitation_analysis;\n@(posedge clk_magnetosphere_study) disable iff (rst_plasma_physics == 1'b1)     particle_precipitation_analysis |-> $past(magnetic_reconnection_event, 8) && auroral_phenomenon_correlation\nendproperty\nassert_p_particle_precipitation_analysis:assert property (p_particle_precipitation_analysis) else $error(\"\");", "task_id": "1_5437", "predict_sva": "@(posedge clk_magnetosphere_study) disable iff (rst_plasma_physics == 1'b1)     particle_precipitation_analysis |-> ($past(magnetic_reconnection_event, 8) && auroral_phenomenon_correlation)"}
{"sva": "@(negedge clk_condition_monitoring) disable iff(rst_sensor_network) bearing_fault_diagnosis && $past(frequency_domain_analysis, 7) |-> maintenance_scheduling_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_bearing_fault_maintenance_scheduling  \n**Trigger Condition**: At every falling edge of the `clk_condition_monitoring`  \n**Disable Condition**: `disable iff (rst_sensor_network)`  \n**Antecedent (LHS of Implication)**: `bearing_fault_diagnosis && $past(frequency_domain_analysis, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `maintenance_scheduling_optimization`", "sva_signals": ["clk_condition_monitoring", "rst_sensor_network", "[0:0] bearing_fault_diagnosis", "[0:0] frequency_domain_analysis", "[0:0] maintenance_scheduling_optimization"], "clock": "clk_condition_monitoring", "attempts_left": 10, "sva_result": "@(negedge clk_condition_monitoring) disable iff (rst_sensor_network)     bearing_fault_diagnosis && $past(frequency_domain_analysis, 7) |-> maintenance_scheduling_optimization", "sva_name": "p_bearing_fault_maintenance", "id": "1884", "full_property": "property p_bearing_fault_maintenance_scheduling;\n@(negedge clk_condition_monitoring) disable iff (rst_sensor_network)     bearing_fault_diagnosis && $past(frequency_domain_analysis, 7) |-> maintenance_scheduling_optimization\nendproperty\nassert_p_bearing_fault_maintenance_scheduling:assert property (p_bearing_fault_maintenance_scheduling) else $error(\"\");", "task_id": "1_5635", "predict_sva": "@(negedge clk_condition_monitoring) disable iff (rst_sensor_network)         (bearing_fault_diagnosis && $past(frequency_domain_analysis, 7)) |-> maintenance_scheduling_optimization"}
{"sva": "@(posedge clk_social_gaming) disable iff(rst_community_platform) friend_recommendation_algorithm && $past(social_graph_analysis, 8) |-> player_engagement_enhancement", "sva_description": "### Assertion description:  \n**Property Name**: p_friend_recommendation_engagement  \n**Trigger Condition**: At every rising edge of `clk_social_gaming`  \n**Disable Condition**: `disable iff (rst_community_platform)`  \n**Antecedent (LHS of Implication)**: `friend_recommendation_algorithm && $past(social_graph_analysis, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `player_engagement_enhancement`  ", "sva_signals": ["clk_social_gaming", "rst_community_platform", "[0:0] friend_recommendation_algorithm", "[0:0] social_graph_analysis", "[0:0] player_engagement_enhancement"], "clock": "clk_social_gaming", "attempts_left": 10, "sva_result": "@(posedge clk_social_gaming) disable iff (rst_community_platform)     (friend_recommendation_algorithm && $past(social_graph_analysis, 8)) |-> player_engagement_enhancement", "sva_name": "p_Friend_Recommendation_Engagement", "id": "1859", "full_property": "property p_friend_recommendation_engagement;\n@(posedge clk_social_gaming) disable iff (rst_community_platform)     (friend_recommendation_algorithm && $past(social_graph_analysis, 8)) |-> player_engagement_enhancement\nendproperty\nassert_p_friend_recommendation_engagement:assert property (p_friend_recommendation_engagement) else $error(\"\");", "task_id": "1_5612", "predict_sva": "@(posedge clk_social_gaming) disable iff (rst_community_platform)         (friend_recommendation_algorithm && $past(social_graph_analysis, 8)) |-> player_engagement_enhancement"}
{"sva": "@(negedge clk_artificial_intelligence) disable iff(!neural_network_reset) convolutional_layer_computation && $past(backpropagation_gradient_descent, 5) |-> machine_learning_convergence", "sva_description": "### Assertion description:  \n**Property Name**: p_machine_learning_convergence  \n**Trigger Condition**: At every falling edge of the `clk_artificial_intelligence`  \n**Disable Condition**: disable iff (`!neural_network_reset`)  \n**Antecedent (LHS of Implication)**: `convolutional_layer_computation && $past(backpropagation_gradient_descent, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `machine_learning_convergence`", "sva_signals": ["clk_artificial_intelligence", "neural_network_reset", "[0:0] convolutional_layer_computation", "[0:0] backpropagation_gradient_descent", "[0:0] machine_learning_convergence"], "clock": "clk_artificial_intelligence", "attempts_left": 10, "sva_result": "@(negedge clk_artificial_intelligence) disable iff (!neural_network_reset)         convolutional_layer_computation && $past(backpropagation_gradient_descent, 5) |-> machine_learning_convergence", "sva_name": "p_Convolutional_Layer_Computation_Convergence", "id": "1838", "full_property": "property p_machine_learning_convergence;\n@(negedge clk_artificial_intelligence) disable iff (!neural_network_reset)         convolutional_layer_computation && $past(backpropagation_gradient_descent, 5) |-> machine_learning_convergence\nendproperty\nassert_p_machine_learning_convergence:assert property (p_machine_learning_convergence) else $error(\"\");", "task_id": "1_5591", "predict_sva": "@(negedge clk_artificial_intelligence) disable iff (!neural_network_reset)         convolutional_layer_computation && $past(backpropagation_gradient_descent, 5) |-> machine_learning_convergence"}
{"sva": "@(posedge clk_gesture_control) disable iff(rst_motion_sensor == 1'b1) hand_tracking_recognition |-> $past(skeletal_joint_estimation, 12) && natural_user_interface", "sva_description": "### Assertion description:  \n**Property Name**: p_hand_tracking_recognition  \n**Trigger Condition**: At every rising edge of the `clk_gesture_control`  \n**Disable Condition**: `disable iff (rst_motion_sensor == 1'b1)`  \n**Antecedent (LHS of Implication)**: `hand_tracking_recognition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(skeletal_joint_estimation, 12) && natural_user_interface`  ", "sva_signals": ["clk_gesture_control", "rst_motion_sensor", "[0:0] hand_tracking_recognition", "[0:0] skeletal_joint_estimation", "[0:0] natural_user_interface"], "clock": "clk_gesture_control", "attempts_left": 10, "sva_result": "@(posedge clk_gesture_control) disable iff (rst_motion_sensor == 1'b1)     hand_tracking_recognition |-> $past(skeletal_joint_estimation, 12) && natural_user_interface", "sva_name": "p_hand_tracking_recognition", "id": "1885", "full_property": "property p_hand_tracking_recognition;\n@(posedge clk_gesture_control) disable iff (rst_motion_sensor == 1'b1)     hand_tracking_recognition |-> $past(skeletal_joint_estimation, 12) && natural_user_interface\nendproperty\nassert_p_hand_tracking_recognition:assert property (p_hand_tracking_recognition) else $error(\"\");", "task_id": "1_5636", "predict_sva": "@(posedge clk_gesture_control) disable iff (rst_motion_sensor == 1'b1)     hand_tracking_recognition |-> $past(skeletal_joint_estimation, 12) && natural_user_interface"}
{"sva": "@(posedge clk_virtual_reality) disable iff(rst_head_mounted_display == 1'b1) stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance", "sva_description": "### Assertion description:  \n**Property Name**: p_Stereoscopic_Rendering_Pipeline_Check  \n**Trigger Condition**: At every rising edge of the `clk_virtual_reality`  \n**Disable Condition**: `disable iff (rst_head_mounted_display == 1'b1)`  \n**Antecedent (LHS of Implication)**: `stereoscopic_rendering_pipeline`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance`  ", "sva_signals": ["clk_virtual_reality", "rst_head_mounted_display", "[0:0] stereoscopic_rendering_pipeline", "[0:0] motion_to_photon_latency_measurement", "[0:0] presence_illusion_maintenance"], "clock": "clk_virtual_reality", "attempts_left": 10, "sva_result": "@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display == 1'b1)     stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance", "sva_name": "p_stereoscopic_rendering_pipeline_check", "id": "1855", "full_property": "property p_Stereoscopic_Rendering_Pipeline_Check;\n@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display == 1'b1)     stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance\nendproperty\nassert_p_Stereoscopic_Rendering_Pipeline_Check:assert property (p_Stereoscopic_Rendering_Pipeline_Check) else $error(\"\");", "task_id": "1_5608", "predict_sva": "@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display == 1'b1)     stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance"}
{"sva": "@(posedge clk_energy_optimization) disable iff(rst_power_analytics) demand_response_coordination && $past(load_forecasting_model_update, 8) |-> energy_consumption_efficiency", "sva_description": "### Assertion description:  \n**Property Name**: p_Energy_Optimization_Check  \n**Trigger Condition**: At every rising edge of the `clk_energy_optimization`  \n**Disable Condition**: `disable iff (rst_power_analytics)`  \n**Antecedent (LHS of Implication)**: `demand_response_coordination && $past(load_forecasting_model_update, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `energy_consumption_efficiency`", "sva_signals": ["clk_energy_optimization", "rst_power_analytics", "[0:0] demand_response_coordination", "[0:0] load_forecasting_model_update", "[0:0] energy_consumption_efficiency"], "clock": "clk_energy_optimization", "attempts_left": 10, "sva_result": "@(posedge clk_energy_optimization) disable iff (rst_power_analytics)     (demand_response_coordination && $past(load_forecasting_model_update, 8)) |-> energy_consumption_efficiency", "sva_name": "p_Energy_Consumption_Efficiency", "id": "1898", "full_property": "property p_Energy_Optimization_Check;\n@(posedge clk_energy_optimization) disable iff (rst_power_analytics)     (demand_response_coordination && $past(load_forecasting_model_update, 8)) |-> energy_consumption_efficiency\nendproperty\nassert_p_Energy_Optimization_Check:assert property (p_Energy_Optimization_Check) else $error(\"\");", "task_id": "1_5648", "predict_sva": "@(posedge clk_energy_optimization) disable iff (rst_power_analytics)         demand_response_coordination && $past(load_forecasting_model_update, 8) |-> energy_consumption_efficiency"}
{"sva": "@(negedge clk_spatial_audio) disable iff(rst_binaural_rendering == 1'b1) head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape", "sva_description": "### Assertion description:  \n**Property Name**: p_head_tracking_compensation  \n**Trigger Condition**: At every falling edge of `clk_spatial_audio`  \n**Disable Condition**: `disable iff (rst_binaural_rendering == 1'b1)`  \n**Antecedent (LHS of Implication)**: `head_tracking_compensation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(room_impulse_response_convolution, 10) && immersive_3d_soundscape`  ", "sva_signals": ["clk", "rst_binaural_rendering", "[0:0] head_tracking_compensation", "[0:0] room_impulse_response_convolution", "[0:0] immersive_3d_soundscape", "clk_spatial_audio"], "clock": "clk_spatial_audio", "attempts_left": 10, "sva_result": "@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape", "sva_name": "p_head_tracking_compensation", "id": "1886", "full_property": "property p_head_tracking_compensation;\n@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape\nendproperty\nassert_p_head_tracking_compensation:assert property (p_head_tracking_compensation) else $error(\"\");", "task_id": "1_5637", "predict_sva": "@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape"}
{"sva": "@(posedge clk_knowledge_management) disable iff(rst_expert_system) tacit_knowledge_capture && $past(machine_learning_knowledge_extraction, 10) |-> organizational_learning_enhancement", "sva_description": "### Assertion description:  \n**Property Name**: p_organizational_learning_enhancement  \n**Trigger Condition**: At every rising edge of the `clk_knowledge_management`  \n**Disable Condition**: `disable iff (rst_expert_system)`  \n**Antecedent (LHS of Implication)**: `tacit_knowledge_capture && $past(machine_learning_knowledge_extraction, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `organizational_learning_enhancement`", "sva_signals": ["clk_knowledge_management", "rst_expert_system", "[0:0] tacit_knowledge_capture", "[0:0] machine_learning_knowledge_extraction", "[0:0] organizational_learning_enhancement"], "clock": "clk_knowledge_management", "attempts_left": 10, "sva_result": "@(posedge clk_knowledge_management) disable iff (rst_expert_system)     tacit_knowledge_capture && $past(machine_learning_knowledge_extraction, 10) |-> organizational_learning_enhancement", "sva_name": "p_Organizational_Learning_Enhancement", "id": "1903", "full_property": "property p_organizational_learning_enhancement;\n@(posedge clk_knowledge_management) disable iff (rst_expert_system)     tacit_knowledge_capture && $past(machine_learning_knowledge_extraction, 10) |-> organizational_learning_enhancement\nendproperty\nassert_p_organizational_learning_enhancement:assert property (p_organizational_learning_enhancement) else $error(\"\");", "task_id": "1_5653", "predict_sva": "@(posedge clk_knowledge_management) disable iff (rst_expert_system)         tacit_knowledge_capture && $past(machine_learning_knowledge_extraction, 10) |-> organizational_learning_enhancement"}
{"sva": "@(posedge clk_molecular_electronics) disable iff(!single_molecule_reset) charge_transport_mechanism && $past(molecular_orbital_alignment, 5) |-> molecular_switch_operation", "sva_description": "### Assertion description:  \n**Property Name**: p_charge_transport_mechanism_switch_operation  \n**Trigger Condition**: At every rising edge of the `clk_molecular_electronics`  \n**Disable Condition**: `disable iff (!single_molecule_reset)`  \n**Antecedent (LHS of Implication)**: `charge_transport_mechanism && $past(molecular_orbital_alignment, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `molecular_switch_operation`", "sva_signals": ["clk_molecular_electronics", "single_molecule_reset", "[0:0] charge_transport_mechanism", "[0:0] molecular_orbital_alignment", "[0:0] molecular_switch_operation"], "clock": "clk_molecular_electronics", "attempts_left": 10, "sva_result": "@(posedge clk_molecular_electronics) disable iff (!single_molecule_reset)     charge_transport_mechanism && $past(molecular_orbital_alignment, 5) |-> molecular_switch_operation", "sva_name": "p_charge_transport_mechanism_trigger", "id": "1942", "full_property": "property p_charge_transport_mechanism_switch_operation;\n@(posedge clk_molecular_electronics) disable iff (!single_molecule_reset)     charge_transport_mechanism && $past(molecular_orbital_alignment, 5) |-> molecular_switch_operation\nendproperty\nassert_p_charge_transport_mechanism_switch_operation:assert property (p_charge_transport_mechanism_switch_operation) else $error(\"\");", "task_id": "1_5692", "predict_sva": "@(posedge clk_molecular_electronics) disable iff (!single_molecule_reset)         charge_transport_mechanism && $past(molecular_orbital_alignment, 5) |-> molecular_switch_operation"}
{"sva": "@(posedge clk_brain_computer_interface) disable iff(!neural_signal_reset) invasive_electrode_array && $past(spike_sorting_algorithm, 9) |-> direct_neural_control", "sva_description": "### Assertion description:  \n**Property Name**: p_direct_neural_control  \n**Trigger Condition**: At every rising edge of the `clk_brain_computer_interface`  \n**Disable Condition**: `disable iff (!neural_signal_reset)`  \n**Antecedent (LHS of Implication)**: `invasive_electrode_array && $past(spike_sorting_algorithm, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `direct_neural_control`  ", "sva_signals": ["clk_brain_computer_interface", "neural_signal_reset", "[0:0] invasive_electrode_array", "[0:0] spike_sorting_algorithm", "[0:0] direct_neural_control"], "clock": "clk_brain_computer_interface", "attempts_left": 10, "sva_result": "@(posedge clk_brain_computer_interface) disable iff (!neural_signal_reset)         invasive_electrode_array && $past(spike_sorting_algorithm, 9) |-> direct_neural_control", "sva_name": "p_Direct_Neural_Control", "id": "1965", "full_property": "property p_direct_neural_control;\n@(posedge clk_brain_computer_interface) disable iff (!neural_signal_reset)         invasive_electrode_array && $past(spike_sorting_algorithm, 9) |-> direct_neural_control\nendproperty\nassert_p_direct_neural_control:assert property (p_direct_neural_control) else $error(\"\");", "task_id": "1_5715", "predict_sva": "@(posedge clk_brain_computer_interface) disable iff (!neural_signal_reset)         (invasive_electrode_array && $past(spike_sorting_algorithm, 9)) |-> direct_neural_control"}
{"sva": "@(posedge clk_metaverse_manufacturing) disable iff(rst_virtual_factory_twin) immersive_production_visualization && $past(haptic_feedback_calibration, 14) |-> next_generation_manufacturing_experience", "sva_description": "### Assertion description:  \n**Property Name**: p_Immersive_Production_NextGen_Experience  \n**Trigger Condition**: At every rising edge of the `clk_metaverse_manufacturing`  \n**Disable Condition**: `disable iff (rst_virtual_factory_twin)`  \n**Antecedent (LHS of Implication)**: `immersive_production_visualization && $past(haptic_feedback_calibration, 14)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `next_generation_manufacturing_experience`", "sva_signals": ["clk_metaverse_manufacturing", "rst_virtual_factory_twin", "[0:0] immersive_production_visualization", "[0:0] haptic_feedback_calibration", "[0:0] next_generation_manufacturing_experience"], "clock": "clk_metaverse_manufacturing", "attempts_left": 10, "sva_result": "@(posedge clk_metaverse_manufacturing) disable iff (rst_virtual_factory_twin)         (immersive_production_visualization && $past(haptic_feedback_calibration, 14)) |-> next_generation_manufacturing_experience", "sva_name": "p_Immersive_Production_Visualization", "id": "1924", "full_property": "property p_Immersive_Production_NextGen_Experience;\n@(posedge clk_metaverse_manufacturing) disable iff (rst_virtual_factory_twin)         (immersive_production_visualization && $past(haptic_feedback_calibration, 14)) |-> next_generation_manufacturing_experience\nendproperty\nassert_p_Immersive_Production_NextGen_Experience:assert property (p_Immersive_Production_NextGen_Experience) else $error(\"\");", "task_id": "1_5674", "predict_sva": "@(posedge clk_metaverse_manufacturing) disable iff (rst_virtual_factory_twin)     immersive_production_visualization && $past(haptic_feedback_calibration, 14) |-> next_generation_manufacturing_experience"}
{"sva": "@(negedge clk_crispr_cas) disable iff(rst_gene_editing) programmable_nuclease_specificity && $past(guide_rna_design_optimization, 7) |-> precise_genome_modification", "sva_description": "### Assertion description:  \n**Property Name**: p_Precise_Genome_Modification  \n**Trigger Condition**: At every falling edge of the `clk_crispr_cas`  \n**Disable Condition**: `disable iff (rst_gene_editing)`  \n**Antecedent (LHS of Implication)**: `programmable_nuclease_specificity && $past(guide_rna_design_optimization, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `precise_genome_modification`  ", "sva_signals": ["clk_crispr_cas", "rst_gene_editing", "[0:0] programmable_nuclease_specificity", "[0:0] guide_rna_design_optimization", "[0:0] precise_genome_modification"], "clock": "clk_crispr_cas", "attempts_left": 10, "sva_result": "@(negedge clk_crispr_cas) disable iff (rst_gene_editing)         programmable_nuclease_specificity && $past(guide_rna_design_optimization, 7) |-> precise_genome_modification", "sva_name": "p_precise_genome_modification", "id": "1949", "full_property": "property p_Precise_Genome_Modification;\n@(negedge clk_crispr_cas) disable iff (rst_gene_editing)         programmable_nuclease_specificity && $past(guide_rna_design_optimization, 7) |-> precise_genome_modification\nendproperty\nassert_p_Precise_Genome_Modification:assert property (p_Precise_Genome_Modification) else $error(\"\");", "task_id": "1_5699", "predict_sva": "@(negedge clk_crispr_cas) disable iff (rst_gene_editing)         programmable_nuclease_specificity && $past(guide_rna_design_optimization, 7) |-> precise_genome_modification"}
{"sva": "@(negedge clk_food_quality_inspection) disable iff(!near_infrared_spectroscopy_reset) chemical_composition_analysis && $past(calibration_model_validation, 10) |-> non_destructive_quality_assessment", "sva_description": "### Assertion description:  \n**Property Name**: p_non_destructive_quality_assessment  \n**Trigger Condition**: At every falling edge of the `clk_food_quality_inspection`  \n**Disable Condition**: disable iff (`!near_infrared_spectroscopy_reset`)  \n**Antecedent (LHS of Implication)**: `chemical_composition_analysis && $past(calibration_model_validation, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `non_destructive_quality_assessment`", "sva_signals": ["clk_food_quality_inspection", "near_infrared_spectroscopy_reset", "[0:0] chemical_composition_analysis", "[0:0] calibration_model_validation", "[0:0] non_destructive_quality_assessment"], "clock": "clk_food_quality_inspection", "attempts_left": 10, "sva_result": "@(negedge clk_food_quality_inspection) disable iff (!near_infrared_spectroscopy_reset)         chemical_composition_analysis && $past(calibration_model_validation, 10) |-> non_destructive_quality_assessment", "sva_name": "p_non_destructive_quality_assessment", "id": "1990", "full_property": "property p_non_destructive_quality_assessment;\n@(negedge clk_food_quality_inspection) disable iff (!near_infrared_spectroscopy_reset)         chemical_composition_analysis && $past(calibration_model_validation, 10) |-> non_destructive_quality_assessment\nendproperty\nassert_p_non_destructive_quality_assessment:assert property (p_non_destructive_quality_assessment) else $error(\"\");", "task_id": "1_5740", "predict_sva": "@(negedge clk_food_quality_inspection) disable iff (!near_infrared_spectroscopy_reset)         chemical_composition_analysis && $past(calibration_model_validation, 10) |-> non_destructive_quality_assessment"}
{"sva": "@(posedge clk_edge_ai_accelerator) disable iff(rst_sparse_computation) pruned_neural_network && $past(weight_quantization_accuracy, 6) |-> energy_efficient_inference", "sva_description": "### Assertion description:  \n**Property Name**: p_PrunedNetwork_WeightAccuracy_EnergyEfficientInference  \n**Trigger Condition**: At every rising edge of the `clk_edge_ai_accelerator`  \n**Disable Condition**: `disable iff (rst_sparse_computation)`  \n**Antecedent (LHS of Implication)**: `pruned_neural_network && $past(weight_quantization_accuracy, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `energy_efficient_inference`  ", "sva_signals": ["clk", "rst_sparse_computation", "[0:0] pruned_neural_network", "[0:0] weight_quantization_accuracy", "[0:0] energy_efficient_inference", "clk_edge_ai_accelerator"], "clock": "clk_edge_ai_accelerator", "attempts_left": 10, "sva_result": "@(posedge clk_edge_ai_accelerator) disable iff (rst_sparse_computation)         pruned_neural_network && $past(weight_quantization_accuracy, 6) |-> energy_efficient_inference", "sva_name": "p_Energy_Efficient_Inference_After_Pruning", "id": "1969", "full_property": "property p_PrunedNetwork_WeightAccuracy_EnergyEfficientInference;\n@(posedge clk_edge_ai_accelerator) disable iff (rst_sparse_computation)         pruned_neural_network && $past(weight_quantization_accuracy, 6) |-> energy_efficient_inference\nendproperty\nassert_p_PrunedNetwork_WeightAccuracy_EnergyEfficientInference:assert property (p_PrunedNetwork_WeightAccuracy_EnergyEfficientInference) else $error(\"\");", "task_id": "1_5719", "predict_sva": "@(posedge clk_edge_ai_accelerator) disable iff (rst_sparse_computation)         (pruned_neural_network && $past(weight_quantization_accuracy, 6)) |-> energy_efficient_inference"}
{"sva": "@(posedge clk_performance_measurement) disable iff(rst_key_performance_indicator == 1'b1) balanced_scorecard_dashboard |-> $past(metric_correlation_analysis, 4) && strategic_objective_alignment", "sva_description": "### Assertion description:  \n**Property Name**: p_balanced_scorecard_dashboard  \n**Trigger Condition**: At every rising edge of the `clk_performance_measurement`  \n**Disable Condition**: `disable iff (rst_key_performance_indicator == 1'b1)`  \n**Antecedent (LHS of Implication)**: `balanced_scorecard_dashboard`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(metric_correlation_analysis, 4) && strategic_objective_alignment`  ", "sva_signals": ["clk_performance_measurement", "rst_key_performance_indicator", "[0:0] balanced_scorecard_dashboard", "[0:0] metric_correlation_analysis", "[0:0] strategic_objective_alignment"], "clock": "clk_performance_measurement", "attempts_left": 10, "sva_result": "@(posedge clk_performance_measurement)     disable iff (rst_key_performance_indicator == 1'b1)     balanced_scorecard_dashboard |-> $past(metric_correlation_analysis, 4) && strategic_objective_alignment", "sva_name": "p_balanced_scorecard_dashboard", "id": "1931", "full_property": "property p_balanced_scorecard_dashboard;\n@(posedge clk_performance_measurement)     disable iff (rst_key_performance_indicator == 1'b1)     balanced_scorecard_dashboard |-> $past(metric_correlation_analysis, 4) && strategic_objective_alignment\nendproperty\nassert_p_balanced_scorecard_dashboard:assert property (p_balanced_scorecard_dashboard) else $error(\"\");", "task_id": "1_5681", "predict_sva": "@(posedge clk_performance_measurement) disable iff (rst_key_performance_indicator == 1'b1)     balanced_scorecard_dashboard |-> $past(metric_correlation_analysis, 4) && strategic_objective_alignment"}
{"sva": "@(posedge clk_agricultural_robotics) disable iff(rst_autonomous_field_operation) navigation_path_planning && $past(obstacle_avoidance_algorithm, 5) |-> unmanned_farming_execution", "sva_description": "### Assertion description:  \n**Property Name**: p_Navigation_Path_Planning_Execution  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_robotics`  \n**Disable Condition**: `disable iff (rst_autonomous_field_operation)`  \n**Antecedent (LHS of Implication)**: `navigation_path_planning && $past(obstacle_avoidance_algorithm, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `unmanned_farming_execution`  ", "sva_signals": ["clk_agricultural_robotics", "rst_autonomous_field_operation", "[0:0] navigation_path_planning", "[0:0] obstacle_avoidance_algorithm", "[0:0] unmanned_farming_execution"], "clock": "clk_agricultural_robotics", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_robotics) disable iff (rst_autonomous_field_operation)         (navigation_path_planning && $past(obstacle_avoidance_algorithm, 5)) |-> unmanned_farming_execution", "sva_name": "p_navigation_path_planning_to_execution", "id": "2005", "full_property": "property p_Navigation_Path_Planning_Execution;\n@(posedge clk_agricultural_robotics) disable iff (rst_autonomous_field_operation)         (navigation_path_planning && $past(obstacle_avoidance_algorithm, 5)) |-> unmanned_farming_execution\nendproperty\nassert_p_Navigation_Path_Planning_Execution:assert property (p_Navigation_Path_Planning_Execution) else $error(\"\");", "task_id": "1_5755", "predict_sva": "@(posedge clk_agricultural_robotics) disable iff (rst_autonomous_field_operation)         navigation_path_planning && $past(obstacle_avoidance_algorithm, 5) |-> unmanned_farming_execution"}
{"sva": "@(posedge clk_immunotherapy_engineering) disable iff(rst_car_t_cell) chimeric_antigen_receptor && $past(t_cell_activation_optimization, 8) |-> cancer_immunotherapy_advancement", "sva_description": "### Assertion description:  \n**Property Name**: p_Cancer_Immunotherapy_Advancement  \n**Trigger Condition**: At every rising edge of the `clk_immunotherapy_engineering`  \n**Disable Condition**: `disable iff (rst_car_t_cell)`  \n**Antecedent (LHS of Implication)**: `chimeric_antigen_receptor && $past(t_cell_activation_optimization, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cancer_immunotherapy_advancement`", "sva_signals": ["clk_immunotherapy_engineering", "rst_car_t_cell", "[0:0] chimeric_antigen_receptor", "[0:0] t_cell_activation_optimization", "[0:0] cancer_immunotherapy_advancement"], "clock": "clk_immunotherapy_engineering", "attempts_left": 10, "sva_result": "@(posedge clk_immunotherapy_engineering) disable iff (rst_car_t_cell)     chimeric_antigen_receptor && $past(t_cell_activation_optimization, 8) |-> cancer_immunotherapy_advancement", "sva_name": "p_Cancer_Immunotherapy_Advancement", "id": "1974", "full_property": "property p_Cancer_Immunotherapy_Advancement;\n@(posedge clk_immunotherapy_engineering) disable iff (rst_car_t_cell)     chimeric_antigen_receptor && $past(t_cell_activation_optimization, 8) |-> cancer_immunotherapy_advancement\nendproperty\nassert_p_Cancer_Immunotherapy_Advancement:assert property (p_Cancer_Immunotherapy_Advancement) else $error(\"\");", "task_id": "1_5724", "predict_sva": "@(posedge clk_immunotherapy_engineering) disable iff (rst_car_t_cell)         chimeric_antigen_receptor && $past(t_cell_activation_optimization, 8) |-> cancer_immunotherapy_advancement"}
{"sva": "@(negedge clk_sustainable_packaging) disable iff(rst_biodegradable_material == 1'b1) compostable_film_development |-> $past(barrier_property_testing, 6) && environmental_impact_reduction", "sva_description": "### Assertion description:  \n**Property Name**: p_compostable_film_development  \n**Trigger Condition**: At every falling edge of the `clk_sustainable_packaging`  \n**Disable Condition**: `disable iff (rst_biodegradable_material == 1'b1)`  \n**Antecedent (LHS of Implication)**: `compostable_film_development`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(barrier_property_testing, 6) && environmental_impact_reduction`  ", "sva_signals": ["clk_sustainable_packaging", "rst_biodegradable_material", "[0:0] compostable_film_development", "[0:0] barrier_property_testing", "[0:0] environmental_impact_reduction"], "clock": "clk_sustainable_packaging", "attempts_left": 10, "sva_result": "@(negedge clk_sustainable_packaging) disable iff (rst_biodegradable_material == 1'b1)     compostable_film_development |-> $past(barrier_property_testing, 6) && environmental_impact_reduction", "sva_name": "p_compostable_film_development", "id": "2002", "full_property": "property p_compostable_film_development;\n@(negedge clk_sustainable_packaging) disable iff (rst_biodegradable_material == 1'b1)     compostable_film_development |-> $past(barrier_property_testing, 6) && environmental_impact_reduction\nendproperty\nassert_p_compostable_film_development:assert property (p_compostable_film_development) else $error(\"\");", "task_id": "1_5752", "predict_sva": "@(negedge clk_sustainable_packaging) disable iff (rst_biodegradable_material == 1'b1)     compostable_film_development |-> $past(barrier_property_testing, 6) && environmental_impact_reduction"}
{"sva": "@(posedge sys_clk) disable iff(debug_mode) cache_hit |-> ($past(tag_match, 1) && $past(valid_bit, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_hit_check  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: `disable iff (debug_mode)`  \n**Antecedent (LHS of Implication)**: `cache_hit`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(tag_match, 1) && $past(valid_bit, 1))`  ", "sva_signals": ["sys_clk", "debug_mode", "[0:0] cache_hit", "[0:0] tag_match", "[0:0] valid_bit"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk) disable iff (debug_mode)     cache_hit |-> ($past(tag_match, 1) && $past(valid_bit, 1))", "sva_name": "p_cache_hit_check", "id": "2048", "full_property": "property p_cache_hit_check;\n@(posedge sys_clk) disable iff (debug_mode)     cache_hit |-> ($past(tag_match, 1) && $past(valid_bit, 1))\nendproperty\nassert_p_cache_hit_check:assert property (p_cache_hit_check) else $error(\"\");", "task_id": "1_5798", "predict_sva": "@(posedge sys_clk) disable iff (debug_mode)     cache_hit |-> ($past(tag_match, 1) && $past(valid_bit, 1))"}
{"sva": "@(posedge clk_agricultural_sustainability) disable iff(!environmental_footprint_reset) life_cycle_assessment && $past(resource_use_efficiency, 3) |-> sustainable_intensification_strategy", "sva_description": "### Assertion description:  \n**Property Name**: p_Sustainable_Intensification  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_sustainability`  \n**Disable Condition**: disable iff `(!environmental_footprint_reset)`  \n**Antecedent (LHS of Implication)**: `life_cycle_assessment && $past(resource_use_efficiency, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sustainable_intensification_strategy`  ", "sva_signals": ["clk_agricultural_sustainability", "environmental_footprint_reset", "[0:0] life_cycle_assessment", "[0:0] resource_use_efficiency", "[0:0] sustainable_intensification_strategy"], "clock": "clk_agricultural_sustainability", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_sustainability) disable iff (!environmental_footprint_reset)     (life_cycle_assessment && $past(resource_use_efficiency, 3)) |-> sustainable_intensification_strategy", "sva_name": "p_Sustainable_Intensification_Strategy", "id": "2026", "full_property": "property p_Sustainable_Intensification;\n@(posedge clk_agricultural_sustainability) disable iff (!environmental_footprint_reset)     (life_cycle_assessment && $past(resource_use_efficiency, 3)) |-> sustainable_intensification_strategy\nendproperty\nassert_p_Sustainable_Intensification:assert property (p_Sustainable_Intensification) else $error(\"\");", "task_id": "1_5776", "predict_sva": "@(posedge clk_agricultural_sustainability) disable iff (!environmental_footprint_reset)         (life_cycle_assessment && $past(resource_use_efficiency, 3)) |-> sustainable_intensification_strategy"}
{"sva": "@(posedge clk_agricultural_biotechnology) disable iff(!genetic_engineering_reset) transgene_expression_monitoring && $past(regulatory_sequence_optimization, 11) |-> crop_improvement_advancement", "sva_description": "### Assertion description:  \n**Property Name**: p_crop_improvement_advancement  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_biotechnology`  \n**Disable Condition**: `disable iff (!genetic_engineering_reset)`  \n**Antecedent (LHS of Implication)**: `transgene_expression_monitoring && $past(regulatory_sequence_optimization, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crop_improvement_advancement`", "sva_signals": ["clk_agricultural_biotechnology", "genetic_engineering_reset", "[0:0] transgene_expression_monitoring", "[0:0] regulatory_sequence_optimization", "[0:0] crop_improvement_advancement"], "clock": "clk_agricultural_biotechnology", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_biotechnology) disable iff (!genetic_engineering_reset)     transgene_expression_monitoring && $past(regulatory_sequence_optimization, 11) |-> crop_improvement_advancement", "sva_name": "p_transgene_expression_monitoring", "id": "2029", "full_property": "property p_crop_improvement_advancement;\n@(posedge clk_agricultural_biotechnology) disable iff (!genetic_engineering_reset)     transgene_expression_monitoring && $past(regulatory_sequence_optimization, 11) |-> crop_improvement_advancement\nendproperty\nassert_p_crop_improvement_advancement:assert property (p_crop_improvement_advancement) else $error(\"\");", "task_id": "1_5779", "predict_sva": "@(posedge clk_agricultural_biotechnology) disable iff (!genetic_engineering_reset)         transgene_expression_monitoring && $past(regulatory_sequence_optimization, 11) |-> crop_improvement_advancement"}
{"sva": "@(negedge clk_livestock_tracking) disable iff(rst_animal_health_sensor == 1'b1) behavioral_pattern_recognition |-> $past(activity_level_monitoring, 7) && disease_early_detection", "sva_description": "### Assertion description:  \n**Property Name**: p_Behavioral_Pattern_Recognition  \n**Trigger Condition**: At every falling edge of the `clk_livestock_tracking`  \n**Disable Condition**: `disable iff (rst_animal_health_sensor == 1'b1)`  \n**Antecedent (LHS of Implication)**: `behavioral_pattern_recognition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(activity_level_monitoring, 7) && disease_early_detection`", "sva_signals": ["clk_livestock_tracking", "rst_animal_health_sensor", "[0:0] behavioral_pattern_recognition", "[0:0] activity_level_monitoring", "[0:0] disease_early_detection"], "clock": "clk_livestock_tracking", "attempts_left": 10, "sva_result": "@(negedge clk_livestock_tracking) disable iff (rst_animal_health_sensor == 1'b1)     behavioral_pattern_recognition |-> ($past(activity_level_monitoring, 7) && disease_early_detection)", "sva_name": "p_behavioral_pattern_recognition", "id": "2038", "full_property": "property p_Behavioral_Pattern_Recognition;\n@(negedge clk_livestock_tracking) disable iff (rst_animal_health_sensor == 1'b1)     behavioral_pattern_recognition |-> ($past(activity_level_monitoring, 7) && disease_early_detection)\nendproperty\nassert_p_Behavioral_Pattern_Recognition:assert property (p_Behavioral_Pattern_Recognition) else $error(\"\");", "task_id": "1_5788", "predict_sva": "@(negedge clk_livestock_tracking) disable iff (rst_animal_health_sensor == 1'b1)     behavioral_pattern_recognition |-> $past(activity_level_monitoring, 7) && disease_early_detection"}
{"sva": "@(posedge clk_axi) disable iff(!rst_axi_n) awvalid_handshake |-> ($past(awready, 1) && $past(awvalid, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_awvalid_handshake  \n**Trigger Condition**: At every rising edge of the `clk_axi`  \n**Disable Condition**: disable iff (!rst_axi_n)  \n**Antecedent (LHS of Implication)**: `awvalid_handshake`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(awready, 1) && $past(awvalid, 1)`  ", "sva_signals": ["clk_axi", "rst_axi_n", "[0:0] awvalid_handshake", "[0:0] awready", "[0:0] awvalid"], "clock": "clk_axi", "attempts_left": 10, "sva_result": "@(posedge clk_axi) disable iff (!rst_axi_n)     awvalid_handshake |-> ($past(awready, 1) && $past(awvalid, 1))", "sva_name": "p_awvalid_handshake", "id": "2128", "full_property": "property p_awvalid_handshake;\n@(posedge clk_axi) disable iff (!rst_axi_n)     awvalid_handshake |-> ($past(awready, 1) && $past(awvalid, 1))\nendproperty\nassert_p_awvalid_handshake:assert property (p_awvalid_handshake) else $error(\"\");", "task_id": "1_5873", "predict_sva": "@(posedge clk_axi) disable iff (!rst_axi_n)     awvalid_handshake |-> ($past(awready, 1) && $past(awvalid, 1))"}
{"sva": "@(posedge clk) disable iff(emulation_mode) stack_pointer_corruption |-> ($past(stack_push, 1) && $past(stack_overflow_detect, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_stack_pointer_corruption_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (emulation_mode)`  \n**Antecedent (LHS of Implication)**: `stack_pointer_corruption`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(stack_push, 1) && $past(stack_overflow_detect, 1))`  ", "sva_signals": ["clk", "[0:0] emulation_mode", "stack_pointer_corruption", "[0:0] stack_push", "[0:0] stack_overflow_detect"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (emulation_mode)     stack_pointer_corruption |-> ($past(stack_push, 1) && $past(stack_overflow_detect, 1))", "sva_name": "p_stack_pointer_corruption_check", "id": "2172", "full_property": "property p_stack_pointer_corruption_check;\n@(posedge clk) disable iff (emulation_mode)     stack_pointer_corruption |-> ($past(stack_push, 1) && $past(stack_overflow_detect, 1))\nendproperty\nassert_p_stack_pointer_corruption_check:assert property (p_stack_pointer_corruption_check) else $error(\"\");", "task_id": "1_5916", "predict_sva": "@(posedge clk) disable iff (emulation_mode)     stack_pointer_corruption |-> ($past(stack_push, 1) && $past(stack_overflow_detect, 1))"}
{"sva": "@(posedge clk) disable iff(static_timing) timing_constraint_validation |-> ($past(setup_check, 1) && $past(hold_check, 1) && $past(recovery_removal, 1))", "sva_description": "### Assertion description:  \n**Property Name**: timing_constraint_validation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (static_timing)`  \n**Antecedent (LHS of Implication)**: `timing_constraint_validation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(setup_check, 1) && $past(hold_check, 1) && $past(recovery_removal, 1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] static_timing", "[0:0] timing_constraint_validation", "[0:0] setup_check", "[0:0] hold_check", "[0:0] recovery_removal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (static_timing)     timing_constraint_validation |->          $past(setup_check, 1) && $past(hold_check, 1) && $past(recovery_removal, 1)", "sva_name": "p_Timing_Constraint_Validation", "id": "2282", "full_property": "property timing_constraint_validation;\n@(posedge clk) disable iff (static_timing)     timing_constraint_validation |->          $past(setup_check, 1) && $past(hold_check, 1) && $past(recovery_removal, 1)\nendproperty\nassert_timing_constraint_validation:assert property (timing_constraint_validation) else $error(\"\");", "task_id": "1_6016", "predict_sva": "@(posedge clk) disable iff (static_timing)     timing_constraint_validation |->          $past(setup_check, 1) && $past(hold_check, 1) && $past(recovery_removal, 1)"}
{"sva": "@(posedge clk_greenhouse_automation) disable iff(rst_climate_control == 1'b1) carbon_dioxide_enrichment |-> $past(photosynthesis_rate_measurement, 6) && crop_yield_maximization", "sva_description": "### Assertion description:  \n**Property Name**: p_carbon_dioxide_enrichment_effect  \n**Trigger Condition**: At every rising edge of the `clk_greenhouse_automation`  \n**Disable Condition**: disable iff (`rst_climate_control == 1'b1`)  \n**Antecedent (LHS of Implication)**: `carbon_dioxide_enrichment == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(photosynthesis_rate_measurement, 6) && crop_yield_maximization`  \n\n*Note*: The consequent checks that both conditions must be true:  \n1. The value of `photosynthesis_rate_measurement` from 6 clock cycles ago (`$past(..., 6)`)  \n2. The current value of `crop_yield_maximization`", "sva_signals": ["clk_greenhouse_automation", "rst_climate_control", "[0:0] carbon_dioxide_enrichment", "[0:0] photosynthesis_rate_measurement", "[0:0] crop_yield_maximization"], "clock": "clk_greenhouse_automation", "attempts_left": 10, "sva_result": "@(posedge clk_greenhouse_automation) disable iff (rst_climate_control == 1'b1)     carbon_dioxide_enrichment == 1'b1 |-> $past(photosynthesis_rate_measurement, 6) && crop_yield_maximization", "sva_name": "p_carbon_dioxide_enrichment_check", "id": "2017", "full_property": "property p_carbon_dioxide_enrichment_effect;\n@(posedge clk_greenhouse_automation) disable iff (rst_climate_control == 1'b1)     carbon_dioxide_enrichment == 1'b1 |-> $past(photosynthesis_rate_measurement, 6) && crop_yield_maximization\nendproperty\nassert_p_carbon_dioxide_enrichment_effect:assert property (p_carbon_dioxide_enrichment_effect) else $error(\"\");", "task_id": "1_5767", "predict_sva": "@(posedge clk_greenhouse_automation) disable iff (rst_climate_control == 1'b1)     carbon_dioxide_enrichment == 1'b1 |-> $past(photosynthesis_rate_measurement, 6) && crop_yield_maximization"}
{"sva": "@(posedge clk_cpu) disable iff(debug_mode) branch_prediction_miss |-> ($past(predicted_target[31:0], 1) != $past(actual_target[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_prediction_miss  \n**Trigger Condition**: At every rising edge of the `clk_cpu`  \n**Disable Condition**: `disable iff (debug_mode)`  \n**Antecedent (LHS of Implication)**: `branch_prediction_miss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(predicted_target[31:0], 1) != $past(actual_target[31:0], 1))`  \n\n", "sva_signals": ["clk_cpu", "debug_mode", "[0:0] branch_prediction_miss", "[31:0] predicted_target", "[31:0] actual_target"], "clock": "clk_cpu", "attempts_left": 10, "sva_result": "@(posedge clk_cpu) disable iff (debug_mode)     branch_prediction_miss == 1'b1 |-> ($past(predicted_target[31:0], 1) != $past(actual_target[31:0], 1))", "sva_name": "p_branch_prediction_miss_check", "id": "2136", "full_property": "property p_branch_prediction_miss;\n@(posedge clk_cpu) disable iff (debug_mode)     branch_prediction_miss == 1'b1 |-> ($past(predicted_target[31:0], 1) != $past(actual_target[31:0], 1))\nendproperty\nassert_p_branch_prediction_miss:assert property (p_branch_prediction_miss) else $error(\"\");", "task_id": "1_5881", "predict_sva": "@(posedge clk_cpu) disable iff (debug_mode)     branch_prediction_miss == 1'b1 |->      $past(predicted_target[31:0], 1) != $past(actual_target[31:0], 1)"}
{"sva": "@(negedge clk_blackparrot) disable iff(!bp_reset_n) black_parrot_cache_miss |-> $past(icache_miss | dcache_miss | l2_miss, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_black_parrot_cache_miss  \n**Trigger Condition**: At every falling edge of the `clk_blackparrot`  \n**Disable Condition**: disable iff (`!bp_reset_n`)  \n**Antecedent (LHS of Implication)**: `black_parrot_cache_miss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(icache_miss | dcache_miss | l2_miss, 1)`  ", "sva_signals": ["clk_blackparrot", "bp_reset_n", "[0:0] black_parrot_cache_miss", "[0:0] icache_miss", "[0:0] dcache_miss", "[0:0] l2_miss"], "clock": "clk_blackparrot", "attempts_left": 10, "sva_result": "@(negedge clk_blackparrot) disable iff (!bp_reset_n)     black_parrot_cache_miss == 1'b1 |-> $past(icache_miss | dcache_miss | l2_miss, 1)", "sva_name": "p_black_parrot_cache_miss", "id": "2240", "full_property": "property p_black_parrot_cache_miss;\n@(negedge clk_blackparrot) disable iff (!bp_reset_n)     black_parrot_cache_miss == 1'b1 |-> $past(icache_miss | dcache_miss | l2_miss, 1)\nendproperty\nassert_p_black_parrot_cache_miss:assert property (p_black_parrot_cache_miss) else $error(\"\");", "task_id": "1_5980", "predict_sva": "@(negedge clk_blackparrot) disable iff (!bp_reset_n)     black_parrot_cache_miss == 1'b1 |-> $past(icache_miss | dcache_miss | l2_miss, 1)"}
{"sva": "@(posedge clk) disable iff(static_power_analysis) leakage_power_estimation |-> ($past(transistor_stack_effect, 1) && $past(temperature_dependency, 1) && $past(process_variation, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_leakage_power_estimation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (static_power_analysis)`  \n**Antecedent (LHS of Implication)**: `leakage_power_estimation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(transistor_stack_effect, 1) && $past(temperature_dependency, 1) && $past(process_variation, 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] static_power_analysis", "[0:0] leakage_power_estimation", "[0:0] transistor_stack_effect", "[0:0] temperature_dependency", "[0:0] process_variation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (static_power_analysis)     leakage_power_estimation |->          ($past(transistor_stack_effect, 1) &&           $past(temperature_dependency, 1) &&           $past(process_variation, 1))", "sva_name": "p_leakage_power_estimation", "id": "2360", "full_property": "property p_leakage_power_estimation;\n@(posedge clk) disable iff (static_power_analysis)     leakage_power_estimation |->          ($past(transistor_stack_effect, 1) &&           $past(temperature_dependency, 1) &&           $past(process_variation, 1))\nendproperty\nassert_p_leakage_power_estimation:assert property (p_leakage_power_estimation) else $error(\"\");", "task_id": "1_6086", "predict_sva": "@(posedge clk) disable iff (static_power_analysis)     leakage_power_estimation |->          $past(transistor_stack_effect, 1) &&          $past(temperature_dependency, 1) &&          $past(process_variation, 1)"}
{"sva": "@(posedge clk) disable iff(calibration_mode) phase_locked_loop_jitter |-> ($past(vco_frequency[31:0], 1) && $past(jitter_measurement[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_phase_locked_loop_jitter  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (calibration_mode)`  \n**Antecedent (LHS of Implication)**: `phase_locked_loop_jitter`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(vco_frequency[31:0], 1) && $past(jitter_measurement[7:0], 1))`  ", "sva_signals": ["clk", "[0:0] calibration_mode", "[0:0] phase_locked_loop_jitter", "[31:0] vco_frequency", "[7:0] jitter_measurement"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (calibration_mode)     phase_locked_loop_jitter |-> ($past(vco_frequency[31:0], 1) && $past(jitter_measurement[7:0], 1))", "sva_name": "p_phase_locked_loop_jitter", "id": "2220", "full_property": "property p_phase_locked_loop_jitter;\n@(posedge clk) disable iff (calibration_mode)     phase_locked_loop_jitter |-> ($past(vco_frequency[31:0], 1) && $past(jitter_measurement[7:0], 1))\nendproperty\nassert_p_phase_locked_loop_jitter:assert property (p_phase_locked_loop_jitter) else $error(\"\");", "task_id": "1_5961", "predict_sva": "@(posedge clk) disable iff (calibration_mode)     phase_locked_loop_jitter |-> ($past(vco_frequency[31:0], 1) && $past(jitter_measurement[7:0], 1))"}
{"sva": "@(posedge clk) disable iff(behavioral_model) synthesizable_construct |-> ($past(always_comb_logic, 1) && !$past(initial_block, 1) && !$past(forever_loop, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Synthesizable_Construct_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (behavioral_model)  \n**Antecedent (LHS of Implication)**: `synthesizable_construct == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(always_comb_logic, 1) && !$past(initial_block, 1) && !$past(forever_loop, 1))`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] behavioral_model", "[0:0] synthesizable_construct", "[0:0] always_comb_logic", "[0:0] initial_block", "[0:0] forever_loop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (behavioral_model)     synthesizable_construct == 1'b1 |->          ($past(always_comb_logic, 1) && !$past(initial_block, 1) && !$past(forever_loop, 1))", "sva_name": "p_Synthesizable_Construct_Check", "id": "2263", "full_property": "property p_Synthesizable_Construct_Check;\n@(posedge clk) disable iff (behavioral_model)     synthesizable_construct == 1'b1 |->          ($past(always_comb_logic, 1) && !$past(initial_block, 1) && !$past(forever_loop, 1))\nendproperty\nassert_p_Synthesizable_Construct_Check:assert property (p_Synthesizable_Construct_Check) else $error(\"\");", "task_id": "1_6001", "predict_sva": "@(posedge clk) disable iff (behavioral_model)     synthesizable_construct == 1'b1 |->      $past(always_comb_logic, 1) && !$past(initial_block) && !$past(forever_loop)"}
{"sva": "@(posedge clk_cva6) disable iff(!cva6_enable) application_core_pipeline |-> ($past(issue_entry_valid, 1) && $past(scoreboard_empty, 1) && $past(commit_stage_ready, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_application_core_pipeline  \n**Trigger Condition**: At every rising edge of the `clk_cva6`  \n**Disable Condition**: `disable iff (!cva6_enable)`  \n**Antecedent (LHS of Implication)**: `application_core_pipeline`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(issue_entry_valid, 1) && $past(scoreboard_empty, 1) && $past(commit_stage_ready, 1))`  ", "sva_signals": ["clk_cva6", "cva6_enable", "[0:0] application_core_pipeline", "[0:0] issue_entry_valid", "[0:0] scoreboard_empty", "[0:0] commit_stage_ready"], "clock": "clk_cva6", "attempts_left": 10, "sva_result": "@(posedge clk_cva6) disable iff (!cva6_enable)     application_core_pipeline |->          ($past(issue_entry_valid, 1) &&           $past(scoreboard_empty, 1) &&           $past(commit_stage_ready, 1))", "sva_name": "p_application_core_pipeline", "id": "2269", "full_property": "property p_application_core_pipeline;\n@(posedge clk_cva6) disable iff (!cva6_enable)     application_core_pipeline |->          ($past(issue_entry_valid, 1) &&           $past(scoreboard_empty, 1) &&           $past(commit_stage_ready, 1))\nendproperty\nassert_p_application_core_pipeline:assert property (p_application_core_pipeline) else $error(\"\");", "task_id": "1_6004", "predict_sva": "@(posedge clk_cva6) disable iff (!cva6_enable)     application_core_pipeline |->          $past(issue_entry_valid, 1) &&          $past(scoreboard_empty, 1) &&          $past(commit_stage_ready, 1)"}
{"sva": "@(posedge clk_resolver) disable iff(!resolver_enable) resolver_to_digital_converter |-> ($past(sine_channel[11:0], 1) && $past(cosine_channel[11:0], 1) && $past(angle_calculation[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_resolver_to_digital_converter  \n**Trigger Condition**: At every rising edge of the `clk_resolver`  \n**Disable Condition**: disable iff `(!resolver_enable)`  \n**Antecedent (LHS of Implication)**: `resolver_to_digital_converter`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(sine_channel[11:0], 1) && $past(cosine_channel[11:0], 1) && $past(angle_calculation[15:0], 1))`  ", "sva_signals": ["clk_resolver", "resolver_enable", "[0:0] resolver_to_digital_converter", "[11:0] sine_channel", "[11:0] cosine_channel", "[15:0] angle_calculation"], "clock": "clk_resolver", "attempts_left": 10, "sva_result": "@(posedge clk_resolver) disable iff (!resolver_enable)     resolver_to_digital_converter |->          ($past(sine_channel[11:0], 1) && $past(cosine_channel[11:0], 1) && $past(angle_calculation[15:0], 1))", "sva_name": "p_resolver_to_digital_converter", "id": "2434", "full_property": "property p_resolver_to_digital_converter;\n@(posedge clk_resolver) disable iff (!resolver_enable)     resolver_to_digital_converter |->          ($past(sine_channel[11:0], 1) && $past(cosine_channel[11:0], 1) && $past(angle_calculation[15:0], 1))\nendproperty\nassert_p_resolver_to_digital_converter:assert property (p_resolver_to_digital_converter) else $error(\"\");", "task_id": "1_6141", "predict_sva": "@(posedge clk_resolver) disable iff (!resolver_enable)     resolver_to_digital_converter |->          ($past(sine_channel[11:0], 1) && $past(cosine_channel[11:0], 1) && $past(angle_calculation[15:0], 1))"}
{"sva": "@(posedge clk_rv_plic) disable iff(!rv_plic_rst_n) risc_v_interrupt_controller |-> ($past(interrupt_pending[1023:0], 1) && $past(hart_context[31:0], 1) && $past(interrupt_gateway, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_RiscVInterruptController  \n**Trigger Condition**: At every rising edge of the `clk_rv_plic`  \n**Disable Condition**: `disable iff (!rv_plic_rst_n)`  \n**Antecedent (LHS of Implication)**: `risc_v_interrupt_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(interrupt_pending[1023:0], 1) && $past(hart_context[31:0], 1) && $past(interrupt_gateway, 1))`  ", "sva_signals": ["clk_rv_plic", "rv_plic_rst_n", "[0:0] risc_v_interrupt_controller", "[1023:0] interrupt_pending", "[31:0] hart_context", "[0:0] interrupt_gateway"], "clock": "clk_rv_plic", "attempts_left": 10, "sva_result": "@(posedge clk_rv_plic) disable iff (!rv_plic_rst_n)     risc_v_interrupt_controller |->          ($past(interrupt_pending[1023:0], 1) &&           $past(hart_context[31:0], 1) &&           $past(interrupt_gateway, 1))", "sva_name": "p_risc_v_interrupt_controller", "id": "2380", "full_property": "property p_RiscVInterruptController;\n@(posedge clk_rv_plic) disable iff (!rv_plic_rst_n)     risc_v_interrupt_controller |->          ($past(interrupt_pending[1023:0], 1) &&           $past(hart_context[31:0], 1) &&           $past(interrupt_gateway, 1))\nendproperty\nassert_p_RiscVInterruptController:assert property (p_RiscVInterruptController) else $error(\"\");", "task_id": "1_6103", "predict_sva": "@(posedge clk_rv_plic) disable iff (!rv_plic_rst_n)     risc_v_interrupt_controller |->          ($past(interrupt_pending[1023:0], 1) &&           $past(hart_context[31:0], 1) &&           $past(interrupt_gateway, 1))"}
{"sva": "@(posedge clk_edn) disable iff(!edn_rst_n) entropy_distribution_network |-> ($past(entropy_request, 1) && $past(entropy_acknowledge, 1) && $past(fips_compliance, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_entropy_distribution_network  \n**Trigger Condition**: At every rising edge of the `clk_edn`  \n**Disable Condition**: `disable iff (!edn_rst_n)`  \n**Antecedent (LHS of Implication)**: `entropy_distribution_network`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(entropy_request, 1) && $past(entropy_acknowledge, 1) && $past(fips_compliance, 1))`  ", "sva_signals": ["clk_edn", "edn_rst_n", "[0:0] entropy_distribution_network", "[0:0] entropy_request", "[0:0] entropy_acknowledge", "[0:0] fips_compliance"], "clock": "clk_edn", "attempts_left": 10, "sva_result": "@(posedge clk_edn) disable iff (!edn_rst_n)     entropy_distribution_network |->          ($past(entropy_request, 1) && $past(entropy_acknowledge, 1) && $past(fips_compliance, 1))", "sva_name": "p_entropy_distribution_network_check", "id": "2366", "full_property": "property p_entropy_distribution_network;\n@(posedge clk_edn) disable iff (!edn_rst_n)     entropy_distribution_network |->          ($past(entropy_request, 1) && $past(entropy_acknowledge, 1) && $past(fips_compliance, 1))\nendproperty\nassert_p_entropy_distribution_network:assert property (p_entropy_distribution_network) else $error(\"\");", "task_id": "1_6090", "predict_sva": "@(posedge clk_edn) disable iff (!edn_rst_n)     entropy_distribution_network |->          ($past(entropy_request, 1) && $past(entropy_acknowledge, 1) && $past(fips_compliance, 1))"}
{"sva": "@(posedge clk) disable iff(signal_integrity) crosstalk_noise_analysis |-> ($past(coupling_capacitance, 1) && $past(switching_activity, 1) && $past(victim_aggressor_nets, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_crosstalk_noise_analysis  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`signal_integrity`)  \n**Antecedent (LHS of Implication)**: `crosstalk_noise_analysis`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(coupling_capacitance, 1) && $past(switching_activity, 1) && $past(victim_aggressor_nets, 1))`  ", "sva_signals": ["clk", "[0:0] signal_integrity", "[0:0] crosstalk_noise_analysis", "[0:0] coupling_capacitance", "[0:0] switching_activity", "[0:0] victim_aggressor_nets"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (signal_integrity)     crosstalk_noise_analysis |-> ($past(coupling_capacitance, 1) && $past(switching_activity, 1) && $past(victim_aggressor_nets, 1))", "sva_name": "p_crosstalk_noise_analysis", "id": "2359", "full_property": "property p_crosstalk_noise_analysis;\n@(posedge clk) disable iff (signal_integrity)     crosstalk_noise_analysis |-> ($past(coupling_capacitance, 1) && $past(switching_activity, 1) && $past(victim_aggressor_nets, 1))\nendproperty\nassert_p_crosstalk_noise_analysis:assert property (p_crosstalk_noise_analysis) else $error(\"\");", "task_id": "1_6085", "predict_sva": "@(posedge clk) disable iff (signal_integrity)     crosstalk_noise_analysis |->          ($past(coupling_capacitance, 1) &&           $past(switching_activity, 1) &&           $past(victim_aggressor_nets, 1))"}
{"sva": "@(posedge clk_scr1) disable iff(!scr1_reset_n) syntacore_risc_v |-> ($past(ifu_req_valid, 1) && $past(lsu_req_valid, 1) && $past(exu_req_valid, 1))", "sva_description": "### Assertion description:  \n**Property Name**: syntacore_risc_v  \n**Trigger Condition**: At every rising edge of the `clk_scr1`  \n**Disable Condition**: `disable iff (!scr1_reset_n)`  \n**Antecedent (LHS of Implication)**: `syntacore_risc_v`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(ifu_req_valid, 1) && $past(lsu_req_valid, 1) && $past(exu_req_valid, 1))`  ", "sva_signals": ["clk_scr1", "scr1_reset_n", "[0:0] syntacore_risc_v", "[0:0] ifu_req_valid", "[0:0] lsu_req_valid", "[0:0] exu_req_valid"], "clock": "clk_scr1", "attempts_left": 10, "sva_result": "@(posedge clk_scr1) disable iff (!scr1_reset_n)     syntacore_risc_v |-> ($past(ifu_req_valid, 1) && $past(lsu_req_valid, 1) && $past(exu_req_valid, 1))", "sva_name": "p_syntacore_risc_v_requirements", "id": "2251", "full_property": "property syntacore_risc_v;\n@(posedge clk_scr1) disable iff (!scr1_reset_n)     syntacore_risc_v |-> ($past(ifu_req_valid, 1) && $past(lsu_req_valid, 1) && $past(exu_req_valid, 1))\nendproperty\nassert_syntacore_risc_v:assert property (syntacore_risc_v) else $error(\"\");", "task_id": "1_5990", "predict_sva": "@(posedge clk_scr1) disable iff (!scr1_reset_n)     syntacore_risc_v |-> ($past(ifu_req_valid, 1) && $past(lsu_req_valid, 1) && $past(exu_req_valid, 1))"}
{"sva": "@(posedge clk) disable iff(electromigration) reliability_analysis_framework |-> ($past(current_density_violation, 1) && $past(metal_layer_stress, 1) && $past(lifetime_estimation, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_reliability_analysis_framework  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (electromigration)  \n**Antecedent (LHS of Implication)**: `reliability_analysis_framework == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(current_density_violation, 1) && $past(metal_layer_stress, 1) && $past(lifetime_estimation, 1))`  \n\n(Note: The consequent checks that in the previous clock cycle, all three signals - `current_density_violation`, `metal_layer_stress`, and `lifetime_estimation` - were simultaneously true.)", "sva_signals": ["clk", "rst_n", "[0:0] electromigration", "[0:0] reliability_analysis_framework", "[0:0] current_density_violation", "[0:0] metal_layer_stress", "[0:0] lifetime_estimation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (electromigration)     reliability_analysis_framework == 1'b1 |->      ($past(current_density_violation, 1) && $past(metal_layer_stress, 1) && $past(lifetime_estimation, 1))", "sva_name": "p_reliability_analysis", "id": "2373", "full_property": "property p_reliability_analysis_framework;\n@(posedge clk) disable iff (electromigration)     reliability_analysis_framework == 1'b1 |->      ($past(current_density_violation, 1) && $past(metal_layer_stress, 1) && $past(lifetime_estimation, 1))\nendproperty\nassert_p_reliability_analysis_framework:assert property (p_reliability_analysis_framework) else $error(\"\");", "task_id": "1_6096", "predict_sva": "@(posedge clk) disable iff (electromigration)     reliability_analysis_framework == 1'b1 |->      $past(current_density_violation, 1) && $past(metal_layer_stress, 1) && $past(lifetime_estimation, 1)"}
{"sva": "@(negedge processor_clk) disable iff(cpu_reset) branch_mispredict |-> $past(branch_taken) != $past(predicted_taken)", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_mispredict  \n**Trigger Condition**: At every falling edge of the `processor_clk`  \n**Disable Condition**: disable iff (`cpu_reset`)  \n**Antecedent (LHS of Implication)**: `branch_mispredict == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(branch_taken) != $past(predicted_taken)`", "sva_signals": ["processor_clk", "cpu_reset", "[0:0] branch_mispredict", "[0:0] branch_taken", "[0:0] predicted_taken"], "clock": "processor_clk", "attempts_left": 10, "sva_result": "@(negedge processor_clk) disable iff (cpu_reset)     branch_mispredict == 1'b1 |-> $past(branch_taken) != $past(predicted_taken)", "sva_name": "p_branch_mispredict_check", "id": "3046", "full_property": "property p_branch_mispredict;\n@(negedge processor_clk) disable iff (cpu_reset)     branch_mispredict == 1'b1 |-> $past(branch_taken) != $past(predicted_taken)\nendproperty\nassert_p_branch_mispredict:assert property (p_branch_mispredict) else $error(\"\");", "task_id": "1_6657", "predict_sva": "@(negedge processor_clk) disable iff (cpu_reset)     branch_mispredict == 1'b1 |-> $past(branch_taken) != $past(predicted_taken)"}
{"sva": "@(posedge clk) disable iff(rst_sequence) state_transition |-> ($past(current_state) == idle_state) && (next_state == active_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_state_transition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (rst_sequence)  \n**Antecedent (LHS of Implication)**: `state_transition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(current_state) == idle_state) && (next_state == active_state)`", "sva_signals": ["clk", "rst_sequence", "[0:0] state_transition", "[0:0] current_state", "[0:0] idle_state", "[0:0] next_state", "[0:0] active_state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst_sequence)     state_transition |-> ($past(current_state) == idle_state) && (next_state == active_state)", "sva_name": "p_State_Transition_Check", "id": "3080", "full_property": "property p_state_transition;\n@(posedge clk) disable iff (rst_sequence)     state_transition |-> ($past(current_state) == idle_state) && (next_state == active_state)\nendproperty\nassert_p_state_transition:assert property (p_state_transition) else $error(\"\");", "task_id": "1_6690", "predict_sva": "@(posedge clk) disable iff (rst_sequence)     state_transition |-> ($past(current_state) == idle_state) && (next_state == active_state)"}
{"sva": "@(posedge clock_domain) disable iff(!hard_reset_n) tx_complete |-> $past(tx_start) && $past(data_loaded)", "sva_description": "### Assertion description:  \n**Property Name**: p_tx_complete_after_start  \n**Trigger Condition**: At every rising edge of `clock_domain`  \n**Disable Condition**: `disable iff (!hard_reset_n)`  \n**Antecedent (LHS of Implication)**: `tx_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tx_start) && $past(data_loaded)`  ", "sva_signals": ["clock_domain", "[0:0] hard_reset_n", "[0:0] tx_complete", "[0:0] tx_start", "[0:0] data_loaded"], "clock": "clock_domain", "attempts_left": 10, "sva_result": "@(posedge clock_domain) disable iff (!hard_reset_n)     tx_complete == 1'b1 |-> $past(tx_start) && $past(data_loaded)", "sva_name": "p_tx_complete_after_start_and_load", "id": "3075", "full_property": "property p_tx_complete_after_start;\n@(posedge clock_domain) disable iff (!hard_reset_n)     tx_complete == 1'b1 |-> $past(tx_start) && $past(data_loaded)\nendproperty\nassert_p_tx_complete_after_start:assert property (p_tx_complete_after_start) else $error(\"\");", "task_id": "1_6685", "predict_sva": "@(posedge clock_domain) disable iff (!hard_reset_n)     tx_complete == 1'b1 |-> $past(tx_start) && $past(data_loaded)"}
{"sva": "@(posedge clk) disable iff(subthreshold_leakage) transistor_subthreshold_conduction |-> ($past(gate_source_voltage[7:0], 1) && $past(body_effect_coefficient[7:0], 1) && $past(drain_induced_barrier_lowering[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_transistor_subthreshold_conduction  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`subthreshold_leakage`)  \n**Antecedent (LHS of Implication)**: `transistor_subthreshold_conduction`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(gate_source_voltage[7:0], 1) && $past(body_effect_coefficient[7:0], 1) && $past(drain_induced_barrier_lowering[7:0], 1))`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] subthreshold_leakage", "[0:0] transistor_subthreshold_conduction", "[7:0] gate_source_voltage", "[7:0] body_effect_coefficient", "[7:0] drain_induced_barrier_lowering"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (subthreshold_leakage)     transistor_subthreshold_conduction |->          ($past(gate_source_voltage[7:0], 1) &&           $past(body_effect_coefficient[7:0], 1) &&           $past(drain_induced_barrier_lowering[7:0], 1))", "sva_name": "p_transistor_subthreshold_conduction", "id": "2515", "full_property": "property p_transistor_subthreshold_conduction;\n@(posedge clk) disable iff (subthreshold_leakage)     transistor_subthreshold_conduction |->          ($past(gate_source_voltage[7:0], 1) &&           $past(body_effect_coefficient[7:0], 1) &&           $past(drain_induced_barrier_lowering[7:0], 1))\nendproperty\nassert_p_transistor_subthreshold_conduction:assert property (p_transistor_subthreshold_conduction) else $error(\"\");", "task_id": "1_6206", "predict_sva": "@(posedge clk) disable iff (subthreshold_leakage)     transistor_subthreshold_conduction |->          ($past(gate_source_voltage[7:0], 1) &&           $past(body_effect_coefficient[7:0], 1) &&           $past(drain_induced_barrier_lowering[7:0], 1))"}
{"sva": "@(posedge clk_network) packet_dropped |-> $past(buffer_almost_full) && $past(incoming_packet)", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_dropped_condition  \n**Trigger Condition**: At every rising edge of the `clk_network`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_dropped == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(buffer_almost_full) && $past(incoming_packet)`  ", "sva_signals": ["clk", "rst_n", "[0:0] packet_dropped", "[0:0] buffer_almost_full", "[0:0] incoming_packet", "clk_network"], "clock": "clk_network", "attempts_left": 10, "sva_result": "@(posedge clk_network)         packet_dropped == 1'b1 |-> $past(buffer_almost_full) && $past(incoming_packet)", "sva_name": "p_Packet_Drop_Condition", "id": "3051", "full_property": "property p_packet_dropped_condition;\n@(posedge clk_network)         packet_dropped == 1'b1 |-> $past(buffer_almost_full) && $past(incoming_packet)\nendproperty\nassert_p_packet_dropped_condition:assert property (p_packet_dropped_condition) else $error(\"\");", "task_id": "1_6662", "predict_sva": "@(posedge clk_network)     packet_dropped == 1'b1 |-> $past(buffer_almost_full) && $past(incoming_packet)"}
{"sva": "@(posedge clk_electron_microscopy) disable iff(!electron_microscope_ready) transmission_electron_microscopy_detector |-> ($past(electron_beam_intensity[15:0], 1) && $past(objective_lens_focus[11:0], 1) && $past(contrast_transfer_function[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Transmission_Electron_Microscopy_Detector  \n**Trigger Condition**: At every rising edge of the `clk_electron_microscopy`  \n**Disable Condition**: disable iff (`!electron_microscope_ready`)  \n**Antecedent (LHS of Implication)**: `transmission_electron_microscopy_detector`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(electron_beam_intensity[15:0], 1) && $past(objective_lens_focus[11:0], 1) && $past(contrast_transfer_function[7:0], 1))`  ", "sva_signals": ["clk_electron_microscopy", "electron_microscope_ready", "transmission_electron_microscopy_detector", "[15:0] electron_beam_intensity", "[11:0] objective_lens_focus", "[7:0] contrast_transfer_function"], "clock": "clk_electron_microscopy", "attempts_left": 10, "sva_result": "@(posedge clk_electron_microscopy) disable iff (!electron_microscope_ready)     transmission_electron_microscopy_detector |->          ($past(electron_beam_intensity[15:0], 1) &&           $past(objective_lens_focus[11:0], 1) &&           $past(contrast_transfer_function[7:0], 1))", "sva_name": "p_transmission_electron_microscopy_detector", "id": "2618", "full_property": "property p_Transmission_Electron_Microscopy_Detector;\n@(posedge clk_electron_microscopy) disable iff (!electron_microscope_ready)     transmission_electron_microscopy_detector |->          ($past(electron_beam_intensity[15:0], 1) &&           $past(objective_lens_focus[11:0], 1) &&           $past(contrast_transfer_function[7:0], 1))\nendproperty\nassert_p_Transmission_Electron_Microscopy_Detector:assert property (p_Transmission_Electron_Microscopy_Detector) else $error(\"\");", "task_id": "1_6292", "predict_sva": "@(posedge clk_electron_microscopy) disable iff (!electron_microscope_ready)     transmission_electron_microscopy_detector |->          ($past(electron_beam_intensity[15:0], 1) &&           $past(objective_lens_focus[11:0], 1) &&           $past(contrast_transfer_function[7:0], 1))"}
{"sva": "@(posedge clk_watchdog) disable iff(!wdt_rst_n) watchdog_timer_expiration |-> ($past(wdt_counter[31:0], 1) == timeout_value && $past(wdt_enable, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_watchdog_timer_expiration  \n**Trigger Condition**: At every rising edge of the `clk_watchdog`  \n**Disable Condition**: `disable iff (!wdt_rst_n)`  \n**Antecedent (LHS of Implication)**: `watchdog_timer_expiration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(wdt_counter[31:0], 1) == timeout_value && $past(wdt_enable, 1))`  \n\nThe assertion checks that whenever the `watchdog_timer_expiration` signal is high, the following two conditions must hold:  \n1. The past value of `wdt_counter[31:0]` (from the previous clock cycle) must equal `timeout_value`.  \n2. The past value of `wdt_enable` (from the previous clock cycle) must be high (`1'b1`).  \nThe assertion is disabled when the reset signal `wdt_rst_n` is low (`!wdt_rst_n`).", "sva_signals": ["clk_watchdog", "wdt_rst_n", "[0:0] watchdog_timer_expiration", "[31:0] wdt_counter", "[31:0] timeout_value", "[0:0] wdt_enable"], "clock": "clk_watchdog", "attempts_left": 10, "sva_result": "@(posedge clk_watchdog) disable iff (!wdt_rst_n)     watchdog_timer_expiration |-> ($past(wdt_counter[31:0], 1) == timeout_value && $past(wdt_enable, 1))", "sva_name": "p_watchdog_timer_expiration", "id": "2386", "full_property": "property p_watchdog_timer_expiration;\n@(posedge clk_watchdog) disable iff (!wdt_rst_n)     watchdog_timer_expiration |-> ($past(wdt_counter[31:0], 1) == timeout_value && $past(wdt_enable, 1))\nendproperty\nassert_p_watchdog_timer_expiration:assert property (p_watchdog_timer_expiration) else $error(\"\");", "task_id": "1_6109", "predict_sva": "@(posedge clk_watchdog) disable iff (!wdt_rst_n)     watchdog_timer_expiration == 1'b1 |->      ($past(wdt_counter[31:0], 1) == timeout_value) && $past(wdt_enable, 1)"}
{"sva": "@(posedge sys_clk) disable iff(!sys_rst_n) overflow_flag |-> $past(operand_a) + $past(operand_b) > 16'hFFFF", "sva_description": "### Assertion description:  \n**Property Name**: p_Overflow_Flag_Check  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: `disable iff (!sys_rst_n)`  \n**Antecedent (LHS of Implication)**: `overflow_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(operand_a) + $past(operand_b) > 16'hFFFF`  ", "sva_signals": ["sys_clk", "sys_rst_n", "[0:0] overflow_flag", "[15:0] operand_a", "[15:0] operand_b"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk) disable iff (!sys_rst_n)     overflow_flag == 1'b1 |-> ($past(operand_a) + $past(operand_b)) > 16'hFFFF", "sva_name": "p_overflow_check", "id": "3033", "full_property": "property p_Overflow_Flag_Check;\n@(posedge sys_clk) disable iff (!sys_rst_n)     overflow_flag == 1'b1 |-> ($past(operand_a) + $past(operand_b)) > 16'hFFFF\nendproperty\nassert_p_Overflow_Flag_Check:assert property (p_Overflow_Flag_Check) else $error(\"\");", "task_id": "1_6646", "predict_sva": "@(posedge sys_clk) disable iff (!sys_rst_n)     overflow_flag == 1'b1 |-> ($past(operand_a) + $past(operand_b)) > 16'hFFFF"}
{"sva": "@(posedge clk_magnetometer) disable iff(!magnetometer_ready) spacecraft_magnetic_field_sensor |-> ($past(three_axis_measurement[23:0], 1) && $past(calibration_matrix[31:0], 1) && $past(magnetic_torquer_control[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_spacecraft_magnetic_field_sensor  \n**Trigger Condition**: At every rising edge of the `clk_magnetometer`  \n**Disable Condition**: disable iff (`!magnetometer_ready`)  \n**Antecedent (LHS of Implication)**: `spacecraft_magnetic_field_sensor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(three_axis_measurement[23:0], 1) && $past(calibration_matrix[31:0], 1) && $past(magnetic_torquer_control[7:0], 1))`  ", "sva_signals": ["clk_magnetometer", "magnetometer_ready", "spacecraft_magnetic_field_sensor", "[23:0] three_axis_measurement", "[31:0] calibration_matrix", "[7:0] magnetic_torquer_control"], "clock": "clk_magnetometer", "attempts_left": 10, "sva_result": "@(posedge clk_magnetometer) disable iff (!magnetometer_ready)     spacecraft_magnetic_field_sensor |->          ($past(three_axis_measurement[23:0], 1) &&           $past(calibration_matrix[31:0], 1) &&           $past(magnetic_torquer_control[7:0], 1))", "sva_name": "p_spacecraft_magnetic_field_sensor", "id": "2636", "full_property": "property p_spacecraft_magnetic_field_sensor;\n@(posedge clk_magnetometer) disable iff (!magnetometer_ready)     spacecraft_magnetic_field_sensor |->          ($past(three_axis_measurement[23:0], 1) &&           $past(calibration_matrix[31:0], 1) &&           $past(magnetic_torquer_control[7:0], 1))\nendproperty\nassert_p_spacecraft_magnetic_field_sensor:assert property (p_spacecraft_magnetic_field_sensor) else $error(\"\");", "task_id": "1_6308", "predict_sva": "@(posedge clk_magnetometer) disable iff (!magnetometer_ready)     spacecraft_magnetic_field_sensor |->          ($past(three_axis_measurement[23:0], 1) &&           $past(calibration_matrix[31:0], 1) &&           $past(magnetic_torquer_control[7:0], 1))"}
{"sva": "@(posedge clk_cpu) disable iff(cpu_halt) cache_miss |-> $past(cache_access) && !$past(tag_hit)", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_miss_condition  \n**Trigger Condition**: At every rising edge of the `clk_cpu`  \n**Disable Condition**: `disable iff (cpu_halt)`  \n**Antecedent (LHS of Implication)**: `cache_miss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cache_access) && !$past(tag_hit)`  ", "sva_signals": ["clk_cpu", "[0:0] cpu_halt", "[0:0] cache_miss", "[0:0] cache_access", "[0:0] tag_hit"], "clock": "clk_cpu", "attempts_left": 10, "sva_result": "@(posedge clk_cpu) disable iff (cpu_halt)     cache_miss == 1'b1 |-> $past(cache_access) && !$past(tag_hit)", "sva_name": "p_cache_miss_check", "id": "3087", "full_property": "property p_cache_miss_condition;\n@(posedge clk_cpu) disable iff (cpu_halt)     cache_miss == 1'b1 |-> $past(cache_access) && !$past(tag_hit)\nendproperty\nassert_p_cache_miss_condition:assert property (p_cache_miss_condition) else $error(\"\");", "task_id": "1_6695", "predict_sva": "@(posedge clk_cpu) disable iff (cpu_halt)     cache_miss == 1'b1 |-> $past(cache_access) && !$past(tag_hit)"}
{"sva": "@(posedge clk) disable iff(thermopneumatic) thermopneumatic_microactuator |-> ($past(thermal_expansion_coefficient[7:0], 1) && $past(working_fluid_pressure[11:0], 1) && $past(membrane_deflection[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_thermopneumatic_microactuator  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (thermopneumatic)`  \n**Antecedent (LHS of Implication)**: `thermopneumatic_microactuator`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(thermal_expansion_coefficient[7:0], 1) && $past(working_fluid_pressure[11:0], 1) && $past(membrane_deflection[15:0], 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] thermopneumatic", "[0:0] thermopneumatic_microactuator", "[7:0] thermal_expansion_coefficient", "[11:0] working_fluid_pressure", "[15:0] membrane_deflection"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (thermopneumatic)     thermopneumatic_microactuator |->      ($past(thermal_expansion_coefficient[7:0], 1) &&       $past(working_fluid_pressure[11:0], 1) &&       $past(membrane_deflection[15:0], 1))", "sva_name": "p_thermopneumatic_microactuator_check", "id": "2533", "full_property": "property p_thermopneumatic_microactuator;\n@(posedge clk) disable iff (thermopneumatic)     thermopneumatic_microactuator |->      ($past(thermal_expansion_coefficient[7:0], 1) &&       $past(working_fluid_pressure[11:0], 1) &&       $past(membrane_deflection[15:0], 1))\nendproperty\nassert_p_thermopneumatic_microactuator:assert property (p_thermopneumatic_microactuator) else $error(\"\");", "task_id": "1_6222", "predict_sva": "@(posedge clk) disable iff (thermopneumatic)     thermopneumatic_microactuator |->          ($past(thermal_expansion_coefficient[7:0], 1) &&           $past(working_fluid_pressure[11:0], 1) &&           $past(membrane_deflection[15:0], 1))"}
{"sva": "@(posedge clk_fabric) disable iff(fabric_reset) routing_table_update |-> $past(topology_change) && $past(convergence_timer, 5)", "sva_description": "### Assertion description:  \n**Property Name**: p_Routing_Table_Update  \n**Trigger Condition**: At every rising edge of the `clk_fabric`  \n**Disable Condition**: `disable iff (fabric_reset)`  \n**Antecedent (LHS of Implication)**: `routing_table_update == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(topology_change) && $past(convergence_timer, 5)`  ", "sva_signals": ["clk_fabric", "fabric_reset", "[0:0] routing_table_update", "[0:0] topology_change", "[0:0] convergence_timer"], "clock": "clk_fabric", "attempts_left": 10, "sva_result": "@(posedge clk_fabric) disable iff (fabric_reset)     routing_table_update == 1'b1 |-> $past(topology_change) && $past(convergence_timer, 5)", "sva_name": "p_routing_table_update", "id": "3112", "full_property": "property p_Routing_Table_Update;\n@(posedge clk_fabric) disable iff (fabric_reset)     routing_table_update == 1'b1 |-> $past(topology_change) && $past(convergence_timer, 5)\nendproperty\nassert_p_Routing_Table_Update:assert property (p_Routing_Table_Update) else $error(\"\");", "task_id": "1_6717", "predict_sva": "@(posedge clk_fabric) disable iff (fabric_reset)     routing_table_update |-> ($past(topology_change) && $past(convergence_timer, 5))"}
{"sva": "@(negedge clock_ref) queue_overflow |-> $past(enqueue_req) && !$past(dequeue_ack)", "sva_description": "### Assertion description:  \n**Property Name**: p_queue_overflow_check  \n**Trigger Condition**: At every falling edge of the `clock_ref`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `queue_overflow == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(enqueue_req) && !$past(dequeue_ack)`  ", "sva_signals": ["clock_ref", "[0:0] queue_overflow", "[0:0] enqueue_req", "[0:0] dequeue_ack"], "clock": "clock_ref", "attempts_left": 10, "sva_result": "@(negedge clock_ref)     queue_overflow == 1'b1 |-> $past(enqueue_req) && !$past(dequeue_ack)", "sva_name": "p_queue_overflow_check", "id": "3099", "full_property": "property p_queue_overflow_check;\n@(negedge clock_ref)     queue_overflow == 1'b1 |-> $past(enqueue_req) && !$past(dequeue_ack)\nendproperty\nassert_p_queue_overflow_check:assert property (p_queue_overflow_check) else $error(\"\");", "task_id": "1_6706", "predict_sva": "@(negedge clock_ref)     queue_overflow == 1'b1 |-> $past(enqueue_req) && !$past(dequeue_ack)"}
{"sva": "@(posedge clk_turbo_decoder) disable iff(decoder_reset) iteration_limit_exceeded |-> $past(decoding_iterations) >= max_turbo_iterations && !$past(convergence_achieved)", "sva_description": "### Assertion description:  \n**Property Name**: p_IterationLimitExceeded  \n**Trigger Condition**: At every rising edge of the `clk_turbo_decoder`  \n**Disable Condition**: `disable iff (decoder_reset)`  \n**Antecedent (LHS of Implication)**: `iteration_limit_exceeded == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(decoding_iterations) >= max_turbo_iterations && !$past(convergence_achieved)`  ", "sva_signals": ["clk_turbo_decoder", "decoder_reset", "[0:0] iteration_limit_exceeded", "[0:0] decoding_iterations", "[0:0] max_turbo_iterations", "[0:0] convergence_achieved"], "clock": "clk_turbo_decoder", "attempts_left": 10, "sva_result": "@(posedge clk_turbo_decoder) disable iff (decoder_reset)         iteration_limit_exceeded == 1'b1 |->         $past(decoding_iterations) >= max_turbo_iterations && !$past(convergence_achieved)", "sva_name": "p_iteration_limit_exceeded", "id": "3239", "full_property": "property p_IterationLimitExceeded;\n@(posedge clk_turbo_decoder) disable iff (decoder_reset)         iteration_limit_exceeded == 1'b1 |->         $past(decoding_iterations) >= max_turbo_iterations && !$past(convergence_achieved)\nendproperty\nassert_p_IterationLimitExceeded:assert property (p_IterationLimitExceeded) else $error(\"\");", "task_id": "1_6833", "predict_sva": "@(posedge clk_turbo_decoder) disable iff (decoder_reset)     iteration_limit_exceeded == 1'b1 |->      $past(decoding_iterations) >= max_turbo_iterations && !$past(convergence_achieved)"}
{"sva": "@(posedge clk) disable iff(environmental_geology) contamination_plume_monitoring |-> ($past(contaminant_concentration[15:0], 1) && $past(migration_pathway[11:0], 1) && $past(remediation_effectiveness[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_contamination_plume_monitoring  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (environmental_geology)`  \n**Antecedent (LHS of Implication)**: `contamination_plume_monitoring == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(contaminant_concentration[15:0], 1) && $past(migration_pathway[11:0], 1) && $past(remediation_effectiveness[7:0], 1))`  ", "sva_signals": ["clk", "environmental_geology", "[0:0] contamination_plume_monitoring", "[15:0] contaminant_concentration", "[11:0] migration_pathway", "[7:0] remediation_effectiveness"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (environmental_geology)     contamination_plume_monitoring == 1'b1 |->     ($past(contaminant_concentration[15:0], 1) &&       $past(migration_pathway[11:0], 1) &&       $past(remediation_effectiveness[7:0], 1))", "sva_name": "p_Contamination_Plume_Monitoring", "id": "2784", "full_property": "property p_contamination_plume_monitoring;\n@(posedge clk) disable iff (environmental_geology)     contamination_plume_monitoring == 1'b1 |->     ($past(contaminant_concentration[15:0], 1) &&       $past(migration_pathway[11:0], 1) &&       $past(remediation_effectiveness[7:0], 1))\nendproperty\nassert_p_contamination_plume_monitoring:assert property (p_contamination_plume_monitoring) else $error(\"\");", "task_id": "1_6434", "predict_sva": "@(posedge clk) disable iff (environmental_geology)     contamination_plume_monitoring == 1'b1 |->      ($past(contaminant_concentration[15:0], 1) &&       $past(migration_pathway[11:0], 1) &&       $past(remediation_effectiveness[7:0], 1))"}
{"sva": "@(posedge clk) disable iff(debug_halt) stack_overflow |-> ($past(stack_pointer) > stack_base) && (stack_pointer < stack_base)", "sva_description": "### Assertion description:  \n**Property Name**: p_stack_overflow_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (debug_halt)`  \n**Antecedent (LHS of Implication)**: `stack_overflow == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(stack_pointer) > stack_base) && (stack_pointer < stack_base)`  ", "sva_signals": ["clk", "[0:0] debug_halt", "[0:0] stack_overflow", "stack_pointer", "stack_base"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (debug_halt)         stack_overflow == 1'b1 |-> ($past(stack_pointer) > stack_base) && (stack_pointer < stack_base)", "sva_name": "p_stack_overflow_wrap_around", "id": "3094", "full_property": "property p_stack_overflow_check;\n@(posedge clk) disable iff (debug_halt)         stack_overflow == 1'b1 |-> ($past(stack_pointer) > stack_base) && (stack_pointer < stack_base)\nendproperty\nassert_p_stack_overflow_check:assert property (p_stack_overflow_check) else $error(\"\");", "task_id": "1_6702", "predict_sva": "@(posedge clk) disable iff (debug_halt)     stack_overflow == 1'b1 |-> $past(stack_pointer) > stack_base && stack_pointer < stack_base"}
{"sva": "@(posedge clk_secondary_ion) disable iff(!sims_rst_n) secondary_ion_mass_spectrometry |-> ($past(primary_ion_beam[15:0], 1) && $past(sputtering_yield[11:0], 1) && $past(surface_analysis[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_secondary_ion_mass_spectrometry  \n**Trigger Condition**: At every rising edge of the `clk_secondary_ion`  \n**Disable Condition**: `disable iff (!sims_rst_n)`  \n**Antecedent (LHS of Implication)**: `secondary_ion_mass_spectrometry == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(primary_ion_beam[15:0], 1) && $past(sputtering_yield[11:0], 1) && $past(surface_analysis[31:0], 1))`  ", "sva_signals": ["clk_secondary_ion", "sims_rst_n", "[0:0] secondary_ion_mass_spectrometry", "[15:0] primary_ion_beam", "[11:0] sputtering_yield", "[31:0] surface_analysis"], "clock": "clk_secondary_ion", "attempts_left": 10, "sva_result": "@(posedge clk_secondary_ion) disable iff (!sims_rst_n)     secondary_ion_mass_spectrometry == 1'b1 |->      ($past(primary_ion_beam[15:0], 1) && $past(sputtering_yield[11:0], 1) && $past(surface_analysis[31:0], 1))", "sva_name": "p_secondary_ion_mass_spectrometry", "id": "2839", "full_property": "property p_secondary_ion_mass_spectrometry;\n@(posedge clk_secondary_ion) disable iff (!sims_rst_n)     secondary_ion_mass_spectrometry == 1'b1 |->      ($past(primary_ion_beam[15:0], 1) && $past(sputtering_yield[11:0], 1) && $past(surface_analysis[31:0], 1))\nendproperty\nassert_p_secondary_ion_mass_spectrometry:assert property (p_secondary_ion_mass_spectrometry) else $error(\"\");", "task_id": "1_6483", "predict_sva": "@(posedge clk_secondary_ion) disable iff (!sims_rst_n)     secondary_ion_mass_spectrometry == 1'b1 |->      ($past(primary_ion_beam[15:0], 1) && $past(sputtering_yield[11:0], 1) && $past(surface_analysis[31:0], 1))"}
{"sva": "@(posedge clk_gc_ms) disable iff(!gas_chromatography_ms_rst_n) gas_chromatography_mass_spectrometer |-> ($past(molecular_ion_peak[15:0], 1) && $past(fragmentation_pattern[31:0], 1) && $past(library_search_match[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_gas_chromatography_mass_spectrometer  \n**Trigger Condition**: At every rising edge of the `clk_gc_ms`  \n**Disable Condition**: disable iff `(!gas_chromatography_ms_rst_n)`  \n**Antecedent (LHS of Implication)**: `gas_chromatography_mass_spectrometer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(molecular_ion_peak[15:0], 1) && $past(fragmentation_pattern[31:0], 1) && $past(library_search_match[11:0], 1))`  \n\n", "sva_signals": ["clk_gc_ms", "gas_chromatography_ms_rst_n", "[0:0] gas_chromatography_mass_spectrometer", "[15:0] molecular_ion_peak", "[31:0] fragmentation_pattern", "[11:0] library_search_match"], "clock": "clk_gc_ms", "attempts_left": 10, "sva_result": "@(posedge clk_gc_ms) disable iff (!gas_chromatography_ms_rst_n)     gas_chromatography_mass_spectrometer |->      ($past(molecular_ion_peak[15:0], 1) &&       $past(fragmentation_pattern[31:0], 1) &&       $past(library_search_match[11:0], 1))", "sva_name": "p_gas_chromatography_mass_spectrometer", "id": "2818", "full_property": "property p_gas_chromatography_mass_spectrometer;\n@(posedge clk_gc_ms) disable iff (!gas_chromatography_ms_rst_n)     gas_chromatography_mass_spectrometer |->      ($past(molecular_ion_peak[15:0], 1) &&       $past(fragmentation_pattern[31:0], 1) &&       $past(library_search_match[11:0], 1))\nendproperty\nassert_p_gas_chromatography_mass_spectrometer:assert property (p_gas_chromatography_mass_spectrometer) else $error(\"\");", "task_id": "1_6465", "predict_sva": "@(posedge clk_gc_ms) disable iff (!gas_chromatography_ms_rst_n)     gas_chromatography_mass_spectrometer |->          ($past(molecular_ion_peak[15:0], 1) &&           $past(fragmentation_pattern[31:0], 1) &&           $past(library_search_match[11:0], 1))"}
{"sva": "@(posedge clk_ethernet) disable iff(eth_reset) collision_detect |-> $past(tx_enable) && $past(rx_carrier_sense)", "sva_description": "### Assertion description:  \n**Property Name**: p_Collision_Detect  \n**Trigger Condition**: At every rising edge of the `clk_ethernet`  \n**Disable Condition**: `disable iff (eth_reset)`  \n**Antecedent (LHS of Implication)**: `collision_detect == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tx_enable) && $past(rx_carrier_sense)`  ", "sva_signals": ["clk_ethernet", "eth_reset", "[0:0] collision_detect", "[0:0] tx_enable", "[0:0] rx_carrier_sense"], "clock": "clk_ethernet", "attempts_left": 10, "sva_result": "@(posedge clk_ethernet) disable iff (eth_reset)     collision_detect == 1'b1 |-> $past(tx_enable) && $past(rx_carrier_sense)", "sva_name": "p_Collision_Detect_Check", "id": "3091", "full_property": "property p_Collision_Detect;\n@(posedge clk_ethernet) disable iff (eth_reset)     collision_detect == 1'b1 |-> $past(tx_enable) && $past(rx_carrier_sense)\nendproperty\nassert_p_Collision_Detect:assert property (p_Collision_Detect) else $error(\"\");", "task_id": "1_6699", "predict_sva": "@(posedge clk_ethernet) disable iff (eth_reset)     collision_detect == 1'b1 |-> $past(tx_enable & rx_carrier_sense, 1)"}
{"sva": "@(negedge clk_gastric_stimulator) disable iff(!gastric_pacemaker_enable) gastric_electrical_stimulation |-> $past(gastric_motility[15:0] & electrical_pulse_pattern[11:0] & weight_loss_efficacy, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_gastric_electrical_stimulation  \n**Trigger Condition**: At every falling edge of `clk_gastric_stimulator`  \n**Disable Condition**: `disable iff (!gastric_pacemaker_enable)`  \n**Antecedent (LHS of Implication)**: `gastric_electrical_stimulation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(gastric_motility[15:0] & electrical_pulse_pattern[11:0] & weight_loss_efficacy, 1)`  ", "sva_signals": ["clk_gastric_stimulator", "gastric_pacemaker_enable", "gastric_electrical_stimulation", "[15:0] gastric_motility", "[11:0] electrical_pulse_pattern", "[15:0] weight_loss_efficacy"], "clock": "clk_gastric_stimulator", "attempts_left": 10, "sva_result": "disable iff (!gastric_pacemaker_enable)     @(negedge clk_gastric_stimulator)     gastric_electrical_stimulation |->          $past(gastric_motility[15:0] & electrical_pulse_pattern[11:0] & weight_loss_efficacy, 1)", "sva_name": "p_Gastric_Stimulator_Check", "id": "2947", "full_property": "property p_gastric_electrical_stimulation;\ndisable iff (!gastric_pacemaker_enable)     @(negedge clk_gastric_stimulator)     gastric_electrical_stimulation |->          $past(gastric_motility[15:0] & electrical_pulse_pattern[11:0] & weight_loss_efficacy, 1)\nendproperty\nassert_p_gastric_electrical_stimulation:assert property (p_gastric_electrical_stimulation) else $error(\"\");", "task_id": "1_6570", "predict_sva": "@(negedge clk_gastric_stimulator) disable iff (!gastric_pacemaker_enable)     gastric_electrical_stimulation |-> $past(gastric_motility[15:0] & electrical_pulse_pattern[11:0] & weight_loss_efficacy, 1)"}
{"sva": "@(posedge clk_liposome) disable iff(!liposomal_ready) liposomal_drug_formulation |-> ($past(lipid_bilayer_stability[15:0], 1) && $past(drug_loading_capacity[11:0], 1) && $past(membrane_permeability[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_liposomal_drug_formulation  \n**Trigger Condition**: At every rising edge of the `clk_liposome`  \n**Disable Condition**: disable iff (`!liposomal_ready`)  \n**Antecedent (LHS of Implication)**: `liposomal_drug_formulation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(lipid_bilayer_stability[15:0], 1) && $past(drug_loading_capacity[11:0], 1) && $past(membrane_permeability[31:0], 1))`  ", "sva_signals": ["clk_liposome", "liposomal_ready", "liposomal_drug_formulation", "[15:0] lipid_bilayer_stability", "[11:0] drug_loading_capacity", "[31:0] membrane_permeability"], "clock": "clk_liposome", "attempts_left": 10, "sva_result": "@(posedge clk_liposome) disable iff (!liposomal_ready)     liposomal_drug_formulation == 1'b1 |->     ($past(lipid_bilayer_stability[15:0], 1) &&       $past(drug_loading_capacity[11:0], 1) &&       $past(membrane_permeability[31:0], 1))", "sva_name": "p_liposomal_drug_formulation", "id": "2963", "full_property": "property p_liposomal_drug_formulation;\n@(posedge clk_liposome) disable iff (!liposomal_ready)     liposomal_drug_formulation == 1'b1 |->     ($past(lipid_bilayer_stability[15:0], 1) &&       $past(drug_loading_capacity[11:0], 1) &&       $past(membrane_permeability[31:0], 1))\nendproperty\nassert_p_liposomal_drug_formulation:assert property (p_liposomal_drug_formulation) else $error(\"\");", "task_id": "1_6584", "predict_sva": "@(posedge clk_liposome) disable iff (!liposomal_ready)     liposomal_drug_formulation == 1'b1 |->      ($past(lipid_bilayer_stability[15:0], 1) &&       $past(drug_loading_capacity[11:0], 1) &&       $past(membrane_permeability[31:0], 1))"}
{"sva": "@(negedge clk_viterbi) disable iff(viterbi_reset) path_metric_overflow |-> ($past(accumulated_metric) + $past(branch_metric)) > metric_saturation_level", "sva_description": "### Assertion description:  \n**Property Name**: p_path_metric_overflow_check  \n**Trigger Condition**: At every falling edge of `clk_viterbi`  \n**Disable Condition**: `disable iff (viterbi_reset)`  \n**Antecedent (LHS of Implication)**: `path_metric_overflow == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(accumulated_metric) + $past(branch_metric)) > metric_saturation_level`  \n\n", "sva_signals": ["clk_viterbi", "viterbi_reset", "path_metric_overflow", "accumulated_metric", "branch_metric", "metric_saturation_level"], "clock": "clk_viterbi", "attempts_left": 10, "sva_result": "@(negedge clk_viterbi) disable iff (viterbi_reset)     path_metric_overflow == 1'b1 |->      ($past(accumulated_metric) + $past(branch_metric)) > metric_saturation_level", "sva_name": "p_path_metric_overflow_check", "id": "3250", "full_property": "property p_path_metric_overflow_check;\n@(negedge clk_viterbi) disable iff (viterbi_reset)     path_metric_overflow == 1'b1 |->      ($past(accumulated_metric) + $past(branch_metric)) > metric_saturation_level\nendproperty\nassert_p_path_metric_overflow_check:assert property (p_path_metric_overflow_check) else $error(\"\");", "task_id": "1_6841", "predict_sva": "@(negedge clk_viterbi) disable iff (viterbi_reset)     path_metric_overflow == 1'b1 |->      ($past(accumulated_metric) + $past(branch_metric)) > metric_saturation_level"}
{"sva": "@(posedge clk) disable iff(redundancy_test) triple_modular_redundancy_fail |-> ($past(module_a_output) != $past(module_b_output)) && ($past(module_b_output) != $past(module_c_output))", "sva_description": "### Assertion description:  \n**Property Name**: p_Triple_Modular_Redundancy_Fail  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (redundancy_test)`  \n**Antecedent (LHS of Implication)**: `triple_modular_redundancy_fail == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(module_a_output) != $past(module_b_output)) && ($past(module_b_output) != $past(module_c_output))`  ", "sva_signals": ["clk", "[0:0] redundancy_test", "[0:0] triple_modular_redundancy_fail", "[0:0] module_a_output", "[0:0] module_b_output", "[0:0] module_c_output"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (redundancy_test)     triple_modular_redundancy_fail == 1'b1 |->      ($past(module_a_output) != $past(module_b_output)) &&      ($past(module_b_output) != $past(module_c_output))", "sva_name": "p_Triple_Modular_Redundancy_Fail", "id": "3170", "full_property": "property p_Triple_Modular_Redundancy_Fail;\n@(posedge clk) disable iff (redundancy_test)     triple_modular_redundancy_fail == 1'b1 |->      ($past(module_a_output) != $past(module_b_output)) &&      ($past(module_b_output) != $past(module_c_output))\nendproperty\nassert_p_Triple_Modular_Redundancy_Fail:assert property (p_Triple_Modular_Redundancy_Fail) else $error(\"\");", "task_id": "1_6769", "predict_sva": "@(posedge clk) disable iff (redundancy_test)     triple_modular_redundancy_fail == 1'b1 |->      ($past(module_a_output) != $past(module_b_output)) &&      ($past(module_b_output) != $past(module_c_output))"}
{"sva": "@(negedge clk_transmission) disable iff(park_engaged) torque_converter_lockup |-> $past(speed_ratio_optimal) && $past(transmission_temperature_ok) && !$past(acceleration_detected)", "sva_description": "### Assertion description:  \n**Property Name**: p_Torque_Converter_Lockup_Conditions  \n**Trigger Condition**: At every falling edge of the `clk_transmission`;  \n**Disable Condition**: `disable iff (park_engaged)`  \n**Antecedent (LHS of Implication)**: `torque_converter_lockup == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(speed_ratio_optimal) && $past(transmission_temperature_ok) && !$past(acceleration_detected)`  ", "sva_signals": ["clk_transmission", "park_engaged", "torque_converter_lockup", "speed_ratio_optimal", "transmission_temperature_ok", "acceleration_detected"], "clock": "clk_transmission", "attempts_left": 10, "sva_result": "@(negedge clk_transmission) disable iff (park_engaged)     torque_converter_lockup == 1'b1 |->      $past(speed_ratio_optimal) &&      $past(transmission_temperature_ok) &&      !$past(acceleration_detected)", "sva_name": "p_torque_converter_lockup", "id": "3269", "full_property": "property p_Torque_Converter_Lockup_Conditions;\n@(negedge clk_transmission) disable iff (park_engaged)     torque_converter_lockup == 1'b1 |->      $past(speed_ratio_optimal) &&      $past(transmission_temperature_ok) &&      !$past(acceleration_detected)\nendproperty\nassert_p_Torque_Converter_Lockup_Conditions:assert property (p_Torque_Converter_Lockup_Conditions) else $error(\"\");", "task_id": "1_6859", "predict_sva": "@(negedge clk_transmission) disable iff (park_engaged)     torque_converter_lockup == 1'b1 |->      $past(speed_ratio_optimal) && $past(transmission_temperature_ok) && !$past(acceleration_detected)"}
{"sva": "@(posedge clk) disable iff(performance_mode) cylinder_deactivation_strategy |-> ($past(engine_load) < deactivation_threshold) && !$past(cylinders_deactivated, 18)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cylinder_Deactivation_Strategy  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (performance_mode)`  \n**Antecedent (LHS of Implication)**: `cylinder_deactivation_strategy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(engine_load) < deactivation_threshold) && !$past(cylinders_deactivated, 18)`  ", "sva_signals": ["clk", "rst_n", "[0:0] performance_mode", "[0:0] cylinder_deactivation_strategy", "[15:0] engine_load", "[15:0] deactivation_threshold", "[0:0] cylinders_deactivated"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (performance_mode)     cylinder_deactivation_strategy == 1'b1 |->      ($past(engine_load) < deactivation_threshold) && !$past(cylinders_deactivated, 18)", "sva_name": "p_cylinder_deactivation_strategy", "id": "3284", "full_property": "property p_Cylinder_Deactivation_Strategy;\n@(posedge clk) disable iff (performance_mode)     cylinder_deactivation_strategy == 1'b1 |->      ($past(engine_load) < deactivation_threshold) && !$past(cylinders_deactivated, 18)\nendproperty\nassert_p_Cylinder_Deactivation_Strategy:assert property (p_Cylinder_Deactivation_Strategy) else $error(\"\");", "task_id": "1_6874", "predict_sva": "@(posedge clk) disable iff (performance_mode)     cylinder_deactivation_strategy == 1'b1 |->      ($past(engine_load) < deactivation_threshold) && !$past(cylinders_deactivated, 18)"}
{"sva": "@(posedge clk_tracer_test) disable iff(!tracer_study_ready) groundwater_tracer_experiment |-> ($past(tracer_concentration[15:0], 1) && $past(breakthrough_curve[31:0], 1) && $past(dispersion_coefficient[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Groundwater_Tracer_Experiment  \n**Trigger Condition**: At every rising edge of the `clk_tracer_test`  \n**Disable Condition**: disable iff `(!tracer_study_ready)`  \n**Antecedent (LHS of Implication)**: `groundwater_tracer_experiment == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(tracer_concentration[15:0], 1) && $past(breakthrough_curve[31:0], 1) && $past(dispersion_coefficient[11:0], 1))`  ", "sva_signals": ["clk_tracer_test", "tracer_study_ready", "[0:0] groundwater_tracer_experiment", "[15:0] tracer_concentration", "[31:0] breakthrough_curve", "[11:0] dispersion_coefficient"], "clock": "clk_tracer_test", "attempts_left": 10, "sva_result": "@(posedge clk_tracer_test) disable iff (!tracer_study_ready)     groundwater_tracer_experiment == 1'b1 |->      ($past(tracer_concentration[15:0], 1) &&       $past(breakthrough_curve[31:0], 1) &&       $past(dispersion_coefficient[11:0], 1))", "sva_name": "groundwater_tracer_experiment_check", "id": "2773", "full_property": "property p_Groundwater_Tracer_Experiment;\n@(posedge clk_tracer_test) disable iff (!tracer_study_ready)     groundwater_tracer_experiment == 1'b1 |->      ($past(tracer_concentration[15:0], 1) &&       $past(breakthrough_curve[31:0], 1) &&       $past(dispersion_coefficient[11:0], 1))\nendproperty\nassert_p_Groundwater_Tracer_Experiment:assert property (p_Groundwater_Tracer_Experiment) else $error(\"\");", "task_id": "1_6424", "predict_sva": "@(posedge clk_tracer_test) disable iff (!tracer_study_ready)     groundwater_tracer_experiment == 1'b1 |->      ($past(tracer_concentration[15:0], 1) &&       $past(breakthrough_curve[31:0], 1) &&       $past(dispersion_coefficient[11:0], 1))"}
{"sva": "@(posedge clk_engine) disable iff(engine_shutdown) fuel_injection_timing |-> ($past(crank_position) == injection_angle) && $past(throttle_position_valid)", "sva_description": "### Assertion description:  \n**Property Name**: p_Fuel_Injection_Timing  \n**Trigger Condition**: At every rising edge of the `clk_engine`  \n**Disable Condition**: `disable iff (engine_shutdown)`  \n**Antecedent (LHS of Implication)**: `fuel_injection_timing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(crank_position) == injection_angle) && $past(throttle_position_valid)`  \n\nThe assertion checks that whenever `fuel_injection_timing` is active (LHS), the crank position from the previous cycle (`$past(crank_position)`) must match the expected `injection_angle`, and the throttle position must have been valid in the previous cycle (`$past(throttle_position_valid)`). The check is disabled if `engine_shutdown` is asserted.", "sva_signals": ["clk_engine", "engine_shutdown", "fuel_injection_timing", "[15:0] crank_position", "[15:0] injection_angle", "throttle_position_valid"], "clock": "clk_engine", "attempts_left": 10, "sva_result": "@(posedge clk_engine) disable iff (engine_shutdown)     fuel_injection_timing |-> ($past(crank_position) == injection_angle) && $past(throttle_position_valid)", "sva_name": "p_Fuel_Injection_Timing", "id": "3226", "full_property": "property p_Fuel_Injection_Timing;\n@(posedge clk_engine) disable iff (engine_shutdown)     fuel_injection_timing |-> ($past(crank_position) == injection_angle) && $past(throttle_position_valid)\nendproperty\nassert_p_Fuel_Injection_Timing:assert property (p_Fuel_Injection_Timing) else $error(\"\");", "task_id": "1_6820", "predict_sva": "@(posedge clk_engine) disable iff (engine_shutdown)     fuel_injection_timing |-> ($past(crank_position) == injection_angle) && $past(throttle_position_valid)"}
{"sva": "@(negedge clk_navigation) disable iff(!gps_signal_valid) route_recalculation |-> $past(position_deviation) > route_tolerance && !$past(recalculation_in_progress, 20)", "sva_description": "### Assertion description:  \n**Property Name**: p_route_recalculation_conditions  \n**Trigger Condition**: At every falling edge of the `clk_navigation`  \n**Disable Condition**: disable iff (`!gps_signal_valid`)  \n**Antecedent (LHS of Implication)**: `route_recalculation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(position_deviation) > route_tolerance && !$past(recalculation_in_progress, 20)`  ", "sva_signals": ["clk_navigation", "gps_signal_valid", "[0:0] route_recalculation", "[0:0] position_deviation", "[0:0] route_tolerance", "[0:0] recalculation_in_progress"], "clock": "clk_navigation", "attempts_left": 10, "sva_result": "@(negedge clk_navigation) disable iff (!gps_signal_valid)     route_recalculation |->          ($past(position_deviation) > route_tolerance) &&          !$past(recalculation_in_progress, 20)", "sva_name": "p_Route_Recalculation_Condition", "id": "3286", "full_property": "property p_route_recalculation_conditions;\n@(negedge clk_navigation) disable iff (!gps_signal_valid)     route_recalculation |->          ($past(position_deviation) > route_tolerance) &&          !$past(recalculation_in_progress, 20)\nendproperty\nassert_p_route_recalculation_conditions:assert property (p_route_recalculation_conditions) else $error(\"\");", "task_id": "1_6876", "predict_sva": "@(negedge clk_navigation) disable iff (!gps_signal_valid)     route_recalculation |-> ($past(position_deviation) > route_tolerance) && !$past(recalculation_in_progress, 20)"}
{"sva": "@(negedge clk_Manchester) disable iff(!Manchester_decoder_on) bit_synchronization_lost |-> $past(edge_transition_expected) && !$past(edge_detected) && $past(bit_period_elapsed)", "sva_description": "### Assertion description:  \n**Property Name**: p_bit_synchronization_lost  \n**Trigger Condition**: At every falling edge of the `clk_Manchester`  \n**Disable Condition**: disable iff (`!Manchester_decoder_on`)  \n**Antecedent (LHS of Implication)**: `bit_synchronization_lost == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(edge_transition_expected) && !$past(edge_detected) && $past(bit_period_elapsed)`  ", "sva_signals": ["clk", "Manchester_decoder_on", "bit_synchronization_lost", "edge_transition_expected", "edge_detected", "bit_period_elapsed", "clk_Manchester"], "clock": "clk_Manchester", "attempts_left": 10, "sva_result": "@(negedge clk_Manchester) disable iff (!Manchester_decoder_on)     bit_synchronization_lost == 1'b1 |->         $past(edge_transition_expected) &&          !$past(edge_detected) &&          $past(bit_period_elapsed)", "sva_name": "p_Bit_Sync_Lost_Condition", "id": "3210", "full_property": "property p_bit_synchronization_lost;\n@(negedge clk_Manchester) disable iff (!Manchester_decoder_on)     bit_synchronization_lost == 1'b1 |->         $past(edge_transition_expected) &&          !$past(edge_detected) &&          $past(bit_period_elapsed)\nendproperty\nassert_p_bit_synchronization_lost:assert property (p_bit_synchronization_lost) else $error(\"\");", "task_id": "1_6804", "predict_sva": "@(negedge clk_Manchester) disable iff (!Manchester_decoder_on)     bit_synchronization_lost == 1'b1 |->      $past(edge_transition_expected) && !$past(edge_detected) && $past(bit_period_elapsed)"}
{"sva": "@(posedge clk) disable iff(decommissioning_phase) reactor_vessel_surveillance |-> $past(neutron_fluence_accumulated) > vessel_lifetime_limit && !$past(inspection_scheduled)", "sva_description": "### Assertion description:  \n**Property Name**: p_Reactor_Vessel_Surveillance  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (decommissioning_phase)`  \n**Antecedent (LHS of Implication)**: `reactor_vessel_surveillance == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(neutron_fluence_accumulated) > vessel_lifetime_limit && !$past(inspection_scheduled)`  ", "sva_signals": ["clk", "[0:0] decommissioning_phase", "[0:0] reactor_vessel_surveillance", "[0:0] inspection_scheduled", "[0:0] neutron_fluence_accumulated", "[0:0] vessel_lifetime_limit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (decommissioning_phase)     reactor_vessel_surveillance == 1'b1 |->      $past(neutron_fluence_accumulated) > vessel_lifetime_limit && !$past(inspection_scheduled)", "sva_name": "p_Reactor_Vessel_Surveillance", "id": "3308", "full_property": "property p_Reactor_Vessel_Surveillance;\n@(posedge clk) disable iff (decommissioning_phase)     reactor_vessel_surveillance == 1'b1 |->      $past(neutron_fluence_accumulated) > vessel_lifetime_limit && !$past(inspection_scheduled)\nendproperty\nassert_p_Reactor_Vessel_Surveillance:assert property (p_Reactor_Vessel_Surveillance) else $error(\"\");", "task_id": "1_6896", "predict_sva": "@(posedge clk) disable iff (decommissioning_phase)     reactor_vessel_surveillance == 1'b1 |->      $past(neutron_fluence_accumulated) > vessel_lifetime_limit && !$past(inspection_scheduled)"}
{"sva": "@(posedge clk) disable iff(emulation_pause) memory_consistency_violation |-> $past(write_operation_a) && $past(write_operation_b) && ($past(memory_ordering) != sequential_consistency)", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_consistency_violation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (emulation_pause)`  \n**Antecedent (LHS of Implication)**: `memory_consistency_violation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(write_operation_a) && $past(write_operation_b) && ($past(memory_ordering) != sequential_consistency)`  ", "sva_signals": ["clk", "[0:0] emulation_pause", "[0:0] memory_consistency_violation", "[0:0] write_operation_a", "[0:0] write_operation_b", "[0:0] memory_ordering", "[0:0] sequential_consistency"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (emulation_pause)     memory_consistency_violation |->          $past(write_operation_a) &&          $past(write_operation_b) &&          ($past(memory_ordering) != sequential_consistency)", "sva_name": "p_memory_consistency_violation_check", "id": "3246", "full_property": "property p_memory_consistency_violation;\n@(posedge clk) disable iff (emulation_pause)     memory_consistency_violation |->          $past(write_operation_a) &&          $past(write_operation_b) &&          ($past(memory_ordering) != sequential_consistency)\nendproperty\nassert_p_memory_consistency_violation:assert property (p_memory_consistency_violation) else $error(\"\");", "task_id": "1_6837", "predict_sva": "@(posedge clk) disable iff (emulation_pause)     memory_consistency_violation |->          $past(write_operation_a) &&          $past(write_operation_b) &&          ($past(memory_ordering) != sequential_consistency)"}
{"sva": "@(negedge clock_orbit) attitude_control_thruster_fire |-> $past(gyroscope_drift_detected) && ($past(thruster_burn_duration) > max_burn_time)", "sva_description": "### Assertion description:  \n**Property Name**: p_Attitude_Control_Thruster_Fire  \n**Trigger Condition**: At every falling edge of `clock_orbit`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `attitude_control_thruster_fire == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(gyroscope_drift_detected) && ($past(thruster_burn_duration) > max_burn_time)`  ", "sva_signals": ["clock_orbit", "[0:0] attitude_control_thruster_fire", "[0:0] gyroscope_drift_detected", "[0:0] thruster_burn_duration", "[0:0] max_burn_time"], "clock": "clock_orbit", "attempts_left": 10, "sva_result": "@(negedge clock_orbit)     attitude_control_thruster_fire == 1'b1 |->         $past(gyroscope_drift_detected) && ($past(thruster_burn_duration) > max_burn_time)", "sva_name": "p_Attitude_Control_Thruster_Fire", "id": "3346", "full_property": "property p_Attitude_Control_Thruster_Fire;\n@(negedge clock_orbit)     attitude_control_thruster_fire == 1'b1 |->         $past(gyroscope_drift_detected) && ($past(thruster_burn_duration) > max_burn_time)\nendproperty\nassert_p_Attitude_Control_Thruster_Fire:assert property (p_Attitude_Control_Thruster_Fire) else $error(\"\");", "task_id": "1_6934", "predict_sva": "@(negedge clock_orbit)     attitude_control_thruster_fire == 1'b1 |->      $past(gyroscope_drift_detected) && ($past(thruster_burn_duration) > max_burn_time)"}
{"sva": "@(posedge clk_turbulence) disable iff(!plasma_turbulence_ready) plasma_turbulence_simulation |-> ($past(drift_wave_turbulence[31:0], 1) && $past(anomalous_transport[15:0], 1) && $past(zonal_flow_generation[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_plasma_turbulence_simulation  \n**Trigger Condition**: At every rising edge of the `clk_turbulence`  \n**Disable Condition**: disable iff (`!plasma_turbulence_ready`)  \n**Antecedent (LHS of Implication)**: `plasma_turbulence_simulation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(drift_wave_turbulence[31:0], 1) && $past(anomalous_transport[15:0], 1) && $past(zonal_flow_generation[11:0], 1))`  ", "sva_signals": ["clk_turbulence", "plasma_turbulence_ready", "[0:0] plasma_turbulence_simulation", "[31:0] drift_wave_turbulence", "[15:0] anomalous_transport", "[11:0] zonal_flow_generation"], "clock": "clk_turbulence", "attempts_left": 10, "sva_result": "@(posedge clk_turbulence) disable iff (!plasma_turbulence_ready)     plasma_turbulence_simulation == 1'b1 |->      ($past(drift_wave_turbulence[31:0], 1) && $past(anomalous_transport[15:0], 1) && $past(zonal_flow_generation[11:0], 1))", "sva_name": "p_plasma_turbulence_simulation", "id": "2857", "full_property": "property p_plasma_turbulence_simulation;\n@(posedge clk_turbulence) disable iff (!plasma_turbulence_ready)     plasma_turbulence_simulation == 1'b1 |->      ($past(drift_wave_turbulence[31:0], 1) && $past(anomalous_transport[15:0], 1) && $past(zonal_flow_generation[11:0], 1))\nendproperty\nassert_p_plasma_turbulence_simulation:assert property (p_plasma_turbulence_simulation) else $error(\"\");", "task_id": "1_6495", "predict_sva": "@(posedge clk_turbulence) disable iff (!plasma_turbulence_ready)     plasma_turbulence_simulation == 1'b1 |->      ($past(drift_wave_turbulence[31:0], 1) &&       $past(anomalous_transport[15:0], 1) &&       $past(zonal_flow_generation[11:0], 1))"}
{"sva": "@(posedge clk) disable iff(simulator_training_mode) g_force_limitation_system |-> ($past(pilot_g_load) > physiological_limit) && !$past(g_suit_inflation_activated, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_g_force_limitation_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (simulator_training_mode)`  \n**Antecedent (LHS of Implication)**: `g_force_limitation_system == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(pilot_g_load) > physiological_limit) && !$past(g_suit_inflation_activated, 2)`  ", "sva_signals": ["clk", "simulator_training_mode", "g_force_limitation_system", "[0:0] physiological_limit", "[0:0] g_suit_inflation_activated", "pilot_g_load"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (simulator_training_mode)     g_force_limitation_system == 1'b1 |->          ($past(pilot_g_load) > physiological_limit) && !$past(g_suit_inflation_activated, 2)", "sva_name": "p_G_Force_Limitation_System", "id": "3423", "full_property": "property p_g_force_limitation_check;\n@(posedge clk) disable iff (simulator_training_mode)     g_force_limitation_system == 1'b1 |->          ($past(pilot_g_load) > physiological_limit) && !$past(g_suit_inflation_activated, 2)\nendproperty\nassert_p_g_force_limitation_check:assert property (p_g_force_limitation_check) else $error(\"\");", "task_id": "1_7008", "predict_sva": "@(posedge clk) disable iff (simulator_training_mode)     g_force_limitation_system == 1'b1 |->      $past(pilot_g_load) > physiological_limit && !$past(g_suit_inflation_activated, 2)"}
{"sva": "@(negedge clk_missile_warning) disable iff(threat_warning_system_off) defensive_maneuvering_cues |-> $past(surface_to_air_missile_launch_detected) && ($past(recommended_evasive_action) == no_recommendation_generated)", "sva_description": "### Assertion description:  \n**Property Name**: p_defensive_maneuvering_cues  \n**Trigger Condition**: At every falling edge of the `clk_missile_warning`  \n**Disable Condition**: disable iff (`threat_warning_system_off`)  \n**Antecedent (LHS of Implication)**: `defensive_maneuvering_cues`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(surface_to_air_missile_launch_detected) && ($past(recommended_evasive_action) == no_recommendation_generated)`", "sva_signals": ["clk_missile_warning", "threat_warning_system_off", "[0:0] defensive_maneuvering_cues", "[0:0] surface_to_air_missile_launch_detected", "[0:0] recommended_evasive_action", "[0:0] no_recommendation_generated"], "clock": "clk_missile_warning", "attempts_left": 10, "sva_result": "@(negedge clk_missile_warning) disable iff (threat_warning_system_off)     defensive_maneuvering_cues |->          $past(surface_to_air_missile_launch_detected) &&          ($past(recommended_evasive_action) == no_recommendation_generated)", "sva_name": "p_defensive_maneuvering_cues", "id": "3435", "full_property": "property p_defensive_maneuvering_cues;\n@(negedge clk_missile_warning) disable iff (threat_warning_system_off)     defensive_maneuvering_cues |->          $past(surface_to_air_missile_launch_detected) &&          ($past(recommended_evasive_action) == no_recommendation_generated)\nendproperty\nassert_p_defensive_maneuvering_cues:assert property (p_defensive_maneuvering_cues) else $error(\"\");", "task_id": "1_7020", "predict_sva": "@(negedge clk_missile_warning) disable iff (threat_warning_system_off)     defensive_maneuvering_cues |->          $past(surface_to_air_missile_launch_detected) &&          ($past(recommended_evasive_action) == no_recommendation_generated)"}
{"sva": "@(posedge clk) disable iff(calibration_mode) temperature_compensation_drift |-> ($past(ambient_temperature) - $past(reference_temperature, 10)) > compensation_range", "sva_description": "### Assertion description:  \n**Property Name**: p_temperature_compensation_drift  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`calibration_mode`)  \n**Antecedent (LHS of Implication)**: `temperature_compensation_drift == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`$past(ambient_temperature) - $past(reference_temperature, 10)) > compensation_range`  \n\nThe assertion checks that whenever `temperature_compensation_drift` is active (high), the difference between the past value of `ambient_temperature` and the past value (10 cycles ago) of `reference_temperature` must be greater than the `compensation_range`. The assertion is disabled during `calibration_mode`.", "sva_signals": ["clk", "[0:0] calibration_mode", "[0:0] temperature_compensation_drift", "[0:0] ambient_temperature", "[0:0] reference_temperature", "[0:0] compensation_range"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (calibration_mode)     temperature_compensation_drift == 1'b1 |->      (($past(ambient_temperature) - $past(reference_temperature, 10)) > compensation_range)", "sva_name": "p_Temperature_Compensation_Drift", "id": "3252", "full_property": "property p_temperature_compensation_drift;\n@(posedge clk) disable iff (calibration_mode)     temperature_compensation_drift == 1'b1 |->      (($past(ambient_temperature) - $past(reference_temperature, 10)) > compensation_range)\nendproperty\nassert_p_temperature_compensation_drift:assert property (p_temperature_compensation_drift) else $error(\"\");", "task_id": "1_6842", "predict_sva": "@(posedge clk) disable iff (calibration_mode)     temperature_compensation_drift == 1'b1 |->      ($past(ambient_temperature) - $past(reference_temperature, 10)) > compensation_range"}
{"sva": "@(negedge clk_superconductor) disable iff(temperature_above_tc) josephson_junction_quench |-> $past(critical_current_exceeded) && ($past(junction_voltage) > quench_voltage)", "sva_description": "### Assertion description:  \n**Property Name**: p_Josephson_Junction_Quench  \n**Trigger Condition**: At every falling edge of `clk_superconductor`  \n**Disable Condition**: `disable iff (temperature_above_tc)`  \n**Antecedent (LHS of Implication)**: `josephson_junction_quench == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(critical_current_exceeded) && ($past(junction_voltage) > quench_voltage)`  ", "sva_signals": ["clk_superconductor", "temperature_above_tc", "[0:0] josephson_junction_quench", "[0:0] critical_current_exceeded", "[0:0] junction_voltage", "[0:0] quench_voltage"], "clock": "clk_superconductor", "attempts_left": 10, "sva_result": "@(negedge clk_superconductor) disable iff (temperature_above_tc)     josephson_junction_quench == 1'b1 |->      $past(critical_current_exceeded) && ($past(junction_voltage) > quench_voltage)", "sva_name": "p_Josephson_Junction_Quench", "id": "3189", "full_property": "property p_Josephson_Junction_Quench;\n@(negedge clk_superconductor) disable iff (temperature_above_tc)     josephson_junction_quench == 1'b1 |->      $past(critical_current_exceeded) && ($past(junction_voltage) > quench_voltage)\nendproperty\nassert_p_Josephson_Junction_Quench:assert property (p_Josephson_Junction_Quench) else $error(\"\");", "task_id": "1_6787", "predict_sva": "@(negedge clk_superconductor) disable iff (temperature_above_tc)     josephson_junction_quench == 1'b1 |->      $past(critical_current_exceeded) && ($past(junction_voltage) > quench_voltage)"}
{"sva": "@(negedge clk_xenon) disable iff(xenon_transient_analysis) fission_product_poisoning |-> ($past(xenon_concentration) > equilibrium_value) && $past(power_level_reduction_completed)", "sva_description": "### Assertion description:  \n**Property Name**: p_Fission_Poisoning_Check  \n**Trigger Condition**: At every falling edge of the `clk_xenon`  \n**Disable Condition**: disable iff (`xenon_transient_analysis`)  \n**Antecedent (LHS of Implication)**: `fission_product_poisoning == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`$past(xenon_concentration) > equilibrium_value`) && `$past(power_level_reduction_completed)`  \n\nThe assertion checks that whenever fission product poisoning is detected, the xenon concentration from the previous cycle was above the equilibrium value and the power level reduction had already been completed in the previous cycle. The check is performed on the falling edge of `clk_xenon` and is disabled during transient analysis.", "sva_signals": ["clk_xenon", "xenon_transient_analysis", "[0:0] fission_product_poisoning", "[0:0] xenon_concentration", "[0:0] equilibrium_value", "[0:0] power_level_reduction_completed"], "clock": "clk_xenon", "attempts_left": 10, "sva_result": "@(negedge clk_xenon) disable iff (xenon_transient_analysis)     fission_product_poisoning == 1'b1 |->      ($past(xenon_concentration) > equilibrium_value) &&      $past(power_level_reduction_completed)", "sva_name": "p_Fission_Product_Poisoning_Check", "id": "3339", "full_property": "property p_Fission_Poisoning_Check;\n@(negedge clk_xenon) disable iff (xenon_transient_analysis)     fission_product_poisoning == 1'b1 |->      ($past(xenon_concentration) > equilibrium_value) &&      $past(power_level_reduction_completed)\nendproperty\nassert_p_Fission_Poisoning_Check:assert property (p_Fission_Poisoning_Check) else $error(\"\");", "task_id": "1_6927", "predict_sva": "@(negedge clk_xenon) disable iff (xenon_transient_analysis)     fission_product_poisoning == 1'b1 |->      ($past(xenon_concentration) > equilibrium_value) && $past(power_level_reduction_completed)"}
{"sva": "@(posedge clk) disable iff(toxicology) in_vitro_toxicity_testing |=> ($past(cell_viability[15:0], 1) && $past(cytotoxicity_assay[11:0], 1) && $past(genotoxicity_screening[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_toxicity_testing_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (toxicology)  \n**Antecedent (LHS of Implication)**: `in_vitro_toxicity_testing`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**:  \n- The past value of `cell_viability[15:0]` from 1 clock cycle ago (`$past(cell_viability[15:0], 1)`) **must be true**,  \n- The past value of `cytotoxicity_assay[11:0]` from 1 clock cycle ago (`$past(cytotoxicity_assay[11:0], 1)`) **must be true**,  \n- The past value of `genotoxicity_screening[31:0]` from 1 clock cycle ago (`$past(genotoxicity_screening[31:0], 1)`) **must be true**.  \n\n**Note**: The consequent evaluates the logical AND of all three past values. The assertion checks that if `in_vitro_toxicity_testing` is true at a clock edge, then in the **next clock cycle**, all three past signals must be non-zero (true). The assertion is disabled if `toxicology` is active.", "sva_signals": ["clk", "[0:0] toxicology", "[0:0] in_vitro_toxicity_testing", "[15:0] cell_viability", "[11:0] cytotoxicity_assay", "[31:0] genotoxicity_screening"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (toxicology)     in_vitro_toxicity_testing |=>      ($past(cell_viability[15:0], 1) != 0) &&      ($past(cytotoxicity_assay[11:0], 1) != 0) &&      ($past(genotoxicity_screening[31:0], 1) != 0)", "sva_name": "p_in_vitro_toxicity_testing", "id": "2929", "full_property": "property p_toxicity_testing_check;\n@(posedge clk) disable iff (toxicology)     in_vitro_toxicity_testing |=>      ($past(cell_viability[15:0], 1) != 0) &&      ($past(cytotoxicity_assay[11:0], 1) != 0) &&      ($past(genotoxicity_screening[31:0], 1) != 0)\nendproperty\nassert_p_toxicity_testing_check:assert property (p_toxicity_testing_check) else $error(\"\");", "task_id": "1_6552", "predict_sva": "@(posedge clk) disable iff (toxicology)     in_vitro_toxicity_testing |->          ($past(cell_viability[15:0], 1) &&           $past(cytotoxicity_assay[11:0], 1) &&           $past(genotoxicity_screening[31:0], 1))"}
{"sva": "@(posedge clk) disable iff(shift_change_in_progress) personnel_tracking_underground |-> $past(miner_badge_scan_entry) && !$past(corresponding_exit_scan_detected, 480) && $past(shift_duration_exceeded)", "sva_description": "### Assertion description:  \n**Property Name**: p_Personnel_Tracking_Underground  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (shift_change_in_progress)`  \n**Antecedent (LHS of Implication)**: `personnel_tracking_underground`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(miner_badge_scan_entry) && !$past(corresponding_exit_scan_detected, 480) && $past(shift_duration_exceeded)`  ", "sva_signals": ["clk", "rst_n", "[0:0] shift_change_in_progress", "[0:0] personnel_tracking_underground", "[0:0] miner_badge_scan_entry", "[0:0] corresponding_exit_scan_detected", "[0:0] shift_duration_exceeded"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (shift_change_in_progress)     personnel_tracking_underground |->          $past(miner_badge_scan_entry) &&          !$past(corresponding_exit_scan_detected, 480) &&          $past(shift_duration_exceeded)", "sva_name": "p_Personnel_Tracking_Underground", "id": "3514", "full_property": "property p_Personnel_Tracking_Underground;\n@(posedge clk) disable iff (shift_change_in_progress)     personnel_tracking_underground |->          $past(miner_badge_scan_entry) &&          !$past(corresponding_exit_scan_detected, 480) &&          $past(shift_duration_exceeded)\nendproperty\nassert_p_Personnel_Tracking_Underground:assert property (p_Personnel_Tracking_Underground) else $error(\"\");", "task_id": "1_7096", "predict_sva": "@(posedge clk) disable iff (shift_change_in_progress)     personnel_tracking_underground |->          $past(miner_badge_scan_entry) &&          !$past(corresponding_exit_scan_detected, 480) &&          $past(shift_duration_exceeded)"}
{"sva": "@(posedge clk) disable iff(quality_assurance_audit) safety_related_component_testing |-> $past(component_test_due) && !$past(test_completion_documented) && $past(operability_questioned)", "sva_description": "### Assertion description:  \n**Property Name**: p_Safety_Related_Component_Testing  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (quality_assurance_audit)`  \n**Antecedent (LHS of Implication)**: `safety_related_component_testing == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(component_test_due) && !$past(test_completion_documented) && $past(operability_questioned)`  ", "sva_signals": ["clk", "quality_assurance_audit", "safety_related_component_testing", "component_test_due", "test_completion_documented", "operability_questioned"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (quality_assurance_audit)     safety_related_component_testing == 1'b1 |->      $past(component_test_due) && !$past(test_completion_documented) && $past(operability_questioned)", "sva_name": "p_Safety_Related_Component_Testing", "id": "3343", "full_property": "property p_Safety_Related_Component_Testing;\n@(posedge clk) disable iff (quality_assurance_audit)     safety_related_component_testing == 1'b1 |->      $past(component_test_due) && !$past(test_completion_documented) && $past(operability_questioned)\nendproperty\nassert_p_Safety_Related_Component_Testing:assert property (p_Safety_Related_Component_Testing) else $error(\"\");", "task_id": "1_6931", "predict_sva": "@(posedge clk) disable iff (quality_assurance_audit)     safety_related_component_testing == 1'b1 |->      $past(component_test_due) && !$past(test_completion_documented) && $past(operability_questioned)"}
{"sva": "@(negedge clk_cyclone) disable iff(cyclone_apex_wear_excessive) particle_size_classification |-> ($past(classification_efficiency_measurement) < design_separation_performance) && $past(feed_pressure_within_operating_range)", "sva_description": "### Assertion description:  \n**Property Name**: (Not specified in the given SVA)  \n**Trigger Condition**: At every falling edge of `clk_cyclone`  \n**Disable Condition**: `disable iff (cyclone_apex_wear_excessive)`  \n**Antecedent (LHS of Implication)**: `particle_size_classification`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(classification_efficiency_measurement) < design_separation_performance) && $past(feed_pressure_within_operating_range)`", "sva_signals": ["clk_cyclone", "cyclone_apex_wear_excessive", "[0:0] particle_size_classification", "[0:0] classification_efficiency_measurement", "[0:0] design_separation_performance", "[0:0] feed_pressure_within_operating_range"], "clock": "clk_cyclone", "attempts_left": 10, "sva_result": "@(negedge clk_cyclone) disable iff (cyclone_apex_wear_excessive)     particle_size_classification |->          ($past(classification_efficiency_measurement) < design_separation_performance) &&          $past(feed_pressure_within_operating_range)", "sva_name": "p_Particle_Size_Classification", "id": "3537", "full_property": "property p_classification_efficiency_check;\n@(negedge clk_cyclone) disable iff (cyclone_apex_wear_excessive)     particle_size_classification |->          ($past(classification_efficiency_measurement) < design_separation_performance) &&          $past(feed_pressure_within_operating_range)\nendproperty\nassert_p_classification_efficiency_check:assert property (p_classification_efficiency_check) else $error(\"\");", "task_id": "1_7119", "predict_sva": "@(negedge clk_cyclone) disable iff (cyclone_apex_wear_excessive)     particle_size_classification |->          ($past(classification_efficiency_measurement) < design_separation_performance) &&          $past(feed_pressure_within_operating_range)"}
{"sva": "@(posedge clk) disable iff(air_show_demonstration_mode) aerobatic_maneuver_envelope |-> ($past(load_factor_limit_exceeded) && $past(airframe_stress_monitoring)) && !$past(maneuver_termination_initiated, 6)", "sva_description": "### Assertion description:  \n**Property Name**: p_Aerobatic_Maneuver_Envelope  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (air_show_demonstration_mode)`  \n**Antecedent (LHS of Implication)**: `aerobatic_maneuver_envelope`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(load_factor_limit_exceeded) && $past(airframe_stress_monitoring)) && !$past(maneuver_termination_initiated, 6)`  ", "sva_signals": ["clk", "rst_n", "[0:0] air_show_demonstration_mode", "[0:0] aerobatic_maneuver_envelope", "[0:0] load_factor_limit_exceeded", "[0:0] airframe_stress_monitoring", "[0:0] maneuver_termination_initiated"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (air_show_demonstration_mode)     aerobatic_maneuver_envelope |->          ($past(load_factor_limit_exceeded) && $past(airframe_stress_monitoring)) &&          !$past(maneuver_termination_initiated, 6)", "sva_name": "p_Aerobatic_Maneuver_Envelope", "id": "3443", "full_property": "property p_Aerobatic_Maneuver_Envelope;\n@(posedge clk) disable iff (air_show_demonstration_mode)     aerobatic_maneuver_envelope |->          ($past(load_factor_limit_exceeded) && $past(airframe_stress_monitoring)) &&          !$past(maneuver_termination_initiated, 6)\nendproperty\nassert_p_Aerobatic_Maneuver_Envelope:assert property (p_Aerobatic_Maneuver_Envelope) else $error(\"\");", "task_id": "1_7027", "predict_sva": "@(posedge clk) disable iff (air_show_demonstration_mode)     aerobatic_maneuver_envelope |->          ($past(load_factor_limit_exceeded) && $past(airframe_stress_monitoring)) &&          !$past(maneuver_termination_initiated, 6)"}
{"sva": "@(posedge clk) disable iff(port_authority_clearance_expired) ship_to_shore_cargo_transfer |-> $past(cargo_handling_crane_overload_detected) && !$past(load_distribution_adjustment_completed, 5)", "sva_description": "### Assertion description:  \n**Property Name**: p_Ship_To_Shore_Cargo_Transfer  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (port_authority_clearance_expired)`  \n**Antecedent (LHS of Implication)**: `ship_to_shore_cargo_transfer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cargo_handling_crane_overload_detected) && !$past(load_distribution_adjustment_completed, 5)`  \n\n(Note: The consequent checks that `cargo_handling_crane_overload_detected` was true in the previous cycle **and** `load_distribution_adjustment_completed` was **not** true 5 cycles prior.)", "sva_signals": ["clk", "[0:0] port_authority_clearance_expired", "[0:0] ship_to_shore_cargo_transfer", "[0:0] cargo_handling_crane_overload_detected", "[0:0] load_distribution_adjustment_completed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (port_authority_clearance_expired)     ship_to_shore_cargo_transfer |->      $past(cargo_handling_crane_overload_detected) &&      !$past(load_distribution_adjustment_completed, 5)", "sva_name": "p_ShipToShoreCargoTransfer", "id": "3556", "full_property": "property p_Ship_To_Shore_Cargo_Transfer;\n@(posedge clk) disable iff (port_authority_clearance_expired)     ship_to_shore_cargo_transfer |->      $past(cargo_handling_crane_overload_detected) &&      !$past(load_distribution_adjustment_completed, 5)\nendproperty\nassert_p_Ship_To_Shore_Cargo_Transfer:assert property (p_Ship_To_Shore_Cargo_Transfer) else $error(\"\");", "task_id": "1_7138", "predict_sva": "@(posedge clk) disable iff (port_authority_clearance_expired)     ship_to_shore_cargo_transfer |->          $past(cargo_handling_crane_overload_detected) &&          !$past(load_distribution_adjustment_completed, 5)"}
{"sva": "@(negedge clk_cyanidation) disable iff(cyanide_destruction_system_fault) gold_extraction_process_safety |-> ($past(residual_cyanide_concentration) > environmental_discharge_limit) && !$past(detoxification_process_initiated, 16)", "sva_description": "### Assertion description:  \n**Property Name**: p_Gold_Extraction_Safety  \n**Trigger Condition**: At every falling edge of the `clk_cyanidation`  \n**Disable Condition**: disable iff (`cyanide_destruction_system_fault`)  \n**Antecedent (LHS of Implication)**: `gold_extraction_process_safety`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(residual_cyanide_concentration) > environmental_discharge_limit)`  \n- **AND** (`&&`)  \n- `!$past(detoxification_process_initiated, 16)`  ", "sva_signals": ["clk_cyanidation", "cyanide_destruction_system_fault", "[0:0] gold_extraction_process_safety", "[0:0] residual_cyanide_concentration", "[0:0] environmental_discharge_limit", "[0:0] detoxification_process_initiated"], "clock": "clk_cyanidation", "attempts_left": 10, "sva_result": "@(negedge clk_cyanidation) disable iff (cyanide_destruction_system_fault)     gold_extraction_process_safety |->          ($past(residual_cyanide_concentration) > environmental_discharge_limit) &&          !$past(detoxification_process_initiated, 16)", "sva_name": "p_Gold_Extraction_Process_Safety", "id": "3523", "full_property": "property p_Gold_Extraction_Safety;\n@(negedge clk_cyanidation) disable iff (cyanide_destruction_system_fault)     gold_extraction_process_safety |->          ($past(residual_cyanide_concentration) > environmental_discharge_limit) &&          !$past(detoxification_process_initiated, 16)\nendproperty\nassert_p_Gold_Extraction_Safety:assert property (p_Gold_Extraction_Safety) else $error(\"\");", "task_id": "1_7105", "predict_sva": "@(negedge clk_cyanidation) disable iff (cyanide_destruction_system_fault)     gold_extraction_process_safety |->          ($past(residual_cyanide_concentration) > environmental_discharge_limit) &&          !$past(detoxification_process_initiated, 16)"}
{"sva": "@(posedge clk_pressurizer) disable iff(!pressure_control_available) primary_system_pressure |-> ($past(pressurizer_level) != $past(program_level)) && !$past(spray_valve_response, 7)", "sva_description": "### Assertion description:  \n**Property Name**: p_Primary_System_Pressure_Check  \n**Trigger Condition**: At every rising edge of the `clk_pressurizer`  \n**Disable Condition**: disable iff (`!pressure_control_available`)  \n**Antecedent (LHS of Implication)**: `primary_system_pressure == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `pressurizer_level` is not equal to the past value of `program_level` (`$past(pressurizer_level) != $past(program_level)`)  \n- AND  \n- The past value of `spray_valve_response` 7 cycles ago is `0` (`!$past(spray_valve_response, 7)`)  ", "sva_signals": ["clk_pressurizer", "pressure_control_available", "primary_system_pressure", "[0:0] pressurizer_level", "[0:0] program_level", "[0:0] spray_valve_response"], "clock": "clk_pressurizer", "attempts_left": 10, "sva_result": "@(posedge clk_pressurizer) disable iff (!pressure_control_available)     primary_system_pressure == 1'b1 |->          ($past(pressurizer_level) != $past(program_level)) &&         (!$past(spray_valve_response, 7))", "sva_name": "p_primary_system_pressure_check", "id": "3347", "full_property": "property p_Primary_System_Pressure_Check;\n@(posedge clk_pressurizer) disable iff (!pressure_control_available)     primary_system_pressure == 1'b1 |->          ($past(pressurizer_level) != $past(program_level)) &&         (!$past(spray_valve_response, 7))\nendproperty\nassert_p_Primary_System_Pressure_Check:assert property (p_Primary_System_Pressure_Check) else $error(\"\");", "task_id": "1_6935", "predict_sva": "@(posedge clk_pressurizer) disable iff (!pressure_control_available)     primary_system_pressure == 1'b1 |->      ($past(pressurizer_level) != $past(program_level)) && !$past(spray_valve_response, 7)"}
{"sva": "@(negedge clk_lighthouse) disable iff(navigation_aid_maintenance_mode) maritime_navigation_safety |-> ($past(lighthouse_beam_intensity) < required_luminous_range) && !$past(backup_navigation_beacon_activated, 4)", "sva_description": "### Assertion description:  \n**Property Name**: p_Maritime_Navigation_Safety  \n**Trigger Condition**: At every falling edge of the `clk_lighthouse`  \n**Disable Condition**: `disable iff (navigation_aid_maintenance_mode)`  \n**Antecedent (LHS of Implication)**: `maritime_navigation_safety`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(lighthouse_beam_intensity) < required_luminous_range) && !$past(backup_navigation_beacon_activated, 4)`", "sva_signals": ["clk_lighthouse", "navigation_aid_maintenance_mode", "[0:0] maritime_navigation_safety", "[0:0] lighthouse_beam_intensity", "[0:0] required_luminous_range", "[0:0] backup_navigation_beacon_activated"], "clock": "clk_lighthouse", "attempts_left": 10, "sva_result": "@(negedge clk_lighthouse) disable iff (navigation_aid_maintenance_mode)     maritime_navigation_safety |->          ($past(lighthouse_beam_intensity) < required_luminous_range) &&          !$past(backup_navigation_beacon_activated, 4)", "sva_name": "p_Maritime_Navigation_Safety", "id": "3602", "full_property": "property p_Maritime_Navigation_Safety;\n@(negedge clk_lighthouse) disable iff (navigation_aid_maintenance_mode)     maritime_navigation_safety |->          ($past(lighthouse_beam_intensity) < required_luminous_range) &&          !$past(backup_navigation_beacon_activated, 4)\nendproperty\nassert_p_Maritime_Navigation_Safety:assert property (p_Maritime_Navigation_Safety) else $error(\"\");", "task_id": "1_7182", "predict_sva": "@(negedge clk_lighthouse) disable iff (navigation_aid_maintenance_mode)     maritime_navigation_safety |->          ($past(lighthouse_beam_intensity) < required_luminous_range) &&          !$past(backup_navigation_beacon_activated, 4)"}
{"id": "309_3_0004", "name": "arb_grant_round_robin_case", "sva": "@(posedge clk)     req_valid && round_robin && !hi_prio |-> grant", "ori_sva": "property arb_grant_round_robin_case;\n@(posedge clk)     req_valid && round_robin && !hi_prio |-> grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_grant_on_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req_valid && round_robin && !hi_prio`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant`", "sva_signals": ["clk", "rst_n", "[0:0] req_valid", "[0:0] round_robin", "[0:0] hi_prio", "[0:0] grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (req_valid && round_robin && !hi_prio) |-> grant", "sva_name": "p_grant_on_round_robin", "full_property": "property p_grant_on_request;\n@(posedge clk)         (req_valid && round_robin && !hi_prio) |-> grant\nendproperty\nassert_p_grant_on_request:assert property (p_grant_on_request) else $error(\"\");", "task_id": "1_7672", "predict_sva": "@(posedge clk)         (req_valid && round_robin && !hi_prio) |-> grant"}
{"sva": "@(negedge clk_hplc_pump) disable iff(solvent_reservoir_empty) high_performance_liquid_chromatography |-> ($past(mobile_phase_gradient_programmed) && $past(column_equilibration_complete)) && ($past(peak_resolution) < chromatographic_separation_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_HPLC_Operation_Check  \n**Trigger Condition**: At every falling edge of the `clk_hplc_pump`;  \n**Disable Condition**: `disable iff (solvent_reservoir_empty)`  \n**Antecedent (LHS of Implication)**: `high_performance_liquid_chromatography == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(mobile_phase_gradient_programmed) && $past(column_equilibration_complete)) && ($past(peak_resolution) < chromatographic_separation_requirement)`  ", "sva_signals": ["clk_hplc_pump", "solvent_reservoir_empty", "[0:0] high_performance_liquid_chromatography", "[0:0] mobile_phase_gradient_programmed", "[0:0] column_equilibration_complete", "[0:0] peak_resolution", "[0:0] chromatographic_separation_requirement"], "clock": "clk_hplc_pump", "attempts_left": 10, "sva_result": "@(negedge clk_hplc_pump) disable iff (solvent_reservoir_empty)     high_performance_liquid_chromatography == 1'b1 |->     ($past(mobile_phase_gradient_programmed) && $past(column_equilibration_complete)) &&      ($past(peak_resolution) < chromatographic_separation_requirement)", "sva_name": "p_HPLC_Conditions", "id": "3464", "full_property": "property p_HPLC_Operation_Check;\n@(negedge clk_hplc_pump) disable iff (solvent_reservoir_empty)     high_performance_liquid_chromatography == 1'b1 |->     ($past(mobile_phase_gradient_programmed) && $past(column_equilibration_complete)) &&      ($past(peak_resolution) < chromatographic_separation_requirement)\nendproperty\nassert_p_HPLC_Operation_Check:assert property (p_HPLC_Operation_Check) else $error(\"\");", "task_id": "1_7048", "predict_sva": "@(negedge clk_hplc_pump) disable iff (solvent_reservoir_empty)     high_performance_liquid_chromatography == 1'b1 |->      ($past(mobile_phase_gradient_programmed) && $past(column_equilibration_complete)) &&     ($past(peak_resolution) < chromatographic_separation_requirement)"}
{"sva": "@(posedge clk) disable iff(!building_permit_validated) foundation_excavation_depth_verification |-> $past(soil_bearing_capacity_test_completed) && ($past(excavation_depth_measurement) != architectural_drawing_specification)", "sva_description": "### Assertion description:  \n**Property Name**: p_foundation_excavation_depth_verification  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!building_permit_validated)  \n**Antecedent (LHS of Implication)**: `foundation_excavation_depth_verification`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(soil_bearing_capacity_test_completed) && ($past(excavation_depth_measurement) != architectural_drawing_specification)`", "sva_signals": ["clk", "building_permit_validated", "foundation_excavation_depth_verification", "soil_bearing_capacity_test_completed", "excavation_depth_measurement", "architectural_drawing_specification"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!building_permit_validated)     foundation_excavation_depth_verification |->          ($past(soil_bearing_capacity_test_completed) &&           ($past(excavation_depth_measurement) != architectural_drawing_specification))", "sva_name": "p_Foundation_Excavation_Verification", "id": "3748", "full_property": "property p_foundation_excavation_depth_verification;\n@(posedge clk) disable iff (!building_permit_validated)     foundation_excavation_depth_verification |->          ($past(soil_bearing_capacity_test_completed) &&           ($past(excavation_depth_measurement) != architectural_drawing_specification))\nendproperty\nassert_p_foundation_excavation_depth_verification:assert property (p_foundation_excavation_depth_verification) else $error(\"\");", "task_id": "1_7324", "predict_sva": "@(posedge clk) disable iff (!building_permit_validated)     foundation_excavation_depth_verification |->          $past(soil_bearing_capacity_test_completed) &&          ($past(excavation_depth_measurement) != architectural_drawing_specification)"}
{"id": "334_3_0254", "name": "cfg_lock_no_write_p3", "sva": "@(posedge clk_signal)     cfg_lock && reg_write |=> $stable(data_bus)", "ori_sva": "property cfg_lock_no_write_p3;\n@(posedge clk_signal)     cfg_lock && reg_write |=> $stable(data_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Data_After_Write  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cfg_lock && reg_write`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(data_bus)`  ", "sva_signals": ["clk_signal", "[0:0] cfg_lock", "[0:0] reg_write", "[0:0] data_bus"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (cfg_lock && reg_write) |=> $stable(data_bus)", "sva_name": "p_Stable_Data_After_Write", "full_property": "property p_Stable_Data_After_Write;\n@(posedge clk_signal)     (cfg_lock && reg_write) |=> $stable(data_bus)\nendproperty\nassert_p_Stable_Data_After_Write:assert property (p_Stable_Data_After_Write) else $error(\"\");", "task_id": "1_7827", "predict_sva": "@(posedge clk_signal)     (cfg_lock && reg_write) |=> $stable(data_bus)"}
{"id": "320_3_0149", "name": "p_parity_consistency_check", "sva": "@(posedge clk_signal)     $rose(data_valid) |-> (even_parity ^ odd_parity) == 0 throughout data_transfer", "ori_sva": "property p_parity_consistency_check;\n@(posedge clk_signal)     $rose(data_valid) |-> (even_parity ^ odd_parity) == 0 throughout data_transfer;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Check_During_Data_Transfer  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(data_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(even_parity ^ odd_parity) == 0 throughout data_transfer`  ", "sva_signals": ["clk_signal", "[0:0] data_valid", "[0:0] even_parity", "[0:0] odd_parity", "[0:0] data_transfer"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(data_valid) |-> (even_parity ^ odd_parity) == 0 throughout data_transfer", "sva_name": "p_Parity_Check_During_Transfer", "full_property": "property p_Parity_Check_During_Data_Transfer;\n@(posedge clk_signal)         $rose(data_valid) |-> (even_parity ^ odd_parity) == 0 throughout data_transfer\nendproperty\nassert_p_Parity_Check_During_Data_Transfer:assert property (p_Parity_Check_During_Data_Transfer) else $error(\"\");", "task_id": "1_7747", "predict_sva": "@(posedge clk_signal)     $rose(data_valid) |-> ((even_parity ^ odd_parity) == 0) throughout data_transfer"}
{"sva": "@(posedge clk_agricultural_weather) disable iff(!climate_change_adaptation_strategy_implementation) extreme_weather_event_preparedness |-> $past(weather_pattern_anomaly_detection) && ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Extreme_Weather_Preparedness  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_weather`  \n**Disable Condition**: `disable iff (!climate_change_adaptation_strategy_implementation)`  \n**Antecedent (LHS of Implication)**: `extreme_weather_event_preparedness`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(weather_pattern_anomaly_detection) && ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)`  ", "sva_signals": ["clk_agricultural_weather", "climate_change_adaptation_strategy_implementation", "[0:0] extreme_weather_event_preparedness", "[0:0] weather_pattern_anomaly_detection", "[0:0] crop_resilience_measure_effectiveness", "[0:0] climate_risk_mitigation_adequacy"], "clock": "clk_agricultural_weather", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)     extreme_weather_event_preparedness |->          $past(weather_pattern_anomaly_detection) &&          ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)", "sva_name": "p_extreme_weather_event_preparedness", "id": "3663", "full_property": "property p_Extreme_Weather_Preparedness;\n@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)     extreme_weather_event_preparedness |->          $past(weather_pattern_anomaly_detection) &&          ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)\nendproperty\nassert_p_Extreme_Weather_Preparedness:assert property (p_Extreme_Weather_Preparedness) else $error(\"\");", "task_id": "1_7243", "predict_sva": "@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)     extreme_weather_event_preparedness |->          $past(weather_pattern_anomaly_detection) &&          ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)"}
{"sva": "@(posedge clk_construction_simulation) disable iff(!virtual_construction_modeling_validation_complete) construction_process_simulation_accuracy |-> $past(simulation_model_reality_correlation_verification) && ($past(construction_planning_optimization_effectiveness) < simulation_based_planning_improvement_benchmark)", "sva_description": "### Assertion description:  \n**Property Name**: p_construction_simulation_accuracy  \n**Trigger Condition**: At every rising edge of the `clk_construction_simulation`  \n**Disable Condition**: `disable iff (!virtual_construction_modeling_validation_complete)`  \n**Antecedent (LHS of Implication)**: `construction_process_simulation_accuracy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(simulation_model_reality_correlation_verification) && ($past(construction_planning_optimization_effectiveness) < simulation_based_planning_improvement_benchmark)`  ", "sva_signals": ["clk_construction_simulation", "virtual_construction_modeling_validation_complete", "[0:0] construction_process_simulation_accuracy", "[0:0] simulation_model_reality_correlation_verification", "[0:0] construction_planning_optimization_effectiveness", "[0:0] simulation_based_planning_improvement_benchmark"], "clock": "clk_construction_simulation", "attempts_left": 10, "sva_result": "@(posedge clk_construction_simulation) disable iff (!virtual_construction_modeling_validation_complete)     construction_process_simulation_accuracy == 1'b1 |->     $past(simulation_model_reality_correlation_verification) &&      ($past(construction_planning_optimization_effectiveness) < simulation_based_planning_improvement_benchmark)", "sva_name": "p_construction_simulation_accuracy", "id": "3789", "full_property": "property p_construction_simulation_accuracy;\n@(posedge clk_construction_simulation) disable iff (!virtual_construction_modeling_validation_complete)     construction_process_simulation_accuracy == 1'b1 |->     $past(simulation_model_reality_correlation_verification) &&      ($past(construction_planning_optimization_effectiveness) < simulation_based_planning_improvement_benchmark)\nendproperty\nassert_p_construction_simulation_accuracy:assert property (p_construction_simulation_accuracy) else $error(\"\");", "task_id": "1_7364", "predict_sva": "@(posedge clk_construction_simulation) disable iff (!virtual_construction_modeling_validation_complete)     construction_process_simulation_accuracy == 1'b1 |->      $past(simulation_model_reality_correlation_verification) &&      ($past(construction_planning_optimization_effectiveness) < simulation_based_planning_improvement_benchmark)"}
{"sva": "@(posedge clk_dark_tourism) disable iff(!ethical_tourism_guideline_compliance_verification_active) sensitive_site_tourism_management |-> $past(historical_accuracy_educational_content_validation) && ($past(respectful_visitation_protocol_enforcement) < ethical_dark_tourism_standard_implementation_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_sensitive_site_tourism_management  \n**Trigger Condition**: At every rising edge of the `clk_dark_tourism`  \n**Disable Condition**: `disable iff (!ethical_tourism_guideline_compliance_verification_active)`  \n**Antecedent (LHS of Implication)**: `sensitive_site_tourism_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(historical_accuracy_educational_content_validation) && ($past(respectful_visitation_protocol_enforcement) < ethical_dark_tourism_standard_implementation_requirement)`  ", "sva_signals": ["clk_dark_tourism", "ethical_tourism_guideline_compliance_verification_active", "[0:0] sensitive_site_tourism_management", "[0:0] historical_accuracy_educational_content_validation", "[0:0] respectful_visitation_protocol_enforcement", "[0:0] ethical_dark_tourism_standard_implementation_requirement"], "clock": "clk_dark_tourism", "attempts_left": 10, "sva_result": "@(posedge clk_dark_tourism) disable iff (!ethical_tourism_guideline_compliance_verification_active)     sensitive_site_tourism_management |->      $past(historical_accuracy_educational_content_validation) &&      ($past(respectful_visitation_protocol_enforcement) < ethical_dark_tourism_standard_implementation_requirement)", "sva_name": "p_Sensitive_Site_Tourism_Management", "id": "3749", "full_property": "property p_sensitive_site_tourism_management;\n@(posedge clk_dark_tourism) disable iff (!ethical_tourism_guideline_compliance_verification_active)     sensitive_site_tourism_management |->      $past(historical_accuracy_educational_content_validation) &&      ($past(respectful_visitation_protocol_enforcement) < ethical_dark_tourism_standard_implementation_requirement)\nendproperty\nassert_p_sensitive_site_tourism_management:assert property (p_sensitive_site_tourism_management) else $error(\"\");", "task_id": "1_7325", "predict_sva": "@(posedge clk_dark_tourism) disable iff (!ethical_tourism_guideline_compliance_verification_active)     sensitive_site_tourism_management |->          $past(historical_accuracy_educational_content_validation) &&          ($past(respectful_visitation_protocol_enforcement) < ethical_dark_tourism_standard_implementation_requirement)"}
{"id": "302_1_0028", "name": "gated_clk_low_when_disabled_1", "sva": "@(posedge clk)      !clk_en |-> !gated_clk", "ori_sva": "property gated_clk_low_when_disabled_1;\n@(posedge clk)      !clk_en |-> !gated_clk;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Gated_Clk_When_Clk_En_Low  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!clk_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!gated_clk`  ", "sva_signals": ["clk", "rst_n", "[0:0] clk_en", "[0:0] gated_clk"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !clk_en |-> !gated_clk", "sva_name": "p_GatedClk_WhenClkEnLow", "full_property": "property p_Gated_Clk_When_Clk_En_Low;\n@(posedge clk)     !clk_en |-> !gated_clk\nendproperty\nassert_p_Gated_Clk_When_Clk_En_Low:assert property (p_Gated_Clk_When_Clk_En_Low) else $error(\"\");", "task_id": "1_7633", "predict_sva": "@(posedge clk)     !clk_en |-> !gated_clk"}
{"id": "346_1_0370", "name": "p_low_pwr_clk_gating_1", "sva": "@(posedge clk_sys)     !active_mode |-> !clock_en", "ori_sva": "property p_low_pwr_clk_gating_1;\n@(posedge clk_sys)     !active_mode |-> !clock_en\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Clock_Enable_Inactive_Mode  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!active_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!clock_en`  ", "sva_signals": ["clk_sys", "[0:0] active_mode", "[0:0] clock_en"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     !active_mode |-> !clock_en", "sva_name": "p_Clock_Enable_Check", "full_property": "property p_Clock_Enable_Inactive_Mode;\n@(posedge clk_sys)     !active_mode |-> !clock_en\nendproperty\nassert_p_Clock_Enable_Inactive_Mode:assert property (p_Clock_Enable_Inactive_Mode) else $error(\"\");", "task_id": "1_7913", "predict_sva": "@(posedge clk_sys)     !active_mode |-> !clock_en"}
{"sva": "@(posedge clk_game_security) disable iff(digital_rights_management_system_update_pending) intellectual_property_protection |-> $past(content_piracy_prevention_mechanism_effectiveness) && ($past(unauthorized_access_detection_sensitivity) < digital_asset_security_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Intellectual_Property_Protection  \n**Trigger Condition**: At every rising edge of `clk_game_security`  \n**Disable Condition**: `disable iff (digital_rights_management_system_update_pending)`  \n**Antecedent (LHS of Implication)**: `intellectual_property_protection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(content_piracy_prevention_mechanism_effectiveness) && ($past(unauthorized_access_detection_sensitivity) < digital_asset_security_requirement)`  ", "sva_signals": ["clk_game_security", "digital_rights_management_system_update_pending", "[0:0] intellectual_property_protection", "[0:0] content_piracy_prevention_mechanism_effectiveness", "[0:0] unauthorized_access_detection_sensitivity", "[0:0] digital_asset_security_requirement"], "clock": "clk_game_security", "attempts_left": 10, "sva_result": "@(posedge clk_game_security) disable iff (digital_rights_management_system_update_pending)     intellectual_property_protection |->          ($past(content_piracy_prevention_mechanism_effectiveness) &&           ($past(unauthorized_access_detection_sensitivity) < digital_asset_security_requirement))", "sva_name": "p_Intellectual_Property_Protection", "id": "3807", "full_property": "property p_Intellectual_Property_Protection;\n@(posedge clk_game_security) disable iff (digital_rights_management_system_update_pending)     intellectual_property_protection |->          ($past(content_piracy_prevention_mechanism_effectiveness) &&           ($past(unauthorized_access_detection_sensitivity) < digital_asset_security_requirement))\nendproperty\nassert_p_Intellectual_Property_Protection:assert property (p_Intellectual_Property_Protection) else $error(\"\");", "task_id": "1_7381", "predict_sva": "@(posedge clk_game_security) disable iff (digital_rights_management_system_update_pending)     intellectual_property_protection == 1'b1 |->      $past(content_piracy_prevention_mechanism_effectiveness) &&      ($past(unauthorized_access_detection_sensitivity) < digital_asset_security_requirement)"}
{"sva": "@(negedge clk_adventure_tour) disable iff(extreme_weather_safety_advisory_issued) outdoor_activity_risk_management |-> ($past(participant_safety_briefing_completion) && $past(equipment_safety_inspection_verification)) && ($past(emergency_response_preparedness_assessment) != adequate_safety_protocol_readiness)", "sva_description": "### Assertion description:  \n**Property Name**: p_Outdoor_Activity_Risk_Management  \n**Trigger Condition**: At every negedge of the `clk_adventure_tour`  \n**Disable Condition**: disable iff (`extreme_weather_safety_advisory_issued`)  \n**Antecedent (LHS of Implication)**: `outdoor_activity_risk_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(participant_safety_briefing_completion) && $past(equipment_safety_inspection_verification)`  \n- AND  \n- `$past(emergency_response_preparedness_assessment) != adequate_safety_protocol_readiness`  \n\nThe assertion checks that whenever `outdoor_activity_risk_management` is active (antecedent), the following conditions must hold (consequent):  \n1. The participant safety briefing was completed (`$past(participant_safety_briefing_completion)`) AND the equipment safety inspection was verified (`$past(equipment_safety_inspection_verification)`).  \n2. The past emergency response preparedness assessment (`$past(emergency_response_preparedness_assessment)`) did NOT indicate adequate safety protocol readiness (`adequate_safety_protocol_readiness`).  \nThe assertion is disabled if `extreme_weather_safety_advisory_issued` is active.", "sva_signals": ["clk_adventure_tour", "extreme_weather_safety_advisory_issued", "outdoor_activity_risk_management", "participant_safety_briefing_completion", "equipment_safety_inspection_verification", "emergency_response_preparedness_assessment", "adequate_safety_protocol_readiness"], "clock": "clk_adventure_tour", "attempts_left": 10, "sva_result": "@(negedge clk_adventure_tour) disable iff (extreme_weather_safety_advisory_issued)     outdoor_activity_risk_management |->          ($past(participant_safety_briefing_completion) &&           $past(equipment_safety_inspection_verification)) &&         ($past(emergency_response_preparedness_assessment) != adequate_safety_protocol_readiness)", "sva_name": "p_Outdoor_Activity_Risk_Management", "id": "3734", "full_property": "property p_Outdoor_Activity_Risk_Management;\n@(negedge clk_adventure_tour) disable iff (extreme_weather_safety_advisory_issued)     outdoor_activity_risk_management |->          ($past(participant_safety_briefing_completion) &&           $past(equipment_safety_inspection_verification)) &&         ($past(emergency_response_preparedness_assessment) != adequate_safety_protocol_readiness)\nendproperty\nassert_p_Outdoor_Activity_Risk_Management:assert property (p_Outdoor_Activity_Risk_Management) else $error(\"\");", "task_id": "1_7310", "predict_sva": "@(negedge clk_adventure_tour) disable iff (extreme_weather_safety_advisory_issued)     outdoor_activity_risk_management |->      ($past(participant_safety_briefing_completion) && $past(equipment_safety_inspection_verification)) &&     ($past(emergency_response_preparedness_assessment) != adequate_safety_protocol_readiness)"}
{"id": "331_3_0257", "name": "auth_pass_phases_sequence_within_3_cycles", "sva": "@(posedge clk_signal)     $rose(auth_pass_phase1) |-> ##[1:3] (auth_pass_phase2 && auth_pass_phase3)", "ori_sva": "property auth_pass_phases_sequence_within_3_cycles;\n@(posedge clk_signal)     $rose(auth_pass_phase1) |-> ##[1:3] (auth_pass_phase2 && auth_pass_phase3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_auth_pass_sequence  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(auth_pass_phase1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] (auth_pass_phase2 && auth_pass_phase3)`  ", "sva_signals": ["clk", "rst_n", "[0:0] auth_pass_phase1", "[0:0] auth_pass_phase2", "[0:0] auth_pass_phase3", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(auth_pass_phase1) |-> ##[1:3] (auth_pass_phase2 && auth_pass_phase3)", "sva_name": "p_auth_pass_phases", "full_property": "property p_auth_pass_sequence;\n@(posedge clk_signal)         $rose(auth_pass_phase1) |-> ##[1:3] (auth_pass_phase2 && auth_pass_phase3)\nendproperty\nassert_p_auth_pass_sequence:assert property (p_auth_pass_sequence) else $error(\"\");", "task_id": "1_7808", "predict_sva": "@(posedge clk_signal)     $rose(auth_pass_phase1) |-> ##[1:3] (auth_pass_phase2 && auth_pass_phase3)"}
{"sva": "@(posedge clk_ball_mill) disable iff(mill_charge_optimization_pending) grinding_media_wear_monitoring |-> ($past(steel_ball_consumption_rate) > normal_wear_rate) && ($past(mill_liner_condition_assessment) != replacement_recommended)", "sva_description": "### Assertion description:  \n**Property Name**: p_grinding_media_wear_monitoring  \n**Trigger Condition**: At every rising edge of the `clk_ball_mill`  \n**Disable Condition**: `disable iff (mill_charge_optimization_pending)`  \n**Antecedent (LHS of Implication)**: `grinding_media_wear_monitoring`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(steel_ball_consumption_rate) > normal_wear_rate)`  \n- `&& ($past(mill_liner_condition_assessment) != replacement_recommended)`  \n\nThe assertion checks that whenever `grinding_media_wear_monitoring` is active, the past value of `steel_ball_consumption_rate` must exceed `normal_wear_rate`, and the past assessment of the mill liner condition must not indicate a replacement recommendation. The check is disabled if `mill_charge_optimization_pending` is asserted.", "sva_signals": ["clk_ball_mill", "mill_charge_optimization_pending", "grinding_media_wear_monitoring", "steel_ball_consumption_rate", "normal_wear_rate", "mill_liner_condition_assessment", "replacement_recommended"], "clock": "clk_ball_mill", "attempts_left": 10, "sva_result": "@(posedge clk_ball_mill) disable iff (mill_charge_optimization_pending)     grinding_media_wear_monitoring |->      ($past(steel_ball_consumption_rate) > normal_wear_rate) &&      ($past(mill_liner_condition_assessment) != replacement_recommended)", "sva_name": "p_Grinding_Media_Wear_Monitoring", "id": "3534", "full_property": "property p_grinding_media_wear_monitoring;\n@(posedge clk_ball_mill) disable iff (mill_charge_optimization_pending)     grinding_media_wear_monitoring |->      ($past(steel_ball_consumption_rate) > normal_wear_rate) &&      ($past(mill_liner_condition_assessment) != replacement_recommended)\nendproperty\nassert_p_grinding_media_wear_monitoring:assert property (p_grinding_media_wear_monitoring) else $error(\"\");", "task_id": "1_7116", "predict_sva": "@(posedge clk_ball_mill) disable iff (mill_charge_optimization_pending)     grinding_media_wear_monitoring |->          ($past(steel_ball_consumption_rate) > normal_wear_rate) &&          ($past(mill_liner_condition_assessment) != replacement_recommended)"}
{"sva": "@(posedge clk_emergency_response) disable iff(hospital_emergency_capacity_overflow) trauma_care_triage_system |-> $past(patient_acuity_assessment_accuracy) && ($past(resource_allocation_optimization_effectiveness) < emergency_care_response_time_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Trauma_Care_Triage_System  \n**Trigger Condition**: At every rising edge of `clk_emergency_response`  \n**Disable Condition**: `disable iff (hospital_emergency_capacity_overflow)`  \n**Antecedent (LHS of Implication)**: `trauma_care_triage_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(patient_acuity_assessment_accuracy) && ($past(resource_allocation_optimization_effectiveness) < emergency_care_response_time_target)`  ", "sva_signals": ["clk_emergency_response", "hospital_emergency_capacity_overflow", "[0:0] trauma_care_triage_system", "[0:0] patient_acuity_assessment_accuracy", "[0:0] resource_allocation_optimization_effectiveness", "[0:0] emergency_care_response_time_target"], "clock": "clk_emergency_response", "attempts_left": 10, "sva_result": "@(posedge clk_emergency_response) disable iff (hospital_emergency_capacity_overflow)     trauma_care_triage_system |->      $past(patient_acuity_assessment_accuracy) &&      ($past(resource_allocation_optimization_effectiveness) < emergency_care_response_time_target)", "sva_name": "p_Trauma_Care_Triage_System_Check", "id": "4004", "full_property": "property p_Trauma_Care_Triage_System;\n@(posedge clk_emergency_response) disable iff (hospital_emergency_capacity_overflow)     trauma_care_triage_system |->      $past(patient_acuity_assessment_accuracy) &&      ($past(resource_allocation_optimization_effectiveness) < emergency_care_response_time_target)\nendproperty\nassert_p_Trauma_Care_Triage_System:assert property (p_Trauma_Care_Triage_System) else $error(\"\");", "task_id": "1_7573", "predict_sva": "@(posedge clk_emergency_response) disable iff (hospital_emergency_capacity_overflow)     trauma_care_triage_system |->          $past(patient_acuity_assessment_accuracy) &&          ($past(resource_allocation_optimization_effectiveness) < emergency_care_response_time_target)"}
{"id": "341_8_0388", "name": "priority_inversion_protection_p8", "sva": "@(posedge clk_arb)     !priority_invert && req_high |-> ##1 grant_high", "ori_sva": "property priority_inversion_protection_p8;\n@(posedge clk_arb)     !priority_invert && req_high |-> ##1 grant_high;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Grant_High_After_Req  \n**Trigger Condition**: At every rising edge of `clk_arb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!priority_invert && req_high`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 grant_high`  ", "sva_signals": ["clk_arb", "rst_n", "[0:0] priority_invert", "[0:0] req_high", "[0:0] grant_high"], "clock": "clk_arb", "attempts_left": 10, "sva_result": "@(posedge clk_arb)         (!priority_invert && req_high) |-> ##1 grant_high", "sva_name": "p_ReqHigh_GrantHigh", "full_property": "property p_Grant_High_After_Req;\n@(posedge clk_arb)         (!priority_invert && req_high) |-> ##1 grant_high\nendproperty\nassert_p_Grant_High_After_Req:assert property (p_Grant_High_After_Req) else $error(\"\");", "task_id": "1_7879", "predict_sva": "@(posedge clk_arb)         (!priority_invert && req_high) |-> ##1 grant_high"}
{"id": "313_4_0108", "name": "p_sw_en_no_clk_overlap_negedge_clk2", "sva": "@(negedge clk_2)     sw_en |-> !(clk_1 && clk_2)", "ori_sva": "property p_sw_en_no_clk_overlap_negedge_clk2;\n@(negedge clk_2)     sw_en |-> !(clk_1 && clk_2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sw_en_clock_check  \n**Trigger Condition**: At every falling edge of `clk_2`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sw_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(clk_1 && clk_2)`  \n\n(Note: The assertion checks that when `sw_en` is high at the falling edge of `clk_2`, `clk_1` and `clk_2` must not be simultaneously high.)", "sva_signals": ["clk_2", "clk_1", "[0:0] sw_en"], "clock": "clk_2", "attempts_left": 10, "sva_result": "@(negedge clk_2)     sw_en == 1'b1 |-> !(clk_1 && clk_2)", "sva_name": "p_sw_en_check", "full_property": "property p_sw_en_clock_check;\n@(negedge clk_2)     sw_en == 1'b1 |-> !(clk_1 && clk_2)\nendproperty\nassert_p_sw_en_clock_check:assert property (p_sw_en_clock_check) else $error(\"\");", "task_id": "1_7699", "predict_sva": "@(negedge clk_2)     sw_en == 1'b1 |-> !(clk_1 && clk_2)"}
{"sva": "@(posedge clk_space_telescope_array) disable iff(interferometry_baseline_stability_compromised) space_based_astronomical_observation |-> $past(telescope_formation_flying_precision) && ($past(interferometric_fringe_tracking_accuracy) < astronomical_observation_resolution_enhancement_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Space_Based_Observation_Requirement  \n**Trigger Condition**: At every rising edge of the `clk_space_telescope_array`  \n**Disable Condition**: `disable iff (interferometry_baseline_stability_compromised)`  \n**Antecedent (LHS of Implication)**: `space_based_astronomical_observation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(telescope_formation_flying_precision) && ($past(interferometric_fringe_tracking_accuracy) < astronomical_observation_resolution_enhancement_target)`  ", "sva_signals": ["clk", "interferometry_baseline_stability_compromised", "space_based_astronomical_observation", "telescope_formation_flying_precision", "interferometric_fringe_tracking_accuracy", "astronomical_observation_resolution_enhancement_target", "clk_space_telescope_array"], "clock": "clk_space_telescope_array", "attempts_left": 10, "sva_result": "@(posedge clk_space_telescope_array) disable iff (interferometry_baseline_stability_compromised)     space_based_astronomical_observation == 1'b1 |->      $past(telescope_formation_flying_precision) &&      ($past(interferometric_fringe_tracking_accuracy) < astronomical_observation_resolution_enhancement_target)", "sva_name": "p_Space_Telescope_Observation", "id": "3972", "full_property": "property p_Space_Based_Observation_Requirement;\n@(posedge clk_space_telescope_array) disable iff (interferometry_baseline_stability_compromised)     space_based_astronomical_observation == 1'b1 |->      $past(telescope_formation_flying_precision) &&      ($past(interferometric_fringe_tracking_accuracy) < astronomical_observation_resolution_enhancement_target)\nendproperty\nassert_p_Space_Based_Observation_Requirement:assert property (p_Space_Based_Observation_Requirement) else $error(\"\");", "task_id": "1_7543", "predict_sva": "@(posedge clk_space_telescope_array) disable iff (interferometry_baseline_stability_compromised)     space_based_astronomical_observation == 1'b1 |->      $past(telescope_formation_flying_precision) &&      ($past(interferometric_fringe_tracking_accuracy) < astronomical_observation_resolution_enhancement_target)"}
{"id": "359_6_0497", "name": "arb_no_grant_condition", "sva": "@(posedge clk)     req_valid && !hi_prio && !round_robin |-> !grant", "ori_sva": "property arb_no_grant_condition;\n@(posedge clk)     req_valid && !hi_prio && !round_robin |-> !grant;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_ReqValidGrantCheck  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req_valid && !hi_prio && !round_robin`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!grant`", "sva_signals": ["clk", "rst_n", "[0:0] req_valid", "[0:0] hi_prio", "[0:0] round_robin", "[0:0] grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (req_valid && !hi_prio && !round_robin) |-> !grant", "sva_name": "p_ReqValid_Grant", "full_property": "property p_ReqValidGrantCheck;\n@(posedge clk)         (req_valid && !hi_prio && !round_robin) |-> !grant\nendproperty\nassert_p_ReqValidGrantCheck:assert property (p_ReqValidGrantCheck) else $error(\"\");", "task_id": "1_8001", "predict_sva": "@(posedge clk)         (req_valid && !hi_prio && !round_robin) |-> !grant"}
{"id": "366_1_0524", "name": "p_temp_not_ready_no_adc_start_posedge", "sva": "@(posedge clk_sys)     !temp_ready |-> !adc_start", "ori_sva": "property p_temp_not_ready_no_adc_start_posedge;\n@(posedge clk_sys)     !temp_ready |-> !adc_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AdcStart_When_TempNotReady  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!temp_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!adc_start`  ", "sva_signals": ["clk_sys", "[0:0] temp_ready", "[0:0] adc_start"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         !temp_ready |-> !adc_start", "sva_name": "p_temp_not_ready_no_adc_start", "full_property": "property p_AdcStart_When_TempNotReady;\n@(posedge clk_sys)         !temp_ready |-> !adc_start\nendproperty\nassert_p_AdcStart_When_TempNotReady:assert property (p_AdcStart_When_TempNotReady) else $error(\"\");", "task_id": "1_8045", "predict_sva": "@(posedge clk_sys)     !temp_ready |-> !adc_start"}
{"sva": "@(posedge clk) disable iff(emergency_response_drill) rescue_chamber_life_support |-> ($past(oxygen_concentration_level) < life_sustaining_threshold) && ($past(co2_scrubber_capacity_remaining) == scrubber_exhausted)", "sva_description": "### Assertion description:  \n**Property Name**: p_rescue_chamber_life_support  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (emergency_response_drill)`  \n**Antecedent (LHS of Implication)**: `rescue_chamber_life_support == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(oxygen_concentration_level) < life_sustaining_threshold) && ($past(co2_scrubber_capacity_remaining) == scrubber_exhausted)`  \n\nThe assertion checks that whenever `rescue_chamber_life_support` is active (high), the following two conditions must hold based on past values:  \n1. The past value of `oxygen_concentration_level` must be below the `life_sustaining_threshold`.  \n2. The past value of `co2_scrubber_capacity_remaining` must indicate the scrubber is exhausted (`scrubber_exhausted`).  \nThe assertion is disabled during an `emergency_response_drill`.", "sva_signals": ["clk", "rst_n", "[0:0] emergency_response_drill", "[0:0] rescue_chamber_life_support", "[0:0] oxygen_concentration_level", "[0:0] life_sustaining_threshold", "[0:0] co2_scrubber_capacity_remaining", "[0:0] scrubber_exhausted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (emergency_response_drill)     rescue_chamber_life_support == 1'b1 |->      ($past(oxygen_concentration_level) < life_sustaining_threshold) &&      ($past(co2_scrubber_capacity_remaining) == scrubber_exhausted)", "sva_name": "p_Rescue_Chamber_Life_Support", "id": "3503", "full_property": "property p_rescue_chamber_life_support;\n@(posedge clk) disable iff (emergency_response_drill)     rescue_chamber_life_support == 1'b1 |->      ($past(oxygen_concentration_level) < life_sustaining_threshold) &&      ($past(co2_scrubber_capacity_remaining) == scrubber_exhausted)\nendproperty\nassert_p_rescue_chamber_life_support:assert property (p_rescue_chamber_life_support) else $error(\"\");", "task_id": "1_7085", "predict_sva": "@(posedge clk) disable iff (emergency_response_drill)     rescue_chamber_life_support == 1'b1 |->      ($past(oxygen_concentration_level) < life_sustaining_threshold) &&     ($past(co2_scrubber_capacity_remaining) == scrubber_exhausted)"}
{"sva": "@(negedge clk_plasma_physics) disable iff(magnetic_reconnection_event_detected) plasma_confinement_stability |-> ($past(plasma_beta_parameter_monitoring) && $past(magnetohydrodynamic_instability_suppression)) && ($past(confinement_time_achievement) == fusion_reactor_performance_target_inadequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_plasma_confinement_stability_check  \n**Trigger Condition**: At every falling edge of `clk_plasma_physics`  \n**Disable Condition**: `disable iff (magnetic_reconnection_event_detected)`  \n**Antecedent (LHS of Implication)**: `plasma_confinement_stability == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(plasma_beta_parameter_monitoring) && $past(magnetohydrodynamic_instability_suppression)) && ($past(confinement_time_achievement) == fusion_reactor_performance_target_inadequacy)`  ", "sva_signals": ["clk_plasma_physics", "magnetic_reconnection_event_detected", "[0:0] plasma_confinement_stability", "[0:0] plasma_beta_parameter_monitoring", "[0:0] magnetohydrodynamic_instability_suppression", "[0:0] confinement_time_achievement", "[0:0] fusion_reactor_performance_target_inadequacy"], "clock": "clk_plasma_physics", "attempts_left": 10, "sva_result": "@(negedge clk_plasma_physics) disable iff (magnetic_reconnection_event_detected)     plasma_confinement_stability == 1'b1 |->     ($past(plasma_beta_parameter_monitoring) && $past(magnetohydrodynamic_instability_suppression)) &&      ($past(confinement_time_achievement) == fusion_reactor_performance_target_inadequacy)", "sva_name": "p_plasma_confinement_stability_check", "id": "3871", "full_property": "property p_plasma_confinement_stability_check;\n@(negedge clk_plasma_physics) disable iff (magnetic_reconnection_event_detected)     plasma_confinement_stability == 1'b1 |->     ($past(plasma_beta_parameter_monitoring) && $past(magnetohydrodynamic_instability_suppression)) &&      ($past(confinement_time_achievement) == fusion_reactor_performance_target_inadequacy)\nendproperty\nassert_p_plasma_confinement_stability_check:assert property (p_plasma_confinement_stability_check) else $error(\"\");", "task_id": "1_7443", "predict_sva": "@(negedge clk_plasma_physics) disable iff (magnetic_reconnection_event_detected)     plasma_confinement_stability == 1'b1 |->      ($past(plasma_beta_parameter_monitoring) && $past(magnetohydrodynamic_instability_suppression)) &&     ($past(confinement_time_achievement) == fusion_reactor_performance_target_inadequacy)"}
{"id": "320_8_0177", "name": "p_parity_error_with_status", "sva": "@(posedge clk_signal)     (even_parity ^ odd_parity) |-> error_status == 1", "ori_sva": "property p_parity_error_with_status;\n@(posedge clk_signal)     (even_parity ^ odd_parity) |-> error_status == 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Error_Status  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(even_parity ^ odd_parity)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_status == 1`  \n\n", "sva_signals": ["clk_signal", "[0:0] even_parity", "[0:0] odd_parity", "[0:0] error_status"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (even_parity ^ odd_parity) |-> error_status == 1", "sva_name": "p_Parity_Error_Check", "full_property": "property p_Parity_Error_Status;\n@(posedge clk_signal)         (even_parity ^ odd_parity) |-> error_status == 1\nendproperty\nassert_p_Parity_Error_Status:assert property (p_Parity_Error_Status) else $error(\"\");", "task_id": "1_7752", "predict_sva": "@(posedge clk_signal)     (even_parity ^ odd_parity) |-> error_status == 1"}
{"id": "366_2_0543", "name": "p_temp_not_ready_no_adc_start_negedge", "sva": "@(negedge clk_sys)     !temp_ready |-> !adc_start", "ori_sva": "property p_temp_not_ready_no_adc_start_negedge;\n@(negedge clk_sys)     !temp_ready |-> !adc_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_ready_adc_start  \n**Trigger Condition**: At every falling edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!temp_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!adc_start`", "sva_signals": ["clk_sys", "temp_ready", "[0:0] adc_start"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(negedge clk_sys)     !temp_ready |-> !adc_start", "sva_name": "p_temp_ready_adc_start", "full_property": "property p_temp_ready_adc_start;\n@(negedge clk_sys)     !temp_ready |-> !adc_start\nendproperty\nassert_p_temp_ready_adc_start:assert property (p_temp_ready_adc_start) else $error(\"\");", "task_id": "1_8046", "predict_sva": "@(negedge clk_sys)     !temp_ready |-> !adc_start"}
{"sva": "@(posedge clk) disable iff(stress_testing_scenario_parameters_outdated) systemic_risk_assessment |-> ($past(financial_institution_interconnectedness_analysis) && $past(contagion_risk_modeling_effectiveness)) && ($past(financial_stability_threat_identification) == systemic_risk_mitigation_preparedness_inadequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_systemic_risk_assessment  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (stress_testing_scenario_parameters_outdated)`  \n**Antecedent (LHS of Implication)**: `systemic_risk_assessment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(financial_institution_interconnectedness_analysis) && $past(contagion_risk_modeling_effectiveness)) && ($past(financial_stability_threat_identification) == systemic_risk_mitigation_preparedness_inadequacy)`  ", "sva_signals": ["clk", "rst_n", "[0:0] stress_testing_scenario_parameters_outdated", "[0:0] systemic_risk_assessment", "[0:0] financial_institution_interconnectedness_analysis", "[0:0] contagion_risk_modeling_effectiveness", "[0:0] financial_stability_threat_identification", "[0:0] systemic_risk_mitigation_preparedness_inadequacy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (stress_testing_scenario_parameters_outdated)     systemic_risk_assessment |->      ($past(financial_institution_interconnectedness_analysis) &&       $past(contagion_risk_modeling_effectiveness)) &&      ($past(financial_stability_threat_identification) == systemic_risk_mitigation_preparedness_inadequacy)", "sva_name": "p_systemic_risk_assessment", "id": "3907", "full_property": "property p_systemic_risk_assessment;\n@(posedge clk) disable iff (stress_testing_scenario_parameters_outdated)     systemic_risk_assessment |->      ($past(financial_institution_interconnectedness_analysis) &&       $past(contagion_risk_modeling_effectiveness)) &&      ($past(financial_stability_threat_identification) == systemic_risk_mitigation_preparedness_inadequacy)\nendproperty\nassert_p_systemic_risk_assessment:assert property (p_systemic_risk_assessment) else $error(\"\");", "task_id": "1_7479", "predict_sva": "@(posedge clk) disable iff (stress_testing_scenario_parameters_outdated)     systemic_risk_assessment |->      ($past(financial_institution_interconnectedness_analysis) &&       $past(contagion_risk_modeling_effectiveness)) &&     ($past(financial_stability_threat_identification) == systemic_risk_mitigation_preparedness_inadequacy)"}
{"sva": "@(posedge clk_green_building) disable iff(!sustainable_material_certification_verification_current) environmentally_responsible_construction |-> $past(sustainable_material_selection_criteria_compliance) && ($past(environmental_impact_reduction_quantification) < green_construction_performance_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Environmentally_Responsible_Construction  \n**Trigger Condition**: At every rising edge of the `clk_green_building`  \n**Disable Condition**: disable iff (`!sustainable_material_certification_verification_current`)  \n**Antecedent (LHS of Implication)**: `environmentally_responsible_construction == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sustainable_material_selection_criteria_compliance) && ($past(environmental_impact_reduction_quantification) < green_construction_performance_target)`  \n\nThe assertion checks that whenever `environmentally_responsible_construction` is active (true), the following conditions must hold:  \n1. The past value of `sustainable_material_selection_criteria_compliance` must be true.  \n2. The past value of `environmental_impact_reduction_quantification` must be less than the current `green_construction_performance_target`.  \nThe assertion is disabled if `sustainable_material_certification_verification_current` is false.", "sva_signals": ["clk_green_building", "sustainable_material_certification_verification_current", "[0:0] environmentally_responsible_construction", "[0:0] sustainable_material_selection_criteria_compliance", "[0:0] environmental_impact_reduction_quantification", "[0:0] green_construction_performance_target"], "clock": "clk_green_building", "attempts_left": 10, "sva_result": "@(posedge clk_green_building) disable iff (!sustainable_material_certification_verification_current)     environmentally_responsible_construction == 1'b1 |->      $past(sustainable_material_selection_criteria_compliance) &&      ($past(environmental_impact_reduction_quantification) < green_construction_performance_target)", "sva_name": "p_Environmentally_Responsible_Construction", "id": "3804", "full_property": "property p_Environmentally_Responsible_Construction;\n@(posedge clk_green_building) disable iff (!sustainable_material_certification_verification_current)     environmentally_responsible_construction == 1'b1 |->      $past(sustainable_material_selection_criteria_compliance) &&      ($past(environmental_impact_reduction_quantification) < green_construction_performance_target)\nendproperty\nassert_p_Environmentally_Responsible_Construction:assert property (p_Environmentally_Responsible_Construction) else $error(\"\");", "task_id": "1_7378", "predict_sva": "@(posedge clk_green_building) disable iff (!sustainable_material_certification_verification_current)     environmentally_responsible_construction == 1'b1 |->      $past(sustainable_material_selection_criteria_compliance) &&      ($past(environmental_impact_reduction_quantification) < green_construction_performance_target)"}
{"id": "348_7_0387", "name": "p_fault_protection_delay", "sva": "@(posedge clk_sys)     sensitive_op_active |-> ##[1:3] fault_detected", "ori_sva": "property p_fault_protection_delay;\n@(posedge clk_sys)     sensitive_op_active |-> ##[1:3] fault_detected;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fault_Detection_After_Sensitive_Op  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensitive_op_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] fault_detected == 1'b1`  ", "sva_signals": ["clk_sys", "[0:0] sensitive_op_active", "[0:0] fault_detected"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     sensitive_op_active == 1'b1 |-> ##[1:3] fault_detected == 1'b1", "sva_name": "fault_detection_during_sensitive_op", "full_property": "property p_Fault_Detection_After_Sensitive_Op;\n@(posedge clk_sys)     sensitive_op_active == 1'b1 |-> ##[1:3] fault_detected == 1'b1\nendproperty\nassert_p_Fault_Detection_After_Sensitive_Op:assert property (p_Fault_Detection_After_Sensitive_Op) else $error(\"\");", "task_id": "1_7933", "predict_sva": "@(posedge clk_sys)     sensitive_op_active == 1'b1 |-> ##[1:3] fault_detected == 1'b1"}
{"id": "334_5_0269", "name": "cfg_lock_no_write_p5", "sva": "@(posedge clk_signal)     cfg_lock && $past(cfg_lock) |-> !$past(reg_write)", "ori_sva": "property cfg_lock_no_write_p5;\n@(posedge clk_signal)     cfg_lock && $past(cfg_lock) |-> !$past(reg_write);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cfg_lock_reg_write  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cfg_lock && $past(cfg_lock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(reg_write)`", "sva_signals": ["clk_signal", "[0:0] cfg_lock", "[0:0] reg_write"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (cfg_lock && $past(cfg_lock)) |-> !$past(reg_write)", "sva_name": "p_cfg_lock_reg_write", "full_property": "property p_cfg_lock_reg_write;\n@(posedge clk_signal)         (cfg_lock && $past(cfg_lock)) |-> !$past(reg_write)\nendproperty\nassert_p_cfg_lock_reg_write:assert property (p_cfg_lock_reg_write) else $error(\"\");", "task_id": "1_7829", "predict_sva": "@(posedge clk_signal)         cfg_lock && $past(cfg_lock) |-> !$past(reg_write)"}
{"sva": "@(posedge clk_universal_health) disable iff(!global_healthcare_access_equity_framework_implementation_complete) planetary_health_system_integration |-> $past(universal_healthcare_coverage_sustainability_assurance) && ($past(global_health_equity_realization_effectiveness) < planetary_health_optimization_objective_comprehensive_achievement_validation_standard)", "sva_description": "### Assertion description:  \n**Property Name**: p_Planetary_Health_System_Integration  \n**Trigger Condition**: At every rising edge of `clk_universal_health`  \n**Disable Condition**: `disable iff (!global_healthcare_access_equity_framework_implementation_complete)`  \n**Antecedent (LHS of Implication)**: `planetary_health_system_integration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(universal_healthcare_coverage_sustainability_assurance) && ($past(global_health_equity_realization_effectiveness) < planetary_health_optimization_objective_comprehensive_achievement_validation_standard)`  ", "sva_signals": ["clk_universal_health", "global_healthcare_access_equity_framework_implementation_complete", "[0:0] planetary_health_system_integration", "[0:0] universal_healthcare_coverage_sustainability_assurance", "[0:0] global_health_equity_realization_effectiveness", "[0:0] planetary_health_optimization_objective_comprehensive_achievement_validation_standard"], "clock": "clk_universal_health", "attempts_left": 10, "sva_result": "@(posedge clk_universal_health) disable iff (!global_healthcare_access_equity_framework_implementation_complete)     planetary_health_system_integration |->      $past(universal_healthcare_coverage_sustainability_assurance) &&      ($past(global_health_equity_realization_effectiveness) < planetary_health_optimization_objective_comprehensive_achievement_validation_standard)", "sva_name": "p_Planetary_Health_System_Integration", "id": "4043", "full_property": "property p_Planetary_Health_System_Integration;\n@(posedge clk_universal_health) disable iff (!global_healthcare_access_equity_framework_implementation_complete)     planetary_health_system_integration |->      $past(universal_healthcare_coverage_sustainability_assurance) &&      ($past(global_health_equity_realization_effectiveness) < planetary_health_optimization_objective_comprehensive_achievement_validation_standard)\nendproperty\nassert_p_Planetary_Health_System_Integration:assert property (p_Planetary_Health_System_Integration) else $error(\"\");", "task_id": "1_7611", "predict_sva": "@(posedge clk_universal_health) disable iff (!global_healthcare_access_equity_framework_implementation_complete)     planetary_health_system_integration |->          $past(universal_healthcare_coverage_sustainability_assurance) &&          ($past(global_health_equity_realization_effectiveness) < planetary_health_optimization_objective_comprehensive_achievement_validation_standard)"}
{"id": "340_2_0314", "name": "phase_en_sync_2", "sva": "@(posedge clk_signal)     phase1_en && !phase2_en |=> phase2_en", "ori_sva": "property phase_en_sync_2;\n@(posedge clk_signal)     phase1_en && !phase2_en |=> phase2_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Phase_Transition  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phase1_en && !phase2_en`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `phase2_en` (asserted in the next clock cycle)  ", "sva_signals": ["clk_signal", "[0:0] phase1_en", "[0:0] phase2_en"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (phase1_en && !phase2_en) |=> phase2_en", "sva_name": "p_Phase_Transition", "full_property": "property p_Phase_Transition;\n@(posedge clk_signal)         (phase1_en && !phase2_en) |=> phase2_en\nendproperty\nassert_p_Phase_Transition:assert property (p_Phase_Transition) else $error(\"\");", "task_id": "1_7867", "predict_sva": "@(posedge clk_signal)         (phase1_en && !phase2_en) |-> ##1 phase2_en"}
{"sva": "@(negedge clk_plumbing_system) disable iff(!water_supply_connection_authorized) plumbing_pressure_test_protocol |-> ($past(pipe_joint_integrity_inspection_completion) && $past(water_pressure_test_duration_adequate)) && ($past(leak_detection_sensitivity) == detection_threshold_insufficient)", "sva_description": "### Assertion description:  \n**Property Name**: plumbing_pressure_test_protocol  \n**Trigger Condition**: At every falling edge of the `clk_plumbing_system`  \n**Disable Condition**: `disable iff (!water_supply_connection_authorized)`  \n**Antecedent (LHS of Implication)**: `plumbing_pressure_test_protocol`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(pipe_joint_integrity_inspection_completion) && $past(water_pressure_test_duration_adequate)) && ($past(leak_detection_sensitivity) == detection_threshold_insufficient)`  ", "sva_signals": ["clk_plumbing_system", "water_supply_connection_authorized", "plumbing_pressure_test_protocol", "pipe_joint_integrity_inspection_completion", "water_pressure_test_duration_adequate", "leak_detection_sensitivity", "detection_threshold_insufficient"], "clock": "clk_plumbing_system", "attempts_left": 10, "sva_result": "@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)     plumbing_pressure_test_protocol |->          ($past(pipe_joint_integrity_inspection_completion) &&           $past(water_pressure_test_duration_adequate)) &&          ($past(leak_detection_sensitivity) == detection_threshold_insufficient)", "sva_name": "p_Plumbing_Pressure_Test_Protocol", "id": "3771", "full_property": "property plumbing_pressure_test_protocol;\n@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)     plumbing_pressure_test_protocol |->          ($past(pipe_joint_integrity_inspection_completion) &&           $past(water_pressure_test_duration_adequate)) &&          ($past(leak_detection_sensitivity) == detection_threshold_insufficient)\nendproperty\nassert_plumbing_pressure_test_protocol:assert property (plumbing_pressure_test_protocol) else $error(\"\");", "task_id": "1_7347", "predict_sva": "@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)     plumbing_pressure_test_protocol |->          ($past(pipe_joint_integrity_inspection_completion) &&           $past(water_pressure_test_duration_adequate)) &&         ($past(leak_detection_sensitivity) == detection_threshold_insufficient)"}
{"sva": "@(negedge clk_payment_processing) disable iff(!fraud_detection_system_operational) transaction_anomaly_detection |-> ($past(spending_pattern_deviation) && $past(geolocation_anomaly_detected)) && ($past(fraud_score_calculation) < detection_sensitivity_threshold)", "sva_description": "### Assertion description:  \n**Property Name**: p_Transaction_Anomaly_Detection  \n**Trigger Condition**: At every falling edge of the `clk_payment_processing`;  \n**Disable Condition**: disable iff (`!fraud_detection_system_operational`)  \n**Antecedent (LHS of Implication)**: `transaction_anomaly_detection == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of two conditions:  \n  1. `$past(spending_pattern_deviation) && $past(geolocation_anomaly_detected)`  \n  2. `$past(fraud_score_calculation) < detection_sensitivity_threshold`  ", "sva_signals": ["clk_payment_processing", "fraud_detection_system_operational", "[0:0] transaction_anomaly_detection", "[0:0] spending_pattern_deviation", "[0:0] geolocation_anomaly_detected", "[0:0] fraud_score_calculation", "[0:0] detection_sensitivity_threshold"], "clock": "clk_payment_processing", "attempts_left": 10, "sva_result": "@(negedge clk_payment_processing) disable iff (!fraud_detection_system_operational)     transaction_anomaly_detection == 1'b1 |->     ($past(spending_pattern_deviation) && $past(geolocation_anomaly_detected)) &&     ($past(fraud_score_calculation) < detection_sensitivity_threshold)", "sva_name": "p_transaction_anomaly_detection", "id": "3905", "full_property": "property p_Transaction_Anomaly_Detection;\n@(negedge clk_payment_processing) disable iff (!fraud_detection_system_operational)     transaction_anomaly_detection == 1'b1 |->     ($past(spending_pattern_deviation) && $past(geolocation_anomaly_detected)) &&     ($past(fraud_score_calculation) < detection_sensitivity_threshold)\nendproperty\nassert_p_Transaction_Anomaly_Detection:assert property (p_Transaction_Anomaly_Detection) else $error(\"\");", "task_id": "1_7477", "predict_sva": "@(negedge clk_payment_processing) disable iff (!fraud_detection_system_operational)     transaction_anomaly_detection == 1'b1 |->      $past(spending_pattern_deviation) &&      $past(geolocation_anomaly_detected) &&      ($past(fraud_score_calculation) < detection_sensitivity_threshold)"}
{"id": "361_1_0485", "name": "crc_match_when_valid", "sva": "@(posedge clk_crc)     data_valid |-> ((crc_result ^ golden_crc) == 0)", "ori_sva": "property crc_match_when_valid;\n@(posedge clk_crc)     data_valid |-> ((crc_result ^ golden_crc) == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match  \n**Trigger Condition**: At every rising edge of the `clk_crc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `((crc_result ^ golden_crc) == 0)`  \n\n(Note: The assertion checks that whenever `data_valid` is high at a rising edge of `clk_crc`, the XOR result of `crc_result` and `golden_crc` must be zero, indicating they match.)", "sva_signals": ["clk_crc", "[0:0] data_valid", "[0:0] crc_result", "[0:0] golden_crc"], "clock": "clk_crc", "attempts_left": 10, "sva_result": "@(posedge clk_crc)     data_valid == 1'b1 |-> ((crc_result ^ golden_crc) == 0)", "sva_name": "p_CRC_Check", "full_property": "property p_crc_match;\n@(posedge clk_crc)     data_valid == 1'b1 |-> ((crc_result ^ golden_crc) == 0)\nendproperty\nassert_p_crc_match:assert property (p_crc_match) else $error(\"\");", "task_id": "1_8009", "predict_sva": "@(posedge clk_crc)     data_valid == 1'b1 |-> (crc_result ^ golden_crc) == 0"}
{"id": "371_5_0586", "name": "p_dma_start_cond5", "sva": "@(posedge clk_i)     $rose(dma_start_o) |-> dma_en_i && (sw_trigger_i || hw_request_i)", "ori_sva": "property p_dma_start_cond5;\n@(posedge clk_i)     $rose(dma_start_o) |-> dma_en_i && (sw_trigger_i || hw_request_i);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_start_trigger  \n**Trigger Condition**: At every rising edge of the `clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(dma_start_o)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dma_en_i && (sw_trigger_i || hw_request_i)`", "sva_signals": ["clk_i", "rst_n", "[0:0] dma_start_o", "[0:0] dma_en_i", "[0:0] sw_trigger_i", "[0:0] hw_request_i"], "clock": "clk_i", "attempts_left": 10, "sva_result": "@(posedge clk_i)         $rose(dma_start_o) |-> (dma_en_i && (sw_trigger_i || hw_request_i))", "sva_name": "p_dma_start_o_rose", "full_property": "property p_dma_start_trigger;\n@(posedge clk_i)         $rose(dma_start_o) |-> (dma_en_i && (sw_trigger_i || hw_request_i))\nendproperty\nassert_p_dma_start_trigger:assert property (p_dma_start_trigger) else $error(\"\");", "task_id": "1_8086", "predict_sva": "@(posedge clk_i)         $rose(dma_start_o) |-> (dma_en_i && (sw_trigger_i || hw_request_i))"}
{"sva": "@(posedge clk_flooring_installation) disable iff(!subfloor_preparation_quality_verified) floor_finishing_durability_assessment |-> $past(subfloor_flatness_tolerance_measurement) && ($past(flooring_material_installation_specification_adherence) < manufacturer_warranty_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_floor_finishing_durability_assessment  \n**Trigger Condition**: At every rising edge of the `clk_flooring_installation`  \n**Disable Condition**: disable iff (`!subfloor_preparation_quality_verified`)  \n**Antecedent (LHS of Implication)**: `floor_finishing_durability_assessment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(subfloor_flatness_tolerance_measurement) && ($past(flooring_material_installation_specification_adherence) < manufacturer_warranty_requirement)`  \n\nThe assertion checks that whenever `floor_finishing_durability_assessment` is true at a rising clock edge, the following must hold:  \n1. The past value of `subfloor_flatness_tolerance_measurement` must be true (logical AND).  \n2. The past value of `flooring_material_installation_specification_adherence` must be less than `manufacturer_warranty_requirement`.  \nThe assertion is disabled if `subfloor_preparation_quality_verified` is false.", "sva_signals": ["clk_flooring_installation", "subfloor_preparation_quality_verified", "[0:0] floor_finishing_durability_assessment", "[0:0] subfloor_flatness_tolerance_measurement", "[0:0] flooring_material_installation_specification_adherence", "[0:0] manufacturer_warranty_requirement"], "clock": "clk_flooring_installation", "attempts_left": 10, "sva_result": "@(posedge clk_flooring_installation) disable iff (!subfloor_preparation_quality_verified)     floor_finishing_durability_assessment |->          $past(subfloor_flatness_tolerance_measurement) &&          ($past(flooring_material_installation_specification_adherence) < manufacturer_warranty_requirement)", "sva_name": "p_Flooring_Installation_Quality", "id": "3767", "full_property": "property p_floor_finishing_durability_assessment;\n@(posedge clk_flooring_installation) disable iff (!subfloor_preparation_quality_verified)     floor_finishing_durability_assessment |->          $past(subfloor_flatness_tolerance_measurement) &&          ($past(flooring_material_installation_specification_adherence) < manufacturer_warranty_requirement)\nendproperty\nassert_p_floor_finishing_durability_assessment:assert property (p_floor_finishing_durability_assessment) else $error(\"\");", "task_id": "1_7343", "predict_sva": "@(posedge clk_flooring_installation) disable iff (!subfloor_preparation_quality_verified)     floor_finishing_durability_assessment |->          $past(subfloor_flatness_tolerance_measurement) &&          ($past(flooring_material_installation_specification_adherence) < manufacturer_warranty_requirement)"}
{"id": "381_10_0675", "name": "auth_pass_phase1_first", "sva": "@(posedge clk_signal)     $rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3) |-> auth_granted", "ori_sva": "property auth_pass_phase1_first;\n@(posedge clk_signal)     $rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3) |-> auth_granted;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_auth_granted  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `auth_granted`  ", "sva_signals": ["clk_signal", "[0:0] auth_pass_phase1", "[0:0] auth_pass_phase2", "[0:0] auth_pass_phase3", "[0:0] auth_granted"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3) |-> auth_granted", "sva_name": "p_auth_granted_after_phases", "full_property": "property p_auth_granted;\n@(posedge clk_signal)         $rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3) |-> auth_granted\nendproperty\nassert_p_auth_granted:assert property (p_auth_granted) else $error(\"\");", "task_id": "1_8134", "predict_sva": "@(posedge clk_signal)     $rose(auth_pass_phase1) ##1 (auth_pass_phase2 && auth_pass_phase3) |-> auth_granted"}
{"id": "384_8_0714", "name": "cfg_lock_no_write_p8", "sva": "@(posedge clk_signal)     cfg_lock |-> !reg_write[*1:$] until !cfg_lock", "ori_sva": "property cfg_lock_no_write_p8;\n@(posedge clk_signal)     cfg_lock |-> !reg_write[*1:$] until !cfg_lock;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cfg_lock_reg_write  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cfg_lock == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write[*1:$] until !cfg_lock`  ", "sva_signals": ["clk", "rst_n", "[0:0] cfg_lock", "[0:0] reg_write", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     cfg_lock == 1'b1 |-> !reg_write[*1:$] until !cfg_lock", "sva_name": "p_cfg_lock_no_reg_write", "full_property": "property p_cfg_lock_reg_write;\n@(posedge clk_signal)     cfg_lock == 1'b1 |-> !reg_write[*1:$] until !cfg_lock\nendproperty\nassert_p_cfg_lock_reg_write:assert property (p_cfg_lock_reg_write) else $error(\"\");", "task_id": "1_8163", "predict_sva": "@(posedge clk_signal)     cfg_lock == 1'b1 |-> !reg_write until !cfg_lock"}
{"id": "382_2_0707", "name": "ecc_valid_2", "sva": "@(posedge clk_signal)     ecc_enable |=> $past(!(ecc_syndrome ^ 0))", "ori_sva": "property ecc_valid_2;\n@(posedge clk_signal)     ecc_enable |=> $past(!(ecc_syndrome ^ 0));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Ecc_Syndrome_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_enable == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: In the next clock cycle, the past value of `!(ecc_syndrome ^ 0)` must hold (i.e., the past value of `ecc_syndrome` must be zero).  ", "sva_signals": ["clk_signal", "[0:0] ecc_enable", "[0:0] ecc_syndrome"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ecc_enable == 1'b1 |=> $past(!(ecc_syndrome ^ 0)) == 1'b1", "sva_name": "p_ecc_syndrome_check", "full_property": "property p_Ecc_Syndrome_Check;\n@(posedge clk_signal)     ecc_enable == 1'b1 |=> $past(!(ecc_syndrome ^ 0)) == 1'b1\nendproperty\nassert_p_Ecc_Syndrome_Check:assert property (p_Ecc_Syndrome_Check) else $error(\"\");", "task_id": "1_8141", "predict_sva": "@(posedge clk_signal)     ecc_enable == 1'b1 |=> $past(ecc_syndrome) == 0"}
{"id": "302_4_0022", "name": "gated_clk_low_when_disabled_4", "sva": "@(posedge clk)      $stable(!clk_en) |-> !gated_clk", "ori_sva": "property gated_clk_low_when_disabled_4;\n@(posedge clk)      $stable(!clk_en) |-> !gated_clk;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_StableClkEn_GatedClk  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(!clk_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!gated_clk`  ", "sva_signals": ["clk", "rst_n", "[0:0] clk_en", "[0:0] gated_clk"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(!clk_en) |-> !gated_clk", "sva_name": "p_StableClkEn_GatedClk", "full_property": "property p_StableClkEn_GatedClk;\n@(posedge clk)     $stable(!clk_en) |-> !gated_clk\nendproperty\nassert_p_StableClkEn_GatedClk:assert property (p_StableClkEn_GatedClk) else $error(\"\");", "task_id": "1_7636", "predict_sva": "@(posedge clk)    $stable(!clk_en) |-> !gated_clk"}
{"sva": "@(posedge clk) disable iff(underwater_welding_operation_suspended) hyperbaric_chamber_pressure_control |-> ($past(chamber_pressure_rate_change) > safe_decompression_rate) && !$past(pressure_equalization_valve_response, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_Hyperbaric_Chamber_Pressure_Control  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (underwater_welding_operation_suspended)`  \n**Antecedent (LHS of Implication)**: `hyperbaric_chamber_pressure_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `chamber_pressure_rate_change` must be greater than `safe_decompression_rate` (`$past(chamber_pressure_rate_change) > safe_decompression_rate`), **and**  \n- The value of `pressure_equalization_valve_response` two cycles ago must be `0` (`!$past(pressure_equalization_valve_response, 2)`).  \n\nThe assertion ensures that when hyperbaric chamber pressure control is active, the chamber's past pressure rate change exceeds the safe decompression threshold, and the pressure equalization valve was not triggered two cycles prior. The check is suspended during underwater welding operation suspension.", "sva_signals": ["clk", "underwater_welding_operation_suspended", "hyperbaric_chamber_pressure_control", "chamber_pressure_rate_change", "safe_decompression_rate", "pressure_equalization_valve_response"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (underwater_welding_operation_suspended)     hyperbaric_chamber_pressure_control == 1'b1 |->     ($past(chamber_pressure_rate_change) > safe_decompression_rate) &&     (!$past(pressure_equalization_valve_response, 2))", "sva_name": "p_Hyperbaric_Chamber_Pressure_Control", "id": "3575", "full_property": "property p_Hyperbaric_Chamber_Pressure_Control;\n@(posedge clk) disable iff (underwater_welding_operation_suspended)     hyperbaric_chamber_pressure_control == 1'b1 |->     ($past(chamber_pressure_rate_change) > safe_decompression_rate) &&     (!$past(pressure_equalization_valve_response, 2))\nendproperty\nassert_p_Hyperbaric_Chamber_Pressure_Control:assert property (p_Hyperbaric_Chamber_Pressure_Control) else $error(\"\");", "task_id": "1_7157", "predict_sva": "@(posedge clk) disable iff (underwater_welding_operation_suspended)     hyperbaric_chamber_pressure_control == 1'b1 |->      ($past(chamber_pressure_rate_change) > safe_decompression_rate) &&     ($past(pressure_equalization_valve_response, 2) == 0)"}
{"id": "385_7_0712", "name": "bus_contention_check_7", "sva": "@(posedge sys_clk)     (bus_request ^ bus_grant) && !$stable(bus_grant) |-> bus_ack", "ori_sva": "property bus_contention_check_7;\n@(posedge sys_clk)     (bus_request ^ bus_grant) && !$stable(bus_grant) |-> bus_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_ack_after_request_grant_change  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(bus_request ^ bus_grant) && !$stable(bus_grant)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bus_ack`  ", "sva_signals": ["sys_clk", "[0:0] bus_request", "[0:0] bus_grant", "[0:0] bus_ack"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)         ((bus_request ^ bus_grant) && !$stable(bus_grant)) |-> bus_ack", "sva_name": "p_bus_ack_after_grant_change", "full_property": "property p_bus_ack_after_request_grant_change;\n@(posedge sys_clk)         ((bus_request ^ bus_grant) && !$stable(bus_grant)) |-> bus_ack\nendproperty\nassert_p_bus_ack_after_request_grant_change:assert property (p_bus_ack_after_request_grant_change) else $error(\"\");", "task_id": "1_8171", "predict_sva": "@(posedge sys_clk)         ((bus_request ^ bus_grant) && !$stable(bus_grant)) |-> bus_ack"}
{"id": "381_1_0657", "name": "auth_pass_all_phases_consecutive", "sva": "@(posedge clk_signal)     $rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3) |-> auth_granted", "ori_sva": "property auth_pass_all_phases_consecutive;\n@(posedge clk_signal)     $rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3) |-> auth_granted;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Auth_Granted  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `auth_granted`  ", "sva_signals": ["clk", "rst_n", "[0:0] auth_pass_phase1", "[0:0] auth_pass_phase2", "[0:0] auth_pass_phase3", "[0:0] auth_granted", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ($rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3)) |-> auth_granted", "sva_name": "p_auth_granted_after_phases", "full_property": "property p_Auth_Granted;\n@(posedge clk_signal)     ($rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3)) |-> auth_granted\nendproperty\nassert_p_Auth_Granted:assert property (p_Auth_Granted) else $error(\"\");", "task_id": "1_8135", "predict_sva": "@(posedge clk_signal)         ($rose(auth_pass_phase1) && $rose(auth_pass_phase2) && $rose(auth_pass_phase3)) |-> auth_granted"}
{"id": "396_6_0798", "name": "p_low_pwr_clk_gating_6", "sva": "@(posedge clk_sys)     $fell(active_mode) |-> !clock_en", "ori_sva": "property p_low_pwr_clk_gating_6;\n@(posedge clk_sys)     $fell(active_mode) |-> !clock_en\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Clock_Disable_On_Mode_Fall  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(active_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!clock_en`  ", "sva_signals": ["clk_sys", "active_mode", "clock_en"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(active_mode) |-> !clock_en", "sva_name": "p_Clock_Disable_On_Mode_Fall", "full_property": "property p_Clock_Disable_On_Mode_Fall;\n@(posedge clk_sys)     $fell(active_mode) |-> !clock_en\nendproperty\nassert_p_Clock_Disable_On_Mode_Fall:assert property (p_Clock_Disable_On_Mode_Fall) else $error(\"\");", "task_id": "1_8241", "predict_sva": "@(posedge clk_sys)     $fell(active_mode) |-> !clock_en"}
{"id": "370_3_0579", "name": "parity_error_detection_3", "sva": "@(posedge clk_signal)     (even_parity ^ odd_parity) |-> $past(even_parity ^ odd_parity, 1)", "ori_sva": "property parity_error_detection_3;\n@(posedge clk_signal)     (even_parity ^ odd_parity) |-> $past(even_parity ^ odd_parity, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(even_parity ^ odd_parity)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(even_parity ^ odd_parity, 1)`  ", "sva_signals": ["clk_signal", "[0:0] even_parity", "[0:0] odd_parity"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (even_parity ^ odd_parity) |-> $past(even_parity ^ odd_parity, 1)", "sva_name": "p_Parity_Stable", "full_property": "property p_Parity_Check;\n@(posedge clk_signal)     (even_parity ^ odd_parity) |-> $past(even_parity ^ odd_parity, 1)\nendproperty\nassert_p_Parity_Check:assert property (p_Parity_Check) else $error(\"\");", "task_id": "1_8075", "predict_sva": "@(posedge clk_signal)     (even_parity ^ odd_parity) |-> $past(even_parity ^ odd_parity, 1)"}
{"id": "392_5_0781", "name": "p_event_combine_5", "sva": "@(posedge clk_sys)     $stable(event_clkA) || $changed(event_clkB) || $past(event_clkC) |-> error_flag == 1'b0", "ori_sva": "property p_event_combine_5;\n@(posedge clk_sys)     $stable(event_clkA) || $changed(event_clkB) || $past(event_clkC) |-> error_flag == 1'b0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_error_flag_check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(event_clkA) || $changed(event_clkB) || $past(event_clkC)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_flag == 1'b0`  ", "sva_signals": ["clk_sys", "[0:0] event_clkA", "[0:0] event_clkB", "[0:0] event_clkC", "[0:0] error_flag"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($stable(event_clkA) || $changed(event_clkB) || $past(event_clkC)) |-> (error_flag == 1'b0)", "sva_name": "p_Error_Flag_Check", "full_property": "property p_error_flag_check;\n@(posedge clk_sys)     ($stable(event_clkA) || $changed(event_clkB) || $past(event_clkC)) |-> (error_flag == 1'b0)\nendproperty\nassert_p_error_flag_check:assert property (p_error_flag_check) else $error(\"\");", "task_id": "1_8210", "predict_sva": "@(posedge clk_sys)     ($stable(event_clkA) || $changed(event_clkB) || $past(event_clkC)) |-> error_flag == 1'b0"}
{"id": "401_2_0823", "name": "mode_sel_test_mode", "sva": "@(posedge clk_signal)     (mode_sel == 2'b01) |-> (test_mode && !normal_mode && !debug_mode)", "ori_sva": "property mode_sel_test_mode;\n@(posedge clk_signal)     (mode_sel == 2'b01) |-> (test_mode && !normal_mode && !debug_mode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mode_sel_check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mode_sel == 2'b01`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `test_mode && !normal_mode && !debug_mode`", "sva_signals": ["clk_signal", "[1:0] mode_sel", "[0:0] test_mode", "[0:0] normal_mode", "[0:0] debug_mode"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     mode_sel == 2'b01 |-> test_mode && !normal_mode && !debug_mode", "sva_name": "p_mode_sel_check", "full_property": "property p_mode_sel_check;\n@(posedge clk_signal)     mode_sel == 2'b01 |-> test_mode && !normal_mode && !debug_mode\nendproperty\nassert_p_mode_sel_check:assert property (p_mode_sel_check) else $error(\"\");", "task_id": "1_8272", "predict_sva": "@(posedge clk_signal)     mode_sel == 2'b01 |-> test_mode && !normal_mode && !debug_mode"}
{"id": "398_3_0819", "name": "fault_protection_p3", "sva": "@(negedge clk_signal)     disable iff (!rst_n)     sensitive_op_active |-> fault_detected == 0", "ori_sva": "property fault_protection_p3;\n@(negedge clk_signal)     disable iff (!rst_n)     sensitive_op_active |-> fault_detected == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fault_Check_On_Sensitive_Op  \n**Trigger Condition**: At every falling edge of the `clk_signal`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `sensitive_op_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fault_detected == 0`", "sva_signals": ["clk_signal", "rst_n", "[0:0] sensitive_op_active", "[0:0] fault_detected"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(negedge clk_signal) disable iff (!rst_n)         sensitive_op_active == 1'b1 |-> fault_detected == 0", "sva_name": "p_Sensitive_Op_No_Fault", "full_property": "property p_Fault_Check_On_Sensitive_Op;\n@(negedge clk_signal) disable iff (!rst_n)         sensitive_op_active == 1'b1 |-> fault_detected == 0\nendproperty\nassert_p_Fault_Check_On_Sensitive_Op:assert property (p_Fault_Check_On_Sensitive_Op) else $error(\"\");", "task_id": "1_8249", "predict_sva": "@(negedge clk_signal) disable iff (!rst_n)     sensitive_op_active == 1'b1 |-> !fault_detected"}
{"id": "401_4_0829", "name": "invalid_mode_combination", "sva": "@(posedge clk_signal)     (mode_sel == 2'b11) |-> (!normal_mode && !test_mode && !debug_mode)", "ori_sva": "property invalid_mode_combination;\n@(posedge clk_signal)     (mode_sel == 2'b11) |-> (!normal_mode && !test_mode && !debug_mode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Mode_Sel_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mode_sel == 2'b11`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(!normal_mode && !test_mode && !debug_mode)`", "sva_signals": ["clk_signal", "[1:0] mode_sel", "[0:0] normal_mode", "[0:0] test_mode", "[0:0] debug_mode"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     mode_sel == 2'b11 |-> (!normal_mode && !test_mode && !debug_mode)", "sva_name": "p_Mode_Selection_Check", "full_property": "property p_Mode_Sel_Check;\n@(posedge clk_signal)     mode_sel == 2'b11 |-> (!normal_mode && !test_mode && !debug_mode)\nendproperty\nassert_p_Mode_Sel_Check:assert property (p_Mode_Sel_Check) else $error(\"\");", "task_id": "1_8274", "predict_sva": "@(posedge clk_signal)     mode_sel == 2'b11 |-> (!normal_mode && !test_mode && !debug_mode)"}
{"id": "371_7_0599", "name": "p_dma_start_cond7", "sva": "@(posedge clk_i)     disable iff (!rst_n_i)     (sw_trigger_i || hw_request_i) && !dma_start_o |=> dma_en_i |-> dma_start_o", "ori_sva": "property p_dma_start_cond7;\n@(posedge clk_i)     disable iff (!rst_n_i)     (sw_trigger_i || hw_request_i) && !dma_start_o |=> dma_en_i |-> dma_start_o;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_DMA_Start_Trigger  \n**Trigger Condition**: At every rising edge of `clk_i`  \n**Disable Condition**: `disable iff (!rst_n_i)`  \n**Antecedent (LHS of Implication)**: `(sw_trigger_i || hw_request_i) && !dma_start_o`  \n**Implication Operator**: `|=>` (followed by another implication `|->`)  \n**Consequent (RHS of Implication)**: `dma_en_i |-> dma_start_o`  ", "sva_signals": ["clk_i", "rst_n_i", "[0:0] sw_trigger_i", "[0:0] hw_request_i", "[0:0] dma_start_o", "[0:0] dma_en_i"], "clock": "clk_i", "attempts_left": 10, "sva_result": "@(posedge clk_i) disable iff (!rst_n_i)         ((sw_trigger_i || hw_request_i) && !dma_start_o) |=> (dma_en_i |-> dma_start_o)", "sva_name": "p_dma_trigger", "full_property": "property p_DMA_Start_Trigger;\n@(posedge clk_i) disable iff (!rst_n_i)         ((sw_trigger_i || hw_request_i) && !dma_start_o) |=> (dma_en_i |-> dma_start_o)\nendproperty\nassert_p_DMA_Start_Trigger:assert property (p_DMA_Start_Trigger) else $error(\"\");", "task_id": "1_8088", "predict_sva": "@(posedge clk_i) disable iff (!rst_n_i)     ((sw_trigger_i || hw_request_i) && !dma_start_o) |-> ##1 (dma_en_i |-> dma_start_o)"}
{"sva": "@(posedge clk_space_based_manufacturing) disable iff(zero_gravity_production_process_optimization_incomplete) orbital_industrial_facility |-> $past(manufacturing_quality_advantage_demonstration) && ($past(space_manufactured_product_commercial_competitiveness) < orbital_manufacturing_economic_justification_threshold)", "sva_description": "### Assertion description:  \n**Property Name**: p_Orbital_Industrial_Facility_Quality_Check  \n**Trigger Condition**: At every rising edge of the `clk_space_based_manufacturing`  \n**Disable Condition**: `disable iff (zero_gravity_production_process_optimization_incomplete)`  \n**Antecedent (LHS of Implication)**: `orbital_industrial_facility == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(manufacturing_quality_advantage_demonstration) && ($past(space_manufactured_product_commercial_competitiveness) < orbital_manufacturing_economic_justification_threshold)`  ", "sva_signals": ["clk_space_based_manufacturing", "zero_gravity_production_process_optimization_incomplete", "orbital_industrial_facility", "manufacturing_quality_advantage_demonstration", "space_manufactured_product_commercial_competitiveness", "orbital_manufacturing_economic_justification_threshold"], "clock": "clk_space_based_manufacturing", "attempts_left": 10, "sva_result": "@(posedge clk_space_based_manufacturing)     disable iff (zero_gravity_production_process_optimization_incomplete)     orbital_industrial_facility == 1'b1 |->         $past(manufacturing_quality_advantage_demonstration) &&          ($past(space_manufactured_product_commercial_competitiveness) < orbital_manufacturing_economic_justification_threshold)", "sva_name": "p_Orbital_Manufacturing_Quality_Check", "id": "3975", "full_property": "property p_Orbital_Industrial_Facility_Quality_Check;\n@(posedge clk_space_based_manufacturing)     disable iff (zero_gravity_production_process_optimization_incomplete)     orbital_industrial_facility == 1'b1 |->         $past(manufacturing_quality_advantage_demonstration) &&          ($past(space_manufactured_product_commercial_competitiveness) < orbital_manufacturing_economic_justification_threshold)\nendproperty\nassert_p_Orbital_Industrial_Facility_Quality_Check:assert property (p_Orbital_Industrial_Facility_Quality_Check) else $error(\"\");", "task_id": "1_7546", "predict_sva": "@(posedge clk_space_based_manufacturing) disable iff (zero_gravity_production_process_optimization_incomplete)     orbital_industrial_facility == 1'b1 |->      $past(manufacturing_quality_advantage_demonstration) &&      ($past(space_manufactured_product_commercial_competitiveness) < orbital_manufacturing_economic_justification_threshold)"}
{"id": "393_4_0764", "name": "secure_access_p4", "sva": "@(posedge clk_main)     $rose(secure_region) |-> !untrusted_access", "ori_sva": "property secure_access_p4;\n@(posedge clk_main)     $rose(secure_region) |-> !untrusted_access;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Secure_Region_Access  \n**Trigger Condition**: At every rising edge of the `clk_main`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(secure_region)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!untrusted_access`  \n\nThe assertion checks that whenever the `secure_region` signal transitions from low to high (i.e., at its rising edge), there should be no `untrusted_access` occurring at the same time. This ensures that untrusted access is prohibited when entering a secure region.", "sva_signals": ["clk_main", "secure_region", "untrusted_access"], "clock": "clk_main", "attempts_left": 10, "sva_result": "@(posedge clk_main)         $rose(secure_region) |-> !untrusted_access", "sva_name": "p_SecureRegion_Access", "full_property": "property p_Secure_Region_Access;\n@(posedge clk_main)         $rose(secure_region) |-> !untrusted_access\nendproperty\nassert_p_Secure_Region_Access:assert property (p_Secure_Region_Access) else $error(\"\");", "task_id": "1_8218", "predict_sva": "@(posedge clk_main)         $rose(secure_region) |-> !untrusted_access"}
{"id": "436_4_1108", "name": "p_aes_rounds_reset", "sva": "@(posedge clk_core)     $rose(aes_rst_ni) |-> (aes_round_cnt_o == 0)", "ori_sva": "property p_aes_rounds_reset;\n@(posedge clk_core)     $rose(aes_rst_ni) |-> (aes_round_cnt_o == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AesRoundCntAfterReset  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(aes_rst_ni)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `aes_round_cnt_o == 0`", "sva_signals": ["clk_core", "[0:0] aes_rst_ni", "[0:0] aes_round_cnt_o"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(aes_rst_ni) |-> aes_round_cnt_o == 0", "sva_name": "p_AesRoundCntAfterReset", "full_property": "property p_AesRoundCntAfterReset;\n@(posedge clk_core)         $rose(aes_rst_ni) |-> aes_round_cnt_o == 0\nendproperty\nassert_p_AesRoundCntAfterReset:assert property (p_AesRoundCntAfterReset) else $error(\"\");", "task_id": "1_8300", "predict_sva": "@(posedge clk_core)     $rose(aes_rst_ni) |-> (aes_round_cnt_o == 0)"}
{"id": "397_8_0815", "name": "p_eventual_xor_match", "sva": "@(posedge clk_signal)     encrypt_mode |-> ##[1:5] (plain_text ^ decrypt_out) == 0", "ori_sva": "property p_eventual_xor_match;\n@(posedge clk_signal)     encrypt_mode |-> ##[1:5] (plain_text ^ decrypt_out) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encrypt_mode_plain_text_match  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encrypt_mode == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 5 clock cycles (`##[1:5]`), the XOR result of `plain_text` and `decrypt_out` must be equal to 0 (`(plain_text ^ decrypt_out) == 0`)  ", "sva_signals": ["clk", "rst_n", "[0:0] encrypt_mode", "[0:0] plain_text", "[0:0] decrypt_out", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     encrypt_mode == 1'b1 |-> ##[1:5] (plain_text ^ decrypt_out) == 0", "sva_name": "p_encrypt_mode_check", "full_property": "property p_encrypt_mode_plain_text_match;\n@(posedge clk_signal)     encrypt_mode == 1'b1 |-> ##[1:5] (plain_text ^ decrypt_out) == 0\nendproperty\nassert_p_encrypt_mode_plain_text_match:assert property (p_encrypt_mode_plain_text_match) else $error(\"\");", "task_id": "1_8247", "predict_sva": "@(posedge clk_signal)     encrypt_mode == 1'b1 |-> ##[1:5] ((plain_text ^ decrypt_out) == 0)"}
{"sva": "@(posedge clk) disable iff(fashion_influencer_collaboration_contract_negotiation) social_media_marketing_effectiveness |-> ($past(brand_engagement_metric_improvement) && $past(target_audience_reach_expansion)) && ($past(marketing_roi_calculation) < campaign_success_profitability_threshold)", "sva_description": "### Assertion description:  \n**Property Name**: p_social_media_marketing_effectiveness  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (fashion_influencer_collaboration_contract_negotiation)`  \n**Antecedent (LHS of Implication)**: `social_media_marketing_effectiveness == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that both `$past(brand_engagement_metric_improvement)` and `$past(target_audience_reach_expansion)` are true (logical AND),  \n- AND the `$past(marketing_roi_calculation)` must be less than the `campaign_success_profitability_threshold`.  \n\nThe assertion checks that when social media marketing is effective, the past brand engagement and audience reach metrics were positive, and the past ROI did not exceed the profitability threshold. The check is disabled during influencer contract negotiations.", "sva_signals": ["clk", "rst_n", "[0:0] fashion_influencer_collaboration_contract_negotiation", "[0:0] social_media_marketing_effectiveness", "[0:0] brand_engagement_metric_improvement", "[0:0] target_audience_reach_expansion", "[0:0] marketing_roi_calculation", "[0:0] campaign_success_profitability_threshold"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (fashion_influencer_collaboration_contract_negotiation)     social_media_marketing_effectiveness == 1'b1 |->     $past(brand_engagement_metric_improvement) &&      $past(target_audience_reach_expansion) &&     ($past(marketing_roi_calculation) < campaign_success_profitability_threshold)", "sva_name": "p_Social_Media_Marketing_Effectiveness", "id": "3685", "full_property": "property p_social_media_marketing_effectiveness;\n@(posedge clk) disable iff (fashion_influencer_collaboration_contract_negotiation)     social_media_marketing_effectiveness == 1'b1 |->     $past(brand_engagement_metric_improvement) &&      $past(target_audience_reach_expansion) &&     ($past(marketing_roi_calculation) < campaign_success_profitability_threshold)\nendproperty\nassert_p_social_media_marketing_effectiveness:assert property (p_social_media_marketing_effectiveness) else $error(\"\");", "task_id": "1_7263", "predict_sva": "@(posedge clk) disable iff (fashion_influencer_collaboration_contract_negotiation)     social_media_marketing_effectiveness == 1'b1 |->      ($past(brand_engagement_metric_improvement) && $past(target_audience_reach_expansion)) &&     ($past(marketing_roi_calculation) < campaign_success_profitability_threshold)"}
{"id": "579_5_0565", "name": "p_simd_access_bounds_fell", "sva": "@(posedge clk)     $fell(simd_access) |-> (elem_idx < VLEN)", "ori_sva": "property p_simd_access_bounds_fell;\n@(posedge clk)     $fell(simd_access) |-> (elem_idx < VLEN);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_access_bounds_fell  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(simd_access)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(elem_idx < VLEN)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_access", "[0:0] elem_idx", "[0:0] VLEN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(simd_access) |-> (elem_idx < VLEN)", "sva_name": "p_simd_access_bounds_fell", "full_property": "property p_simd_access_bounds_fell;\n@(posedge clk)         $fell(simd_access) |-> (elem_idx < VLEN)\nendproperty\nassert_p_simd_access_bounds_fell:assert property (p_simd_access_bounds_fell) else $error(\"\");", "task_id": "1_8695", "predict_sva": "@(posedge clk)     $fell(simd_access) |-> (elem_idx < VLEN) throughout (1)"}
{"sva": "@(posedge clk_drug_delivery) disable iff(patient_physiological_parameter_unstable) targeted_therapy_administration |-> ($past(drug_concentration_monitoring) && $past(therapeutic_window_maintenance)) && ($past(treatment_efficacy_optimization) < personalized_medicine_effectiveness_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Targeted_Therapy_Administration  \n**Trigger Condition**: At every rising edge of the `clk_drug_delivery`  \n**Disable Condition**: `disable iff (patient_physiological_parameter_unstable)`  \n**Antecedent (LHS of Implication)**: `targeted_therapy_administration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(drug_concentration_monitoring) && $past(therapeutic_window_maintenance)) && ($past(treatment_efficacy_optimization) < personalized_medicine_effectiveness_target)`  ", "sva_signals": ["clk_drug_delivery", "patient_physiological_parameter_unstable", "[0:0] targeted_therapy_administration", "[0:0] drug_concentration_monitoring", "[0:0] therapeutic_window_maintenance", "[0:0] treatment_efficacy_optimization", "[0:0] personalized_medicine_effectiveness_target"], "clock": "clk_drug_delivery", "attempts_left": 10, "sva_result": "@(posedge clk_drug_delivery) disable iff (patient_physiological_parameter_unstable)     targeted_therapy_administration |->          ($past(drug_concentration_monitoring) && $past(therapeutic_window_maintenance)) &&          ($past(treatment_efficacy_optimization) < personalized_medicine_effectiveness_target)", "sva_name": "p_Targeted_Therapy_Administration", "id": "3990", "full_property": "property p_Targeted_Therapy_Administration;\n@(posedge clk_drug_delivery) disable iff (patient_physiological_parameter_unstable)     targeted_therapy_administration |->          ($past(drug_concentration_monitoring) && $past(therapeutic_window_maintenance)) &&          ($past(treatment_efficacy_optimization) < personalized_medicine_effectiveness_target)\nendproperty\nassert_p_Targeted_Therapy_Administration:assert property (p_Targeted_Therapy_Administration) else $error(\"\");", "task_id": "1_7560", "predict_sva": "@(posedge clk_drug_delivery) disable iff (patient_physiological_parameter_unstable)     targeted_therapy_administration |->          ($past(drug_concentration_monitoring) && $past(therapeutic_window_maintenance)) &&          ($past(treatment_efficacy_optimization) < personalized_medicine_effectiveness_target)"}
{"id": "348_6_0392", "name": "p_fault_protection_stable", "sva": "@(posedge clk_sys)     $stable(sensitive_op_active) || fault_detected", "ori_sva": "property p_fault_protection_stable;\n@(posedge clk_sys)     $stable(sensitive_op_active) || fault_detected;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_stable_sensitive_op_or_fault  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple concurrent assertion without implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `$stable(sensitive_op_active) || fault_detected`  \n**Description**: The assertion checks that at every positive edge of `clk_sys`, either the value of `sensitive_op_active` remains stable (unchanged from the previous cycle) or `fault_detected` is asserted (true).  \n\nNote: Since this is a simple concurrent assertion without an implication operator (`|->` or `|=>`), it directly evaluates the expression `$stable(sensitive_op_active) || fault_detected` at every clock edge. There is no antecedent-consequent structure in this case.", "sva_signals": ["clk_sys", "[0:0] sensitive_op_active", "[0:0] fault_detected"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $stable(sensitive_op_active) || fault_detected", "sva_name": "p_sensitive_op_active_or_fault", "full_property": "property p_stable_sensitive_op_or_fault;\n@(posedge clk_sys)     $stable(sensitive_op_active) || fault_detected\nendproperty\nassert_p_stable_sensitive_op_or_fault:assert property (p_stable_sensitive_op_or_fault) else $error(\"\");", "task_id": "1_7932", "predict_sva": "@(posedge clk_sys)    $past(sensitive_op_active) == sensitive_op_active || fault_detected"}
{"id": "581_1_0576", "name": "p_simd_store_alignment_posedge", "sva": "@(posedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0)", "ori_sva": "property p_simd_store_alignment_posedge;\n@(posedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_store_alignment_posedge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_store)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mem_addr % VLEN == 0)`", "sva_signals": ["clk", "rst_n", "[0:0] simd_store", "[31:0] mem_addr", "[31:0] VLEN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_store) |-> (mem_addr % VLEN == 0)", "sva_name": "p_simd_store_alignment_rose_posedge", "full_property": "property p_simd_store_alignment_posedge;\n@(posedge clk)         $rose(simd_store) |-> (mem_addr % VLEN == 0)\nendproperty\nassert_p_simd_store_alignment_posedge:assert property (p_simd_store_alignment_posedge) else $error(\"\");", "task_id": "1_8704", "predict_sva": "@(posedge clk)         $rose(simd_store) |-> (mem_addr % VLEN == 0)"}
{"id": "366_6_0561", "name": "p_temp_not_ready_no_adc_start_stable", "sva": "@(posedge clk_sys)     $stable(!temp_ready) |-> !adc_start", "ori_sva": "property p_temp_not_ready_no_adc_start_stable;\n@(posedge clk_sys)     $stable(!temp_ready) |-> !adc_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_StableTempReady_NoAdcStart  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(!temp_ready)` (the value of `!temp_ready` remains unchanged from the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!adc_start` (the signal `adc_start` must be low)", "sva_signals": ["clk_sys", "temp_ready", "adc_start"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $stable(!temp_ready) |-> !adc_start", "sva_name": "p_StableNotTempReady_NoAdcStart", "full_property": "property p_StableTempReady_NoAdcStart;\n@(posedge clk_sys)     $stable(!temp_ready) |-> !adc_start\nendproperty\nassert_p_StableTempReady_NoAdcStart:assert property (p_StableTempReady_NoAdcStart) else $error(\"\");", "task_id": "1_8050", "predict_sva": "@(posedge clk_sys)    $stable(!temp_ready) |-> !adc_start"}
{"id": "602_4_0751", "name": "p_simd_illegal_opcode_changed_posedge", "sva": "@(posedge clk)     $changed(simd_issue) |-> !(illegal_opcode)", "ori_sva": "property p_simd_illegal_opcode_changed_posedge;\n@(posedge clk)     $changed(simd_issue) |-> !(illegal_opcode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_illegal_opcode_changed_posedge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(simd_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(illegal_opcode)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] illegal_opcode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $changed(simd_issue) |-> !(illegal_opcode)", "sva_name": "p_simd_illegal_opcode_change", "full_property": "property p_simd_illegal_opcode_changed_posedge;\n@(posedge clk)     $changed(simd_issue) |-> !(illegal_opcode)\nendproperty\nassert_p_simd_illegal_opcode_changed_posedge:assert property (p_simd_illegal_opcode_changed_posedge) else $error(\"\");", "task_id": "1_8819", "predict_sva": "@(posedge clk)         $changed(simd_issue) |-> !(illegal_opcode)"}
{"id": "599_1_0727", "name": "p_simd_context_switch_consistency_1", "sva": "@(posedge clk_signal)     $rose(context_switch) |-> (vreg_save == vreg_restore)", "ori_sva": "property p_simd_context_switch_consistency_1;\n@(posedge clk_signal)     $rose(context_switch) |-> (vreg_save == vreg_restore);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_context_switch_consistency_1  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(context_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `vreg_save == vreg_restore`", "sva_signals": ["clk_signal", "context_switch", "vreg_save", "vreg_restore"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(context_switch) |-> vreg_save == vreg_restore", "sva_name": "p_simd_context_switch_consistency_6", "full_property": "property p_simd_context_switch_consistency_1;\n@(posedge clk_signal)         $rose(context_switch) |-> vreg_save == vreg_restore\nendproperty\nassert_p_simd_context_switch_consistency_1:assert property (p_simd_context_switch_consistency_1) else $error(\"\");", "task_id": "1_8802", "predict_sva": "@(posedge clk_signal)     $rose(context_switch) |-> (vreg_save == vreg_restore)"}
{"sva": "@(negedge clk_containment_spray) disable iff(!spray_system_operable) fission_product_removal |-> $past(containment_atmosphere_activity) > design_basis_limit && !$past(spray_pumps_started, 9)", "sva_description": "### Assertion description:  \n**Property Name**: p_Fission_Product_Removal_Check  \n**Trigger Condition**: At every falling edge of `clk_containment_spray`  \n**Disable Condition**: `disable iff (!spray_system_operable)`  \n**Antecedent (LHS of Implication)**: `fission_product_removal == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `containment_atmosphere_activity` (sampled at the previous clock edge) must be greater than `design_basis_limit`, **and**  \n- The past value of `spray_pumps_started` (sampled 9 clock cycles earlier) must be `0` (`!$past(spray_pumps_started, 9)`).  \n\n### Notes:  \n- The assertion checks that when `fission_product_removal` is active, the containment atmosphere activity was previously above the design limit, and the spray pumps were not started 9 cycles prior.  \n- The check is disabled if the spray system is inoperable (`!spray_system_operable`).  \n- The evaluation occurs on the **negedge** of `clk_containment_spray`.", "sva_signals": ["clk_containment_spray", "spray_system_operable", "fission_product_removal", "containment_atmosphere_activity", "design_basis_limit", "spray_pumps_started"], "clock": "clk_containment_spray", "attempts_left": 10, "sva_result": "@(negedge clk_containment_spray) disable iff (!spray_system_operable)     fission_product_removal == 1'b1 |->      ($past(containment_atmosphere_activity) > design_basis_limit) &&     (!$past(spray_pumps_started, 9))", "sva_name": "p_Fission_Product_Removal", "id": "3334", "full_property": "property p_Fission_Product_Removal_Check;\n@(negedge clk_containment_spray) disable iff (!spray_system_operable)     fission_product_removal == 1'b1 |->      ($past(containment_atmosphere_activity) > design_basis_limit) &&     (!$past(spray_pumps_started, 9))\nendproperty\nassert_p_Fission_Product_Removal_Check:assert property (p_Fission_Product_Removal_Check) else $error(\"\");", "task_id": "1_6922", "predict_sva": "@(negedge clk_containment_spray) disable iff (!spray_system_operable)     fission_product_removal == 1'b1 |->      ($past(containment_atmosphere_activity) > design_basis_limit) &&     (!$past(spray_pumps_started, 9))"}
{"id": "443_8_1195", "name": "config_reg_reset_p", "sva": "@(posedge clk_signal)     $rose(reset_n) |-> config_reg == 'h0000", "ori_sva": "property config_reg_reset_p;\n@(posedge clk_signal)     $rose(reset_n) |-> config_reg == 'h0000;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_ConfigReg_After_Reset  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `config_reg == 'h0000`  \n\n(Note: This assertion checks that whenever the `reset_n` signal rises (active-high reset deassertion), the `config_reg` should be cleared to 0 in the same clock cycle.)", "sva_signals": ["clk_signal", "reset_n", "[15:0] config_reg"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(reset_n) |-> config_reg == 'h0000", "sva_name": "p_config_reg_reset", "full_property": "property p_ConfigReg_After_Reset;\n@(posedge clk_signal)         $rose(reset_n) |-> config_reg == 'h0000\nendproperty\nassert_p_ConfigReg_After_Reset:assert property (p_ConfigReg_After_Reset) else $error(\"\");", "task_id": "1_8315", "predict_sva": "@(posedge clk_signal)     $rose(reset_n) |-> config_reg == 16'h0000"}
{"id": "468_9_1389", "name": "p_raster_done_window", "sva": "@(posedge clk_core)     triangle_ready |-> ##[1:3] !raster_done", "ori_sva": "property p_raster_done_window;\n@(posedge clk_core)     triangle_ready |-> ##[1:3] !raster_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Triangle_Ready_To_Raster_Done  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `triangle_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 3 clock cycles (`##[1:3]`), `raster_done` must be deasserted (`!raster_done`)  ", "sva_signals": ["clk_core", "[0:0] triangle_ready", "[0:0] raster_done"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     triangle_ready == 1'b1 |-> ##[1:3] !raster_done", "sva_name": "p_Triangle_Ready_Raster_Done", "full_property": "property p_Triangle_Ready_To_Raster_Done;\n@(posedge clk_core)     triangle_ready == 1'b1 |-> ##[1:3] !raster_done\nendproperty\nassert_p_Triangle_Ready_To_Raster_Done:assert property (p_Triangle_Ready_To_Raster_Done) else $error(\"\");", "task_id": "1_8407", "predict_sva": "@(posedge clk_core)     triangle_ready == 1'b1 |-> ##[1:3] !raster_done"}
{"id": "599_2_0707", "name": "p_simd_context_switch_consistency_2", "sva": "@(posedge clk_signal)     context_switch && !$past(context_switch) |-> (vreg_save == vreg_restore)", "ori_sva": "property p_simd_context_switch_consistency_2;\n@(posedge clk_signal)     context_switch && !$past(context_switch) |-> (vreg_save == vreg_restore);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_context_switch_consistency_2  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `context_switch && !$past(context_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `vreg_save == vreg_restore`", "sva_signals": ["clk_signal", "[0:0] context_switch", "[0:0] vreg_save", "[0:0] vreg_restore"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (context_switch && !$past(context_switch)) |-> (vreg_save == vreg_restore)", "sva_name": "p_simd_context_switch_consistency_7", "full_property": "property p_simd_context_switch_consistency_2;\n@(posedge clk_signal)         (context_switch && !$past(context_switch)) |-> (vreg_save == vreg_restore)\nendproperty\nassert_p_simd_context_switch_consistency_2:assert property (p_simd_context_switch_consistency_2) else $error(\"\");", "task_id": "1_8803", "predict_sva": "@(posedge clk_signal)         (context_switch && !$past(context_switch)) |-> (vreg_save == vreg_restore)"}
{"id": "517_3_0103", "name": "p_zq_cal_long_first", "sva": "@(posedge clk_sys)     zq_start |-> ##2 long_cal", "ori_sva": "property p_zq_cal_long_first;\n@(posedge clk_sys)     zq_start |-> ##2 long_cal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_zq_cal_long_first  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `zq_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 long_cal == 1'b1`", "sva_signals": ["clk_sys", "[0:0] zq_start", "[0:0] long_cal"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     zq_start == 1'b1 |-> ##2 long_cal == 1'b1", "sva_name": "p_zq_cal_long_after_start", "full_property": "property p_zq_cal_long_first;\n@(posedge clk_sys)     zq_start == 1'b1 |-> ##2 long_cal == 1'b1\nendproperty\nassert_p_zq_cal_long_first:assert property (p_zq_cal_long_first) else $error(\"\");", "task_id": "1_8620", "predict_sva": "@(posedge clk_sys)     zq_start == 1'b1 |-> ##2 long_cal == 1'b1"}
{"id": "621_1_0880", "name": "simd_segment_underflow_protection_p1", "sva": "@(posedge clk)     $rose(simd_segment_read) |-> (segment_idx >= 0)", "ori_sva": "property simd_segment_underflow_protection_p1;\n@(posedge clk)     $rose(simd_segment_read) |-> (segment_idx >= 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_underflow_protection_p1  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_segment_read)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `segment_idx >= 0`", "sva_signals": ["clk", "rst_n", "[0:0] simd_segment_read", "[0:0] segment_idx"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_segment_read) |-> segment_idx >= 0", "sva_name": "simd_segment_underflow_protection_p6", "full_property": "property simd_segment_underflow_protection_p1;\n@(posedge clk)         $rose(simd_segment_read) |-> segment_idx >= 0\nendproperty\nassert_simd_segment_underflow_protection_p1:assert property (simd_segment_underflow_protection_p1) else $error(\"\");", "task_id": "1_8924", "predict_sva": "@(posedge clk)         $rose(simd_segment_read) |-> (segment_idx >= 0)"}
{"id": "389_4_0742", "name": "p_reset_source_valid_4", "sva": "@(posedge clk)     reset_active |-> (ext_reset || wdt_reset || !power_good) throughout reset_active", "ori_sva": "property p_reset_source_valid_4;\n@(posedge clk)     reset_active |-> (ext_reset || wdt_reset || !power_good) throughout reset_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Reset_Active  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reset_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(ext_reset || wdt_reset || !power_good) throughout reset_active`  ", "sva_signals": ["clk", "rst_n", "[0:0] reset_active", "[0:0] ext_reset", "[0:0] wdt_reset", "[0:0] power_good"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         reset_active |-> (ext_reset || wdt_reset || !power_good) throughout reset_active", "sva_name": "p_Reset_Active_Condition", "full_property": "property p_Reset_Active;\n@(posedge clk)         reset_active |-> (ext_reset || wdt_reset || !power_good) throughout reset_active\nendproperty\nassert_p_Reset_Active:assert property (p_Reset_Active) else $error(\"\");", "task_id": "1_8189", "predict_sva": "@(posedge clk)    reset_active throughout (ext_reset || wdt_reset || !power_good)"}
{"id": "621_8_0903", "name": "simd_segment_underflow_protection_p8", "sva": "@(posedge clk)     $rose(simd_segment_read) |-> (segment_idx >= 0) and (1'b1)", "ori_sva": "property simd_segment_underflow_protection_p8;\n@(posedge clk)     $rose(simd_segment_read) |-> (segment_idx >= 0) and (1'b1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_underflow_protection_p8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_segment_read)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(segment_idx >= 0) and (1'b1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_segment_read", "[31:0] segment_idx"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_segment_read) |-> (segment_idx >= 0) and (1'b1)", "sva_name": "simd_segment_underflow_protection_p6", "full_property": "property simd_segment_underflow_protection_p8;\n@(posedge clk)         $rose(simd_segment_read) |-> (segment_idx >= 0) and (1'b1)\nendproperty\nassert_simd_segment_underflow_protection_p8:assert property (simd_segment_underflow_protection_p8) else $error(\"\");", "task_id": "1_8931", "predict_sva": "@(posedge clk)         $rose(simd_segment_read) |-> (segment_idx >= 0)"}
{"id": "632_6_0971", "name": "p_write_mask_transition_to_zero", "sva": "@(posedge clk_signal)     ($past(write_mask != '0) && (write_mask == '0)) |-> !write_en", "ori_sva": "property p_write_mask_transition_to_zero;\n@(posedge clk_signal)     ($past(write_mask != '0) && (write_mask == '0)) |-> !write_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_write_mask_transition_to_zero  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `($past(write_mask != '0) && (write_mask == '0))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!write_en`  \n\n", "sva_signals": ["clk", "rst_n", "write_mask", "write_en", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ($past(write_mask != '0) && (write_mask == '0)) |-> !write_en", "sva_name": "p_write_mask_transition", "full_property": "property p_write_mask_transition_to_zero;\n@(posedge clk_signal)     ($past(write_mask != '0) && (write_mask == '0)) |-> !write_en\nendproperty\nassert_p_write_mask_transition_to_zero:assert property (p_write_mask_transition_to_zero) else $error(\"\");", "task_id": "1_8969", "predict_sva": "@(posedge clk_signal)         ($past(write_mask) != '0 && write_mask == '0) |-> !write_en"}
{"id": "521_2_0147", "name": "weight_load_followed_by_window_shift", "sva": "@(posedge clk_signal)     weight_load |-> ##[1:2] window_shift", "ori_sva": "property weight_load_followed_by_window_shift;\n@(posedge clk_signal)     weight_load |-> ##[1:2] window_shift;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: weight_load_followed_by_window_shift  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `weight_load == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] window_shift == 1'b1`  \n\n(Note: The consequent specifies that within 1 to 2 clock cycles after the antecedent is true, `window_shift` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] weight_load", "[0:0] window_shift", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         weight_load == 1'b1 |-> ##[1:2] window_shift == 1'b1", "sva_name": "weight_load_implies_shift", "full_property": "property weight_load_followed_by_window_shift;\n@(posedge clk_signal)         weight_load == 1'b1 |-> ##[1:2] window_shift == 1'b1\nendproperty\nassert_weight_load_followed_by_window_shift:assert property (weight_load_followed_by_window_shift) else $error(\"\");", "task_id": "1_8632", "predict_sva": "@(posedge clk_signal)     weight_load == 1'b1 |-> ##[1:2] window_shift == 1'b1"}
{"id": "608_7_0783", "name": "p_simd_multicore_consistency_ack", "sva": "@(posedge clk)     simd_multicore_issue && simd_multicore_ack |-> (core0_out == core1_out)", "ori_sva": "property p_simd_multicore_consistency_ack;\n@(posedge clk)     simd_multicore_issue && simd_multicore_ack |-> (core0_out == core1_out);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_multicore_consistency_ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `simd_multicore_issue && simd_multicore_ack`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `core0_out == core1_out`", "sva_signals": ["clk", "rst_n", "[0:0] simd_multicore_issue", "[0:0] simd_multicore_ack", "[0:0] core0_out", "[0:0] core1_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (simd_multicore_issue && simd_multicore_ack) |-> (core0_out == core1_out)", "sva_name": "p_simd_multicore_consistency_delay", "full_property": "property p_simd_multicore_consistency_ack;\n@(posedge clk)     (simd_multicore_issue && simd_multicore_ack) |-> (core0_out == core1_out)\nendproperty\nassert_p_simd_multicore_consistency_ack:assert property (p_simd_multicore_consistency_ack) else $error(\"\");", "task_id": "1_8852", "predict_sva": "@(posedge clk)         (simd_multicore_issue && simd_multicore_ack) |-> (core0_out == core1_out)"}
{"id": "635_2_0998", "name": "p_no_overlap_addr_2", "sva": "@(posedge clk)     read_en && write_en |-> read_addr != write_addr", "ori_sva": "property p_no_overlap_addr_2;\n@(posedge clk)     read_en && write_en |-> read_addr != write_addr;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_overlap_addr_2  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `read_en && write_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `read_addr != write_addr`", "sva_signals": ["clk", "rst_n", "[0:0] read_en", "[0:0] write_en", "read_addr", "write_addr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (read_en && write_en) |-> (read_addr != write_addr)", "sva_name": "p_no_overlap_addr_7", "full_property": "property p_no_overlap_addr_2;\n@(posedge clk)         (read_en && write_en) |-> (read_addr != write_addr)\nendproperty\nassert_p_no_overlap_addr_2:assert property (p_no_overlap_addr_2) else $error(\"\");", "task_id": "1_8988", "predict_sva": "@(posedge clk)         (read_en && write_en) |-> !(read_addr == write_addr)"}
{"id": "637_1_1002", "name": "can_len_legal_p1", "sva": "@(posedge can_clk)     can_len <= CAN_MAX_LEN", "ori_sva": "property can_len_legal_p1;\n@(posedge can_clk)     can_len <= CAN_MAX_LEN;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_len_legal_p1  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Assertion Condition**: `can_len <= CAN_MAX_LEN`  \n\n(Note: This assertion is a simple property check without an implication operator. It directly verifies that `can_len` is always less than or equal to `CAN_MAX_LEN` at every rising edge of `can_clk`.)", "sva_signals": ["can_clk", "[0:0] can_len", "[0:0] CAN_MAX_LEN"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     can_len <= CAN_MAX_LEN", "sva_name": "can_len_legal_p6", "full_property": "property can_len_legal_p1;\n@(posedge can_clk)     can_len <= CAN_MAX_LEN\nendproperty\nassert_can_len_legal_p1:assert property (can_len_legal_p1) else $error(\"\");", "task_id": "1_9000", "predict_sva": "@(posedge can_clk)         !(can_len > CAN_MAX_LEN)"}
{"id": "630_9_0969", "name": "p_burst_len_legal_9", "sva": "@(posedge clk_mem)     (wr_enable && !$past(wr_enable)) |-> burst_len inside {[1:MAX_BURST]}", "ori_sva": "property p_burst_len_legal_9;\n@(posedge clk_mem)     (wr_enable && !$past(wr_enable)) |-> burst_len inside {[1:MAX_BURST]};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_burst_len_legal_9  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wr_enable && !$past(wr_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `burst_len inside {[1:MAX_BURST]}`", "sva_signals": ["clk_mem", "wr_enable", "[0:0] burst_len", "[0:0] MAX_BURST"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)     (wr_enable && !$past(wr_enable)) |-> burst_len inside {[1:MAX_BURST]}", "sva_name": "p_burst_len_legal_6", "full_property": "property p_burst_len_legal_9;\n@(posedge clk_mem)     (wr_enable && !$past(wr_enable)) |-> burst_len inside {[1:MAX_BURST]}\nendproperty\nassert_p_burst_len_legal_9:assert property (p_burst_len_legal_9) else $error(\"\");", "task_id": "1_8964", "predict_sva": "@(posedge clk_mem)         (wr_enable && !$past(wr_enable)) |-> burst_len inside {[1:MAX_BURST]}"}
{"id": "635_8_1017", "name": "p_no_overlap_addr_8", "sva": "@(posedge clk)     read_en && write_en |-> ##1 read_addr != $past(write_addr)", "ori_sva": "property p_no_overlap_addr_8;\n@(posedge clk)     read_en && write_en |-> ##1 read_addr != $past(write_addr);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_overlap_addr_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `read_en && write_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 read_addr != $past(write_addr)`", "sva_signals": ["clk", "rst_n", "[0:0] read_en", "[0:0] write_en", "[0:0] read_addr", "[0:0] write_addr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (read_en && write_en) |-> ##1 (read_addr != $past(write_addr))", "sva_name": "p_no_overlap_addr_5", "full_property": "property p_no_overlap_addr_8;\n@(posedge clk)         (read_en && write_en) |-> ##1 (read_addr != $past(write_addr))\nendproperty\nassert_p_no_overlap_addr_8:assert property (p_no_overlap_addr_8) else $error(\"\");", "task_id": "1_8993", "predict_sva": "@(posedge clk)         (read_en && write_en) |=> (read_addr != $past(write_addr))"}
{"id": "633_4_0982", "name": "ecc_syndrome_stable_with_no_error", "sva": "@(posedge clk)     $stable(ecc_syndrome) && !ecc_error |-> $stable(ecc_syndrome)", "ori_sva": "property ecc_syndrome_stable_with_no_error;\n@(posedge clk)     $stable(ecc_syndrome) && !ecc_error |-> $stable(ecc_syndrome);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_syndrome_stable_with_no_error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(ecc_syndrome) && !ecc_error`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(ecc_syndrome)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] ecc_error", "[0:0] ecc_syndrome"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($stable(ecc_syndrome) && !ecc_error) |-> $stable(ecc_syndrome)", "sva_name": "ecc_stable_when_no_error_p6", "full_property": "property ecc_syndrome_stable_with_no_error;\n@(posedge clk)         ($stable(ecc_syndrome) && !ecc_error) |-> $stable(ecc_syndrome)\nendproperty\nassert_ecc_syndrome_stable_with_no_error:assert property (ecc_syndrome_stable_with_no_error) else $error(\"\");", "task_id": "1_8973", "predict_sva": "@(posedge clk)     ($stable(ecc_syndrome) && !ecc_error) |=> $stable(ecc_syndrome)"}
{"id": "637_7_1042", "name": "can_len_legal_p7", "sva": "@(posedge can_clk)     can_frame_complete |-> $past(can_len) <= CAN_MAX_LEN", "ori_sva": "property can_len_legal_p7;\n@(posedge can_clk)     can_frame_complete |-> $past(can_len) <= CAN_MAX_LEN;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_len_legal_p7  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_frame_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(can_len) <= CAN_MAX_LEN`  ", "sva_signals": ["can_clk", "[0:0] can_frame_complete", "[0:0] can_len", "[0:0] CAN_MAX_LEN"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_frame_complete == 1'b1 |-> $past(can_len) <= CAN_MAX_LEN", "sva_name": "can_len_legal_p7", "full_property": "property can_len_legal_p7;\n@(posedge can_clk)         can_frame_complete == 1'b1 |-> $past(can_len) <= CAN_MAX_LEN\nendproperty\nassert_can_len_legal_p7:assert property (can_len_legal_p7) else $error(\"\");", "task_id": "1_9006", "predict_sva": "@(posedge can_clk)     can_frame_complete == 1'b1 |-> $past(can_len) <= CAN_MAX_LEN"}
{"id": "647_1_1118", "name": "p_thread_switch_context_saved_rose", "sva": "@(posedge clk_core)     $rose(thread_switch_req) |-> (thread_context_saved == 1'b1)", "ori_sva": "property p_thread_switch_context_saved_rose;\n@(posedge clk_core)     $rose(thread_switch_req) |-> (thread_context_saved == 1'b1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_thread_switch_context_saved_rose  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(thread_switch_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `thread_context_saved == 1'b1`", "sva_signals": ["clk_core", "[0:0] thread_switch_req", "[0:0] thread_context_saved"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(thread_switch_req) |-> thread_context_saved == 1'b1", "sva_name": "p_thread_switch_context_saved", "full_property": "property p_thread_switch_context_saved_rose;\n@(posedge clk_core)     $rose(thread_switch_req) |-> thread_context_saved == 1'b1\nendproperty\nassert_p_thread_switch_context_saved_rose:assert property (p_thread_switch_context_saved_rose) else $error(\"\");", "task_id": "1_9040", "predict_sva": "@(posedge clk_core)         $rose(thread_switch_req) |-> thread_context_saved == 1'b1"}
{"id": "622_10_0906", "name": "p_norm_max_abs_packet_end", "sva": "@(posedge clk)     end_packet |-> $past(max_abs_data, 2) < norm_max", "ori_sva": "property p_norm_max_abs_packet_end;\n@(posedge clk)     end_packet |-> $past(max_abs_data, 2) < norm_max;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_norm_max_abs_packet_end  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `end_packet == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(max_abs_data, 2) < norm_max`  \n\n(Note: The assertion checks that when `end_packet` is high, the value of `max_abs_data` two clock cycles earlier must be less than `norm_max`.)", "sva_signals": ["clk", "rst_n", "[0:0] end_packet", "[0:0] norm_max", "[0:0] max_abs_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         end_packet == 1'b1 |-> $past(max_abs_data, 2) < norm_max", "sva_name": "p_norm_max_abs_check", "full_property": "property p_norm_max_abs_packet_end;\n@(posedge clk)         end_packet == 1'b1 |-> $past(max_abs_data, 2) < norm_max\nendproperty\nassert_p_norm_max_abs_packet_end:assert property (p_norm_max_abs_packet_end) else $error(\"\");", "task_id": "1_8932", "predict_sva": "@(posedge clk)         end_packet == 1'b1 |-> $past(max_abs_data, 2) < norm_max"}
{"id": "661_7_1261", "name": "sync_detected_p7", "sva": "@(posedge clk_signal)     sync_search_window |-> ##[1:8] sync_detected", "ori_sva": "property sync_detected_p7;\n@(posedge clk_signal)     sync_search_window |-> ##[1:8] sync_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sync_detected_p7  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_search_window`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] sync_detected`  ", "sva_signals": ["clk_signal", "sync_search_window", "[0:0] sync_detected"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         sync_search_window |-> ##[1:8] sync_detected", "sva_name": "sync_pulse_detection", "full_property": "property sync_detected_p7;\n@(posedge clk_signal)         sync_search_window |-> ##[1:8] sync_detected\nendproperty\nassert_sync_detected_p7:assert property (sync_detected_p7) else $error(\"\");", "task_id": "1_9130", "predict_sva": "@(posedge clk_signal)     sync_search_window |-> ##[1:8] sync_detected"}
{"id": "661_3_1257", "name": "sync_detected_p3", "sva": "@(posedge clk_signal)     sync_enable && !sync_detected |-> ##[0:5] sync_detected", "ori_sva": "property sync_detected_p3;\n@(posedge clk_signal)     sync_enable && !sync_detected |-> ##[0:5] sync_detected\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: sync_detected_p3  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_enable && !sync_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:5] sync_detected`  ", "sva_signals": ["clk_signal", "[0:0] sync_enable", "[0:0] sync_detected"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (sync_enable && !sync_detected) |-> ##[0:5] sync_detected", "sva_name": "sync_detected_p6", "full_property": "property sync_detected_p3;\n@(posedge clk_signal)     (sync_enable && !sync_detected) |-> ##[0:5] sync_detected\nendproperty\nassert_sync_detected_p3:assert property (sync_detected_p3) else $error(\"\");", "task_id": "1_9128", "predict_sva": "@(posedge clk_signal)         (sync_enable && !sync_detected) |-> ##[0:5] sync_detected"}
{"id": "623_2_0930", "name": "batch_norm_delay_check", "sva": "@(posedge clk)     disable iff (!rst_n)     valid_in |=> (batchnorm_out == $past(scale * input_data + bias, 1))", "ori_sva": "property batch_norm_delay_check;\n@(posedge clk)     disable iff (!rst_n)     valid_in |=> (batchnorm_out == $past(scale * input_data + bias, 1));\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: batch_norm_delay_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `valid_in`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `batchnorm_out == $past(scale * input_data + bias, 1)`  \n\nThe assertion checks that if `valid_in` is true at a clock edge, then in the next cycle (`|=>`), `batchnorm_out` should equal the past value of `scale * input_data + bias` (delayed by 1 cycle). The assertion is disabled when `rst_n` is low.", "sva_signals": ["clk", "rst_n", "valid_in", "batchnorm_out", "scale", "input_data", "bias"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     valid_in |=> batchnorm_out == $past(scale * input_data + bias, 1)", "sva_name": "batch_norm_stable_after_valid", "full_property": "property batch_norm_delay_check;\n@(posedge clk) disable iff (!rst_n)     valid_in |=> batchnorm_out == $past(scale * input_data + bias, 1)\nendproperty\nassert_batch_norm_delay_check:assert property (batch_norm_delay_check) else $error(\"\");", "task_id": "1_8940", "predict_sva": "@(posedge clk) disable iff (!rst_n)     valid_in |=> batchnorm_out == ($past(scale)*$past(input_data)+$past(bias))"}
{"id": "652_2_1129", "name": "tlp_header_length_nonzero", "sva": "@(posedge clk_tlp)     tlp_header_valid |-> (tlp_length != 0)", "ori_sva": "property tlp_header_length_nonzero;\n@(posedge clk_tlp)     tlp_header_valid |-> (tlp_length != 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: tlp_header_length_nonzero  \n**Trigger Condition**: At every rising edge of the `clk_tlp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_header_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tlp_length != 0`", "sva_signals": ["clk_tlp", "[0:0] tlp_header_valid", "[15:0] tlp_length"], "clock": "clk_tlp", "attempts_left": 10, "sva_result": "@(posedge clk_tlp)         tlp_header_valid == 1'b1 |-> tlp_length != 0", "sva_name": "tlp_header_consistent_with_payload", "full_property": "property tlp_header_length_nonzero;\n@(posedge clk_tlp)         tlp_header_valid == 1'b1 |-> tlp_length != 0\nendproperty\nassert_tlp_header_length_nonzero:assert property (tlp_header_length_nonzero) else $error(\"\");", "task_id": "1_9074", "predict_sva": "@(posedge clk_tlp)     tlp_header_valid == 1'b1 |-> tlp_length != 0"}
{"id": "658_1_1232", "name": "ldpc_check_pass_p1", "sva": "@(posedge clk_sys)     $rose(ldpc_check_enable) |-> ##[1:10] (ldpc_check_result == 1'b1)", "ori_sva": "property ldpc_check_pass_p1;\n@(posedge clk_sys)     $rose(ldpc_check_enable) |-> ##[1:10] (ldpc_check_result == 1'b1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ldpc_check_pass_p1  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ldpc_check_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] (ldpc_check_result == 1'b1)`  ", "sva_signals": ["clk_sys", "ldpc_check_enable", "[0:0] ldpc_check_result"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $rose(ldpc_check_enable) |-> ##[1:10] (ldpc_check_result == 1'b1)", "sva_name": "ldpc_check_pass_p6", "full_property": "property ldpc_check_pass_p1;\n@(posedge clk_sys)     $rose(ldpc_check_enable) |-> ##[1:10] (ldpc_check_result == 1'b1)\nendproperty\nassert_ldpc_check_pass_p1:assert property (ldpc_check_pass_p1) else $error(\"\");", "task_id": "1_9110", "predict_sva": "@(posedge clk_sys)     $rose(ldpc_check_enable) |-> ##[1:10] (ldpc_check_result == 1'b1)"}
{"id": "660_9_1221", "name": "p_pdcch_alloc_sync_with_enable", "sva": "@(posedge clk_signal)     alloc_enable |-> $onehot(pdcch_alloc)", "ori_sva": "property p_pdcch_alloc_sync_with_enable;\n@(posedge clk_signal)     alloc_enable |-> $onehot(pdcch_alloc);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pdcch_alloc_sync_with_enable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `alloc_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(pdcch_alloc)`  \n\n(Note: `$onehot(pdcch_alloc)` ensures that exactly one bit in `pdcch_alloc` is set to 1 at any given time.)", "sva_signals": ["clk_signal", "[0:0] alloc_enable", "[0:0] pdcch_alloc"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         alloc_enable == 1'b1 |-> $onehot(pdcch_alloc)", "sva_name": "p_pdcch_alloc_unique_per_slot", "full_property": "property p_pdcch_alloc_sync_with_enable;\n@(posedge clk_signal)         alloc_enable == 1'b1 |-> $onehot(pdcch_alloc)\nendproperty\nassert_p_pdcch_alloc_sync_with_enable:assert property (p_pdcch_alloc_sync_with_enable) else $error(\"\");", "task_id": "1_9124", "predict_sva": "@(posedge clk_signal)     alloc_enable == 1'b1 |-> $onehot(pdcch_alloc)"}
{"id": "670_7_1316", "name": "p_wavelength_power_on_default", "sva": "@(posedge clk_3d)     (power_on_reset |-> (wavelength_tune == WL_DEFAULT))", "ori_sva": "property p_wavelength_power_on_default;\n@(posedge clk_3d)     (power_on_reset |-> (wavelength_tune == WL_DEFAULT));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wavelength_power_on_default  \n**Trigger Condition**: At every rising edge of the `clk_3d`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_on_reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wavelength_tune == WL_DEFAULT`", "sva_signals": ["clk_3d", "power_on_reset", "[0:0] wavelength_tune", "[0:0] WL_DEFAULT"], "clock": "clk_3d", "attempts_left": 10, "sva_result": "@(posedge clk_3d)     power_on_reset |-> wavelength_tune == WL_DEFAULT", "sva_name": "p_power_on_reset_wavelength", "full_property": "property p_wavelength_power_on_default;\n@(posedge clk_3d)     power_on_reset |-> wavelength_tune == WL_DEFAULT\nendproperty\nassert_p_wavelength_power_on_default:assert property (p_wavelength_power_on_default) else $error(\"\");", "task_id": "1_9181", "predict_sva": "@(posedge clk_3d)     power_on_reset |-> wavelength_tune == WL_DEFAULT"}
{"id": "675_1_1379", "name": "kernel_stride_equality_p", "sva": "@(posedge clk_i)     $rose(kernel_enable_i) |-> (kernel_pos_next_o - kernel_pos_now_o) == stride_i", "ori_sva": "property kernel_stride_equality_p;\n@(posedge clk_i)     $rose(kernel_enable_i) |-> (kernel_pos_next_o - kernel_pos_now_o) == stride_i;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: kernel_stride_equality_p  \n**Trigger Condition**: At every rising edge of the `clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(kernel_enable_i)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(kernel_pos_next_o - kernel_pos_now_o) == stride_i`  ", "sva_signals": ["clk_i", "kernel_enable_i", "kernel_pos_next_o", "kernel_pos_now_o", "stride_i"], "clock": "clk_i", "attempts_left": 10, "sva_result": "@(posedge clk_i)     $rose(kernel_enable_i) |-> (kernel_pos_next_o - kernel_pos_now_o) == stride_i", "sva_name": "kernel_stride_consistency_p5", "full_property": "property kernel_stride_equality_p;\n@(posedge clk_i)     $rose(kernel_enable_i) |-> (kernel_pos_next_o - kernel_pos_now_o) == stride_i\nendproperty\nassert_kernel_stride_equality_p:assert property (kernel_stride_equality_p) else $error(\"\");", "task_id": "1_9208", "predict_sva": "@(posedge clk_i)     $rose(kernel_enable_i) |-> (kernel_pos_next_o - kernel_pos_now_o) == stride_i"}
{"id": "676_3_1391", "name": "p_activation_out_range_3", "sva": "@(posedge clk)     !$isunknown(activation_out) && activation_ready |-> activation_out <= 1", "ori_sva": "property p_activation_out_range_3;\n@(posedge clk)     !$isunknown(activation_out) && activation_ready |-> activation_out <= 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_activation_out_range_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!$isunknown(activation_out) && activation_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `activation_out <= 1`", "sva_signals": ["clk", "rst_n", "[0:0] activation_out", "[0:0] activation_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !$isunknown(activation_out) && activation_ready |-> activation_out <= 1", "sva_name": "p_activation_out_range_6", "full_property": "property p_activation_out_range_3;\n@(posedge clk)         !$isunknown(activation_out) && activation_ready |-> activation_out <= 1\nendproperty\nassert_p_activation_out_range_3:assert property (p_activation_out_range_3) else $error(\"\");", "task_id": "1_9217", "predict_sva": "@(posedge clk)         (!$isunknown(activation_out) && activation_ready) |-> (activation_out <= 1)"}
{"id": "715_4_1714", "name": "pim_mode_switch_completion_4", "sva": "@(posedge clk)     $changed(pim_mode_switch) |-> pim_op_done", "ori_sva": "property pim_mode_switch_completion_4;\n@(posedge clk)     $changed(pim_mode_switch) |-> pim_op_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pim_mode_switch_completion_4  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(pim_mode_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pim_op_done`", "sva_signals": ["clk", "rst_n", "[0:0] pim_mode_switch", "[0:0] pim_op_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $changed(pim_mode_switch) |-> pim_op_done", "sva_name": "pim_mode_switch_completion_6", "full_property": "property pim_mode_switch_completion_4;\n@(posedge clk)         $changed(pim_mode_switch) |-> pim_op_done\nendproperty\nassert_pim_mode_switch_completion_4:assert property (pim_mode_switch_completion_4) else $error(\"\");", "task_id": "1_9377", "predict_sva": "@(posedge clk)         $changed(pim_mode_switch) |-> pim_op_done"}
{"id": "648_8_1143", "name": "mul_result_overflow_check_p8", "sva": "@(posedge clk)     disable iff (!rst_n)     $rose(mul_busy) |-> ##[1:$] $fell(mul_busy) && (mul_result <= MUL_MAX && mul_result >= MUL_MIN)", "ori_sva": "property mul_result_overflow_check_p8;\n@(posedge clk)     disable iff (!rst_n)     $rose(mul_busy) |-> ##[1:$] $fell(mul_busy) && (mul_result <= MUL_MAX && mul_result >= MUL_MIN);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mul_result_overflow_check_p8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$rose(mul_busy)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:$] $fell(mul_busy) && (mul_result <= MUL_MAX && mul_result >= MUL_MIN)`  ", "sva_signals": ["clk", "rst_n", "[0:0] mul_busy", "[0:0] MUL_MAX", "[0:0] MUL_MIN", "[0:0] mul_result"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     $rose(mul_busy) |-> ##[1:$] $fell(mul_busy) && (mul_result <= MUL_MAX && mul_result >= MUL_MIN)", "sva_name": "p_mul_result_after_busy", "full_property": "property mul_result_overflow_check_p8;\n@(posedge clk) disable iff (!rst_n)     $rose(mul_busy) |-> ##[1:$] $fell(mul_busy) && (mul_result <= MUL_MAX && mul_result >= MUL_MIN)\nendproperty\nassert_mul_result_overflow_check_p8:assert property (mul_result_overflow_check_p8) else $error(\"\");", "task_id": "1_9050", "predict_sva": "@(posedge clk) disable iff (!rst_n)    $rose(mul_busy) |-> ##[0:$] $fell(mul_busy) ##0 (mul_result <= MUL_MAX && mul_result >= MUL_MIN)"}
{"id": "666_5_1290", "name": "p_sparse_ratio_pipeline_check", "sva": "@(posedge clk)     (valid_in && ready_out) |-> ##1 (sparse_ratio <= MAX_SPARSE)", "ori_sva": "property p_sparse_ratio_pipeline_check;\n@(posedge clk)     (valid_in && ready_out) |-> ##1 (sparse_ratio <= MAX_SPARSE);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sparse_ratio_pipeline_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `valid_in && ready_out`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (sparse_ratio <= MAX_SPARSE)`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid_in", "[0:0] ready_out", "[0:0] sparse_ratio", "[0:0] MAX_SPARSE"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     valid_in && ready_out |-> ##1 (sparse_ratio <= MAX_SPARSE)", "sva_name": "p_sparse_ratio_control", "full_property": "property p_sparse_ratio_pipeline_check;\n@(posedge clk)     valid_in && ready_out |-> ##1 (sparse_ratio <= MAX_SPARSE)\nendproperty\nassert_p_sparse_ratio_pipeline_check:assert property (p_sparse_ratio_pipeline_check) else $error(\"\");", "task_id": "1_9158", "predict_sva": "@(posedge clk)         valid_in && ready_out |-> ##1 sparse_ratio <= MAX_SPARSE"}
{"sva": "@(negedge clk_leaching) disable iff(heap_leach_pad_liner_breach) in_situ_leaching_recovery |-> ($past(leaching_solution_concentration) && $past(ore_permeability_adequate)) && ($past(metal_extraction_rate) == zero_recovery_detected)", "sva_description": "### Assertion description:  \n**Property Name**: p_in_situ_leaching_recovery  \n**Trigger Condition**: At every falling edge of the `clk_leaching`  \n**Disable Condition**: disable iff (`heap_leach_pad_liner_breach`)  \n**Antecedent (LHS of Implication)**: `in_situ_leaching_recovery == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(leaching_solution_concentration) && $past(ore_permeability_adequate)` must be true, and  \n- `$past(metal_extraction_rate) == zero_recovery_detected` must hold.  \n\nThe assertion checks that when in-situ leaching recovery is active (`in_situ_leaching_recovery` is high), the following conditions must be true at the previous clock cycle:  \n1. Both the leaching solution concentration and ore permeability were adequate.  \n2. The metal extraction rate was equal to the `zero_recovery_detected` value.  \nThe assertion is disabled if `heap_leach_pad_liner_breach` is active.", "sva_signals": ["clk_leaching", "heap_leach_pad_liner_breach", "in_situ_leaching_recovery", "leaching_solution_concentration", "ore_permeability_adequate", "metal_extraction_rate", "zero_recovery_detected"], "clock": "clk_leaching", "attempts_left": 10, "sva_result": "@(negedge clk_leaching) disable iff (heap_leach_pad_liner_breach)     in_situ_leaching_recovery == 1'b1 |->     ($past(leaching_solution_concentration) && $past(ore_permeability_adequate)) &&     ($past(metal_extraction_rate) == zero_recovery_detected)", "sva_name": "p_InSituLeachingRecovery", "id": "3541", "full_property": "property p_in_situ_leaching_recovery;\n@(negedge clk_leaching) disable iff (heap_leach_pad_liner_breach)     in_situ_leaching_recovery == 1'b1 |->     ($past(leaching_solution_concentration) && $past(ore_permeability_adequate)) &&     ($past(metal_extraction_rate) == zero_recovery_detected)\nendproperty\nassert_p_in_situ_leaching_recovery:assert property (p_in_situ_leaching_recovery) else $error(\"\");", "task_id": "1_7123", "predict_sva": "@(negedge clk_leaching) disable iff (heap_leach_pad_liner_breach)     in_situ_leaching_recovery == 1'b1 |->      ($past(leaching_solution_concentration) && $past(ore_permeability_adequate))     && ($past(metal_extraction_rate) == zero_recovery_detected)"}
{"id": "701_2_1609", "name": "p_hazard_no_reg_write_2", "sva": "@(posedge clk_core)     $rose(pipeline_hazard) |-> !reg_write_en throughout pipeline_hazard", "ori_sva": "property p_hazard_no_reg_write_2;\n@(posedge clk_core)     $rose(pipeline_hazard) |-> !reg_write_en throughout pipeline_hazard;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hazard_no_reg_write_2  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pipeline_hazard)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write_en throughout pipeline_hazard`  ", "sva_signals": ["clk_core", "rst_n", "[0:0] pipeline_hazard", "[0:0] reg_write_en"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(pipeline_hazard) |-> !reg_write_en throughout pipeline_hazard", "sva_name": "p_hazard_no_reg_write_7", "full_property": "property p_hazard_no_reg_write_2;\n@(posedge clk_core)         $rose(pipeline_hazard) |-> !reg_write_en throughout pipeline_hazard\nendproperty\nassert_p_hazard_no_reg_write_2:assert property (p_hazard_no_reg_write_2) else $error(\"\");", "task_id": "1_9316", "predict_sva": "@(posedge clk_core)         $rose(pipeline_hazard) |-> !reg_write_en throughout pipeline_hazard"}
{"id": "716_7_1723", "name": "reram_write_pulse_p", "sva": "@(posedge reram_clk)     $fell(reram_write_enable) |-> reram_cell_state == expected_state", "ori_sva": "property reram_write_pulse_p;\n@(posedge reram_clk)     $fell(reram_write_enable) |-> reram_cell_state == expected_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: reram_write_pulse_p  \n**Trigger Condition**: At every posedge of the `reram_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(reram_write_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `reram_cell_state == expected_state`", "sva_signals": ["reram_clk", "reram_write_enable", "reram_cell_state", "expected_state"], "clock": "reram_clk", "attempts_left": 10, "sva_result": "@(posedge reram_clk)         $fell(reram_write_enable) |-> reram_cell_state == expected_state", "sva_name": "reram_write_transition_check", "full_property": "property reram_write_pulse_p;\n@(posedge reram_clk)         $fell(reram_write_enable) |-> reram_cell_state == expected_state\nendproperty\nassert_reram_write_pulse_p:assert property (reram_write_pulse_p) else $error(\"\");", "task_id": "1_9385", "predict_sva": "@(posedge reram_clk)     $fell(reram_write_enable) |-> ##0 reram_cell_state == expected_state"}
{"id": "701_1_1585", "name": "p_hazard_no_reg_write_1", "sva": "@(posedge clk_core)     pipeline_hazard |-> !reg_write_en", "ori_sva": "property p_hazard_no_reg_write_1;\n@(posedge clk_core)     pipeline_hazard |-> !reg_write_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hazard_no_reg_write_1  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_hazard == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write_en`", "sva_signals": ["clk_core", "[0:0] pipeline_hazard", "[0:0] reg_write_en"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         pipeline_hazard == 1'b1 |-> !reg_write_en", "sva_name": "p_no_write_during_hazard", "full_property": "property p_hazard_no_reg_write_1;\n@(posedge clk_core)         pipeline_hazard == 1'b1 |-> !reg_write_en\nendproperty\nassert_p_hazard_no_reg_write_1:assert property (p_hazard_no_reg_write_1) else $error(\"\");", "task_id": "1_9315", "predict_sva": "@(posedge clk_core)         pipeline_hazard == 1'b1 |-> !reg_write_en"}
{"id": "727_7_1823", "name": "cfg_before_data_valid", "sva": "@(posedge clk_sys)     $rose(quant_valid_out) |-> $past(quant_cfg_valid, 1)", "ori_sva": "property cfg_before_data_valid;\n@(posedge clk_sys)     $rose(quant_valid_out) |-> $past(quant_cfg_valid, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cfg_before_data_valid  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(quant_valid_out)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(quant_cfg_valid, 1)`  ", "sva_signals": ["clk_sys", "[0:0] quant_valid_out", "[0:0] quant_cfg_valid"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(quant_valid_out) |-> $past(quant_cfg_valid, 1)", "sva_name": "quant_valid_after_config", "full_property": "property cfg_before_data_valid;\n@(posedge clk_sys)         $rose(quant_valid_out) |-> $past(quant_cfg_valid, 1)\nendproperty\nassert_cfg_before_data_valid:assert property (cfg_before_data_valid) else $error(\"\");", "task_id": "1_9452", "predict_sva": "@(posedge clk_sys)     $rose(quant_valid_out) |-> $past(quant_cfg_valid, 1)"}
{"id": "664_5_1271", "name": "pim_mode_transition_GEMV", "sva": "@(posedge pim_clk)     disable iff(!rst_n)     (op_mode == GEMV) |=> (op_mode inside {GEMM, ADD, MUL})", "ori_sva": "property pim_mode_transition_GEMV;\n@(posedge pim_clk)     disable iff(!rst_n)     (op_mode == GEMV) |=> (op_mode inside {GEMM, ADD, MUL});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pim_mode_transition_GEMV  \n**Trigger Condition**: At every rising edge of the `pim_clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `op_mode == GEMV`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `op_mode inside {GEMM, ADD, MUL}`", "sva_signals": ["pim_clk", "rst_n", "[1:0] op_mode", "[1:0] GEMV", "[1:0] GEMM", "[1:0] ADD", "[1:0] MUL"], "clock": "pim_clk", "attempts_left": 10, "sva_result": "@(posedge pim_clk) disable iff (!rst_n)     op_mode == GEMV |=> op_mode inside {GEMM, ADD, MUL}", "sva_name": "p_op_mode_transition", "full_property": "property pim_mode_transition_GEMV;\n@(posedge pim_clk) disable iff (!rst_n)     op_mode == GEMV |=> op_mode inside {GEMM, ADD, MUL}\nendproperty\nassert_pim_mode_transition_GEMV:assert property (pim_mode_transition_GEMV) else $error(\"\");", "task_id": "1_9146", "predict_sva": "@(posedge pim_clk) disable iff (!rst_n)     op_mode == GEMV |-> ##1 op_mode inside {GEMM, ADD, MUL}"}
{"id": "720_5_1746", "name": "p_initial_cooling_response", "sva": "@(posedge clk_sys)     thermal_coupling_done && (current_temp > threshold_temp) |-> ##2 (temp_drop_rate > MIN_COOL_RATE)", "ori_sva": "property p_initial_cooling_response;\n@(posedge clk_sys)     thermal_coupling_done && (current_temp > threshold_temp) |-> ##2 (temp_drop_rate > MIN_COOL_RATE);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_initial_cooling_response  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_coupling_done && (current_temp > threshold_temp)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 (temp_drop_rate > MIN_COOL_RATE)`", "sva_signals": ["clk_sys", "[0:0] thermal_coupling_done", "[0:0] current_temp", "[0:0] threshold_temp", "[0:0] temp_drop_rate", "[0:0] MIN_COOL_RATE"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (thermal_coupling_done && (current_temp > threshold_temp)) |-> ##2 (temp_drop_rate > MIN_COOL_RATE)", "sva_name": "p_temp_drop_rate_after_coupling", "full_property": "property p_initial_cooling_response;\n@(posedge clk_sys)     (thermal_coupling_done && (current_temp > threshold_temp)) |-> ##2 (temp_drop_rate > MIN_COOL_RATE)\nendproperty\nassert_p_initial_cooling_response:assert property (p_initial_cooling_response) else $error(\"\");", "task_id": "1_9406", "predict_sva": "@(posedge clk_sys)     (thermal_coupling_done && (current_temp > threshold_temp)) |-> ##2 (temp_drop_rate > MIN_COOL_RATE)"}
{"id": "738_1_1939", "name": "p_err_state_no_new_frame_1", "sva": "@(posedge can_clk)     can_error_state |-> !can_tx_frame_start", "ori_sva": "property p_err_state_no_new_frame_1;\n@(posedge can_clk)     can_error_state |-> !can_tx_frame_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_err_state_no_new_frame_1  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_state`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!can_tx_frame_start`", "sva_signals": ["can_clk", "[0:0] can_error_state", "[0:0] can_tx_frame_start"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_error_state |-> !can_tx_frame_start", "sva_name": "p_err_state_no_new_frame_5", "full_property": "property p_err_state_no_new_frame_1;\n@(posedge can_clk)         can_error_state |-> !can_tx_frame_start\nendproperty\nassert_p_err_state_no_new_frame_1:assert property (p_err_state_no_new_frame_1) else $error(\"\");", "task_id": "1_9488", "predict_sva": "@(posedge can_clk)         can_error_state |-> !can_tx_frame_start"}
{"id": "721_4_1762", "name": "p_wl_step_max_fall", "sva": "@(posedge clk)     (wavelength_now < $past(wavelength_now)) |-> (($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX)", "ori_sva": "property p_wl_step_max_fall;\n@(posedge clk)     (wavelength_now < $past(wavelength_now)) |-> (($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wl_step_max_fall  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(wavelength_now < $past(wavelength_now))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX)`  ", "sva_signals": ["clk", "rst_n", "[0:0] wavelength_now", "[0:0] WL_STEP_MAX"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (wavelength_now < $past(wavelength_now)) |-> (($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX)", "sva_name": "p_wavelength_decrease_step", "full_property": "property p_wl_step_max_fall;\n@(posedge clk)         (wavelength_now < $past(wavelength_now)) |-> (($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX)\nendproperty\nassert_p_wl_step_max_fall:assert property (p_wl_step_max_fall) else $error(\"\");", "task_id": "1_9410", "predict_sva": "@(posedge clk)     wavelength_now < $past(wavelength_now) |-> ($past(wavelength_now) - wavelength_now) <= WL_STEP_MAX"}
{"id": "741_10_1955", "name": "sync_pulse_not_before_frame_end", "sva": "@(posedge clk_signal)     !frame_end throughout (##1 !frame_end [*0:$]) |-> !sync_pulse", "ori_sva": "property sync_pulse_not_before_frame_end;\n@(posedge clk_signal)     !frame_end throughout (##1 !frame_end [*0:$]) |-> !sync_pulse;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sync_pulse_not_before_frame_end  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!frame_end throughout (##1 !frame_end [*0:$])`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!sync_pulse`  ", "sva_signals": ["clk", "rst_n", "[0:0] frame_end", "[0:0] sync_pulse", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     !frame_end throughout (##1 !frame_end [*0:$]) |-> !sync_pulse", "sva_name": "p_No_Sync_Before_Frame_End", "full_property": "property sync_pulse_not_before_frame_end;\n@(posedge clk_signal)     !frame_end throughout (##1 !frame_end [*0:$]) |-> !sync_pulse\nendproperty\nassert_sync_pulse_not_before_frame_end:assert property (sync_pulse_not_before_frame_end) else $error(\"\");", "task_id": "1_9499", "predict_sva": "@(posedge clk_signal)     !sync_pulse throughout !frame_end[*1:$]"}
{"id": "742_9_1962", "name": "p_avb_sync_rising_edge_alignment", "sva": "@(posedge avb_clk)     $rose(avb_sync_signal) |-> ##1 (avb_clock_counter == 0)", "ori_sva": "property p_avb_sync_rising_edge_alignment;\n@(posedge avb_clk)     $rose(avb_sync_signal) |-> ##1 (avb_clock_counter == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_avb_sync_rising_edge_alignment  \n**Trigger Condition**: At every rising edge of the `avb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(avb_sync_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (avb_clock_counter == 0)`", "sva_signals": ["avb_clk", "avb_sync_signal", "[0:0] avb_clock_counter"], "clock": "avb_clk", "attempts_left": 10, "sva_result": "@(posedge avb_clk)     $rose(avb_sync_signal) |-> ##1 (avb_clock_counter == 0)", "sva_name": "p_avb_sync_alignment", "full_property": "property p_avb_sync_rising_edge_alignment;\n@(posedge avb_clk)     $rose(avb_sync_signal) |-> ##1 (avb_clock_counter == 0)\nendproperty\nassert_p_avb_sync_rising_edge_alignment:assert property (p_avb_sync_rising_edge_alignment) else $error(\"\");", "task_id": "1_9511", "predict_sva": "@(posedge avb_clk)     $rose(avb_sync_signal) |-> ##1 (avb_clock_counter == 0)"}
{"id": "750_3_2022", "name": "p_no_write_with_hazard", "sva": "@(posedge clk_pipe)     pipeline_hazard_active |-> !reg_write_enable", "ori_sva": "property p_no_write_with_hazard;\n@(posedge clk_pipe)     pipeline_hazard_active |-> !reg_write_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_write_with_hazard  \n**Trigger Condition**: At every rising edge of the `clk_pipe`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_hazard_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write_enable`  ", "sva_signals": ["clk_pipe", "rst_n", "[0:0] pipeline_hazard_active", "[0:0] reg_write_enable"], "clock": "clk_pipe", "attempts_left": 10, "sva_result": "@(posedge clk_pipe)         pipeline_hazard_active == 1'b1 |-> !reg_write_enable", "sva_name": "p_no_write_during_hazard", "full_property": "property p_no_write_with_hazard;\n@(posedge clk_pipe)         pipeline_hazard_active == 1'b1 |-> !reg_write_enable\nendproperty\nassert_p_no_write_with_hazard:assert property (p_no_write_with_hazard) else $error(\"\");", "task_id": "1_9552", "predict_sva": "@(posedge clk_pipe)         pipeline_hazard_active == 1'b1 |-> !reg_write_enable"}
{"id": "744_2_1964", "name": "p_reg_access_exclusive", "sva": "@(posedge clk_core)     atomic_op_active |-> !(reg_access_grant[1] && reg_access_grant[0])", "ori_sva": "property p_reg_access_exclusive;\n@(posedge clk_core)     atomic_op_active |-> !(reg_access_grant[1] && reg_access_grant[0]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_reg_access_exclusive  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atomic_op_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(reg_access_grant[1] && reg_access_grant[0])`  ", "sva_signals": ["clk_core", "[1:0] reg_access_grant", "[0:0] atomic_op_active"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         atomic_op_active == 1'b1 |-> !(reg_access_grant[1] && reg_access_grant[0])", "sva_name": "atomic_operation_integrity", "full_property": "property p_reg_access_exclusive;\n@(posedge clk_core)         atomic_op_active == 1'b1 |-> !(reg_access_grant[1] && reg_access_grant[0])\nendproperty\nassert_p_reg_access_exclusive:assert property (p_reg_access_exclusive) else $error(\"\");", "task_id": "1_9514", "predict_sva": "@(posedge clk_core)     atomic_op_active == 1'b1 |-> !(reg_access_grant[1] && reg_access_grant[0])"}
{"id": "737_3_1938", "name": "p_idle_bus_z_check3", "sva": "@(posedge clk_signal)     !bus_control_enable |-> ##1 (data_bus === 'bz)", "ori_sva": "property p_idle_bus_z_check3;\n@(posedge clk_signal)     !bus_control_enable |-> ##1 (data_bus === 'bz);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_idle_bus_z_check3  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!bus_control_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (data_bus === 'bz)`  ", "sva_signals": ["clk_signal", "bus_control_enable", "data_bus"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     !bus_control_enable |-> ##1 (data_bus === 'bz)", "sva_name": "p_data_bus_highz_when_disabled", "full_property": "property p_idle_bus_z_check3;\n@(posedge clk_signal)     !bus_control_enable |-> ##1 (data_bus === 'bz)\nendproperty\nassert_p_idle_bus_z_check3:assert property (p_idle_bus_z_check3) else $error(\"\");", "task_id": "1_9486", "predict_sva": "@(posedge clk_signal)     !bus_control_enable |-> ##1 data_bus === 'bz"}
{"id": "753_7_2052", "name": "tlp_length_match_7", "sva": "@(posedge clk_tlp)     (tlp_transfer_finished && !tlp_error) |-> (measured_length == declared_length)", "ori_sva": "property tlp_length_match_7;\n@(posedge clk_tlp)     (tlp_transfer_finished && !tlp_error) |-> (measured_length == declared_length);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: tlp_length_match_7  \n**Trigger Condition**: At every rising edge of the `clk_tlp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_transfer_finished && !tlp_error`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `measured_length == declared_length`", "sva_signals": ["clk_tlp", "tlp_transfer_finished", "tlp_error", "measured_length", "declared_length"], "clock": "clk_tlp", "attempts_left": 10, "sva_result": "@(posedge clk_tlp)         tlp_transfer_finished && !tlp_error |-> measured_length == declared_length", "sva_name": "tlp_length_match_7", "full_property": "property tlp_length_match_7;\n@(posedge clk_tlp)         tlp_transfer_finished && !tlp_error |-> measured_length == declared_length\nendproperty\nassert_tlp_length_match_7:assert property (tlp_length_match_7) else $error(\"\");", "task_id": "1_9576", "predict_sva": "@(posedge clk_tlp)         tlp_transfer_finished && !tlp_error |-> measured_length == declared_length"}
{"id": "754_2_2069", "name": "p_no_new_channel_until_old_released", "sva": "@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel", "ori_sva": "property p_no_new_channel_until_old_released;\n@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_new_channel_until_old_released  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(sel_channel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(release_old_channel) && !ack_old_channel`  ", "sva_signals": ["clk_signal", "[0:0] sel_channel", "[0:0] release_old_channel", "[0:0] ack_old_channel"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel", "sva_name": "p_sel_channel_change", "full_property": "property p_no_new_channel_until_old_released;\n@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel\nendproperty\nassert_p_no_new_channel_until_old_released:assert property (p_no_new_channel_until_old_released) else $error(\"\");", "task_id": "1_9579", "predict_sva": "@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel"}
{"id": "752_7_2033", "name": "flit_retrans_crc_recalc_7", "sva": "@(posedge clk_core)     flit_retrans_in_progress |-> !crc_final_until_retrans_done", "ori_sva": "property flit_retrans_crc_recalc_7;\n@(posedge clk_core)     flit_retrans_in_progress |-> !crc_final_until_retrans_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: flit_retrans_crc_recalc_7  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flit_retrans_in_progress`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!crc_final_until_retrans_done`", "sva_signals": ["clk_core", "flit_retrans_in_progress", "crc_final_until_retrans_done"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         flit_retrans_in_progress |-> !crc_final_until_retrans_done", "sva_name": "flit_retrans_crc_recalc_6", "full_property": "property flit_retrans_crc_recalc_7;\n@(posedge clk_core)         flit_retrans_in_progress |-> !crc_final_until_retrans_done\nendproperty\nassert_flit_retrans_crc_recalc_7:assert property (flit_retrans_crc_recalc_7) else $error(\"\");", "task_id": "1_9568", "predict_sva": "@(posedge clk_core)         flit_retrans_in_progress |-> !crc_final_until_retrans_done"}
{"id": "750_4_2032", "name": "p_hazard_prevents_write", "sva": "@(posedge clk_pipe)     pipeline_hazard_detected |-> ##[1:3] !reg_write_enable", "ori_sva": "property p_hazard_prevents_write;\n@(posedge clk_pipe)     pipeline_hazard_detected |-> ##[1:3] !reg_write_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hazard_prevents_write  \n**Trigger Condition**: At every rising edge of the `clk_pipe`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_hazard_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] !reg_write_enable` (Within 1 to 3 clock cycles after the trigger, `reg_write_enable` must be deasserted (`0`))", "sva_signals": ["clk_pipe", "rst_n", "[0:0] pipeline_hazard_detected", "[0:0] reg_write_enable"], "clock": "clk_pipe", "attempts_left": 10, "sva_result": "@(posedge clk_pipe)     pipeline_hazard_detected == 1'b1 |-> ##[1:3] !reg_write_enable", "sva_name": "p_no_write_during_hazard_7", "full_property": "property p_hazard_prevents_write;\n@(posedge clk_pipe)     pipeline_hazard_detected == 1'b1 |-> ##[1:3] !reg_write_enable\nendproperty\nassert_p_hazard_prevents_write:assert property (p_hazard_prevents_write) else $error(\"\");", "task_id": "1_9553", "predict_sva": "@(posedge clk_pipe)     pipeline_hazard_detected == 1'b1 |-> ##[1:3] !reg_write_enable"}
{"id": "762_5_2138", "name": "p_sequential_access", "sva": "@(posedge clk_matrix)     matrix_element_access |=> (next_element_access == $past(current_element) + 1)", "ori_sva": "property p_sequential_access;\n@(posedge clk_matrix)     matrix_element_access |=> (next_element_access == $past(current_element) + 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sequential_access  \n**Trigger Condition**: At every rising edge of the `clk_matrix`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `matrix_element_access`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `next_element_access == ($past(current_element) + 1)`  ", "sva_signals": ["clk_matrix", "[0:0] matrix_element_access", "[0:0] next_element_access", "[0:0] current_element"], "clock": "clk_matrix", "attempts_left": 10, "sva_result": "@(posedge clk_matrix)     matrix_element_access |=> next_element_access == ($past(current_element) + 1)", "sva_name": "matrix_element_access_order", "full_property": "property p_sequential_access;\n@(posedge clk_matrix)     matrix_element_access |=> next_element_access == ($past(current_element) + 1)\nendproperty\nassert_p_sequential_access:assert property (p_sequential_access) else $error(\"\");", "task_id": "1_9610", "predict_sva": "@(posedge clk_matrix)     matrix_element_access |=> (next_element_access == ($past(current_element) + 1))"}
{"id": "764_8_2176", "name": "pim_mode_switch_completion_8", "sva": "@(posedge pim_clk)     pim_mode_transition |-> pim_prev_mode_ops_finished", "ori_sva": "property pim_mode_switch_completion_8;\n@(posedge pim_clk)     pim_mode_transition |-> pim_prev_mode_ops_finished;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pim_mode_switch_completion_8  \n**Trigger Condition**: At every rising edge of the `pim_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pim_mode_transition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pim_prev_mode_ops_finished`", "sva_signals": ["pim_clk", "[0:0] pim_mode_transition", "[0:0] pim_prev_mode_ops_finished"], "clock": "pim_clk", "attempts_left": 10, "sva_result": "@(posedge pim_clk)     pim_mode_transition |-> pim_prev_mode_ops_finished", "sva_name": "pim_mode_transition_completion_7", "full_property": "property pim_mode_switch_completion_8;\n@(posedge pim_clk)     pim_mode_transition |-> pim_prev_mode_ops_finished\nendproperty\nassert_pim_mode_switch_completion_8:assert property (pim_mode_switch_completion_8) else $error(\"\");", "task_id": "1_9623", "predict_sva": "@(posedge pim_clk)         pim_mode_transition |-> pim_prev_mode_ops_finished"}
{"id": "772_2_2217", "name": "batchnorm_output_range", "sva": "@(posedge clk_core)     bn_valid_out |-> (bn_out >= -3 && bn_out <= 3)", "ori_sva": "property batchnorm_output_range;\n@(posedge clk_core)     bn_valid_out |-> (bn_out >= -3 && bn_out <= 3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: batchnorm_output_range  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bn_valid_out == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(bn_out >= -3 && bn_out <= 3)`", "sva_signals": ["clk_core", "[0:0] bn_valid_out", "[2:0] bn_out"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         bn_valid_out == 1'b1 |-> (bn_out >= -3 && bn_out <= 3)", "sva_name": "normalization_range_check", "full_property": "property batchnorm_output_range;\n@(posedge clk_core)         bn_valid_out == 1'b1 |-> (bn_out >= -3 && bn_out <= 3)\nendproperty\nassert_batchnorm_output_range:assert property (batchnorm_output_range) else $error(\"\");", "task_id": "1_9669", "predict_sva": "@(posedge clk_core)     bn_valid_out == 1'b1 |-> bn_out >= -3 && bn_out <= 3"}
{"id": "761_4_2123", "name": "p_ch_est_iq_balance", "sva": "@(posedge clk_est)     iq_est_enable |-> ((ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM)", "ori_sva": "property p_ch_est_iq_balance;\n@(posedge clk_est)     iq_est_enable |-> ((ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ch_est_iq_balance  \n**Trigger Condition**: At every rising edge of the `clk_est`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `iq_est_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM`  ", "sva_signals": ["clk_est", "rst_n", "[0:0] iq_est_enable", "[15:0] ch_est_i_value", "[15:0] ch_est_q_value", "[16:0] MAX_IQ_SUM"], "clock": "clk_est", "attempts_left": 10, "sva_result": "@(posedge clk_est)     iq_est_enable == 1'b1 |-> (ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM", "sva_name": "p_ch_est_iq_sum", "full_property": "property p_ch_est_iq_balance;\n@(posedge clk_est)     iq_est_enable == 1'b1 |-> (ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM\nendproperty\nassert_p_ch_est_iq_balance:assert property (p_ch_est_iq_balance) else $error(\"\");", "task_id": "1_9607", "predict_sva": "@(posedge clk_est)     iq_est_enable == 1'b1 |-> (ch_est_i_value + ch_est_q_value) <= MAX_IQ_SUM"}
{"id": "754_8_2066", "name": "p_channel_switch_complete", "sva": "@(posedge clk_signal)     $rose(ack_new_channel) |-> $past($fell(ack_old_channel), 1)", "ori_sva": "property p_channel_switch_complete;\n@(posedge clk_signal)     $rose(ack_new_channel) |-> $past($fell(ack_old_channel), 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_channel_switch_complete  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ack_new_channel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past($fell(ack_old_channel), 1)`  ", "sva_signals": ["clk_signal", "ack_new_channel", "ack_old_channel"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(ack_new_channel) |-> $past($fell(ack_old_channel), 1)", "sva_name": "p_Ack_Channel_Transition", "full_property": "property p_channel_switch_complete;\n@(posedge clk_signal)         $rose(ack_new_channel) |-> $past($fell(ack_old_channel), 1)\nendproperty\nassert_p_channel_switch_complete:assert property (p_channel_switch_complete) else $error(\"\");", "task_id": "1_9584", "predict_sva": "@(posedge clk_signal)     $rose(ack_new_channel) |-> $past($fell(ack_old_channel), 1)"}
{"id": "750_6_2028", "name": "p_no_concurrent_write_hazard", "sva": "@(posedge clk_pipe)     !(pipeline_hazard_active && reg_write_enable)", "ori_sva": "property p_no_concurrent_write_hazard;\n@(posedge clk_pipe)     !(pipeline_hazard_active && reg_write_enable);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_concurrent_write_hazard  \n**Trigger Condition**: At every rising edge of `clk_pipe`  \n**Disable Condition**: None  \n**Assertion Expression**: `!(pipeline_hazard_active && reg_write_enable)`  \n\nNote: This is a simple assertion property without an implication operator (`|->` or `|=>`). It directly checks that the condition `!(pipeline_hazard_active && reg_write_enable)` holds true at every rising edge of `clk_pipe`. The assertion fails if both `pipeline_hazard_active` and `reg_write_enable` are simultaneously high.", "sva_signals": ["clk", "rst_n", "[0:0] pipeline_hazard_active", "[0:0] reg_write_enable", "clk_pipe"], "clock": "clk_pipe", "attempts_left": 10, "sva_result": "@(posedge clk_pipe)         !(pipeline_hazard_active && reg_write_enable)", "sva_name": "p_no_concurrent_write_hazard", "full_property": "property p_no_concurrent_write_hazard;\n@(posedge clk_pipe)         !(pipeline_hazard_active && reg_write_enable)\nendproperty\nassert_p_no_concurrent_write_hazard:assert property (p_no_concurrent_write_hazard) else $error(\"\");", "task_id": "1_9555", "predict_sva": "@(posedge clk_pipe)     !(pipeline_hazard_active && reg_write_enable)"}
{"id": "783_8_2373", "name": "p_csr_addr_range_check", "sva": "@(posedge clk_csr)     csr_access_enable |-> (csr_addr inside {[CSR_BASE:CSR_TOP]})", "ori_sva": "property p_csr_addr_range_check;\n@(posedge clk_csr)     csr_access_enable |-> (csr_addr inside {[CSR_BASE:CSR_TOP]});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_csr_addr_range_check  \n**Trigger Condition**: At every rising edge of the `clk_csr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `csr_access_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `csr_addr inside {[CSR_BASE:CSR_TOP]}`", "sva_signals": ["clk_csr", "rst_n", "[0:0] csr_access_enable", "[15:0] csr_addr", "[15:0] CSR_BASE", "[15:0] CSR_TOP"], "clock": "clk_csr", "attempts_left": 10, "sva_result": "@(posedge clk_csr)         csr_access_enable == 1'b1 |-> csr_addr inside {[CSR_BASE:CSR_TOP]}", "sva_name": "csr_access_range_check", "full_property": "property p_csr_addr_range_check;\n@(posedge clk_csr)         csr_access_enable == 1'b1 |-> csr_addr inside {[CSR_BASE:CSR_TOP]}\nendproperty\nassert_p_csr_addr_range_check:assert property (p_csr_addr_range_check) else $error(\"\");", "task_id": "1_9768", "predict_sva": "@(posedge clk_csr)     csr_access_enable == 1'b1 |-> csr_addr inside {[CSR_BASE:CSR_TOP]}"}
{"id": "769_3_2192", "name": "p_temp_drop_rate_3", "sva": "@(posedge clk_sys)     thermal_coupling_response |-> ##2 (current_temp < ($past(current_temp,2) - (2*min_cool_rate)))", "ori_sva": "property p_temp_drop_rate_3;\n@(posedge clk_sys)     thermal_coupling_response |-> ##2 (current_temp < ($past(current_temp,2) - (2*min_cool_rate)));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_drop_rate_3  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_coupling_response`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 (current_temp < ($past(current_temp,2) - (2*min_cool_rate)))`  ", "sva_signals": ["clk_sys", "current_temp", "min_cool_rate", "thermal_coupling_response"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     thermal_coupling_response |-> ##2 (current_temp < ($past(current_temp, 2) - (2*min_cool_rate)))", "sva_name": "p_temp_drop_rate_7", "full_property": "property p_temp_drop_rate_3;\n@(posedge clk_sys)     thermal_coupling_response |-> ##2 (current_temp < ($past(current_temp, 2) - (2*min_cool_rate)))\nendproperty\nassert_p_temp_drop_rate_3:assert property (p_temp_drop_rate_3) else $error(\"\");", "task_id": "1_9656", "predict_sva": "@(posedge clk_sys)     thermal_coupling_response |-> ##2 (current_temp < ($past(current_temp,2) - (2 * min_cool_rate)))"}
{"id": "720_8_1766", "name": "p_cooling_rate_consistency", "sva": "@(posedge clk_sys)     (temp_drop_rate > MIN_COOL_RATE) until (cooling_complete)", "ori_sva": "property p_cooling_rate_consistency;\n@(posedge clk_sys)     (temp_drop_rate > MIN_COOL_RATE) until (cooling_complete);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cooling_rate_consistency  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: Not applicable (direct assertion without implication)  \n**Implication Operator**: Not applicable  \n**Consequent (RHS of Implication)**: `(temp_drop_rate > MIN_COOL_RATE) until (cooling_complete)`  \n**Description**: The property asserts that the `temp_drop_rate` must remain greater than `MIN_COOL_RATE` continuously until the signal `cooling_complete` becomes true. The check is evaluated at every positive edge of `clk_sys`.  \n\n### Key Notes:  \n1. This is a **direct temporal assertion** (no implication operator `|->` or `|=>`).  \n2. The `until` operator ensures the condition `(temp_drop_rate > MIN_COOL_RATE)` holds **at every clock cycle** until `cooling_complete` is asserted.  \n3. If `cooling_complete` never occurs, the assertion requires `temp_drop_rate > MIN_COOL_RATE` to hold indefinitely.", "sva_signals": ["clk_sys", "[0:0] rst_n", "[0:0] temp_drop_rate", "[0:0] MIN_COOL_RATE", "[0:0] cooling_complete"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (temp_drop_rate > MIN_COOL_RATE) until (cooling_complete)", "sva_name": "p_temp_drop_rate_until_cooling_complete", "full_property": "property p_cooling_rate_consistency;\n@(posedge clk_sys)     (temp_drop_rate > MIN_COOL_RATE) until (cooling_complete)\nendproperty\nassert_p_cooling_rate_consistency:assert property (p_cooling_rate_consistency) else $error(\"\");", "task_id": "1_9409", "predict_sva": "@(posedge clk_sys)     (temp_drop_rate > MIN_COOL_RATE) until cooling_complete"}
{"id": "811_5_2684", "name": "beamforming_symbol_align", "sva": "@(posedge clk_frame)     frame_start |-> beamforming_ready && symbol_map_ready", "ori_sva": "property beamforming_symbol_align;\n@(posedge clk_frame)     frame_start |-> beamforming_ready && symbol_map_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: beamforming_symbol_align  \n**Trigger Condition**: At every rising edge of the `clk_frame`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `beamforming_ready && symbol_map_ready`", "sva_signals": ["clk", "rst_n", "[0:0] frame_start", "[0:0] beamforming_ready", "[0:0] symbol_map_ready", "[0:0] clk_frame"], "clock": "clk_frame", "attempts_left": 10, "sva_result": "@(posedge clk_frame)         frame_start |-> beamforming_ready && symbol_map_ready", "sva_name": "frame_sync_check", "full_property": "property beamforming_symbol_align;\n@(posedge clk_frame)         frame_start |-> beamforming_ready && symbol_map_ready\nendproperty\nassert_beamforming_symbol_align:assert property (beamforming_symbol_align) else $error(\"\");", "task_id": "1_10010", "predict_sva": "@(posedge clk_frame)     frame_start |-> beamforming_ready && symbol_map_ready"}
{"id": "781_10_2346", "name": "amo_collision_detection", "sva": "@(posedge clk_core)     $rose(amo_req_1 && amo_req_2) |->      ##1 $countones({amo_grant_1, amo_grant_2}) <= 1", "ori_sva": "property amo_collision_detection;\n@(posedge clk_core)     $rose(amo_req_1 && amo_req_2) |->      ##1 $countones({amo_grant_1, amo_grant_2}) <= 1\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: amo_collision_detection  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(amo_req_1 && amo_req_2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $countones({amo_grant_1, amo_grant_2}) <= 1`  \n\n", "sva_signals": ["clk_core", "[0:0] amo_req_1", "[0:0] amo_req_2", "[0:0] amo_grant_1", "[0:0] amo_grant_2"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(amo_req_1 && amo_req_2) |-> ##1 ($countones({amo_grant_1, amo_grant_2}) <= 1)", "sva_name": "amo_serialization_check", "full_property": "property amo_collision_detection;\n@(posedge clk_core)     $rose(amo_req_1 && amo_req_2) |-> ##1 ($countones({amo_grant_1, amo_grant_2}) <= 1)\nendproperty\nassert_amo_collision_detection:assert property (amo_collision_detection) else $error(\"\");", "task_id": "1_9742", "predict_sva": "@(posedge clk_core)     $rose(amo_req_1 && amo_req_2) |-> ##1 ($countones({amo_grant_1, amo_grant_2}) <= 1)"}
{"id": "800_10_2581", "name": "thermal_hysteresis", "sva": "@(posedge thermal_clk)     $past(temp_sensor_out) > (safe_temp_threshold + 5) |-> low_power_mode", "ori_sva": "property thermal_hysteresis;\n@(posedge thermal_clk)     $past(temp_sensor_out) > (safe_temp_threshold + 5) |-> low_power_mode;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_hysteresis  \n**Trigger Condition**: At every rising edge of the `thermal_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(temp_sensor_out) > (safe_temp_threshold + 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `low_power_mode`", "sva_signals": ["thermal_clk", "[0:0] low_power_mode", "[0:0] temp_sensor_out", "[0:0] safe_temp_threshold"], "clock": "thermal_clk", "attempts_left": 10, "sva_result": "@(posedge thermal_clk)         ($past(temp_sensor_out) > (safe_temp_threshold + 5)) |-> low_power_mode", "sva_name": "p_temp_monitor_lowpower_6", "full_property": "property thermal_hysteresis;\n@(posedge thermal_clk)         ($past(temp_sensor_out) > (safe_temp_threshold + 5)) |-> low_power_mode\nendproperty\nassert_thermal_hysteresis:assert property (thermal_hysteresis) else $error(\"\");", "task_id": "1_9911", "predict_sva": "@(posedge thermal_clk)     ($past(temp_sensor_out) > safe_temp_threshold + 5) |-> low_power_mode"}
{"id": "783_5_2337", "name": "p_csr_multi_thread_rd_priority", "sva": "@(posedge clk_csr)     (thread_arb_grant[0] && csr_read_enable) |->      !(thread_arb_grant[1] && csr_write_enable)", "ori_sva": "property p_csr_multi_thread_rd_priority;\n@(posedge clk_csr)     (thread_arb_grant[0] && csr_read_enable) |->      !(thread_arb_grant[1] && csr_write_enable);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_csr_multi_thread_rd_priority  \n**Trigger Condition**: At every rising edge of the `clk_csr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thread_arb_grant[0] && csr_read_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(thread_arb_grant[1] && csr_write_enable)`  ", "sva_signals": ["clk_csr", "thread_arb_grant[1:0]", "[0:0] csr_read_enable", "[0:0] csr_write_enable"], "clock": "clk_csr", "attempts_left": 10, "sva_result": "@(posedge clk_csr)     (thread_arb_grant[0] && csr_read_enable) |-> !(thread_arb_grant[1] && csr_write_enable)", "sva_name": "p_csr_operation_unique_per_thread", "full_property": "property p_csr_multi_thread_rd_priority;\n@(posedge clk_csr)     (thread_arb_grant[0] && csr_read_enable) |-> !(thread_arb_grant[1] && csr_write_enable)\nendproperty\nassert_p_csr_multi_thread_rd_priority:assert property (p_csr_multi_thread_rd_priority) else $error(\"\");", "task_id": "1_9765", "predict_sva": "@(posedge clk_csr)     (thread_arb_grant[0] && csr_read_enable) |-> !(thread_arb_grant[1] && csr_write_enable)"}
{"id": "808_11_2641", "name": "store_hit_coherence", "sva": "@(posedge clk_core)     (store_req && cache_hit) |-> (cache_line_state inside {EXCLUSIVE, MODIFIED})", "ori_sva": "property store_hit_coherence;\n@(posedge clk_core)     (store_req && cache_hit) |-> (cache_line_state inside {EXCLUSIVE, MODIFIED});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: store_hit_coherence  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `store_req && cache_hit`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cache_line_state inside {EXCLUSIVE, MODIFIED}`", "sva_signals": ["clk_core", "[0:0] store_req", "[0:0] cache_hit", "[1:0] cache_line_state", "[0:0] EXCLUSIVE", "[0:0] MODIFIED"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     (store_req && cache_hit) |-> (cache_line_state inside {EXCLUSIVE, MODIFIED})", "sva_name": "p_cache_coherency_store", "full_property": "property store_hit_coherence;\n@(posedge clk_core)     (store_req && cache_hit) |-> (cache_line_state inside {EXCLUSIVE, MODIFIED})\nendproperty\nassert_store_hit_coherence:assert property (store_hit_coherence) else $error(\"\");", "task_id": "1_9972", "predict_sva": "@(posedge clk_core)         (store_req && cache_hit) |-> cache_line_state inside {EXCLUSIVE, MODIFIED}"}
{"id": "797_4_2518", "name": "pim_target_sel_stable_during_acc", "sva": "@(posedge pim_clk)     pim_acc_en |-> $stable(pim_target_sel) throughout pim_acc_busy", "ori_sva": "property pim_target_sel_stable_during_acc;\n@(posedge pim_clk)     pim_acc_en |-> $stable(pim_target_sel) throughout pim_acc_busy;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pim_target_sel_stable_during_acc  \n**Trigger Condition**: At every rising edge of the `pim_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pim_acc_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(pim_target_sel) throughout pim_acc_busy`  ", "sva_signals": ["pim_clk", "pim_acc_en", "pim_target_sel", "pim_acc_busy"], "clock": "pim_clk", "attempts_left": 10, "sva_result": "@(posedge pim_clk)     pim_acc_en == 1'b1 |-> $stable(pim_target_sel) throughout pim_acc_busy", "sva_name": "pim_unique_target_per_access", "full_property": "property pim_target_sel_stable_during_acc;\n@(posedge pim_clk)     pim_acc_en == 1'b1 |-> $stable(pim_target_sel) throughout pim_acc_busy\nendproperty\nassert_pim_target_sel_stable_during_acc:assert property (pim_target_sel_stable_during_acc) else $error(\"\");", "task_id": "1_9885", "predict_sva": "@(posedge pim_clk)     pim_acc_en == 1'b1 |-> $stable(pim_target_sel) throughout pim_acc_busy"}
{"id": "809_4_2677", "name": "no_instruction_loss", "sva": "@(posedge clk_core)     (exception_ack && !pipeline_stall) |-> ##[1:3] instruction_retired", "ori_sva": "property no_instruction_loss;\n@(posedge clk_core)     (exception_ack && !pipeline_stall) |-> ##[1:3] instruction_retired\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_instruction_loss  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `exception_ack && !pipeline_stall`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] instruction_retired`  ", "sva_signals": ["clk_core", "rst_n", "[0:0] exception_ack", "[0:0] pipeline_stall", "[0:0] instruction_retired"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     (exception_ack && !pipeline_stall) |-> ##[1:3] instruction_retired", "sva_name": "pipeline_consistency", "full_property": "property no_instruction_loss;\n@(posedge clk_core)     (exception_ack && !pipeline_stall) |-> ##[1:3] instruction_retired\nendproperty\nassert_no_instruction_loss:assert property (no_instruction_loss) else $error(\"\");", "task_id": "1_9986", "predict_sva": "@(posedge clk_core)         (exception_ack && !pipeline_stall) |-> ##[1:3] instruction_retired"}
{"id": "815_10_2741", "name": "compression_ratio_monitor", "sva": "@(posedge clk_sparse)     (compression_ratio > 10) |-> (sparsity > 90)", "ori_sva": "property compression_ratio_monitor;\n@(posedge clk_sparse)     (compression_ratio > 10) |-> (sparsity > 90);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: compression_ratio_monitor  \n**Trigger Condition**: At every rising edge of the `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `compression_ratio > 10`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sparsity > 90`", "sva_signals": ["clk", "rst_n", "[0:0] compression_ratio", "[0:0] sparsity", "clk_sparse"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)     compression_ratio > 10 |-> sparsity > 90", "sva_name": "sparsity_compression_ratio", "full_property": "property compression_ratio_monitor;\n@(posedge clk_sparse)     compression_ratio > 10 |-> sparsity > 90\nendproperty\nassert_compression_ratio_monitor:assert property (compression_ratio_monitor) else $error(\"\");", "task_id": "1_10036", "predict_sva": "@(posedge clk_sparse)         compression_ratio > 10 |-> sparsity > 90"}
{"id": "786_8_2383", "name": "pcie_disabled_state_persistence", "sva": "@(posedge pcie_clk_i)     link_state_disabled_i && !link_reset_i |=> link_state_disabled_i", "ori_sva": "property pcie_disabled_state_persistence;\n@(posedge pcie_clk_i)     link_state_disabled_i && !link_reset_i |=> link_state_disabled_i\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_disabled_state_persistence  \n**Trigger Condition**: At every rising edge of the `pcie_clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `link_state_disabled_i && !link_reset_i`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `link_state_disabled_i`", "sva_signals": ["pcie_clk_i", "[0:0] link_state_disabled_i", "[0:0] link_reset_i"], "clock": "pcie_clk_i", "attempts_left": 10, "sva_result": "@(posedge pcie_clk_i)         (link_state_disabled_i && !link_reset_i) |=> link_state_disabled_i", "sva_name": "pcie_link_disabled_persists", "full_property": "property pcie_disabled_state_persistence;\n@(posedge pcie_clk_i)         (link_state_disabled_i && !link_reset_i) |=> link_state_disabled_i\nendproperty\nassert_pcie_disabled_state_persistence:assert property (pcie_disabled_state_persistence) else $error(\"\");", "task_id": "1_9795", "predict_sva": "@(posedge pcie_clk_i)         (link_state_disabled_i && !link_reset_i) |=> link_state_disabled_i"}
{"id": "797_3_2526", "name": "pim_acc_operation_complete", "sva": "@(posedge pim_clk)     pim_acc_en |-> ##1 pim_acc_done", "ori_sva": "property pim_acc_operation_complete;\n@(posedge pim_clk)     pim_acc_en |-> ##1 pim_acc_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pim_acc_operation_complete  \n**Trigger Condition**: At every rising edge of the `pim_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pim_acc_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 pim_acc_done`  \n\n(Note: The consequent states that one clock cycle after the antecedent is true, `pim_acc_done` must be asserted.)", "sva_signals": ["pim_clk", "[0:0] pim_acc_en", "[0:0] pim_acc_done"], "clock": "pim_clk", "attempts_left": 10, "sva_result": "@(posedge pim_clk)     pim_acc_en == 1'b1 |-> ##1 pim_acc_done", "sva_name": "pim_acc_completion", "full_property": "property pim_acc_operation_complete;\n@(posedge pim_clk)     pim_acc_en == 1'b1 |-> ##1 pim_acc_done\nendproperty\nassert_pim_acc_operation_complete:assert property (pim_acc_operation_complete) else $error(\"\");", "task_id": "1_9884", "predict_sva": "@(posedge pim_clk)         pim_acc_en == 1'b1 |-> ##1 pim_acc_done"}
{"id": "725_8_1814", "name": "bounded_linear_range", "sva": "@(posedge clk_signal)     $stable(act_bl_low) && $stable(act_bl_high) |->     (act_bl_out >= act_bl_low && act_bl_out <= act_bl_high)", "ori_sva": "property bounded_linear_range;\n@(posedge clk_signal)     $stable(act_bl_low) && $stable(act_bl_high) |->     (act_bl_out >= act_bl_low && act_bl_out <= act_bl_high);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bounded_linear_range  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(act_bl_low) && $stable(act_bl_high)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(act_bl_out >= act_bl_low && act_bl_out <= act_bl_high)`  ", "sva_signals": ["clk_signal", "[0:0] act_bl_low", "[0:0] act_bl_high", "[0:0] act_bl_out"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ($stable(act_bl_low) && $stable(act_bl_high)) |->      (act_bl_out >= act_bl_low && act_bl_out <= act_bl_high)", "sva_name": "p_act_bl_stable_range", "full_property": "property bounded_linear_range;\n@(posedge clk_signal)     ($stable(act_bl_low) && $stable(act_bl_high)) |->      (act_bl_out >= act_bl_low && act_bl_out <= act_bl_high)\nendproperty\nassert_bounded_linear_range:assert property (bounded_linear_range) else $error(\"\");", "task_id": "1_9432", "predict_sva": "@(posedge clk_signal)    ($stable(act_bl_low) && $stable(act_bl_high)) |->     (act_bl_out >= act_bl_low && act_bl_out <= act_bl_high)"}
{"id": "815_12_2764", "name": "compressed_index_bounds", "sva": "@(posedge clk_sparse)     compression_valid |-> (compressed_idx < max_compressed_idx)", "ori_sva": "property compressed_index_bounds;\n@(posedge clk_sparse)     compression_valid |-> (compressed_idx < max_compressed_idx);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: compressed_index_bounds  \n**Trigger Condition**: At every rising edge of the `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `compression_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `compressed_idx < max_compressed_idx`", "sva_signals": ["clk_sparse", "[0:0] compression_valid", "[0:0] compressed_idx", "[0:0] max_compressed_idx"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)     compression_valid == 1'b1 |-> compressed_idx < max_compressed_idx", "sva_name": "p_compression_idx_valid", "full_property": "property compressed_index_bounds;\n@(posedge clk_sparse)     compression_valid == 1'b1 |-> compressed_idx < max_compressed_idx\nendproperty\nassert_compressed_index_bounds:assert property (compressed_index_bounds) else $error(\"\");", "task_id": "1_10038", "predict_sva": "@(posedge clk_sparse)     compression_valid == 1'b1 |-> compressed_idx < max_compressed_idx"}
{"id": "812_13_2708", "name": "p_hard_decision_valid", "sva": "@(posedge clk_core)     (dec_data_valid && dec_mode_sel == HARD_MODE) |-> $countones(dec_out_data) <= MAX_ERROR_BITS", "ori_sva": "property p_hard_decision_valid;\n@(posedge clk_core)     (dec_data_valid && dec_mode_sel == HARD_MODE) |-> $countones(dec_out_data) <= MAX_ERROR_BITS\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hard_decision_valid  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dec_data_valid && dec_mode_sel == HARD_MODE`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$countones(dec_out_data) <= MAX_ERROR_BITS`", "sva_signals": ["clk_core", "[0:0] dec_data_valid", "[0:0] dec_mode_sel", "[0:0] HARD_MODE", "[0:0] MAX_ERROR_BITS", "[0:0] dec_out_data"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         (dec_data_valid && dec_mode_sel == HARD_MODE) |-> ($countones(dec_out_data) <= MAX_ERROR_BITS)", "sva_name": "hard_decision_error_count", "full_property": "property p_hard_decision_valid;\n@(posedge clk_core)         (dec_data_valid && dec_mode_sel == HARD_MODE) |-> ($countones(dec_out_data) <= MAX_ERROR_BITS)\nendproperty\nassert_p_hard_decision_valid:assert property (p_hard_decision_valid) else $error(\"\");", "task_id": "1_10016", "predict_sva": "@(posedge clk_core)     (dec_data_valid && (dec_mode_sel == HARD_MODE)) |-> ($countones(dec_out_data) <= MAX_ERROR_BITS)"}
{"id": "827_13_2875", "name": "no_simultaneous_miso", "sva": "@(posedge spi_clk)     $countones(cs_n) > 1 |-> miso_data === 'z", "ori_sva": "property no_simultaneous_miso;\n@(posedge spi_clk)     $countones(cs_n) > 1 |-> miso_data === 'z;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_simultaneous_miso  \n**Trigger Condition**: At every rising edge of `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$countones(cs_n) > 1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `miso_data === 'z`  ", "sva_signals": ["spi_clk", "[0:0] cs_n", "[0:0] miso_data"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     ($countones(cs_n) > 1) |-> (miso_data === 'z)", "sva_name": "multi_cs_no_response", "full_property": "property no_simultaneous_miso;\n@(posedge spi_clk)     ($countones(cs_n) > 1) |-> (miso_data === 'z)\nendproperty\nassert_no_simultaneous_miso:assert property (no_simultaneous_miso) else $error(\"\");", "task_id": "1_10147", "predict_sva": "@(posedge spi_clk)     $countones(cs_n) > 1 |-> miso_data === 'z"}
{"id": "831_10_2916", "name": "lp_mode_data_invalid", "sva": "@(posedge dsi_clk)     lp_mode_en |-> !lane_data_valid", "ori_sva": "property lp_mode_data_invalid;\n@(posedge dsi_clk)     lp_mode_en |-> !lane_data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: lp_mode_data_invalid  \n**Trigger Condition**: At every rising edge of the `dsi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lp_mode_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!lane_data_valid`", "sva_signals": ["dsi_clk", "[0:0] lp_mode_en", "[0:0] lane_data_valid"], "clock": "dsi_clk", "attempts_left": 10, "sva_result": "@(posedge dsi_clk)         lp_mode_en == 1'b1 |-> !lane_data_valid", "sva_name": "hs_to_lp_transition", "full_property": "property lp_mode_data_invalid;\n@(posedge dsi_clk)         lp_mode_en == 1'b1 |-> !lane_data_valid\nendproperty\nassert_lp_mode_data_invalid:assert property (lp_mode_data_invalid) else $error(\"\");", "task_id": "1_10189", "predict_sva": "@(posedge dsi_clk)     lp_mode_en == 1'b1 |-> !lane_data_valid"}
{"id": "815_1_2744", "name": "sparse_zero_skip", "sva": "@(posedge clk_sparse)     (sparse_val == 0) |-> ##1 !mult_en", "ori_sva": "property sparse_zero_skip;\n@(posedge clk_sparse)     (sparse_val == 0) |-> ##1 !mult_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sparse_zero_skip  \n**Trigger Condition**: At every rising edge of the `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sparse_val == 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !mult_en`  ", "sva_signals": ["clk_sparse", "[0:0] sparse_val", "[0:0] mult_en"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)         sparse_val == 0 |-> ##1 !mult_en", "sva_name": "zero_skip_throughput", "full_property": "property sparse_zero_skip;\n@(posedge clk_sparse)         sparse_val == 0 |-> ##1 !mult_en\nendproperty\nassert_sparse_zero_skip:assert property (sparse_zero_skip) else $error(\"\");", "task_id": "1_10039", "predict_sva": "@(posedge clk_sparse)     sparse_val == 0 |-> ##1 !mult_en"}
{"id": "823_1_2818", "name": "addr_match_ack", "sva": "@(posedge i2c_clk)     $rose(i2c_start) ##1 (i2c_addr == slave_addr) |-> ##1 i2c_ack", "ori_sva": "property addr_match_ack;\n@(posedge i2c_clk)     $rose(i2c_start) ##1 (i2c_addr == slave_addr) |-> ##1 i2c_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: addr_match_ack  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(i2c_start) ##1 (i2c_addr == slave_addr)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 i2c_ack`  ", "sva_signals": ["i2c_clk", "i2c_start", "[0:0] i2c_ack", "[7:0] i2c_addr", "[7:0] slave_addr"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)         $rose(i2c_start) ##1 (i2c_addr == slave_addr) |-> ##1 i2c_ack", "sva_name": "addr_match_ack_follows", "full_property": "property addr_match_ack;\n@(posedge i2c_clk)         $rose(i2c_start) ##1 (i2c_addr == slave_addr) |-> ##1 i2c_ack\nendproperty\nassert_addr_match_ack:assert property (addr_match_ack) else $error(\"\");", "task_id": "1_10114", "predict_sva": "@(posedge i2c_clk)     $rose(i2c_start) ##1 i2c_addr == slave_addr |-> ##1 i2c_ack"}
{"id": "816_7_2747", "name": "no_write_during_switch", "sva": "@(posedge ddr_clk)     rank_switch_ack_ |-> !write_enable_", "ori_sva": "property no_write_during_switch;\n@(posedge ddr_clk)     rank_switch_ack_ |-> !write_enable_;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_write_during_switch  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rank_switch_ack_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!write_enable_`  \n\n(Note: The assertion checks that whenever `rank_switch_ack_` is high, `write_enable_` must be low at the same clock edge.)", "sva_signals": ["ddr_clk", "write_enable_", "[0:0] rank_switch_ack_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> !write_enable_", "sva_name": "no_write_during_switch", "full_property": "property no_write_during_switch;\n@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> !write_enable_\nendproperty\nassert_no_write_during_switch:assert property (no_write_during_switch) else $error(\"\");", "task_id": "1_10056", "predict_sva": "@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> !write_enable_"}
{"id": "836_7_2987", "name": "priority_arbitration", "sva": "@(posedge ddr_clk)     (high_prio_req_ && low_prio_req_) |-> ##[1:2] high_prio_grant_", "ori_sva": "property priority_arbitration;\n@(posedge ddr_clk)     (high_prio_req_ && low_prio_req_) |-> ##[1:2] high_prio_grant_;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: priority_arbitration  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `high_prio_req_ && low_prio_req_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] high_prio_grant_`  ", "sva_signals": ["ddr_clk", "[0:0] high_prio_req_", "[0:0] low_prio_req_", "[0:0] high_prio_grant_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         (high_prio_req_ && low_prio_req_) |-> ##[1:2] high_prio_grant_", "sva_name": "priority_arbitration_correct", "full_property": "property priority_arbitration;\n@(posedge ddr_clk)         (high_prio_req_ && low_prio_req_) |-> ##[1:2] high_prio_grant_\nendproperty\nassert_priority_arbitration:assert property (priority_arbitration) else $error(\"\");", "task_id": "1_10248", "predict_sva": "@(posedge ddr_clk)         (high_prio_req_ && low_prio_req_) |-> ##[1:2] high_prio_grant_"}
{"id": "837_8_2993", "name": "p_high_temp_self_refresh", "sva": "@(posedge ddr_clk)     disable iff(!rst_n)     (temp_extreme_high && !high_load) |-> ##[1:3] self_refresh_en", "ori_sva": "property p_high_temp_self_refresh;\n@(posedge ddr_clk)     disable iff(!rst_n)     (temp_extreme_high && !high_load) |-> ##[1:3] self_refresh_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_high_temp_self_refresh  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `temp_extreme_high && !high_load`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] self_refresh_en`  ", "sva_signals": ["ddr_clk", "rst_n", "[0:0] temp_extreme_high", "[0:0] high_load", "[0:0] self_refresh_en"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk) disable iff (!rst_n)         (temp_extreme_high && !high_load) |-> ##[1:3] self_refresh_en", "sva_name": "p_self_refresh_priority", "full_property": "property p_high_temp_self_refresh;\n@(posedge ddr_clk) disable iff (!rst_n)         (temp_extreme_high && !high_load) |-> ##[1:3] self_refresh_en\nendproperty\nassert_p_high_temp_self_refresh:assert property (p_high_temp_self_refresh) else $error(\"\");", "task_id": "1_10262", "predict_sva": "@(posedge ddr_clk) disable iff (!rst_n)         (temp_extreme_high && !high_load) |-> ##[1:3] self_refresh_en"}
{"id": "828_7_2903", "name": "no_data_corruption_after_overflow", "sva": "@(posedge spi_clk)     fifo_overflow_flag |-> ##[1:10] $stable(spi_tx_data)", "ori_sva": "property no_data_corruption_after_overflow;\n@(posedge spi_clk)     fifo_overflow_flag |-> ##[1:10] $stable(spi_tx_data);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_data_corruption_after_overflow  \n**Trigger Condition**: At every rising edge of `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_overflow_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] $stable(spi_tx_data)`  \n\n", "sva_signals": ["spi_clk", "[0:0] fifo_overflow_flag", "[7:0] spi_tx_data"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     fifo_overflow_flag == 1'b1 |-> ##[1:10] $stable(spi_tx_data)", "sva_name": "no_new_data_during_overflow", "full_property": "property no_data_corruption_after_overflow;\n@(posedge spi_clk)     fifo_overflow_flag == 1'b1 |-> ##[1:10] $stable(spi_tx_data)\nendproperty\nassert_no_data_corruption_after_overflow:assert property (no_data_corruption_after_overflow) else $error(\"\");", "task_id": "1_10164", "predict_sva": "@(posedge spi_clk)     fifo_overflow_flag == 1'b1 |-> ##[1:10] $stable(spi_tx_data)"}
{"id": "839_6_3027", "name": "refresh_after_precharge", "sva": "@(posedge ddr_clk)     $rose(refresh_req) |-> $past(bank_precharge_done,1)", "ori_sva": "property refresh_after_precharge;\n@(posedge ddr_clk)     $rose(refresh_req) |-> $past(bank_precharge_done,1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: refresh_after_precharge  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(refresh_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(bank_precharge_done, 1)`  ", "sva_signals": ["ddr_clk", "refresh_req", "bank_precharge_done"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         $rose(refresh_req) |-> $past(bank_precharge_done, 1)", "sva_name": "precharge_all_before_refresh", "full_property": "property refresh_after_precharge;\n@(posedge ddr_clk)         $rose(refresh_req) |-> $past(bank_precharge_done, 1)\nendproperty\nassert_refresh_after_precharge:assert property (refresh_after_precharge) else $error(\"\");", "task_id": "1_10279", "predict_sva": "@(posedge ddr_clk)         $rose(refresh_req) |-> $past(bank_precharge_done, 1)"}
{"id": "835_9_2966", "name": "p_packet_continuity", "sva": "@(posedge mipi_clk)     mipi_packet_start |-> ##[1:64] mipi_packet_end", "ori_sva": "property p_packet_continuity;\n@(posedge mipi_clk)     mipi_packet_start |-> ##[1:64] mipi_packet_end;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_continuity  \n**Trigger Condition**: At every rising edge of the `mipi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mipi_packet_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:64] mipi_packet_end` (The signal `mipi_packet_end` must be asserted within 1 to 64 clock cycles after `mipi_packet_start` is asserted)", "sva_signals": ["mipi_clk", "mipi_packet_start", "mipi_packet_end"], "clock": "mipi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_clk)         mipi_packet_start == 1'b1 |-> ##[1:64] mipi_packet_end", "sva_name": "packet_completion_timeout", "full_property": "property p_packet_continuity;\n@(posedge mipi_clk)         mipi_packet_start == 1'b1 |-> ##[1:64] mipi_packet_end\nendproperty\nassert_p_packet_continuity:assert property (p_packet_continuity) else $error(\"\");", "task_id": "1_10236", "predict_sva": "@(posedge mipi_clk)     mipi_packet_start == 1'b1 |-> ##[1:64] mipi_packet_end"}
{"id": "838_5_3014", "name": "ecc_recovery_complete", "sva": "@(posedge ecc_clk)     ecc_error_detected && ecc_scrub_enable |-> ##[1:100] !ecc_error_detected", "ori_sva": "property ecc_recovery_complete;\n@(posedge ecc_clk)     ecc_error_detected && ecc_scrub_enable |-> ##[1:100] !ecc_error_detected;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_recovery_complete  \n**Trigger Condition**: At every rising edge of the `ecc_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_error_detected && ecc_scrub_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 100 clock cycles (`##[1:100]`), `ecc_error_detected` becomes `0` (`!ecc_error_detected`)  ", "sva_signals": ["ecc_clk", "ecc_error_detected", "ecc_scrub_enable"], "clock": "ecc_clk", "attempts_left": 10, "sva_result": "@(posedge ecc_clk)         (ecc_error_detected && ecc_scrub_enable) |-> ##[1:100] !ecc_error_detected", "sva_name": "ecc_scrub_error_cleared", "full_property": "property ecc_recovery_complete;\n@(posedge ecc_clk)         (ecc_error_detected && ecc_scrub_enable) |-> ##[1:100] !ecc_error_detected\nendproperty\nassert_ecc_recovery_complete:assert property (ecc_recovery_complete) else $error(\"\");", "task_id": "1_10270", "predict_sva": "@(posedge ecc_clk)         (ecc_error_detected && ecc_scrub_enable) |-> ##[1:100] !ecc_error_detected"}
{"id": "839_11_3026", "name": "no_concurrent_bank_activate", "sva": "@(posedge ddr_clk)     $rose(bank_activate_req) |-> !$rose(another_bank_activate_req)", "ori_sva": "property no_concurrent_bank_activate;\n@(posedge ddr_clk)     $rose(bank_activate_req) |-> !$rose(another_bank_activate_req);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_concurrent_bank_activate  \n**Trigger Condition**: At every rising edge of `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(bank_activate_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$rose(another_bank_activate_req)`  \n\n", "sva_signals": ["ddr_clk", "another_bank_activate_req", "bank_activate_req"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         $rose(bank_activate_req) |-> !$rose(another_bank_activate_req)", "sva_name": "no_concurrent_bank_activate", "full_property": "property no_concurrent_bank_activate;\n@(posedge ddr_clk)         $rose(bank_activate_req) |-> !$rose(another_bank_activate_req)\nendproperty\nassert_no_concurrent_bank_activate:assert property (no_concurrent_bank_activate) else $error(\"\");", "task_id": "1_10275", "predict_sva": "@(posedge ddr_clk)         $rose(bank_activate_req) |-> !$rose(another_bank_activate_req)"}
{"id": "822_4_2834", "name": "arbitration_recovery_check", "sva": "@(posedge i2c_clk)     $fell(i2c_sda) && $fell(i2c_scl) |->      ##[1:1000] $stable(i2c_sda) && $stable(i2c_scl)", "ori_sva": "property arbitration_recovery_check;\n@(posedge i2c_clk)     $fell(i2c_sda) && $fell(i2c_scl) |->      ##[1:1000] $stable(i2c_sda) && $stable(i2c_scl);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: arbitration_recovery_check  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(i2c_sda) && $fell(i2c_scl)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:1000] $stable(i2c_sda) && $stable(i2c_scl)`  ", "sva_signals": ["i2c_clk", "i2c_sda", "i2c_scl"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     ($fell(i2c_sda) && $fell(i2c_scl)) |-> ##[1:1000] ($stable(i2c_sda) && $stable(i2c_scl))", "sva_name": "p_i2c_no_glitch_after_fall", "full_property": "property arbitration_recovery_check;\n@(posedge i2c_clk)     ($fell(i2c_sda) && $fell(i2c_scl)) |-> ##[1:1000] ($stable(i2c_sda) && $stable(i2c_scl))\nendproperty\nassert_arbitration_recovery_check:assert property (arbitration_recovery_check) else $error(\"\");", "task_id": "1_10105", "predict_sva": "@(posedge i2c_clk)     ($fell(i2c_sda) && $fell(i2c_scl)) |-> ##[1:1000] ($stable(i2c_sda) && $stable(i2c_scl))"}
{"id": "850_3_3179", "name": "signal_distortion_recovery", "sva": "@(posedge serdes_clk)     (signal_distortion_detected && !manual_override) |-> ##[1:200] $rose(link_training_start)", "ori_sva": "property signal_distortion_recovery;\n@(posedge serdes_clk)     (signal_distortion_detected && !manual_override) |-> ##[1:200] $rose(link_training_start);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: signal_distortion_recovery  \n**Trigger Condition**: At every rising edge of `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `signal_distortion_detected && !manual_override`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:200] $rose(link_training_start)`  \n\n", "sva_signals": ["serdes_clk", "[0:0] signal_distortion_detected", "[0:0] manual_override", "[0:0] link_training_start"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)         (signal_distortion_detected && !manual_override) |-> ##[1:200] $rose(link_training_start)", "sva_name": "signal_distortion_recovery", "full_property": "property signal_distortion_recovery;\n@(posedge serdes_clk)         (signal_distortion_detected && !manual_override) |-> ##[1:200] $rose(link_training_start)\nendproperty\nassert_signal_distortion_recovery:assert property (signal_distortion_recovery) else $error(\"\");", "task_id": "1_10389", "predict_sva": "@(posedge serdes_clk)     (signal_distortion_detected && !manual_override) |-> ##[1:200] $rose(link_training_start)"}
{"id": "847_9_3143", "name": "pcie_tlp_retransmit_sequence_id", "sva": "@(posedge pcie_clk)     (tlp_retransmitted && tlp_sequence_valid) |-> tlp_sequence_id == retransmit_sequence_id", "ori_sva": "property pcie_tlp_retransmit_sequence_id;\n@(posedge pcie_clk)     (tlp_retransmitted && tlp_sequence_valid) |-> tlp_sequence_id == retransmit_sequence_id;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_tlp_retransmit_sequence_id  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_retransmitted && tlp_sequence_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tlp_sequence_id == retransmit_sequence_id`", "sva_signals": ["pcie_clk", "tlp_retransmitted", "tlp_sequence_valid", "tlp_sequence_id", "retransmit_sequence_id"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)         (tlp_retransmitted && tlp_sequence_valid) |-> (tlp_sequence_id == retransmit_sequence_id)", "sva_name": "pcie_tlp_retransmission_consistency", "full_property": "property pcie_tlp_retransmit_sequence_id;\n@(posedge pcie_clk)         (tlp_retransmitted && tlp_sequence_valid) |-> (tlp_sequence_id == retransmit_sequence_id)\nendproperty\nassert_pcie_tlp_retransmit_sequence_id:assert property (pcie_tlp_retransmit_sequence_id) else $error(\"\");", "task_id": "1_10370", "predict_sva": "@(posedge pcie_clk)         (tlp_retransmitted && tlp_sequence_valid) |-> (tlp_sequence_id == retransmit_sequence_id)"}
{"id": "865_14_3382", "name": "usb_split_transaction", "sva": "@(posedge usb_clk)     (usb_split_token_received) |-> ##[1:100] usb_complete_split", "ori_sva": "property usb_split_transaction;\n@(posedge usb_clk)     (usb_split_token_received) |-> ##[1:100] usb_complete_split;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_split_transaction  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_split_token_received == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] usb_complete_split == 1'b1`  ", "sva_signals": ["usb_clk", "[0:0] usb_split_token_received", "[0:0] usb_complete_split"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_split_token_received == 1'b1 |-> ##[1:100] usb_complete_split == 1'b1", "sva_name": "usb_split_completion_timeout", "full_property": "property usb_split_transaction;\n@(posedge usb_clk)     usb_split_token_received == 1'b1 |-> ##[1:100] usb_complete_split == 1'b1\nendproperty\nassert_usb_split_transaction:assert property (usb_split_transaction) else $error(\"\");", "task_id": "1_10537", "predict_sva": "@(posedge usb_clk)     usb_split_token_received == 1'b1 |-> ##[1:100] usb_complete_split == 1'b1"}
{"id": "874_5_3457", "name": "credit_based_shaping", "sva": "@(posedge tsn_clk)     (credit_counter > 0) |-> tx_gate_open", "ori_sva": "property credit_based_shaping;\n@(posedge tsn_clk)     (credit_counter > 0) |-> tx_gate_open;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: credit_based_shaping  \n**Trigger Condition**: At every rising edge of the `tsn_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `credit_counter > 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tx_gate_open`", "sva_signals": ["tsn_clk", "[0:0] credit_counter", "[0:0] tx_gate_open"], "clock": "tsn_clk", "attempts_left": 10, "sva_result": "@(posedge tsn_clk)         credit_counter > 0 |-> tx_gate_open", "sva_name": "p_credit_implies_tx_gate", "full_property": "property credit_based_shaping;\n@(posedge tsn_clk)         credit_counter > 0 |-> tx_gate_open\nendproperty\nassert_credit_based_shaping:assert property (credit_based_shaping) else $error(\"\");", "task_id": "1_10632", "predict_sva": "@(posedge tsn_clk)         credit_counter > 0 |-> tx_gate_open"}
{"id": "843_9_3085", "name": "p_no_new_txn_during_reset", "sva": "@(posedge axi_clk)     master_reset_ |-> !(awvalid_ || arvalid_)", "ori_sva": "property p_no_new_txn_during_reset;\n@(posedge axi_clk)     master_reset_ |-> !(awvalid_ || arvalid_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_new_txn_during_reset  \n**Trigger Condition**: At every rising edge of the `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `master_reset_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(awvalid_ || arvalid_)`  ", "sva_signals": ["axi_clk", "master_reset_", "[0:0] awvalid_", "[0:0] arvalid_"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)         master_reset_ == 1'b1 |-> !(awvalid_ || arvalid_)", "sva_name": "p_no_new_transaction_during_reset", "full_property": "property p_no_new_txn_during_reset;\n@(posedge axi_clk)         master_reset_ == 1'b1 |-> !(awvalid_ || arvalid_)\nendproperty\nassert_p_no_new_txn_during_reset:assert property (p_no_new_txn_during_reset) else $error(\"\");", "task_id": "1_10334", "predict_sva": "@(posedge axi_clk)     master_reset_ == 1'b1 |-> !awvalid_ && !arvalid_"}
{"id": "867_2_3390", "name": "error_state_entry_on_ack_error", "sva": "@(posedge can_clk)     can_ack_error_detected |-> ##1 can_node_error_state[0]", "ori_sva": "property error_state_entry_on_ack_error;\n@(posedge can_clk)     can_ack_error_detected |-> ##1 can_node_error_state[0];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: error_state_entry_on_ack_error  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_ack_error_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 can_node_error_state[0]`", "sva_signals": ["can_clk", "can_ack_error_detected", "[0:0] can_node_error_state"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_ack_error_detected |-> ##1 can_node_error_state[0]", "sva_name": "ack_error_detection", "full_property": "property error_state_entry_on_ack_error;\n@(posedge can_clk)         can_ack_error_detected |-> ##1 can_node_error_state[0]\nendproperty\nassert_error_state_entry_on_ack_error:assert property (error_state_entry_on_ack_error) else $error(\"\");", "task_id": "1_10569", "predict_sva": "@(posedge can_clk)         can_ack_error_detected |-> ##1 can_node_error_state[0]"}
{"id": "871_4_3441", "name": "auto_negotiation_complete", "sva": "@(posedge eth_clk)     (auto_neg_start && !auto_neg_busy) |-> ##[1:1000] auto_neg_done", "ori_sva": "property auto_negotiation_complete;\n@(posedge eth_clk)     (auto_neg_start && !auto_neg_busy) |-> ##[1:1000] auto_neg_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: auto_negotiation_complete  \n**Trigger Condition**: At every rising edge of `eth_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `auto_neg_start && !auto_neg_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:1000] auto_neg_done`  \n\n", "sva_signals": ["eth_clk", "auto_neg_start", "auto_neg_busy", "auto_neg_done"], "clock": "eth_clk", "attempts_left": 10, "sva_result": "@(posedge eth_clk)         (auto_neg_start && !auto_neg_busy) |-> ##[1:1000] auto_neg_done", "sva_name": "auto_negotiation_complete", "full_property": "property auto_negotiation_complete;\n@(posedge eth_clk)         (auto_neg_start && !auto_neg_busy) |-> ##[1:1000] auto_neg_done\nendproperty\nassert_auto_negotiation_complete:assert property (auto_negotiation_complete) else $error(\"\");", "task_id": "1_10605", "predict_sva": "@(posedge eth_clk)         (auto_neg_start && !auto_neg_busy) |-> ##[1:1000] auto_neg_done"}
{"id": "851_13_3201", "name": "error_propagation_check", "sva": "@(posedge serdes_clk)     lane_error[0] |-> ##[1:4] agg_error_flag", "ori_sva": "property error_propagation_check;\n@(posedge serdes_clk)     lane_error[0] |-> ##[1:4] agg_error_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: error_propagation_check  \n**Trigger Condition**: At every rising edge of the `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lane_error[0] == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] agg_error_flag` (The `agg_error_flag` must be asserted within 1 to 4 clock cycles after `lane_error[0]` is detected)", "sva_signals": ["serdes_clk", "[0:0] lane_error", "[0:0] agg_error_flag"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)     lane_error[0] == 1'b1 |-> ##[1:4] agg_error_flag", "sva_name": "error_propagation", "full_property": "property error_propagation_check;\n@(posedge serdes_clk)     lane_error[0] == 1'b1 |-> ##[1:4] agg_error_flag\nendproperty\nassert_error_propagation_check:assert property (error_propagation_check) else $error(\"\");", "task_id": "1_10397", "predict_sva": "@(posedge serdes_clk)     lane_error[0] == 1'b1 |-> ##[1:4] agg_error_flag"}
{"id": "870_11_3438", "name": "can_safe_mode_ack", "sva": "@(posedge can_clk)     can_node_safe_mode |-> ##[1:100] can_ack_received", "ori_sva": "property can_safe_mode_ack;\n@(posedge can_clk)     can_node_safe_mode |-> ##[1:100] can_ack_received;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_safe_mode_ack  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_node_safe_mode == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] can_ack_received == 1'b1`  ", "sva_signals": ["can_clk", "[0:0] can_node_safe_mode", "[0:0] can_ack_received"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     can_node_safe_mode == 1'b1 |-> ##[1:100] can_ack_received == 1'b1", "sva_name": "can_node_safety_mode", "full_property": "property can_safe_mode_ack;\n@(posedge can_clk)     can_node_safe_mode == 1'b1 |-> ##[1:100] can_ack_received == 1'b1\nendproperty\nassert_can_safe_mode_ack:assert property (can_safe_mode_ack) else $error(\"\");", "task_id": "1_10594", "predict_sva": "@(posedge can_clk)     can_node_safe_mode == 1'b1 |-> ##[1:100] can_ack_received == 1'b1"}
{"id": "846_5_3111", "name": "pcie_power_down_exit", "sva": "@(posedge pcie_clk_i)     $rose(power_management_req_i) && (ltssm_state_o == LTSSM_L2) |-> ##[8:1024] ltssm_state_o == LTSSM_DETECT", "ori_sva": "property pcie_power_down_exit;\n@(posedge pcie_clk_i)     $rose(power_management_req_i) && (ltssm_state_o == LTSSM_L2) |-> ##[8:1024] ltssm_state_o == LTSSM_DETECT;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_power_down_exit  \n**Trigger Condition**: At every rising edge of `pcie_clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(power_management_req_i) && (ltssm_state_o == LTSSM_L2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:1024] ltssm_state_o == LTSSM_DETECT`  \n\n", "sva_signals": ["pcie_clk_i", "[0:0] power_management_req_i", "[0:0] ltssm_state_o", "[0:0] LTSSM_L2", "[0:0] LTSSM_DETECT"], "clock": "pcie_clk_i", "attempts_left": 10, "sva_result": "@(posedge pcie_clk_i)         ($rose(power_management_req_i) && (ltssm_state_o == LTSSM_L2)) |-> ##[8:1024] (ltssm_state_o == LTSSM_DETECT)", "sva_name": "pcie_link_ltssm_transition_valid", "full_property": "property pcie_power_down_exit;\n@(posedge pcie_clk_i)         ($rose(power_management_req_i) && (ltssm_state_o == LTSSM_L2)) |-> ##[8:1024] (ltssm_state_o == LTSSM_DETECT)\nendproperty\nassert_pcie_power_down_exit:assert property (pcie_power_down_exit) else $error(\"\");", "task_id": "1_10355", "predict_sva": "@(posedge pcie_clk_i)     ($rose(power_management_req_i) && ltssm_state_o == LTSSM_L2) |-> ##[8:1024] (ltssm_state_o == LTSSM_DETECT)"}
{"id": "877_5_3517", "name": "cmd_data_handshake", "sva": "@(posedge nand_clk)     $rose(cmd_latch_en) |-> ##[0:2] data_valid", "ori_sva": "property cmd_data_handshake;\n@(posedge nand_clk)     $rose(cmd_latch_en) |-> ##[0:2] data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cmd_data_handshake  \n**Trigger Condition**: At every rising edge of the `nand_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cmd_latch_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] data_valid`  ", "sva_signals": ["nand_clk", "cmd_latch_en", "data_valid"], "clock": "nand_clk", "attempts_left": 10, "sva_result": "@(posedge nand_clk)         $rose(cmd_latch_en) |-> ##[0:2] data_valid", "sva_name": "data_valid_after_cmd", "full_property": "property cmd_data_handshake;\n@(posedge nand_clk)         $rose(cmd_latch_en) |-> ##[0:2] data_valid\nendproperty\nassert_cmd_data_handshake:assert property (cmd_data_handshake) else $error(\"\");", "task_id": "1_10666", "predict_sva": "@(posedge nand_clk)     $rose(cmd_latch_en) |-> ##[0:2] data_valid"}
{"id": "877_13_3503", "name": "cache_prog_timing", "sva": "@(posedge nand_clk)     cache_prog_start |-> ##[10:100] cache_prog_done", "ori_sva": "property cache_prog_timing;\n@(posedge nand_clk)     cache_prog_start |-> ##[10:100] cache_prog_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cache_prog_timing  \n**Trigger Condition**: At every rising edge of the `nand_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_prog_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:100] cache_prog_done`  ", "sva_signals": ["nand_clk", "[0:0] cache_prog_start", "[0:0] cache_prog_done"], "clock": "nand_clk", "attempts_left": 10, "sva_result": "@(posedge nand_clk)         cache_prog_start == 1'b1 |-> ##[10:100] cache_prog_done", "sva_name": "cache_prog_completion", "full_property": "property cache_prog_timing;\n@(posedge nand_clk)         cache_prog_start == 1'b1 |-> ##[10:100] cache_prog_done\nendproperty\nassert_cache_prog_timing:assert property (cache_prog_timing) else $error(\"\");", "task_id": "1_10659", "predict_sva": "@(posedge nand_clk)     cache_prog_start == 1'b1 |-> ##[10:100] cache_prog_done"}
{"id": "878_2_3526", "name": "bad_block_remap_after_wear", "sva": "@(posedge flash_clk)     (write_cycle_count >= max_rated_cycles) |-> ##2 remap_controller_active", "ori_sva": "property bad_block_remap_after_wear;\n@(posedge flash_clk)     (write_cycle_count >= max_rated_cycles) |-> ##2 remap_controller_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bad_block_remap_after_wear  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_cycle_count >= max_rated_cycles`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 remap_controller_active`  ", "sva_signals": ["flash_clk", "[0:0] write_cycle_count", "[0:0] max_rated_cycles", "[0:0] remap_controller_active"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active", "sva_name": "remap_before_fail", "full_property": "property bad_block_remap_after_wear;\n@(posedge flash_clk)         write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active\nendproperty\nassert_bad_block_remap_after_wear:assert property (bad_block_remap_after_wear) else $error(\"\");", "task_id": "1_10675", "predict_sva": "@(posedge flash_clk)     write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active"}
{"id": "882_12_3582", "name": "command_sequence_protection", "sva": "@(posedge flash_clk)     $fell(flash_cmd_valid) && !flash_cmd_complete |-> ##1 flash_cmd_error", "ori_sva": "property command_sequence_protection;\n@(posedge flash_clk)     $fell(flash_cmd_valid) && !flash_cmd_complete |-> ##1 flash_cmd_error;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: command_sequence_protection  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(flash_cmd_valid) && !flash_cmd_complete`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 flash_cmd_error`  ", "sva_signals": ["flash_clk", "flash_cmd_valid", "flash_cmd_complete", "[0:0] flash_cmd_error"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         ($fell(flash_cmd_valid) && !flash_cmd_complete) |-> ##1 flash_cmd_error", "sva_name": "command_timeout_handling", "full_property": "property command_sequence_protection;\n@(posedge flash_clk)         ($fell(flash_cmd_valid) && !flash_cmd_complete) |-> ##1 flash_cmd_error\nendproperty\nassert_command_sequence_protection:assert property (command_sequence_protection) else $error(\"\");", "task_id": "1_10719", "predict_sva": "@(posedge flash_clk)     ($fell(flash_cmd_valid) && !flash_cmd_complete) |-> ##1 flash_cmd_error"}
{"id": "854_7_3216", "name": "p_retransmit_count_limit", "sva": "@(posedge clk_mac)     disable iff(reset_active)     retransmit_count <= max_retransmit_count", "ori_sva": "property p_retransmit_count_limit;\n@(posedge clk_mac)     disable iff(reset_active)     retransmit_count <= max_retransmit_count;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_retransmit_count_limit  \n**Trigger Condition**: At every rising edge of `clk_mac`  \n**Disable Condition**: `disable iff (reset_active)`  \n**Antecedent (LHS of Implication)**: None (This is a simple concurrent assertion without an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `retransmit_count <= max_retransmit_count`  \n\n(Note: This assertion is a direct check rather than an implication-based property. It verifies that `retransmit_count` never exceeds `max_retransmit_count` at every rising clock edge, unless `reset_active` is asserted.)", "sva_signals": ["clk_mac", "reset_active", "[0:0] retransmit_count", "[0:0] max_retransmit_count"], "clock": "clk_mac", "attempts_left": 10, "sva_result": "@(posedge clk_mac) disable iff (reset_active)     retransmit_count <= max_retransmit_count", "sva_name": "p_retransmit_count_limit", "full_property": "property p_retransmit_count_limit;\n@(posedge clk_mac) disable iff (reset_active)     retransmit_count <= max_retransmit_count\nendproperty\nassert_p_retransmit_count_limit:assert property (p_retransmit_count_limit) else $error(\"\");", "task_id": "1_10431", "predict_sva": "@(posedge clk_mac) disable iff (reset_active)     retransmit_count <= max_retransmit_count"}
{"id": "874_12_3481", "name": "schedule_transition", "sva": "@(posedge tsn_clk)     (current_time == schedule_end) |-> ##1 !queue_enable", "ori_sva": "property schedule_transition;\n@(posedge tsn_clk)     (current_time == schedule_end) |-> ##1 !queue_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: schedule_transition  \n**Trigger Condition**: At every rising edge of the `tsn_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `current_time == schedule_end`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !queue_enable`", "sva_signals": ["tsn_clk", "current_time", "schedule_end", "[0:0] queue_enable"], "clock": "tsn_clk", "attempts_left": 10, "sva_result": "@(posedge tsn_clk)         current_time == schedule_end |-> ##1 !queue_enable", "sva_name": "frame_preemption_handling", "full_property": "property schedule_transition;\n@(posedge tsn_clk)         current_time == schedule_end |-> ##1 !queue_enable\nendproperty\nassert_schedule_transition:assert property (schedule_transition) else $error(\"\");", "task_id": "1_10628", "predict_sva": "@(posedge tsn_clk)     current_time == schedule_end |-> ##1 !queue_enable"}
{"id": "889_3_3665", "name": "no_data_without_sync", "sva": "@(posedge isp_clk)     data_valid |-> (frame_valid && line_valid)", "ori_sva": "property no_data_without_sync;\n@(posedge isp_clk)     data_valid |-> (frame_valid && line_valid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_data_without_sync  \n**Trigger Condition**: At every rising edge of the `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(frame_valid && line_valid)`", "sva_signals": ["isp_clk", "[0:0] data_valid", "[0:0] frame_valid", "[0:0] line_valid"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     data_valid == 1'b1 |-> (frame_valid && line_valid)", "sva_name": "p_data_valid_implies_frame_line", "full_property": "property no_data_without_sync;\n@(posedge isp_clk)     data_valid == 1'b1 |-> (frame_valid && line_valid)\nendproperty\nassert_no_data_without_sync:assert property (no_data_without_sync) else $error(\"\");", "task_id": "1_10803", "predict_sva": "@(posedge isp_clk)     data_valid == 1'b1 |-> frame_valid && line_valid"}
{"id": "882_8_3583", "name": "power_loss_recovery", "sva": "@(posedge flash_clk)     $fell(flash_power_good) ##1 $rose(flash_power_good) |-> ##3 flash_recovery_sequence", "ori_sva": "property power_loss_recovery;\n@(posedge flash_clk)     $fell(flash_power_good) ##1 $rose(flash_power_good) |-> ##3 flash_recovery_sequence;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: power_loss_recovery  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(flash_power_good) ##1 $rose(flash_power_good)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 flash_recovery_sequence`  ", "sva_signals": ["flash_clk", "[0:0] flash_power_good", "[0:0] flash_recovery_sequence"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)     $fell(flash_power_good) ##1 $rose(flash_power_good) |-> ##3 flash_recovery_sequence", "sva_name": "pwr_loss_recovery", "full_property": "property power_loss_recovery;\n@(posedge flash_clk)     $fell(flash_power_good) ##1 $rose(flash_power_good) |-> ##3 flash_recovery_sequence\nendproperty\nassert_power_loss_recovery:assert property (power_loss_recovery) else $error(\"\");", "task_id": "1_10730", "predict_sva": "@(posedge flash_clk)     ($fell(flash_power_good) ##1 $rose(flash_power_good)) |-> ##3 flash_recovery_sequence"}
{"id": "867_4_3367", "name": "bit_stuff_error_detection", "sva": "@(posedge can_clk)     can_bit_stuff_violation |-> ##1 can_node_error_state[1]", "ori_sva": "property bit_stuff_error_detection;\n@(posedge can_clk)     can_bit_stuff_violation |-> ##1 can_node_error_state[1];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bit_stuff_error_detection  \n**Trigger Condition**: At every rising edge of `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_bit_stuff_violation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 can_node_error_state[1] == 1'b1`  \n\n(Note: The consequent checks that in the next clock cycle (`##1`), the second bit of `can_node_error_state` is asserted, indicating an error state following a bit-stuffing violation.)", "sva_signals": ["can_clk", "[0:0] can_bit_stuff_violation", "[1:0] can_node_error_state"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_bit_stuff_violation == 1'b1 |-> ##1 can_node_error_state[1] == 1'b1", "sva_name": "can_bit_stuff_violation_detection", "full_property": "property bit_stuff_error_detection;\n@(posedge can_clk)         can_bit_stuff_violation == 1'b1 |-> ##1 can_node_error_state[1] == 1'b1\nendproperty\nassert_bit_stuff_error_detection:assert property (bit_stuff_error_detection) else $error(\"\");", "task_id": "1_10571", "predict_sva": "@(posedge can_clk)     can_bit_stuff_violation == 1'b1 |-> ##1 can_node_error_state[1] == 1'b1"}
{"id": "890_13_3706", "name": "p_input_data_range_check", "sva": "@(posedge isp_clk)     data_valid_in_ |-> (pixel_data_in_ <= 24'hFFFFFF)", "ori_sva": "property p_input_data_range_check;\n@(posedge isp_clk)     data_valid_in_ |-> (pixel_data_in_ <= 24'hFFFFFF);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_input_data_range_check  \n**Trigger Condition**: At every rising edge of the `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid_in_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pixel_data_in_ <= 24'hFFFFFF`", "sva_signals": ["isp_clk", "data_valid_in_", "[23:0] pixel_data_in_"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     data_valid_in_ == 1'b1 |-> pixel_data_in_ <= 24'hFFFFFF", "sva_name": "p_input_data_range_check", "full_property": "property p_input_data_range_check;\n@(posedge isp_clk)     data_valid_in_ == 1'b1 |-> pixel_data_in_ <= 24'hFFFFFF\nendproperty\nassert_p_input_data_range_check:assert property (p_input_data_range_check) else $error(\"\");", "task_id": "1_10812", "predict_sva": "@(posedge isp_clk)     data_valid_in_ == 1'b1 |-> pixel_data_in_ <= 24'hFFFFFF"}
{"id": "890_15_3683", "name": "p_no_output_during_reset", "sva": "@(posedge isp_clk)     isp_reset_ |-> !data_valid_out_ && !frame_valid_out_", "ori_sva": "property p_no_output_during_reset;\n@(posedge isp_clk)     isp_reset_ |-> !data_valid_out_ && !frame_valid_out_;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_output_during_reset  \n**Trigger Condition**: At every rising edge of `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `isp_reset_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!data_valid_out_ && !frame_valid_out_`", "sva_signals": ["isp_clk", "isp_reset_", "[0:0] data_valid_out_", "[0:0] frame_valid_out_"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     isp_reset_ |-> (!data_valid_out_ && !frame_valid_out_)", "sva_name": "p_output_signals_low_during_reset", "full_property": "property p_no_output_during_reset;\n@(posedge isp_clk)     isp_reset_ |-> (!data_valid_out_ && !frame_valid_out_)\nendproperty\nassert_p_no_output_during_reset:assert property (p_no_output_during_reset) else $error(\"\");", "task_id": "1_10814", "predict_sva": "@(posedge isp_clk)     isp_reset_ |-> (!data_valid_out_ && !frame_valid_out_)"}
{"id": "876_6_3487", "name": "write_protect_hold", "sva": "@(posedge flash_clk)     write_protect_active |-> ##[1:10] !flash_write_enable", "ori_sva": "property write_protect_hold;\n@(posedge flash_clk)     write_protect_active |-> ##[1:10] !flash_write_enable;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: write_protect_hold  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_protect_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] !flash_write_enable`  \n\n(Note: The consequent means that within 1 to 10 clock cycles after the antecedent is true, `flash_write_enable` must be low (`!flash_write_enable`).)", "sva_signals": ["flash_clk", "[0:0] write_protect_active", "[0:0] flash_write_enable"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)     write_protect_active == 1'b1 |-> ##[1:10] !flash_write_enable", "sva_name": "p_write_protect_active", "full_property": "property write_protect_hold;\n@(posedge flash_clk)     write_protect_active == 1'b1 |-> ##[1:10] !flash_write_enable\nendproperty\nassert_write_protect_hold:assert property (write_protect_hold) else $error(\"\");", "task_id": "1_10652", "predict_sva": "@(posedge flash_clk)     write_protect_active == 1'b1 |-> ##[1:10] !flash_write_enable"}
{"id": "892_1_3721", "name": "p_core_sync_ack", "sva": "@(posedge clk_sys)     $rose(core_req_sync_[0]) |-> ##[1:4] $rose(core_ack_sync_[0])", "ori_sva": "property p_core_sync_ack;\n@(posedge clk_sys)     $rose(core_req_sync_[0]) |-> ##[1:4] $rose(core_ack_sync_[0]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_core_sync_ack  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(core_req_sync_[0])` (a rising edge is detected on `core_req_sync_[0]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] $rose(core_ack_sync_[0])` (within 1 to 4 clock cycles after the antecedent, a rising edge is detected on `core_ack_sync_[0]`)", "sva_signals": ["clk_sys", "[0:0] core_req_sync_", "[0:0] core_ack_sync_"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $rose(core_req_sync_[0]) |-> ##[1:4] $rose(core_ack_sync_[0])", "sva_name": "sync_pulse_prop_6", "full_property": "property p_core_sync_ack;\n@(posedge clk_sys)     $rose(core_req_sync_[0]) |-> ##[1:4] $rose(core_ack_sync_[0])\nendproperty\nassert_p_core_sync_ack:assert property (p_core_sync_ack) else $error(\"\");", "task_id": "1_10838", "predict_sva": "@(posedge clk_sys)     $rose(core_req_sync_[0]) |-> ##[1:4] $rose(core_ack_sync_[0])"}
{"id": "897_12_3789", "name": "p_burst_packet_continuity", "sva": "@(posedge chip_clk)     (burst_mode_active && packet_valid) |-> ##[1:4] next_packet_valid", "ori_sva": "property p_burst_packet_continuity;\n@(posedge chip_clk)     (burst_mode_active && packet_valid) |-> ##[1:4] next_packet_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_burst_packet_continuity  \n**Trigger Condition**: At every rising edge of the `chip_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `burst_mode_active && packet_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] next_packet_valid`  ", "sva_signals": ["chip_clk", "burst_mode_active", "packet_valid", "next_packet_valid"], "clock": "chip_clk", "attempts_left": 10, "sva_result": "@(posedge chip_clk)     (burst_mode_active && packet_valid) |-> ##[1:4] next_packet_valid", "sva_name": "burst_packet_sequence", "full_property": "property p_burst_packet_continuity;\n@(posedge chip_clk)     (burst_mode_active && packet_valid) |-> ##[1:4] next_packet_valid\nendproperty\nassert_p_burst_packet_continuity:assert property (p_burst_packet_continuity) else $error(\"\");", "task_id": "1_10888", "predict_sva": "@(posedge chip_clk)         (burst_mode_active && packet_valid) |-> ##[1:4] next_packet_valid"}
{"id": "896_1_3782", "name": "p_carrier_agg_handshake", "sva": "@(posedge clk_core)     $rose(carrier_agg_enable) |-> ##[1:3] (agg_ready && $stable(data_path_select))", "ori_sva": "property p_carrier_agg_handshake;\n@(posedge clk_core)     $rose(carrier_agg_enable) |-> ##[1:3] (agg_ready && $stable(data_path_select));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_carrier_agg_handshake  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(carrier_agg_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] (agg_ready && $stable(data_path_select))`  ", "sva_signals": ["clk_core", "carrier_agg_enable", "agg_ready", "data_path_select"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(carrier_agg_enable) |-> ##[1:3] (agg_ready && $stable(data_path_select))", "sva_name": "carrier_aggregation_setup", "full_property": "property p_carrier_agg_handshake;\n@(posedge clk_core)     $rose(carrier_agg_enable) |-> ##[1:3] (agg_ready && $stable(data_path_select))\nendproperty\nassert_p_carrier_agg_handshake:assert property (p_carrier_agg_handshake) else $error(\"\");", "task_id": "1_10880", "predict_sva": "@(posedge clk_core)     $rose(carrier_agg_enable) |-> ##[1:3] (agg_ready && $stable(data_path_select))"}
{"id": "896_4_3755", "name": "p_mimo_mode_consistency", "sva": "@(posedge clk_phy)     $changed(mimo_mode_select) |-> ##2 (tx_antenna_mask == rx_antenna_mask)", "ori_sva": "property p_mimo_mode_consistency;\n@(posedge clk_phy)     $changed(mimo_mode_select) |-> ##2 (tx_antenna_mask == rx_antenna_mask);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mimo_mode_consistency  \n**Trigger Condition**: At every rising edge of `clk_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(mimo_mode_select)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 (tx_antenna_mask == rx_antenna_mask)`  ", "sva_signals": ["clk", "rst_n", "[0:0] mimo_mode_select", "[0:0] tx_antenna_mask", "[0:0] rx_antenna_mask", "clk_phy"], "clock": "clk_phy", "attempts_left": 10, "sva_result": "@(posedge clk_phy)     $changed(mimo_mode_select) |-> ##2 (tx_antenna_mask == rx_antenna_mask)", "sva_name": "p_mimo_mode_consistency", "full_property": "property p_mimo_mode_consistency;\n@(posedge clk_phy)     $changed(mimo_mode_select) |-> ##2 (tx_antenna_mask == rx_antenna_mask)\nendproperty\nassert_p_mimo_mode_consistency:assert property (p_mimo_mode_consistency) else $error(\"\");", "task_id": "1_10883", "predict_sva": "@(posedge clk_phy)     $changed(mimo_mode_select) |-> ##2 (tx_antenna_mask == rx_antenna_mask)"}
{"id": "10_39_0499", "name": "p_past_val_39", "sva": "@(posedge clk)     $past(scan_enable, 1) |-> $past(test_mode, 2)", "ori_sva": "property p_past_val_39;\n@(posedge clk)     $past(scan_enable, 1) |-> $past(test_mode, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Past_Scan_Enable_Implies_Past_Test_Mode  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(scan_enable, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(test_mode, 2)`  ", "sva_signals": ["clk", "rst_n", "[0:0] scan_enable", "[0:0] test_mode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(scan_enable, 1) |-> $past(test_mode, 2)", "sva_name": "p_Scan_Enable_To_Test_Mode", "full_property": "property p_Past_Scan_Enable_Implies_Past_Test_Mode;\n@(posedge clk)     $past(scan_enable, 1) |-> $past(test_mode, 2);\nendproperty\nassert_p_Past_Scan_Enable_Implies_Past_Test_Mode:assert property (p_Past_Scan_Enable_Implies_Past_Test_Mode) else $error(\"\");", "task_id": "2_31", "predict_sva": "@(posedge clk)     $past(scan_enable, 1) |-> $past(test_mode, 2)"}
{"id": "10_23_0457", "name": "p_past_val_23", "sva": "@(posedge clk)     $past(threshold_exceeded, 4) |-> $past(warning_issued, 3)", "ori_sva": "property p_past_val_23;\n@(posedge clk)     $past(threshold_exceeded, 4) |-> $past(warning_issued, 3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Warning_After_Threshold  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(threshold_exceeded, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(warning_issued, 3)`  ", "sva_signals": ["clk", "rst_n", "[0:0] threshold_exceeded", "[0:0] warning_issued"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(threshold_exceeded, 4) |-> $past(warning_issued, 3)", "sva_name": "p_Threshold_Exceeded_Warning_Issued", "full_property": "property p_Warning_After_Threshold;\n@(posedge clk)         $past(threshold_exceeded, 4) |-> $past(warning_issued, 3);\nendproperty\nassert_p_Warning_After_Threshold:assert property (p_Warning_After_Threshold) else $error(\"\");", "task_id": "2_12", "predict_sva": "@(posedge clk)     $past(threshold_exceeded, 4) |-> $past(warning_issued, 3)"}
{"id": "10_42_0502", "name": "p_past_val_42", "sva": "@(posedge clk)     $past(temp_alert, 1) |-> $past(temp_read, 2) > max_temp", "ori_sva": "property p_past_val_42;\n@(posedge clk)     $past(temp_alert, 1) |-> $past(temp_read, 2) > max_temp;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Temp_Alert_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(temp_alert, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(temp_read, 2) > max_temp`", "sva_signals": ["clk", "rst_n", "[0:0] temp_alert", "[0:0] temp_read", "[0:0] max_temp"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(temp_alert, 1) |-> $past(temp_read, 2) > max_temp", "sva_name": "p_Temp_Alert_Check", "full_property": "property p_Temp_Alert_Check;\n@(posedge clk)         $past(temp_alert, 1) |-> $past(temp_read, 2) > max_temp;\nendproperty\nassert_p_Temp_Alert_Check:assert property (p_Temp_Alert_Check) else $error(\"\");", "task_id": "2_32", "predict_sva": "@(posedge clk)         $past(temp_alert, 1) |-> $past(temp_read, 2) > max_temp"}
{"id": "10_37_0474", "name": "p_past_val_37", "sva": "@(posedge clk)     $past(clock_gate_en, 3) |-> $past(clock_active, 4)", "ori_sva": "property p_past_val_37;\n@(posedge clk)     $past(clock_gate_en, 3) |-> $past(clock_active, 4);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Past_Clock_Gate_Enable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(clock_gate_en, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(clock_active, 4)`  ", "sva_signals": ["clk", "rst_n", "[0:0] clock_gate_en", "[0:0] clock_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(clock_gate_en, 3) |-> $past(clock_active, 4)", "sva_name": "p_ClockGateEn_Implies_Active", "full_property": "property p_Past_Clock_Gate_Enable;\n@(posedge clk)         $past(clock_gate_en, 3) |-> $past(clock_active, 4);\nendproperty\nassert_p_Past_Clock_Gate_Enable:assert property (p_Past_Clock_Gate_Enable) else $error(\"\");", "task_id": "2_26", "predict_sva": "@(posedge clk)     $past(clock_gate_en, 3) |-> $past(clock_active, 4)"}
{"id": "892_8_3747", "name": "p_pipeline_stall_clear", "sva": "@(posedge clk_core)     pipeline_stall_ |-> ##[1:5] !pipeline_stall_ && $rose(pipeline_advance_)", "ori_sva": "property p_pipeline_stall_clear;\n@(posedge clk_core)     pipeline_stall_ |-> ##[1:5] !pipeline_stall_ && $rose(pipeline_advance_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_stall_clear  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_stall_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 5 clock cycles (`##[1:5]`), the following must hold:  \n   - `pipeline_stall_` is deasserted (`!pipeline_stall_`)  \n   - A rising edge occurs on `pipeline_advance_` (`$rose(pipeline_advance_)`)  ", "sva_signals": ["clk_core", "pipeline_stall_", "pipeline_advance_"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     pipeline_stall_ == 1'b1 |-> ##[1:5] (!pipeline_stall_ && $rose(pipeline_advance_))", "sva_name": "pipeline_stall_recovery", "full_property": "property p_pipeline_stall_clear;\n@(posedge clk_core)     pipeline_stall_ == 1'b1 |-> ##[1:5] (!pipeline_stall_ && $rose(pipeline_advance_))\nendproperty\nassert_p_pipeline_stall_clear:assert property (p_pipeline_stall_clear) else $error(\"\");", "task_id": "1_10843", "predict_sva": "@(posedge clk_core)     pipeline_stall_ == 1'b1 |-> ##[1:5] (!pipeline_stall_ && $rose(pipeline_advance_))"}
{"id": "11_1_0489", "name": "p_and_1", "sva": "@(posedge clk)     req && !busy |-> grant", "ori_sva": "property p_and_1;\n@(posedge clk)     req && !busy |-> grant\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_req_grant  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req && !busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant`", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] busy", "[0:0] grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (req && !busy) |-> grant", "sva_name": "p_overlap_47", "full_property": "property p_req_grant;\n@(posedge clk)         (req && !busy) |-> grant;\nendproperty\nassert_p_req_grant:assert property (p_req_grant) else $error(\"\");", "task_id": "2_56", "predict_sva": "@(posedge clk)         req && !busy |-> grant"}
{"id": "11_12_0494", "name": "p_and_12", "sva": "@(posedge clk)     (ack && !err) && (timeout_counter == 0) |-> complete", "ori_sva": "property p_and_12;\n@(posedge clk)     (ack && !err) && (timeout_counter == 0) |-> complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AckNoErrTimeoutComplete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(ack && !err) && (timeout_counter == 0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `complete`", "sva_signals": ["clk", "rst_n", "[0:0] ack", "[0:0] err", "[0:0] complete", "[0:0] timeout_counter"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (ack && !err) && (timeout_counter == 0) |-> complete", "sva_name": "p_and_47", "full_property": "property p_AckNoErrTimeoutComplete;\n@(posedge clk)         (ack && !err) && (timeout_counter == 0) |-> complete;\nendproperty\nassert_p_AckNoErrTimeoutComplete:assert property (p_AckNoErrTimeoutComplete) else $error(\"\");", "task_id": "2_50", "predict_sva": "@(posedge clk)         (ack && !err) && (timeout_counter == 0) |-> complete"}
{"id": "10_7_0455", "name": "p_past_val_7", "sva": "@(posedge clk)     $past(state, 1) == IDLE |-> $past(cmd, 2) == NOP", "ori_sva": "property p_past_val_7;\n@(posedge clk)     $past(state, 1) == IDLE |-> $past(cmd, 2) == NOP;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_State_Idle_Past_Cmd_Nop  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(state, 1) == IDLE`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cmd, 2) == NOP`  ", "sva_signals": ["clk", "rst_n", "[1:0] state", "[1:0] cmd", "[1:0] IDLE", "[1:0] NOP"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(state, 1) == IDLE |-> $past(cmd, 2) == NOP", "sva_name": "p_Past_State_Cmd_Check", "full_property": "property p_State_Idle_Past_Cmd_Nop;\n@(posedge clk)         $past(state, 1) == IDLE |-> $past(cmd, 2) == NOP;\nendproperty\nassert_p_State_Idle_Past_Cmd_Nop:assert property (p_State_Idle_Past_Cmd_Nop) else $error(\"\");", "task_id": "2_46", "predict_sva": "@(posedge clk)         $past(state, 1) == IDLE |-> $past(cmd, 2) == NOP"}
{"id": "10_48_0501", "name": "p_past_val_48", "sva": "@(posedge clk)     $past(pll_lock, 1) |-> $past(pll_enable, 2)", "ori_sva": "property p_past_val_48;\n@(posedge clk)     $past(pll_lock, 1) |-> $past(pll_enable, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pll_Enable_After_Lock  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(pll_lock, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pll_enable, 2)`  ", "sva_signals": ["clk", "rst_n", "[0:0] pll_lock", "[0:0] pll_enable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(pll_lock, 1) |-> $past(pll_enable, 2)", "sva_name": "p_past_pll_lock_implies_enable", "full_property": "property p_Pll_Enable_After_Lock;\n@(posedge clk)     $past(pll_lock, 1) |-> $past(pll_enable, 2);\nendproperty\nassert_p_Pll_Enable_After_Lock:assert property (p_Pll_Enable_After_Lock) else $error(\"\");", "task_id": "2_39", "predict_sva": "@(posedge clk)     $past(pll_lock, 1) |-> $past(pll_enable, 2) == 1'b1"}
{"id": "11_31_0521", "name": "p_and_31", "sva": "@(posedge clk)     (test_mode && scan_enable) && !bist_active |-> scan_out_valid", "ori_sva": "property p_and_31;\n@(posedge clk)     (test_mode && scan_enable) && !bist_active |-> scan_out_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_scan_out_valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(test_mode && scan_enable) && !bist_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `scan_out_valid`", "sva_signals": ["clk", "rst_n", "[0:0] test_mode", "[0:0] scan_enable", "[0:0] bist_active", "[0:0] scan_out_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (test_mode && scan_enable) && !bist_active |-> scan_out_valid", "sva_name": "p_and_47", "full_property": "property p_scan_out_valid;\n@(posedge clk)     (test_mode && scan_enable) && !bist_active |-> scan_out_valid;\nendproperty\nassert_p_scan_out_valid:assert property (p_scan_out_valid) else $error(\"\");", "task_id": "2_68", "predict_sva": "@(posedge clk)         (test_mode && scan_enable) && !bist_active |-> scan_out_valid"}
{"id": "11_30_0515", "name": "p_and_30", "sva": "@(posedge clk)     (pwr_down && !wakeup_req) |-> ##[1:10] low_power_mode", "ori_sva": "property p_and_30;\n@(posedge clk)     (pwr_down && !wakeup_req) |-> ##[1:10] low_power_mode\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Low_Power_Mode_Activation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwr_down && !wakeup_req`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] low_power_mode`  ", "sva_signals": ["clk", "rst_n", "[0:0] pwr_down", "[0:0] wakeup_req", "[0:0] low_power_mode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pwr_down && !wakeup_req) |-> ##[1:10] low_power_mode", "sva_name": "p_and_47", "full_property": "property p_Low_Power_Mode_Activation;\n@(posedge clk)         (pwr_down && !wakeup_req) |-> ##[1:10] low_power_mode;\nendproperty\nassert_p_Low_Power_Mode_Activation:assert property (p_Low_Power_Mode_Activation) else $error(\"\");", "task_id": "2_66", "predict_sva": "@(posedge clk)         (pwr_down && !wakeup_req) |-> ##[1:10] low_power_mode"}
{"id": "11_13_0508", "name": "p_and_13", "sva": "@(posedge clk)     (power_good && !reset) |-> ##[1:5] initialized", "ori_sva": "property p_and_13;\n@(posedge clk)     (power_good && !reset) |-> ##[1:5] initialized\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PowerGood_Initialized  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_good && !reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] initialized`  ", "sva_signals": ["clk", "reset", "[0:0] power_good", "[0:0] initialized"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (power_good && !reset) |-> ##[1:5] initialized", "sva_name": "p_Initialized_After_Power_Good", "full_property": "property p_PowerGood_Initialized;\n@(posedge clk)         (power_good && !reset) |-> ##[1:5] initialized;\nendproperty\nassert_p_PowerGood_Initialized:assert property (p_PowerGood_Initialized) else $error(\"\");", "task_id": "2_51", "predict_sva": "@(posedge clk)     (power_good && !reset) |-> ##[1:5] initialized"}
{"id": "12_35_0590", "name": "p_or_35", "sva": "@(posedge clk)     (int_req || ext_req) |-> req_ack", "ori_sva": "property p_or_35;\n@(posedge clk)     (int_req || ext_req) |-> req_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Req_Ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(int_req || ext_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `req_ack`", "sva_signals": ["clk", "rst_n", "[0:0] int_req", "[0:0] ext_req", "[0:0] req_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (int_req || ext_req) |-> req_ack", "sva_name": "p_or_45", "full_property": "property p_Req_Ack;\n@(posedge clk)         (int_req || ext_req) |-> req_ack;\nendproperty\nassert_p_Req_Ack:assert property (p_Req_Ack) else $error(\"\");", "task_id": "2_122", "predict_sva": "@(posedge clk)         (int_req || ext_req) |-> req_ack"}
{"id": "11_44_0549", "name": "p_and_44", "sva": "@(posedge clk)     (can_tx_req && !can_bus_off) && arbitration_won |-> can_tx_start", "ori_sva": "property p_and_44;\n@(posedge clk)     (can_tx_req && !can_bus_off) && arbitration_won |-> can_tx_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_tx_start_condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(can_tx_req && !can_bus_off) && arbitration_won`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `can_tx_start`", "sva_signals": ["clk", "rst_n", "[0:0] can_tx_req", "[0:0] can_bus_off", "[0:0] arbitration_won", "[0:0] can_tx_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (can_tx_req && !can_bus_off) && arbitration_won |-> can_tx_start", "sva_name": "can_tx_start_condition", "full_property": "property p_can_tx_start_condition;\n@(posedge clk)         (can_tx_req && !can_bus_off) && arbitration_won |-> can_tx_start;\nendproperty\nassert_p_can_tx_start_condition:assert property (p_can_tx_start_condition) else $error(\"\");", "task_id": "2_85", "predict_sva": "@(posedge clk)         (can_tx_req && !can_bus_off) && arbitration_won |-> can_tx_start"}
{"id": "13_42_0639", "name": "p_not_42", "sva": "@(posedge clk) !(cache_miss && critical_path) |-> cache_hit", "ori_sva": "property p_not_42;\n@(posedge clk) !(cache_miss && critical_path) |-> cache_hit;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_hit_condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(cache_miss && critical_path)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cache_hit`", "sva_signals": ["clk", "rst_n", "[0:0] cache_miss", "[0:0] critical_path", "[0:0] cache_hit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(cache_miss && critical_path) |-> cache_hit", "sva_name": "p_cache_hit_check", "full_property": "property p_cache_hit_condition;\n@(posedge clk)         !(cache_miss && critical_path) |-> cache_hit;\nendproperty\nassert_p_cache_hit_condition:assert property (p_cache_hit_condition) else $error(\"\");", "task_id": "2_180", "predict_sva": "@(posedge clk)         !(cache_miss && critical_path) |-> cache_hit"}
{"id": "11_10_0519", "name": "p_and_10", "sva": "@(posedge clk)     (fifo_empty && rd_en) |-> ##1 underflow", "ori_sva": "property p_and_10;\n@(posedge clk)     (fifo_empty && rd_en) |-> ##1 underflow\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Underflow  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_empty && rd_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 underflow`  \n\n(Note: The assertion checks that if the FIFO is empty (`fifo_empty`) and a read operation is attempted (`rd_en`), then in the next clock cycle (`##1`), an underflow condition (`underflow`) must occur.)", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] rd_en", "[0:0] underflow"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         fifo_empty && rd_en |-> ##1 underflow", "sva_name": "p_and_40", "full_property": "property p_Fifo_Underflow;\n@(posedge clk)         fifo_empty && rd_en |-> ##1 underflow;\nendproperty\nassert_p_Fifo_Underflow:assert property (p_Fifo_Underflow) else $error(\"\");", "task_id": "2_49", "predict_sva": "@(posedge clk)         (fifo_empty && rd_en) |-> ##1 underflow"}
{"id": "12_11_0565", "name": "p_or_11", "sva": "@(posedge clk)     (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt", "ori_sva": "property p_or_11;\n@(posedge clk)     (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Interrupt_On_Fifo_Error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fifo_overflow || fifo_underflow)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 error_interrupt`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_overflow", "[0:0] fifo_underflow", "[0:0] error_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt", "sva_name": "p_Error_Interrupt_After_Fifo_Fault", "full_property": "property p_Error_Interrupt_On_Fifo_Error;\n@(posedge clk)         (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt;\nendproperty\nassert_p_Error_Interrupt_On_Fifo_Error:assert property (p_Error_Interrupt_On_Fifo_Error) else $error(\"\");", "task_id": "2_96", "predict_sva": "@(posedge clk)     (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt"}
{"id": "1_43_0015", "name": "p_fixed_delay_43", "sva": "@(posedge clk)     (voltage_drop && !battery_low) |-> ##1 regulator_boost", "ori_sva": "property p_fixed_delay_43;\n@(posedge clk)     (voltage_drop && !battery_low) |-> ##1 regulator_boost;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Regulator_Boost_On_Drop  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_drop && !battery_low`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 regulator_boost`  ", "sva_signals": ["clk", "rst_n", "[0:0] voltage_drop", "[0:0] battery_low", "[0:0] regulator_boost"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (voltage_drop && !battery_low) |-> ##1 regulator_boost", "sva_name": "p_and_47", "full_property": "property p_Regulator_Boost_On_Drop;\n@(posedge clk)     (voltage_drop && !battery_low) |-> ##1 regulator_boost;\nendproperty\nassert_p_Regulator_Boost_On_Drop:assert property (p_Regulator_Boost_On_Drop) else $error(\"\");", "task_id": "2_294", "predict_sva": "@(posedge clk)         (voltage_drop && !battery_low) |-> ##1 regulator_boost"}
{"id": "3_1_0088", "name": "p_req_grant_with_data", "sva": "@(posedge clk)     (req && data_valid) |-> (grant && data_ready)", "ori_sva": "property p_req_grant_with_data;\n@(posedge clk)     (req && data_valid) |-> (grant && data_ready);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_req_data_valid_grant_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req && data_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant && data_ready`", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] data_valid", "[0:0] grant", "[0:0] data_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (req && data_valid) |-> (grant && data_ready)", "sva_name": "p_and_46", "full_property": "property p_req_data_valid_grant_ready;\n@(posedge clk)     (req && data_valid) |-> (grant && data_ready);\nendproperty\nassert_p_req_data_valid_grant_ready:assert property (p_req_data_valid_grant_ready) else $error(\"\");", "task_id": "2_364", "predict_sva": "@(posedge clk)         req && data_valid |-> grant && data_ready"}
{"id": "11_9_0507", "name": "p_and_9", "sva": "@(posedge clk)     (mode[0] && !mode[1]) && enable |-> ##2 output_en", "ori_sva": "property p_and_9;\n@(posedge clk)     (mode[0] && !mode[1]) && enable |-> ##2 output_en\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mode_enable_output  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(mode[0] && !mode[1]) && enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 output_en`  ", "sva_signals": ["clk", "rst_n", "[1:0] mode", "[0:0] enable", "[0:0] output_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((mode[0] && !mode[1]) && enable) |-> ##2 output_en", "sva_name": "p_and_46", "full_property": "property p_mode_enable_output;\n@(posedge clk)         ((mode[0] && !mode[1]) && enable) |-> ##2 output_en;\nendproperty\nassert_p_mode_enable_output:assert property (p_mode_enable_output) else $error(\"\");", "task_id": "2_95", "predict_sva": "@(posedge clk)         (mode[0] && !mode[1]) && enable |-> ##2 output_en"}
{"id": "1_36_0078", "name": "p_fixed_delay_36", "sva": "@(posedge clk)     (thunderbolt_wake && !low_power) |-> ##1 thunderbolt_active", "ori_sva": "property p_fixed_delay_36;\n@(posedge clk)     (thunderbolt_wake && !low_power) |-> ##1 thunderbolt_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thunderbolt_Wake_Active  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thunderbolt_wake && !low_power`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 thunderbolt_active`", "sva_signals": ["clk", "rst_n", "[0:0] thunderbolt_wake", "[0:0] low_power", "[0:0] thunderbolt_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     thunderbolt_wake && !low_power |-> ##1 thunderbolt_active", "sva_name": "p_thunderbolt_activation", "full_property": "property p_Thunderbolt_Wake_Active;\n@(posedge clk)     thunderbolt_wake && !low_power |-> ##1 thunderbolt_active;\nendproperty\nassert_p_Thunderbolt_Wake_Active:assert property (p_Thunderbolt_Wake_Active) else $error(\"\");", "task_id": "2_286", "predict_sva": "@(posedge clk)         (thunderbolt_wake && !low_power) |-> ##1 thunderbolt_active"}
{"id": "8_22_0354", "name": "p_fell_burst_last_in_packet", "sva": "@(posedge clk)     $fell(burst) |-> in_packet", "ori_sva": "property p_fell_burst_last_in_packet;\n@(posedge clk)     $fell(burst) |-> in_packet;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Fell_Burst_In_Packet  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(burst)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `in_packet`", "sva_signals": ["clk", "rst_n", "[0:0] burst", "[0:0] in_packet"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(burst) |-> in_packet", "sva_name": "p_fell_burst_in_packet", "full_property": "property p_Fell_Burst_In_Packet;\n@(posedge clk)         $fell(burst) |-> in_packet;\nendproperty\nassert_p_Fell_Burst_In_Packet:assert property (p_Fell_Burst_In_Packet) else $error(\"\");", "task_id": "2_554", "predict_sva": "@(posedge clk)         $fell(burst) |-> in_packet"}
{"id": "3_2_0108", "name": "p_error_abort_with_status", "sva": "@(posedge clk)     (error && error_type == 2'b01) |-> (abort && status != 3'b000)", "ori_sva": "property p_error_abort_with_status;\n@(posedge clk)     (error && error_type == 2'b01) |-> (abort && status != 3'b000);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Abort_Status  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error && (error_type == 2'b01)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `abort && (status != 3'b000)`", "sva_signals": ["clk", "rst_n", "[0:0] error", "[1:0] error_type", "[0:0] abort", "[2:0] status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (error && (error_type == 2'b01)) |-> (abort && (status != 3'b000))", "sva_name": "p_Error_Abort_Status", "full_property": "property p_Error_Abort_Status;\n@(posedge clk)     (error && (error_type == 2'b01)) |-> (abort && (status != 3'b000));\nendproperty\nassert_p_Error_Abort_Status:assert property (p_Error_Abort_Status) else $error(\"\");", "task_id": "2_375", "predict_sva": "@(posedge clk)         (error && (error_type == 2'b01)) |-> (abort && (status != 3'b000))"}
{"id": "1_40_0079", "name": "p_fixed_delay_40", "sva": "@(posedge clk)     (edp_panel_power_on && !backlight_off) |-> ##1 edp_video_on", "ori_sva": "property p_fixed_delay_40;\n@(posedge clk)     (edp_panel_power_on && !backlight_off) |-> ##1 edp_video_on;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_edp_video_on_after_power_on  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `edp_panel_power_on && !backlight_off`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 edp_video_on`  \n\n(Note: The property checks that if the EDP panel is powered on (`edp_panel_power_on`) and the backlight is not off (`!backlight_off`), then in the next clock cycle (`##1`), the EDP video signal (`edp_video_on`) must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] edp_panel_power_on", "[0:0] backlight_off", "[0:0] edp_video_on"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (edp_panel_power_on && !backlight_off) |-> ##1 edp_video_on", "sva_name": "p_edp_video_on_after_power", "full_property": "property p_edp_video_on_after_power_on;\n@(posedge clk)     (edp_panel_power_on && !backlight_off) |-> ##1 edp_video_on;\nendproperty\nassert_p_edp_video_on_after_power_on:assert property (p_edp_video_on_after_power_on) else $error(\"\");", "task_id": "2_291", "predict_sva": "@(posedge clk)         (edp_panel_power_on && !backlight_off) |-> ##1 edp_video_on"}
{"id": "5_1_0231", "name": "p_1", "sva": "@(posedge clk)     start |-> ##1 data_valid[*3] ##1 done", "ori_sva": "property p_1;\n@(posedge clk)     start |-> ##1 data_valid[*3] ##1 done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_start_to_data_valid_to_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 data_valid[*3] ##1 done`  \n**Consequent Explanation**:  \n- After 1 clock cycle (`##1`), `data_valid` must remain high for 3 consecutive cycles (`[*3]`), followed by `done` being high 1 clock cycle later (`##1`).  \n\n(Note: The property checks that if `start` is high, then in the next cycle, `data_valid` must stay high for 3 cycles, and `done` must assert in the cycle immediately after those 3 cycles.)", "sva_signals": ["clk", "rst_n", "[0:0] start", "[0:0] data_valid", "[0:0] done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         start == 1'b1 |-> ##1 data_valid[*3] ##1 done", "sva_name": "p_Start_DataValid_Done", "full_property": "property p_start_to_data_valid_to_done;\n@(posedge clk)         start == 1'b1 |-> ##1 data_valid[*3] ##1 done;\nendproperty\nassert_p_start_to_data_valid_to_done:assert property (p_start_to_data_valid_to_done) else $error(\"\");", "task_id": "2_461", "predict_sva": "@(posedge clk)     start == 1'b1 |-> ##1 data_valid[*3] ##1 done"}
{"id": "1_50_0060", "name": "p_fixed_delay_50", "sva": "@(posedge clk)     (analog_test_enable && !calibration_active) |-> ##7 adc_test_result_valid", "ori_sva": "property p_fixed_delay_50;\n@(posedge clk)     (analog_test_enable && !calibration_active) |-> ##7 adc_test_result_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Adc_Test_Result_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `analog_test_enable && !calibration_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##7 adc_test_result_valid`", "sva_signals": ["clk", "rst_n", "[0:0] analog_test_enable", "[0:0] calibration_active", "[0:0] adc_test_result_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (analog_test_enable && !calibration_active) |-> ##7 adc_test_result_valid", "sva_name": "p_and_46", "full_property": "property p_Adc_Test_Result_Valid;\n@(posedge clk)     (analog_test_enable && !calibration_active) |-> ##7 adc_test_result_valid;\nendproperty\nassert_p_Adc_Test_Result_Valid:assert property (p_Adc_Test_Result_Valid) else $error(\"\");", "task_id": "2_302", "predict_sva": "@(posedge clk)         (analog_test_enable && !calibration_active) |-> ##7 adc_test_result_valid"}
{"id": "2_18_0068", "name": "p_var_delay_18", "sva": "@(posedge clk) mem_write |-> ##[5:10] mem_read", "ori_sva": "property p_var_delay_18;\n@(posedge clk) mem_write |-> ##[5:10] mem_read;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_write_to_read  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_write == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] mem_read == 1'b1`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] mem_write", "[0:0] mem_read"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         mem_write == 1'b1 |-> ##[5:10] mem_read == 1'b1", "sva_name": "p_mem_write_to_read", "full_property": "property p_mem_write_to_read;\n@(posedge clk)         mem_write == 1'b1 |-> ##[5:10] mem_read == 1'b1;\nendproperty\nassert_p_mem_write_to_read:assert property (p_mem_write_to_read) else $error(\"\");", "task_id": "2_314", "predict_sva": "@(posedge clk)     mem_write == 1'b1 |-> ##[5:10] mem_read == 1'b1"}
{"id": "10_34_0481", "name": "p_debounced_input", "sva": "@(posedge clk)     $past(raw_in,5) == $past(raw_in,4) |-> debounced_in", "ori_sva": "property p_debounced_input;\n@(posedge clk)     $past(raw_in,5) == $past(raw_in,4) |-> debounced_in;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Debounced_Input  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(raw_in, 5) == $past(raw_in, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `debounced_in`  ", "sva_signals": ["clk", "rst_n", "[7:0] raw_in", "[0:0] debounced_in"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(raw_in, 5) == $past(raw_in, 4) |-> debounced_in", "sva_name": "p_past_debounce", "full_property": "property p_Debounced_Input;\n@(posedge clk)     $past(raw_in, 5) == $past(raw_in, 4) |-> debounced_in;\nendproperty\nassert_p_Debounced_Input:assert property (p_Debounced_Input) else $error(\"\");", "task_id": "2_666", "predict_sva": "@(posedge clk)         ($past(raw_in, 5) == $past(raw_in, 4)) |-> debounced_in"}
{"id": "3_19_0099", "name": "p_parity_error_correct", "sva": "@(posedge clk)     parity_error |-> (error_correct && !parity_ok)", "ori_sva": "property p_parity_error_correct;\n@(posedge clk)     parity_error |-> (error_correct && !parity_ok);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Error_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `parity_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(error_correct && !parity_ok)`", "sva_signals": ["clk", "rst_n", "[0:0] parity_error", "[0:0] error_correct", "[0:0] parity_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         parity_error == 1'b1 |-> (error_correct && !parity_ok)", "sva_name": "p_Parity_Error_Condition", "full_property": "property p_Parity_Error_Check;\n@(posedge clk)         parity_error == 1'b1 |-> (error_correct && !parity_ok);\nendproperty\nassert_p_Parity_Error_Check:assert property (p_Parity_Error_Check) else $error(\"\");", "task_id": "2_363", "predict_sva": "@(posedge clk)         parity_error == 1'b1 |-> (error_correct && !parity_ok)"}
{"id": "2_29_0056", "name": "p_var_delay_29", "sva": "@(posedge clk) ecc_error |-> ##[2:5] ecc_corrected", "ori_sva": "property p_var_delay_29;\n@(posedge clk) ecc_error |-> ##[2:5] ecc_corrected;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ecc_error_to_corrected  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] ecc_corrected == 1'b1`  \n\n(Note: The consequent specifies that within 2 to 5 clock cycles after the antecedent is true, `ecc_corrected` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] ecc_error", "[0:0] ecc_corrected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ecc_error == 1'b1 |-> ##[2:5] ecc_corrected == 1'b1", "sva_name": "p_ecc_error_to_corrected", "full_property": "property p_ecc_error_to_corrected;\n@(posedge clk)     ecc_error == 1'b1 |-> ##[2:5] ecc_corrected == 1'b1;\nendproperty\nassert_p_ecc_error_to_corrected:assert property (p_ecc_error_to_corrected) else $error(\"\");", "task_id": "2_325", "predict_sva": "@(posedge clk)     ecc_error == 1'b1 |-> ##[2:5] ecc_corrected == 1'b1"}
{"id": "12_27_0573", "name": "p_or_27", "sva": "@(posedge clk)     (crc_err || ecc_err) |-> retry_operation", "ori_sva": "property p_or_27;\n@(posedge clk)     (crc_err || ecc_err) |-> retry_operation\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Retry  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(crc_err || ecc_err)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `retry_operation`", "sva_signals": ["clk", "rst_n", "[0:0] crc_err", "[0:0] ecc_err", "[0:0] retry_operation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (crc_err || ecc_err) |-> retry_operation", "sva_name": "p_or_40", "full_property": "property p_Error_Retry;\n@(posedge clk)     (crc_err || ecc_err) |-> retry_operation;\nendproperty\nassert_p_Error_Retry:assert property (p_Error_Retry) else $error(\"\");", "task_id": "2_750", "predict_sva": "@(posedge clk)         (crc_err || ecc_err) |-> retry_operation"}
{"id": "10_42_0493", "name": "p_spi_mode_change", "sva": "@(posedge clk)     $past(spi_mode,2) != spi_mode |-> $past(cs_n,1)", "ori_sva": "property p_spi_mode_change;\n@(posedge clk)     $past(spi_mode,2) != spi_mode |-> $past(cs_n,1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_mode_change_cs_n  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(spi_mode, 2) != spi_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cs_n, 1)`  ", "sva_signals": ["clk", "rst_n", "[1:0] spi_mode", "[0:0] cs_n"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ($past(spi_mode, 2) != spi_mode) |-> $past(cs_n, 1)", "sva_name": "p_past_spi_mode_switch", "full_property": "property p_spi_mode_change_cs_n;\n@(posedge clk)     ($past(spi_mode, 2) != spi_mode) |-> $past(cs_n, 1);\nendproperty\nassert_p_spi_mode_change_cs_n:assert property (p_spi_mode_change_cs_n) else $error(\"\");", "task_id": "2_675", "predict_sva": "@(posedge clk)     $past(spi_mode, 2) != spi_mode |-> $past(cs_n, 1)"}
{"id": "11_25_0522", "name": "p_and_25", "sva": "@(posedge clk) (debug_mode && trace_enable) |-> (trace_data != 32'h0)", "ori_sva": "property p_and_25;\n@(posedge clk) (debug_mode && trace_enable) |-> (trace_data != 32'h0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_DebugModeTraceData  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `debug_mode && trace_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `trace_data != 32'h0`", "sva_signals": ["clk", "rst_n", "[0:0] debug_mode", "[0:0] trace_enable", "[31:0] trace_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (debug_mode && trace_enable) |-> (trace_data != 32'h0)", "sva_name": "p_DebugMode_TraceEnable_Check", "full_property": "property p_DebugModeTraceData;\n@(posedge clk)         (debug_mode && trace_enable) |-> (trace_data != 32'h0);\nendproperty\nassert_p_DebugModeTraceData:assert property (p_DebugModeTraceData) else $error(\"\");", "task_id": "2_703", "predict_sva": "@(posedge clk)         (debug_mode && trace_enable) |-> (trace_data != 32'h0)"}
{"id": "12_42_0575", "name": "p_or_42", "sva": "@(posedge clk)     (channel_a_act || channel_b_act) |-> mux_select", "ori_sva": "property p_or_42;\n@(posedge clk)     (channel_a_act || channel_b_act) |-> mux_select\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Mux_Select_Activation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `channel_a_act || channel_b_act`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mux_select`", "sva_signals": ["clk", "rst_n", "[0:0] channel_a_act", "[0:0] channel_b_act", "[0:0] mux_select"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (channel_a_act || channel_b_act) |-> mux_select", "sva_name": "p_or_47", "full_property": "property p_Mux_Select_Activation;\n@(posedge clk)         (channel_a_act || channel_b_act) |-> mux_select;\nendproperty\nassert_p_Mux_Select_Activation:assert property (p_Mux_Select_Activation) else $error(\"\");", "task_id": "2_767", "predict_sva": "@(posedge clk)         (channel_a_act || channel_b_act) |-> mux_select"}
{"id": "4_12_0168", "name": "p_hold_data_until_ack", "sva": "@(posedge clk)     data_valid |=> data_ack || $stable(data_bus)", "ori_sva": "property p_hold_data_until_ack;\n@(posedge clk)     data_valid |=> data_ack || $stable(data_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_valid_ack_or_stable  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `data_ack == 1'b1 || $stable(data_bus)`  \n\n(Note: The `|=>` operator indicates that the consequent is checked on the next clock cycle after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[0:0] data_ack", "data_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         data_valid == 1'b1 |=> (data_ack == 1'b1 || $stable(data_bus))", "sva_name": "p_data_valid_stable_check", "full_property": "property p_data_valid_ack_or_stable;\n@(posedge clk)         data_valid == 1'b1 |=> (data_ack == 1'b1 || $stable(data_bus));\nendproperty\nassert_p_data_valid_ack_or_stable:assert property (p_data_valid_ack_or_stable) else $error(\"\");", "task_id": "2_406", "predict_sva": "@(posedge clk)     data_valid == 1'b1 |-> ##1 ($stable(data_bus) || data_ack)"}
{"id": "5_33_0212", "name": "p_33", "sva": "@(posedge clk)     (packet_start && !packet_error)[*6] |-> packet_complete", "ori_sva": "property p_33;\n@(posedge clk)     (packet_start && !packet_error)[*6] |-> packet_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_complete_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(packet_start && !packet_error)[*6]` (packet_start is high and packet_error is low for 6 consecutive cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `packet_complete` (packet_complete must be high in the cycle following the 6-cycle antecedent condition)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_error", "[0:0] packet_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (packet_start && !packet_error)[*6] |-> packet_complete", "sva_name": "prop_38", "full_property": "property p_packet_complete_after_start;\n@(posedge clk)         (packet_start && !packet_error)[*6] |-> packet_complete;\nendproperty\nassert_p_packet_complete_after_start:assert property (p_packet_complete_after_start) else $error(\"\");", "task_id": "2_474", "predict_sva": "@(posedge clk)     (packet_start && !packet_error)[*6] |-> packet_complete"}
{"id": "12_9_0557", "name": "p_or_9", "sva": "@(posedge clk)     (test_mode || debug_mode) |-> !normal_op", "ori_sva": "property p_or_9;\n@(posedge clk)     (test_mode || debug_mode) |-> !normal_op\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_TestDebug_Mode_NormalOp  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(test_mode || debug_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!normal_op`", "sva_signals": ["clk", "rst_n", "[0:0] test_mode", "[0:0] debug_mode", "[0:0] normal_op"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (test_mode || debug_mode) |-> !normal_op", "sva_name": "p_or_47", "full_property": "property p_TestDebug_Mode_NormalOp;\n@(posedge clk)     (test_mode || debug_mode) |-> !normal_op;\nendproperty\nassert_p_TestDebug_Mode_NormalOp:assert property (p_TestDebug_Mode_NormalOp) else $error(\"\");", "task_id": "2_782", "predict_sva": "@(posedge clk)         (test_mode || debug_mode) |-> !normal_op"}
{"id": "13_40_0640", "name": "p_not_40", "sva": "@(posedge clk) !(!dac_update && dac_ready) |-> dac_active", "ori_sva": "property p_not_40;\n@(posedge clk) !(!dac_update && dac_ready) |-> dac_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Dac_Active_Condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!dac_update && dac_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dac_active`  ", "sva_signals": ["clk", "rst_n", "[0:0] dac_update", "[0:0] dac_ready", "[0:0] dac_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !(!dac_update && dac_ready) |-> dac_active", "sva_name": "p_dac_active_condition", "full_property": "property p_Dac_Active_Condition;\n@(posedge clk)     !(!dac_update && dac_ready) |-> dac_active;\nendproperty\nassert_p_Dac_Active_Condition:assert property (p_Dac_Active_Condition) else $error(\"\");", "task_id": "2_815", "predict_sva": "@(posedge clk)         !(!dac_update && dac_ready) |-> dac_active"}
{"id": "13_38_0639", "name": "p_not_38", "sva": "@(posedge clk) !(!pwm_enable && pwm_start) |-> pwm_running", "ori_sva": "property p_not_38;\n@(posedge clk) !(!pwm_enable && pwm_start) |-> pwm_running;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pwm_running_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!pwm_enable && pwm_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pwm_running`  ", "sva_signals": ["clk", "rst_n", "[0:0] pwm_enable", "[0:0] pwm_start", "[0:0] pwm_running"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!pwm_enable && pwm_start) |-> pwm_running", "sva_name": "p_PWM_Running_Condition", "full_property": "property p_pwm_running_check;\n@(posedge clk)         !(!pwm_enable && pwm_start) |-> pwm_running;\nendproperty\nassert_p_pwm_running_check:assert property (p_pwm_running_check) else $error(\"\");", "task_id": "2_812", "predict_sva": "@(posedge clk)         !(!pwm_enable && pwm_start) |-> pwm_running"}
{"id": "11_27_0538", "name": "p_and_27", "sva": "@(negedge clk) (crc_match && eop_detected) |=> packet_done", "ori_sva": "property p_and_27;\n@(negedge clk) (crc_match && eop_detected) |=> packet_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match_eop_to_packet_done  \n**Trigger Condition**: At every negedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_match && eop_detected`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `packet_done`  \n\n(Note: The `|=>` operator indicates that the consequent (`packet_done`) must hold true in the next clock cycle (negedge) after the antecedent (`crc_match && eop_detected`) is satisfied.)", "sva_signals": ["clk", "rst_n", "[0:0] crc_match", "[0:0] eop_detected", "[0:0] packet_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (crc_match && eop_detected) |=> packet_done", "sva_name": "p_crc_match_eop_detected", "full_property": "property p_crc_match_eop_to_packet_done;\n@(negedge clk)     (crc_match && eop_detected) |=> packet_done;\nendproperty\nassert_p_crc_match_eop_to_packet_done:assert property (p_crc_match_eop_to_packet_done) else $error(\"\");", "task_id": "2_705", "predict_sva": "@(negedge clk)     (crc_match && eop_detected) |-> ##1 packet_done"}
{"id": "11_5_0509", "name": "p_and_5", "sva": "@(negedge clk) (fifo_full && write_en) |-> $past(error, 1)", "ori_sva": "property p_and_5;\n@(negedge clk) (fifo_full && write_en) |-> $past(error, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FifoFull_WriteEn_Error  \n**Trigger Condition**: At every negedge of the `clk`;  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_full && write_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(error, 1)`  \n\n(Note: The assertion checks that whenever `fifo_full` and `write_en` are both true at the falling edge of `clk`, the value of `error` from the previous clock cycle must be true.)", "sva_signals": ["clk", "rst_n", "[0:0] fifo_full", "[0:0] write_en", "[0:0] error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (fifo_full && write_en) |-> $past(error, 1)", "sva_name": "p_FifoFull_WriteEn_Error", "full_property": "property p_FifoFull_WriteEn_Error;\n@(negedge clk)     (fifo_full && write_en) |-> $past(error, 1);\nendproperty\nassert_p_FifoFull_WriteEn_Error:assert property (p_FifoFull_WriteEn_Error) else $error(\"\");", "task_id": "2_730", "predict_sva": "@(negedge clk)     fifo_full && write_en |-> $past(error, 1)"}
{"id": "12_33_0591", "name": "p_or_33", "sva": "@(posedge clk)     (first_beat || last_beat) |-> beat_count", "ori_sva": "property p_or_33;\n@(posedge clk)     (first_beat || last_beat) |-> beat_count\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_beat_count_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(first_beat || last_beat)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `beat_count`  \n\n(Note: The consequent `beat_count` appears to be incomplete in the original SVA code - typically, we'd expect a comparison or evaluation here like `beat_count == value` or `beat_count > 0`. The description reflects the assertion as given.)", "sva_signals": ["clk", "rst_n", "[0:0] first_beat", "[0:0] last_beat", "[0:0] beat_count"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (first_beat || last_beat) |-> beat_count;     // WARNING: Consequent 'beat_count' appears incomplete - typically should include comparison/operation     // Example expected format: (first_beat || last_beat) |-> (beat_count == expected_value)", "sva_name": "p_beat_count_check", "full_property": "property p_beat_count_check;\n@(posedge clk)     (first_beat || last_beat) |-> beat_count;     // WARNING: Consequent 'beat_count' appears incomplete - typically should include comparison/operation     // Example expected format: (first_beat || last_beat) |-> (beat_count == expected_value)\nendproperty\nassert_p_beat_count_check:assert property (p_beat_count_check) else $error(\"\");", "task_id": "2_757", "predict_sva": "@(posedge clk)     (first_beat || last_beat) |-> beat_count"}
{"id": "1_17_0073", "name": "p_quiesce_after_stop", "sva": "@(posedge clk)     stop |-> ##2 quiesce", "ori_sva": "property p_quiesce_after_stop;\n@(posedge clk)     stop |-> ##2 quiesce;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stop_to_quiesce  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `stop == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 quiesce == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] stop", "[0:0] quiesce"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         stop == 1'b1 |-> ##2 quiesce == 1'b1", "sva_name": "p_fixed_delay_46", "full_property": "property p_stop_to_quiesce;\n@(posedge clk)         stop == 1'b1 |-> ##2 quiesce == 1'b1;\nendproperty\nassert_p_stop_to_quiesce:assert property (p_stop_to_quiesce) else $error(\"\");", "task_id": "2_907", "predict_sva": "@(posedge clk)         stop == 1'b1 |-> ##2 quiesce == 1'b1"}
{"id": "2_23_0016", "name": "p_register_write_propagation", "sva": "@(posedge clk) reg_write |-> ##[1:3] reg_update", "ori_sva": "property p_register_write_propagation;\n@(posedge clk) reg_write |-> ##[1:3] reg_update;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_reg_update_after_write  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reg_write == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] reg_update`  ", "sva_signals": ["clk", "rst_n", "[0:0] reg_write", "[0:0] reg_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         reg_write == 1'b1 |-> ##[1:3] reg_update", "sva_name": "p_reg_write_to_update", "full_property": "property p_reg_update_after_write;\n@(posedge clk)         reg_write == 1'b1 |-> ##[1:3] reg_update;\nendproperty\nassert_p_reg_update_after_write:assert property (p_reg_update_after_write) else $error(\"\");", "task_id": "2_964", "predict_sva": "@(posedge clk)     reg_write == 1'b1 |-> ##[1:3] reg_update"}
{"id": "10_2_0450", "name": "p_fifo_ptr_wrap", "sva": "@(posedge clk)     $past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20 |-> wr_ptr == 'h21", "ori_sva": "property p_fifo_ptr_wrap;\n@(posedge clk)     $past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20 |-> wr_ptr == 'h21;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wr_ptr_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wr_ptr == 'h21`  ", "sva_signals": ["clk", "rst_n", "[4:0] wr_ptr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20) |-> (wr_ptr == 'h21)", "sva_name": "p_past_wr_ptr_sequence", "full_property": "property p_wr_ptr_sequence;\n@(posedge clk)         ($past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20) |-> (wr_ptr == 'h21);\nendproperty\nassert_p_wr_ptr_sequence:assert property (p_wr_ptr_sequence) else $error(\"\");", "task_id": "2_662", "predict_sva": "@(posedge clk)         ($past(wr_ptr, 3) == 'h1F && $past(wr_ptr, 2) == 'h20) |-> (wr_ptr == 'h21)"}
{"id": "2_24_0010", "name": "p_sensor_sample_ready", "sva": "@(posedge clk) sample_start |-> ##[5:10] sample_ready", "ori_sva": "property p_sensor_sample_ready;\n@(posedge clk) sample_start |-> ##[5:10] sample_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sample_ready_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sample_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] sample_ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] sample_start", "[0:0] sample_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     sample_start == 1'b1 |-> ##[5:10] sample_ready", "sva_name": "p_sample_ready_after_start", "full_property": "property p_sample_ready_after_start;\n@(posedge clk)     sample_start == 1'b1 |-> ##[5:10] sample_ready;\nendproperty\nassert_p_sample_ready_after_start:assert property (p_sample_ready_after_start) else $error(\"\");", "task_id": "2_965", "predict_sva": "@(posedge clk)     sample_start == 1'b1 |-> ##[5:10] sample_ready"}
{"id": "15_25_0711", "name": "p_burst_transfer_1", "sva": "@(posedge clk) disable iff(burst_rst) burst_start |-> ##4 burst_end", "ori_sva": "property p_burst_transfer_1;\n@(posedge clk) disable iff(burst_rst) burst_start |-> ##4 burst_end;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_burst_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (burst_rst)`  \n**Antecedent (LHS of Implication)**: `burst_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 burst_end == 1'b1`  \n\n(Note: The assertion checks that if `burst_start` is high, then exactly 4 clock cycles later, `burst_end` must also be high. The check is disabled if `burst_rst` is active.)", "sva_signals": ["clk", "burst_rst", "[0:0] burst_start", "[0:0] burst_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (burst_rst)         burst_start == 1'b1 |-> ##4 burst_end == 1'b1", "sva_name": "p_burst_start_to_end", "full_property": "property p_burst_sequence;\n@(posedge clk) disable iff (burst_rst)         burst_start == 1'b1 |-> ##4 burst_end == 1'b1;\nendproperty\nassert_p_burst_sequence:assert property (p_burst_sequence) else $error(\"\");", "task_id": "2_866", "predict_sva": "@(posedge clk) disable iff (burst_rst)         burst_start == 1'b1 |-> ##4 burst_end == 1'b1"}
{"id": "1_23_0042", "name": "p_wakeup_after_pwr_on", "sva": "@(posedge clk)     pwr_on |-> ##15 wakeup", "ori_sva": "property p_wakeup_after_pwr_on;\n@(posedge clk)     pwr_on |-> ##15 wakeup;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wakeup_after_pwr_on  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwr_on == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##15 wakeup == 1'b1`  \n\n(Note: The consequent specifies that 15 clock cycles after the antecedent is true, the signal `wakeup` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] pwr_on", "[0:0] wakeup"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     pwr_on == 1'b1 |-> ##15 wakeup == 1'b1", "sva_name": "p_wakeup_after_pwr_on", "full_property": "property p_wakeup_after_pwr_on;\n@(posedge clk)     pwr_on == 1'b1 |-> ##15 wakeup == 1'b1;\nendproperty\nassert_p_wakeup_after_pwr_on:assert property (p_wakeup_after_pwr_on) else $error(\"\");", "task_id": "2_914", "predict_sva": "@(posedge clk)         pwr_on == 1'b1 |-> ##15 wakeup == 1'b1"}
{"id": "2_26_0046", "name": "p_dac_settling_time", "sva": "@(posedge clk) dac_update |-> ##[3:7] dac_ready", "ori_sva": "property p_dac_settling_time;\n@(posedge clk) dac_update |-> ##[3:7] dac_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dac_ready_after_update  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dac_update == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] dac_ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] dac_update", "[0:0] dac_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     dac_update == 1'b1 |-> ##[3:7] dac_ready", "sva_name": "p_dac_update_to_ready", "full_property": "property p_dac_ready_after_update;\n@(posedge clk)     dac_update == 1'b1 |-> ##[3:7] dac_ready;\nendproperty\nassert_p_dac_ready_after_update:assert property (p_dac_ready_after_update) else $error(\"\");", "task_id": "2_967", "predict_sva": "@(posedge clk)     dac_update == 1'b1 |-> ##[3:7] dac_ready"}
{"id": "1_33_0030", "name": "p_gclk_stable_after_en", "sva": "@(posedge clk)     gclk_en |-> ##5 gclk_stable", "ori_sva": "property p_gclk_stable_after_en;\n@(posedge clk)     gclk_en |-> ##5 gclk_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gclk_stable_after_enable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gclk_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 gclk_stable` (The signal `gclk_stable` must be true 5 clock cycles after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] gclk_en", "[0:0] gclk_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     gclk_en == 1'b1 |-> ##5 gclk_stable", "sva_name": "p_gclk_stable_after_enable", "full_property": "property p_gclk_stable_after_enable;\n@(posedge clk)     gclk_en == 1'b1 |-> ##5 gclk_stable;\nendproperty\nassert_p_gclk_stable_after_enable:assert property (p_gclk_stable_after_enable) else $error(\"\");", "task_id": "2_925", "predict_sva": "@(posedge clk)     gclk_en == 1'b1 |-> ##5 gclk_stable == 1'b1"}
{"id": "3_11_0083", "name": "p_11", "sva": "@(posedge clk)     (tx_fifo_not_empty && tx_ready) |-> tx_valid", "ori_sva": "property p_11;\n@(posedge clk)     (tx_fifo_not_empty && tx_ready) |-> tx_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_tx_valid_assertion  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_fifo_not_empty && tx_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tx_valid`", "sva_signals": ["clk", "rst_n", "[0:0] tx_fifo_not_empty", "[0:0] tx_ready", "[0:0] tx_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         tx_fifo_not_empty && tx_ready |-> tx_valid", "sva_name": "p_tx_valid_condition", "full_property": "property p_tx_valid_assertion;\n@(posedge clk)         tx_fifo_not_empty && tx_ready |-> tx_valid;\nendproperty\nassert_p_tx_valid_assertion:assert property (p_tx_valid_assertion) else $error(\"\");", "task_id": "2_1002", "predict_sva": "@(posedge clk)         (tx_fifo_not_empty && tx_ready) |-> tx_valid"}
{"id": "1_39_0054", "name": "p_master_sync_after_slave", "sva": "@(posedge clk)     slave_sync |-> ##1 master_sync", "ori_sva": "property p_master_sync_after_slave;\n@(posedge clk)     slave_sync |-> ##1 master_sync;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_slave_to_master_sync  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `slave_sync == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 master_sync == 1'b1`  \n\n(Note: The consequent checks that `master_sync` is high one clock cycle after `slave_sync` is high.)", "sva_signals": ["clk", "rst_n", "[0:0] slave_sync", "[0:0] master_sync"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         slave_sync == 1'b1 |-> ##1 master_sync == 1'b1", "sva_name": "p_slave_sync_to_master_sync", "full_property": "property p_slave_to_master_sync;\n@(posedge clk)         slave_sync == 1'b1 |-> ##1 master_sync == 1'b1;\nendproperty\nassert_p_slave_to_master_sync:assert property (p_slave_to_master_sync) else $error(\"\");", "task_id": "2_931", "predict_sva": "@(posedge clk)         slave_sync == 1'b1 |-> ##1 master_sync == 1'b1"}
{"id": "1_38_0052", "name": "p_low_power_after_idle", "sva": "@(posedge clk)     idle_timeout |-> ##3 low_power", "ori_sva": "property p_low_power_after_idle;\n@(posedge clk)     idle_timeout |-> ##3 low_power;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Idle_Timeout_Low_Power  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `idle_timeout == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 3 clock cycles (`##3`), `low_power` must be asserted (`low_power == 1'b1`)  \n\n(Note: The assertion checks that if `idle_timeout` is high, then 3 clock cycles later, `low_power` must also be high.)", "sva_signals": ["clk", "rst_n", "[0:0] idle_timeout", "[0:0] low_power"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         idle_timeout == 1'b1 |-> ##3 low_power == 1'b1", "sva_name": "p_Idle_Timeout_Low_Power", "full_property": "property p_Idle_Timeout_Low_Power;\n@(posedge clk)         idle_timeout == 1'b1 |-> ##3 low_power == 1'b1;\nendproperty\nassert_p_Idle_Timeout_Low_Power:assert property (p_Idle_Timeout_Low_Power) else $error(\"\");", "task_id": "2_930", "predict_sva": "@(posedge clk)         idle_timeout == 1'b1 |-> ##3 low_power == 1'b1"}
{"id": "3_20_0118", "name": "p_20", "sva": "@(posedge clk)     (debug_mode && debug_cmd_valid) |-> debug_resp_ready", "ori_sva": "property p_20;\n@(posedge clk)     (debug_mode && debug_cmd_valid) |-> debug_resp_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_debug_resp_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `debug_mode && debug_cmd_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `debug_resp_ready`", "sva_signals": ["clk", "rst_n", "[0:0] debug_mode", "[0:0] debug_cmd_valid", "[0:0] debug_resp_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (debug_mode && debug_cmd_valid) |-> debug_resp_ready", "sva_name": "p_overlap_47", "full_property": "property p_debug_resp_ready;\n@(posedge clk)         (debug_mode && debug_cmd_valid) |-> debug_resp_ready;\nendproperty\nassert_p_debug_resp_ready:assert property (p_debug_resp_ready) else $error(\"\");", "task_id": "2_1011", "predict_sva": "@(posedge clk)         (debug_mode && debug_cmd_valid) |-> debug_resp_ready"}
{"id": "1_44_0009", "name": "p_scan_done_after_start", "sva": "@(posedge clk)     scan_start |-> ##200 scan_done", "ori_sva": "property p_scan_done_after_start;\n@(posedge clk)     scan_start |-> ##200 scan_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_scan_start_to_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `scan_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##200 scan_done == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] scan_start", "[0:0] scan_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         scan_start == 1'b1 |-> ##200 scan_done == 1'b1", "sva_name": "p_scan_start_to_done", "full_property": "property p_scan_start_to_done;\n@(posedge clk)         scan_start == 1'b1 |-> ##200 scan_done == 1'b1;\nendproperty\nassert_p_scan_start_to_done:assert property (p_scan_start_to_done) else $error(\"\");", "task_id": "2_937", "predict_sva": "@(posedge clk)     scan_start == 1'b1 |-> ##200 scan_done == 1'b1"}
{"id": "3_25_0124", "name": "p_25", "sva": "@(posedge clk)     (thermal_critical && !thermal_override) |-> throttle_enable", "ori_sva": "property p_25;\n@(posedge clk)     (thermal_critical && !thermal_override) |-> throttle_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Throttle_On_Thermal_Critical  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_critical && !thermal_override`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `throttle_enable`", "sva_signals": ["clk", "rst_n", "[0:0] thermal_critical", "[0:0] thermal_override", "[0:0] throttle_enable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (thermal_critical && !thermal_override) |-> throttle_enable", "sva_name": "p_and_46", "full_property": "property p_Throttle_On_Thermal_Critical;\n@(posedge clk)         (thermal_critical && !thermal_override) |-> throttle_enable;\nendproperty\nassert_p_Throttle_On_Thermal_Critical:assert property (p_Throttle_On_Thermal_Critical) else $error(\"\");", "task_id": "2_1016", "predict_sva": "@(posedge clk)         (thermal_critical && !thermal_override) |-> throttle_enable"}
{"id": "3_29_0103", "name": "p_29", "sva": "@(posedge clk)     (spi_cs_assert && spi_busy) |-> spi_error", "ori_sva": "property p_29;\n@(posedge clk)     (spi_cs_assert && spi_busy) |-> spi_error;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_error_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `spi_cs_assert && spi_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `spi_error`  ", "sva_signals": ["clk", "rst_n", "[0:0] spi_cs_assert", "[0:0] spi_busy", "[0:0] spi_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (spi_cs_assert && spi_busy) |-> spi_error", "sva_name": "p_spi_error_check", "full_property": "property p_spi_error_check;\n@(posedge clk)     (spi_cs_assert && spi_busy) |-> spi_error;\nendproperty\nassert_p_spi_error_check:assert property (p_spi_error_check) else $error(\"\");", "task_id": "2_1020", "predict_sva": "@(posedge clk)         spi_cs_assert && spi_busy |-> spi_error"}
{"id": "2_46_0120", "name": "p_sd_card_read_latency", "sva": "@(posedge clk) sd_read_cmd |-> ##[5:10] sd_data_ready", "ori_sva": "property p_sd_card_read_latency;\n@(posedge clk) sd_read_cmd |-> ##[5:10] sd_data_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sd_read_cmd_to_data_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sd_read_cmd == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] sd_data_ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] sd_read_cmd", "[0:0] sd_data_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready", "sva_name": "p_sd_data_ready_after_cmd", "full_property": "property p_sd_read_cmd_to_data_ready;\n@(posedge clk)         sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready;\nendproperty\nassert_p_sd_read_cmd_to_data_ready:assert property (p_sd_read_cmd_to_data_ready) else $error(\"\");", "task_id": "2_989", "predict_sva": "@(posedge clk)     sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready"}
{"id": "2_20_0078", "name": "p_decryption_block_latency", "sva": "@(posedge clk) decrypt_req |-> ##[6:14] decrypt_done", "ori_sva": "property p_decryption_block_latency;\n@(posedge clk) decrypt_req |-> ##[6:14] decrypt_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_decrypt_req_to_done  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `decrypt_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[6:14] decrypt_done == 1'b1`  \n\n(Note: The consequent specifies that `decrypt_done` must become true within 6 to 14 clock cycles after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] decrypt_req", "[0:0] decrypt_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     decrypt_req == 1'b1 |-> ##[6:14] decrypt_done == 1'b1", "sva_name": "p_decrypt_req_to_done", "full_property": "property p_decrypt_req_to_done;\n@(posedge clk)     decrypt_req == 1'b1 |-> ##[6:14] decrypt_done == 1'b1;\nendproperty\nassert_p_decrypt_req_to_done:assert property (p_decrypt_req_to_done) else $error(\"\");", "task_id": "2_961", "predict_sva": "@(posedge clk)     decrypt_req == 1'b1 |-> ##[6:14] decrypt_done == 1'b1"}
{"id": "3_37_0122", "name": "p_37", "sva": "@(posedge clk)     (usb_sof_detected && usb_en) |-> usb_frame_start", "ori_sva": "property p_37;\n@(posedge clk)     (usb_sof_detected && usb_en) |-> usb_frame_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_usb_frame_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_sof_detected && usb_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `usb_frame_start`", "sva_signals": ["clk", "rst_n", "[0:0] usb_sof_detected", "[0:0] usb_en", "[0:0] usb_frame_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         usb_sof_detected && usb_en |-> usb_frame_start", "sva_name": "p_overlap_49", "full_property": "property p_usb_frame_start;\n@(posedge clk)         usb_sof_detected && usb_en |-> usb_frame_start;\nendproperty\nassert_p_usb_frame_start:assert property (p_usb_frame_start) else $error(\"\");", "task_id": "2_1029", "predict_sva": "@(posedge clk)         (usb_sof_detected && usb_en) |-> usb_frame_start"}
{"id": "3_38_0140", "name": "p_38", "sva": "@(posedge clk)     (can_tx_ready && can_bus_idle) |-> can_tx_start", "ori_sva": "property p_38;\n@(posedge clk)     (can_tx_ready && can_bus_idle) |-> can_tx_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_tx_start_condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_tx_ready && can_bus_idle`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `can_tx_start`", "sva_signals": ["clk", "rst_n", "[0:0] can_tx_ready", "[0:0] can_bus_idle", "[0:0] can_tx_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         can_tx_ready && can_bus_idle |-> can_tx_start", "sva_name": "p_can_tx_start", "full_property": "property p_can_tx_start_condition;\n@(posedge clk)         can_tx_ready && can_bus_idle |-> can_tx_start;\nendproperty\nassert_p_can_tx_start_condition:assert property (p_can_tx_start_condition) else $error(\"\");", "task_id": "2_1030", "predict_sva": "@(posedge clk)         (can_tx_ready && can_bus_idle) |-> can_tx_start"}
{"id": "3_27_0110", "name": "p_27", "sva": "@(posedge clk)     (adc_sample_ready && adc_chan_en[3]) |-> adc_data_valid[3]", "ori_sva": "property p_27;\n@(posedge clk)     (adc_sample_ready && adc_chan_en[3]) |-> adc_data_valid[3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_data_valid_chan3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `adc_sample_ready && adc_chan_en[3]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `adc_data_valid[3]`", "sva_signals": ["clk", "rst_n", "[0:0] adc_sample_ready", "[3:0] adc_chan_en", "[3:0] adc_data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (adc_sample_ready && adc_chan_en[3]) |-> adc_data_valid[3]", "sva_name": "p_adc_data_valid_channel_3", "full_property": "property p_adc_data_valid_chan3;\n@(posedge clk)         (adc_sample_ready && adc_chan_en[3]) |-> adc_data_valid[3];\nendproperty\nassert_p_adc_data_valid_chan3:assert property (p_adc_data_valid_chan3) else $error(\"\");", "task_id": "2_1018", "predict_sva": "@(posedge clk)         (adc_sample_ready && adc_chan_en[3]) |-> adc_data_valid[3]"}
{"id": "3_45_0147", "name": "p_45", "sva": "@(posedge clk)     (dram_refresh_req && dram_init_done) |-> dram_refresh_ack", "ori_sva": "property p_45;\n@(posedge clk)     (dram_refresh_req && dram_init_done) |-> dram_refresh_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dram_refresh_ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dram_refresh_req && dram_init_done`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dram_refresh_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] dram_refresh_req", "[0:0] dram_init_done", "[0:0] dram_refresh_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (dram_refresh_req && dram_init_done) |-> dram_refresh_ack", "sva_name": "p_overlap_47", "full_property": "property p_dram_refresh_ack;\n@(posedge clk)         (dram_refresh_req && dram_init_done) |-> dram_refresh_ack;\nendproperty\nassert_p_dram_refresh_ack:assert property (p_dram_refresh_ack) else $error(\"\");", "task_id": "2_1038", "predict_sva": "@(posedge clk)         dram_refresh_req && dram_init_done |-> dram_refresh_ack"}
{"id": "2_33_0084", "name": "p_flash_program_time", "sva": "@(posedge clk) flash_prog |-> ##[20:50] flash_ready", "ori_sva": "property p_flash_program_time;\n@(posedge clk) flash_prog |-> ##[20:50] flash_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_flash_prog_to_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flash_prog == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[20:50] flash_ready == 1'b1`  \n\n(Note: The consequent specifies that within 20 to 50 clock cycles after the antecedent is true, `flash_ready` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] flash_prog", "[0:0] flash_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         flash_prog == 1'b1 |-> ##[20:50] flash_ready == 1'b1", "sva_name": "p_flash_prog_to_ready", "full_property": "property p_flash_prog_to_ready;\n@(posedge clk)         flash_prog == 1'b1 |-> ##[20:50] flash_ready == 1'b1;\nendproperty\nassert_p_flash_prog_to_ready:assert property (p_flash_prog_to_ready) else $error(\"\");", "task_id": "2_975", "predict_sva": "@(posedge clk)     flash_prog == 1'b1 |-> ##[20:50] flash_ready == 1'b1"}
{"id": "5_16_0231", "name": "p_fixed_rep_16", "sva": "@(posedge clk) (crc_match)[*3] |-> crc_valid", "ori_sva": "property p_fixed_rep_16;\n@(posedge clk) (crc_match)[*3] |-> crc_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match_to_valid  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_match` is true for 3 consecutive clock cycles (`crc_match[*3]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crc_valid` is true in the same cycle as the last occurrence of `crc_match` in the sequence", "sva_signals": ["clk", "rst_n", "[0:0] crc_match", "[0:0] crc_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     crc_match[*3] |-> crc_valid", "sva_name": "p_crc_match_to_valid", "full_property": "property p_crc_match_to_valid;\n@(posedge clk)     crc_match[*3] |-> crc_valid;\nendproperty\nassert_p_crc_match_to_valid:assert property (p_crc_match_to_valid) else $error(\"\");", "task_id": "2_1102", "predict_sva": "@(posedge clk)     crc_match[*3] |-> crc_valid"}
{"id": "2_45_0085", "name": "p_pcie_completion_timeout", "sva": "@(posedge clk) pcie_req |-> ##[8:16] pcie_comp", "ori_sva": "property p_pcie_completion_timeout;\n@(posedge clk) pcie_req |-> ##[8:16] pcie_comp;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pcie_req_to_comp  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pcie_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] pcie_comp == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] pcie_req", "[0:0] pcie_comp"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         pcie_req == 1'b1 |-> ##[8:16] pcie_comp == 1'b1", "sva_name": "p_pcie_req_comp_check", "full_property": "property p_pcie_req_to_comp;\n@(posedge clk)         pcie_req == 1'b1 |-> ##[8:16] pcie_comp == 1'b1;\nendproperty\nassert_p_pcie_req_to_comp:assert property (p_pcie_req_to_comp) else $error(\"\");", "task_id": "2_988", "predict_sva": "@(posedge clk)     pcie_req == 1'b1 |-> ##[8:16] pcie_comp == 1'b1"}
{"id": "5_7_0188", "name": "p_fixed_rep_7", "sva": "@(posedge clk) sync[*4] |-> ##4 $stable(signal)", "ori_sva": "property p_fixed_rep_7;\n@(posedge clk) sync[*4] |-> ##4 $stable(signal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_stable_signal  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync` is true for 4 consecutive clock cycles (`sync[*4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 4 clock cycles (`##4`), `signal` remains stable (`$stable(signal)`)  ", "sva_signals": ["clk", "rst_n", "[0:0] sync", "[0:0] signal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sync[*4] |-> ##4 $stable(signal)", "sva_name": "p_20", "full_property": "property p_sync_stable_signal;\n@(posedge clk)         sync[*4] |-> ##4 $stable(signal);\nendproperty\nassert_p_sync_stable_signal:assert property (p_sync_stable_signal) else $error(\"\");", "task_id": "2_1141", "predict_sva": "@(posedge clk)     sync[*4] |-> ##4 $stable(signal)"}
{"id": "3_3_0144", "name": "p_3", "sva": "@(posedge clk)     (error_code == 4'h1) |-> (status_reg[0] && !status_reg[1])", "ori_sva": "property p_3;\n@(posedge clk)     (error_code == 4'h1) |-> (status_reg[0] && !status_reg[1]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ErrorCode_StatusReg  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_code == 4'h1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `status_reg[0] && !status_reg[1]`", "sva_signals": ["clk", "rst_n", "[3:0] error_code", "[1:0] status_reg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         error_code == 4'h1 |-> status_reg[0] && !status_reg[1]", "sva_name": "p_error_code_status_check", "full_property": "property p_ErrorCode_StatusReg;\n@(posedge clk)         error_code == 4'h1 |-> status_reg[0] && !status_reg[1];\nendproperty\nassert_p_ErrorCode_StatusReg:assert property (p_ErrorCode_StatusReg) else $error(\"\");", "task_id": "2_1032", "predict_sva": "@(posedge clk)     error_code == 4'h1 |-> status_reg[0] == 1 && status_reg[1] == 0"}
{"id": "10_31_0472", "name": "p_past_clock_switch", "sva": "@(posedge clk)     $past(clk_sel,1) != clk_sel |-> pll_locked", "ori_sva": "property p_past_clock_switch;\n@(posedge clk)     $past(clk_sel,1) != clk_sel |-> pll_locked;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_clock_switch  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(clk_sel, 1) != clk_sel`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pll_locked`", "sva_signals": ["clk", "rst_n", "pll_locked", "clk_sel"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(clk_sel, 1) != clk_sel |-> pll_locked", "sva_name": "p_past_clock_switch", "full_property": "property p_past_clock_switch;\n@(posedge clk)     $past(clk_sel, 1) != clk_sel |-> pll_locked;\nendproperty\nassert_p_past_clock_switch:assert property (p_past_clock_switch) else $error(\"\");", "task_id": "2_1359", "predict_sva": "@(posedge clk)     $past(clk_sel, 1) != clk_sel |-> pll_locked"}
{"id": "7_4_0275", "name": "p_rose_4", "sva": "@(posedge clk) $rose(valid) |-> ##2 ready", "ori_sva": "property p_rose_4;\n@(posedge clk) $rose(valid) |-> ##2 ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Valid_Rose_To_Ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(valid) |-> ##2 ready", "sva_name": "p_rose_valid_ready_after", "full_property": "property p_Valid_Rose_To_Ready;\n@(posedge clk)         $rose(valid) |-> ##2 ready;\nendproperty\nassert_p_Valid_Rose_To_Ready:assert property (p_Valid_Rose_To_Ready) else $error(\"\");", "task_id": "2_1233", "predict_sva": "@(posedge clk)         $rose(valid) |-> ##2 ready"}
{"id": "10_24_0465", "name": "p_past_voltage_monitor", "sva": "@(posedge clk)     $past(voltage_ok,1) |-> !brownout_reset", "ori_sva": "property p_past_voltage_monitor;\n@(posedge clk)     $past(voltage_ok,1) |-> !brownout_reset;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_voltage_monitor  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(voltage_ok, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!brownout_reset`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_ok", "[0:0] brownout_reset"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(voltage_ok, 1) |-> !brownout_reset", "sva_name": "p_past_voltage_monitoring", "full_property": "property p_past_voltage_monitor;\n@(posedge clk)         $past(voltage_ok, 1) |-> !brownout_reset;\nendproperty\nassert_p_past_voltage_monitor:assert property (p_past_voltage_monitor) else $error(\"\");", "task_id": "2_1351", "predict_sva": "@(posedge clk)         $past(voltage_ok, 1) |-> !brownout_reset"}
{"id": "8_5_0362", "name": "p_fell_start_no_busy", "sva": "@(posedge clk)     $fell(start) |-> ##2 !busy", "ori_sva": "property p_fell_start_no_busy;\n@(posedge clk)     $fell(start) |-> ##2 !busy;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fell_Start_To_Busy  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 !busy`  \n\n(Note: The property checks that whenever `start` has a falling edge, the signal `busy` should be deasserted (`!busy`) two clock cycles later.)", "sva_signals": ["clk", "rst_n", "[0:0] start", "[0:0] busy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(start) |-> ##2 !busy", "sva_name": "p_fell_4", "full_property": "property p_Fell_Start_To_Busy;\n@(posedge clk)     $fell(start) |-> ##2 !busy;\nendproperty\nassert_p_Fell_Start_To_Busy:assert property (p_Fell_Start_To_Busy) else $error(\"\");", "task_id": "2_1283", "predict_sva": "@(posedge clk)         $fell(start) |-> ##2 !busy"}
{"id": "11_16_0506", "name": "p_and_16", "sva": "@(posedge clk)     (addr_match && !access_denied) |-> data_transfer", "ori_sva": "property p_and_16;\n@(posedge clk)     (addr_match && !access_denied) |-> data_transfer\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_16  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(addr_match && !access_denied)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_transfer`", "sva_signals": ["clk", "rst_n", "[0:0] addr_match", "[0:0] access_denied", "[0:0] data_transfer"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (addr_match && !access_denied) |-> data_transfer", "sva_name": "p_overlap_45", "full_property": "property p_and_16;\n@(posedge clk)         (addr_match && !access_denied) |-> data_transfer;\nendproperty\nassert_p_and_16:assert property (p_and_16) else $error(\"\");", "task_id": "2_1392", "predict_sva": "@(posedge clk)         (addr_match && !access_denied) |-> data_transfer"}
{"id": "10_28_0461", "name": "p_past_sync_pulse", "sva": "@(posedge clk)     $past(sync_pulse,5) |-> frame_start", "ori_sva": "property p_past_sync_pulse;\n@(posedge clk)     $past(sync_pulse,5) |-> frame_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_sync_pulse  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(sync_pulse, 5)` (sync_pulse was high 5 clock cycles ago)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `frame_start` (frame_start must be high in the current cycle)", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] frame_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(sync_pulse, 5) |-> frame_start", "sva_name": "p_past_sync_pulse", "full_property": "property p_past_sync_pulse;\n@(posedge clk)     $past(sync_pulse, 5) |-> frame_start;\nendproperty\nassert_p_past_sync_pulse:assert property (p_past_sync_pulse) else $error(\"\");", "task_id": "2_1355", "predict_sva": "@(posedge clk)         $past(sync_pulse, 5) |-> frame_start"}
{"id": "11_19_0536", "name": "p_and_19", "sva": "@(posedge clk)     (test_mode && scan_enable) |-> scan_data_out", "ori_sva": "property p_and_19;\n@(posedge clk)     (test_mode && scan_enable) |-> scan_data_out\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_19  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `test_mode && scan_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `scan_data_out`", "sva_signals": ["clk", "rst_n", "[0:0] test_mode", "[0:0] scan_enable", "[0:0] scan_data_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (test_mode && scan_enable) |-> scan_data_out", "sva_name": "p_overlap_47", "full_property": "property p_and_19;\n@(posedge clk)         (test_mode && scan_enable) |-> scan_data_out;\nendproperty\nassert_p_and_19:assert property (p_and_19) else $error(\"\");", "task_id": "2_1395", "predict_sva": "@(posedge clk)         (test_mode && scan_enable) |-> scan_data_out"}
{"id": "6_37_0300", "name": "prop_37", "sva": "@(posedge clk)      (fan_on && !fan_off)[*6:10] |-> ##2 fan_error", "ori_sva": "property prop_37;\n@(posedge clk)      (fan_on && !fan_off)[*6:10] |-> ##2 fan_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fan_Error_After_On  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fan_on && !fan_off)` holds true consecutively for 6 to 10 clock cycles (`[*6:10]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 2 clock cycles (`##2`), `fan_error` is asserted  ", "sva_signals": ["clk", "rst_n", "[0:0] fan_on", "[0:0] fan_off", "[0:0] fan_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (fan_on && !fan_off)[*6:10] |-> ##2 fan_error", "sva_name": "p_var_rep_35", "full_property": "property p_Fan_Error_After_On;\n@(posedge clk)     (fan_on && !fan_off)[*6:10] |-> ##2 fan_error;\nendproperty\nassert_p_Fan_Error_After_On:assert property (p_Fan_Error_After_On) else $error(\"\");", "task_id": "2_1171", "predict_sva": "@(posedge clk)     (fan_on && !fan_off)[*6:10] |-> ##2 fan_error"}
{"id": "11_35_0533", "name": "p_and_35", "sva": "@(posedge clk)     (timer_expired && !timer_disabled) |-> timer_interrupt", "ori_sva": "property p_and_35;\n@(posedge clk)     (timer_expired && !timer_disabled) |-> timer_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_35  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timer_expired && !timer_disabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `timer_interrupt`", "sva_signals": ["clk", "rst_n", "[0:0] timer_expired", "[0:0] timer_disabled", "[0:0] timer_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (timer_expired && !timer_disabled) |-> timer_interrupt", "sva_name": "p_overlap_46", "full_property": "property p_and_35;\n@(posedge clk)         (timer_expired && !timer_disabled) |-> timer_interrupt;\nendproperty\nassert_p_and_35:assert property (p_and_35) else $error(\"\");", "task_id": "2_1413", "predict_sva": "@(posedge clk)         timer_expired && !timer_disabled |-> timer_interrupt"}
{"id": "11_24_0511", "name": "p_and_24", "sva": "@(posedge clk)     (queue_push && !queue_full) |-> queue_count_inc", "ori_sva": "property p_and_24;\n@(posedge clk)     (queue_push && !queue_full) |-> queue_count_inc\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_24  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `queue_push && !queue_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `queue_count_inc`", "sva_signals": ["clk", "rst_n", "[0:0] queue_push", "[0:0] queue_full", "[0:0] queue_count_inc"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (queue_push && !queue_full) |-> queue_count_inc", "sva_name": "p_overlap_49", "full_property": "property p_and_24;\n@(posedge clk)         (queue_push && !queue_full) |-> queue_count_inc;\nendproperty\nassert_p_and_24:assert property (p_and_24) else $error(\"\");", "task_id": "2_1401", "predict_sva": "@(posedge clk)         (queue_push && !queue_full) |-> queue_count_inc"}
{"id": "10_13_0457", "name": "p_past_fsm_transition", "sva": "@(posedge clk)     $past(next_state,1) != curr_state |-> state_changed", "ori_sva": "property p_past_fsm_transition;\n@(posedge clk)     $past(next_state,1) != curr_state |-> state_changed;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_fsm_transition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(next_state, 1) != curr_state`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `state_changed`  ", "sva_signals": ["clk", "rst_n", "[0:0] state_changed", "[0:0] next_state", "[0:0] curr_state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(next_state, 1) != curr_state |-> state_changed", "sva_name": "p_past_state_transition", "full_property": "property p_past_fsm_transition;\n@(posedge clk)         $past(next_state, 1) != curr_state |-> state_changed;\nendproperty\nassert_p_past_fsm_transition:assert property (p_past_fsm_transition) else $error(\"\");", "task_id": "2_1342", "predict_sva": "@(posedge clk)         ($past(next_state, 1) != curr_state) |-> state_changed"}
{"id": "11_47_0539", "name": "p_and_47", "sva": "@(posedge clk)     (gpio_int_en && gpio_edge_detect) |-> gpio_interrupt", "ori_sva": "property p_and_47;\n@(posedge clk)     (gpio_int_en && gpio_edge_detect) |-> gpio_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_47  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gpio_int_en && gpio_edge_detect`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gpio_interrupt`", "sva_signals": ["clk", "rst_n", "[0:0] gpio_int_en", "[0:0] gpio_edge_detect", "[0:0] gpio_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (gpio_int_en && gpio_edge_detect) |-> gpio_interrupt", "sva_name": "p_gpio_interrupt_trigger", "full_property": "property p_and_47;\n@(posedge clk)         (gpio_int_en && gpio_edge_detect) |-> gpio_interrupt;\nendproperty\nassert_p_and_47:assert property (p_and_47) else $error(\"\");", "task_id": "2_1428", "predict_sva": "@(posedge clk)         (gpio_int_en && gpio_edge_detect) |-> gpio_interrupt"}
{"id": "11_49_0549", "name": "p_and_49", "sva": "@(posedge clk)     (modem_rx_en && modem_sync_detect) |-> modem_data_valid", "ori_sva": "property p_and_49;\n@(posedge clk)     (modem_rx_en && modem_sync_detect) |-> modem_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_49  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `modem_rx_en && modem_sync_detect`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `modem_data_valid`", "sva_signals": ["clk", "rst_n", "[0:0] modem_rx_en", "[0:0] modem_sync_detect", "[0:0] modem_data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (modem_rx_en && modem_sync_detect) |-> modem_data_valid", "sva_name": "p_overlap_45", "full_property": "property p_and_49;\n@(posedge clk)         (modem_rx_en && modem_sync_detect) |-> modem_data_valid;\nendproperty\nassert_p_and_49:assert property (p_and_49) else $error(\"\");", "task_id": "2_1427", "predict_sva": "@(posedge clk)         (modem_rx_en && modem_sync_detect) |-> modem_data_valid"}
{"id": "11_8_0512", "name": "p_and_8", "sva": "@(posedge clk)     (interrupt_pending && !interrupt_mask) |-> interrupt_ack", "ori_sva": "property p_and_8;\n@(posedge clk)     (interrupt_pending && !interrupt_mask) |-> interrupt_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `interrupt_pending && !interrupt_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interrupt_ack`", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_pending", "[0:0] interrupt_mask", "[0:0] interrupt_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (interrupt_pending && !interrupt_mask) |-> interrupt_ack", "sva_name": "p_overlap_40", "full_property": "property p_and_8;\n@(posedge clk)         (interrupt_pending && !interrupt_mask) |-> interrupt_ack;\nendproperty\nassert_p_and_8:assert property (p_and_8) else $error(\"\");", "task_id": "2_1433", "predict_sva": "@(posedge clk)         (interrupt_pending && !interrupt_mask) |-> interrupt_ack"}
{"id": "10_50_0527", "name": "p_past_yield_request", "sva": "@(posedge clk)     $past(yield_req,5) |-> arbitration_grant", "ori_sva": "property p_past_yield_request;\n@(posedge clk)     $past(yield_req,5) |-> arbitration_grant;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_past_yield_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(yield_req, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `arbitration_grant`", "sva_signals": ["clk", "rst_n", "[0:0] yield_req", "[0:0] arbitration_grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(yield_req, 5) |-> arbitration_grant", "sva_name": "p_past_yield_priority", "full_property": "property p_past_yield_request;\n@(posedge clk)         $past(yield_req, 5) |-> arbitration_grant;\nendproperty\nassert_p_past_yield_request:assert property (p_past_yield_request) else $error(\"\");", "task_id": "2_1379", "predict_sva": "@(posedge clk)         $past(yield_req, 5) |-> arbitration_grant"}
{"id": "13_13_0621", "name": "p_not_13", "sva": "@(posedge clk) !(parity_error || crc_error) |-> data_good", "ori_sva": "property p_not_13;\n@(posedge clk) !(parity_error || crc_error) |-> data_good;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_13  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(parity_error || crc_error)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_good`", "sva_signals": ["clk", "rst_n", "[0:0] parity_error", "[0:0] crc_error", "[0:0] data_good"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(parity_error || crc_error) |-> data_good", "sva_name": "p_not_47", "full_property": "property p_not_13;\n@(posedge clk)         !(parity_error || crc_error) |-> data_good;\nendproperty\nassert_p_not_13:assert property (p_not_13) else $error(\"\");", "task_id": "2_1487", "predict_sva": "@(posedge clk)         !(parity_error || crc_error) |-> data_good"}
{"id": "3_9_0142", "name": "p_9", "sva": "@(posedge clk)     (data_in_valid && (data_in[31:28] == 4'b1100)) |-> (data_out_ready && data_out[0])", "ori_sva": "property p_9;\n@(posedge clk)     (data_in_valid && (data_in[31:28] == 4'b1100)) |-> (data_out_ready && data_out[0]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_out_ready_on_valid_input  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_in_valid && (data_in[31:28] == 4'b1100)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_out_ready && data_out[0]`  ", "sva_signals": ["clk", "rst_n", "[0:0] data_in_valid", "[31:0] data_in", "[0:0] data_out_ready", "[0:0] data_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (data_in_valid && (data_in[31:28] == 4'b1100)) |-> (data_out_ready && data_out[0])", "sva_name": "p_data_out_ready_after_valid", "full_property": "property p_data_out_ready_on_valid_input;\n@(posedge clk)     (data_in_valid && (data_in[31:28] == 4'b1100)) |-> (data_out_ready && data_out[0]);\nendproperty\nassert_p_data_out_ready_on_valid_input:assert property (p_data_out_ready_on_valid_input) else $error(\"\");", "task_id": "2_1049", "predict_sva": "@(posedge clk)         (data_in_valid && (data_in[31:28] == 4'b1100)) |-> (data_out_ready && data_out[0])"}
{"id": "12_12_0584", "name": "p_or_12", "sva": "@(posedge clk)     $changed(control_reg[3:0]) || $stable(status_reg[7:4]) |-> reg_update", "ori_sva": "property p_or_12;\n@(posedge clk)     $changed(control_reg[3:0]) || $stable(status_reg[7:4]) |-> reg_update\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_12  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(control_reg[3:0]) || $stable(status_reg[7:4])`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `reg_update`  ", "sva_signals": ["clk", "rst_n", "[3:0] control_reg", "[7:0] status_reg", "[0:0] reg_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($changed(control_reg[3:0]) || $stable(status_reg[7:4])) |-> reg_update", "sva_name": "p_or_48", "full_property": "property p_or_12;\n@(posedge clk)         ($changed(control_reg[3:0]) || $stable(status_reg[7:4])) |-> reg_update;\nendproperty\nassert_p_or_12:assert property (p_or_12) else $error(\"\");", "task_id": "2_1437", "predict_sva": "@(posedge clk)         ($changed(control_reg[3:0]) || $stable(status_reg[7:4])) |-> reg_update"}
{"id": "13_20_0603", "name": "p_not_20", "sva": "@(posedge clk) !(phase1 && !phase2) |-> sync", "ori_sva": "property p_not_20;\n@(posedge clk) !(phase1 && !phase2) |-> sync;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_20  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(phase1 && !phase2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sync`", "sva_signals": ["clk", "rst_n", "[0:0] sync", "[0:0] phase1", "[0:0] phase2"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(phase1 && !phase2) |-> sync", "sva_name": "p_not_47", "full_property": "property p_not_20;\n@(posedge clk)         !(phase1 && !phase2) |-> sync;\nendproperty\nassert_p_not_20:assert property (p_not_20) else $error(\"\");", "task_id": "2_1495", "predict_sva": "@(posedge clk)         !(phase1 && !phase2) |-> sync"}
{"id": "12_22_0571", "name": "p_or_22", "sva": "@(posedge clk)     $past(fifo_write,2) || $past(mem_write,2) |-> write_pending", "ori_sva": "property p_or_22;\n@(posedge clk)     $past(fifo_write,2) || $past(mem_write,2) |-> write_pending\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_22  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(fifo_write, 2) || $past(mem_write, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `write_pending`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_write", "[0:0] mem_write", "[0:0] write_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(fifo_write, 2) || $past(mem_write, 2)) |-> write_pending", "sva_name": "p_or_47", "full_property": "property p_or_22;\n@(posedge clk)         ($past(fifo_write, 2) || $past(mem_write, 2)) |-> write_pending;\nendproperty\nassert_p_or_22:assert property (p_or_22) else $error(\"\");", "task_id": "2_1448", "predict_sva": "@(posedge clk)         ($past(fifo_write, 2) || $past(mem_write, 2)) |-> write_pending"}
{"id": "11_20_0513", "name": "p_and_20", "sva": "@(posedge clk)     (sync_pulse && !sync_hold) |=> sync_complete", "ori_sva": "property p_and_20;\n@(posedge clk)     (sync_pulse && !sync_hold) |=> sync_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_20  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse && !sync_hold`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `sync_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] sync_hold", "[0:0] sync_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sync_pulse && !sync_hold) |=> sync_complete", "sva_name": "p_and_46", "full_property": "property p_and_20;\n@(posedge clk)         (sync_pulse && !sync_hold) |=> sync_complete;\nendproperty\nassert_p_and_20:assert property (p_and_20) else $error(\"\");", "task_id": "2_1397", "predict_sva": "@(posedge clk)         (sync_pulse && !sync_hold) |-> ##1 sync_complete"}
{"id": "13_27_0619", "name": "p_not_27", "sva": "@(posedge clk) !(!power_good && voltage_ok) |-> !shutdown", "ori_sva": "property p_not_27;\n@(posedge clk) !(!power_good && voltage_ok) |-> !shutdown;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_27  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!power_good && voltage_ok)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!shutdown`  ", "sva_signals": ["clk", "rst_n", "[0:0] power_good", "[0:0] voltage_ok", "[0:0] shutdown"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!power_good && voltage_ok) |-> !shutdown", "sva_name": "p_Shutdown_Condition", "full_property": "property p_not_27;\n@(posedge clk)         !(!power_good && voltage_ok) |-> !shutdown;\nendproperty\nassert_p_not_27:assert property (p_not_27) else $error(\"\");", "task_id": "2_1501", "predict_sva": "@(posedge clk)         !(!power_good && voltage_ok) |-> !shutdown"}
{"id": "12_49_0610", "name": "p_or_49", "sva": "@(posedge clk)     (sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed |-> system_interrupt", "ori_sva": "property p_or_49;\n@(posedge clk)     (sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed |-> system_interrupt\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_or_49  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `system_interrupt`  \n\nThe assertion checks that whenever either `sensor_m_alarm` or `sensor_n_alarm` is active (`1`) and the alarm is not suppressed (`!alarm_suppressed`), the `system_interrupt` signal must be asserted (`1`) at the same clock edge.", "sva_signals": ["clk", "rst_n", "[0:0] sensor_m_alarm", "[0:0] sensor_n_alarm", "[0:0] alarm_suppressed", "[0:0] system_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed) |-> system_interrupt", "sva_name": "p_or_45", "full_property": "property p_or_49;\n@(posedge clk)         ((sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed) |-> system_interrupt;\nendproperty\nassert_p_or_49:assert property (p_or_49) else $error(\"\");", "task_id": "2_1477", "predict_sva": "@(posedge clk)         ((sensor_m_alarm || sensor_n_alarm) && !alarm_suppressed) |-> system_interrupt == 1'b1"}
{"id": "10_46_0482", "name": "p_past_underrun_cond", "sva": "@(posedge clk)     $past(underrun_flag,2) |-> buffer_refill", "ori_sva": "property p_past_underrun_cond;\n@(posedge clk)     $past(underrun_flag,2) |-> buffer_refill;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_underrun_cond  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(underrun_flag, 2)` (The value of `underrun_flag` two clock cycles ago is true)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `buffer_refill` (The `buffer_refill` signal must be true in the current cycle)", "sva_signals": ["clk", "rst_n", "[0:0] underrun_flag", "[0:0] buffer_refill"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(underrun_flag, 2) |-> buffer_refill", "sva_name": "p_past_underrun_condition", "full_property": "property p_past_underrun_cond;\n@(posedge clk)     $past(underrun_flag, 2) |-> buffer_refill;\nendproperty\nassert_p_past_underrun_cond:assert property (p_past_underrun_cond) else $error(\"\");", "task_id": "2_1374", "predict_sva": "@(posedge clk)     $past(underrun_flag, 2) |-> buffer_refill"}
{"id": "3_3_0116", "name": "p_overlap_3", "sva": "@(posedge clk)     (req && !busy) |-> grant", "ori_sva": "property p_overlap_3;\n@(posedge clk)     (req && !busy) |-> grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req && !busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant`", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] busy", "[0:0] grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         req && !busy |-> grant", "sva_name": "p_overlap_47", "full_property": "property p_overlap_3;\n@(posedge clk)         req && !busy |-> grant;\nendproperty\nassert_p_overlap_3:assert property (p_overlap_3) else $error(\"\");", "task_id": "2_1729", "predict_sva": "@(posedge clk)         req && !busy |-> grant"}
{"id": "15_5_0733", "name": "p_packet_start_end", "sva": "@(posedge clk) disable iff(!rst_n)     packet_start |-> ##[1:8] packet_end", "ori_sva": "property p_packet_start_end;\n@(posedge clk) disable iff(!rst_n)     packet_start |-> ##[1:8] packet_end;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_start_end  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `packet_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] packet_end` (packet_end must occur within 1 to 8 clock cycles after packet_start)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)         packet_start == 1'b1 |-> ##[1:8] packet_end", "sva_name": "p_packet_start_to_end", "full_property": "property p_packet_start_end;\n@(posedge clk) disable iff (!rst_n)         packet_start == 1'b1 |-> ##[1:8] packet_end;\nendproperty\nassert_p_packet_start_end:assert property (p_packet_start_end) else $error(\"\");", "task_id": "2_1592", "predict_sva": "@(posedge clk) disable iff (!rst_n)     packet_start == 1'b1 |-> ##[1:8] packet_end"}
{"id": "2_38_0083", "name": "prop_38", "sva": "@(posedge clk)      encryption_start |-> ##[5:9] encryption_done", "ori_sva": "property prop_38;\n@(posedge clk)      encryption_start |-> ##[5:9] encryption_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_38  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:9] encryption_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] encryption_start", "[0:0] encryption_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         encryption_start == 1'b1 |-> ##[5:9] encryption_done", "sva_name": "prop_47", "full_property": "property prop_38;\n@(posedge clk)         encryption_start == 1'b1 |-> ##[5:9] encryption_done;\nendproperty\nassert_prop_38:assert property (prop_38) else $error(\"\");", "task_id": "2_1678", "predict_sva": "@(posedge clk)     encryption_start == 1'b1 |-> ##[5:9] encryption_done"}
{"id": "15_3_0689", "name": "p_fifo_not_full_when_read", "sva": "@(posedge clk) disable iff(fifo_flush)     !fifo_full |-> ##[1:3] !fifo_empty", "ori_sva": "property p_fifo_not_full_when_read;\n@(posedge clk) disable iff(fifo_flush)     !fifo_full |-> ##[1:3] !fifo_empty;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_not_full_when_read  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (fifo_flush)`  \n**Antecedent (LHS of Implication)**: `!fifo_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] !fifo_empty`  ", "sva_signals": ["clk", "fifo_flush", "[0:0] fifo_full", "[0:0] fifo_empty"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (fifo_flush)         !fifo_full |-> ##[1:3] !fifo_empty", "sva_name": "p_Fifo_Empty_After_Flush", "full_property": "property p_fifo_not_full_when_read;\n@(posedge clk) disable iff (fifo_flush)         !fifo_full |-> ##[1:3] !fifo_empty;\nendproperty\nassert_p_fifo_not_full_when_read:assert property (p_fifo_not_full_when_read) else $error(\"\");", "task_id": "2_1580", "predict_sva": "@(posedge clk) disable iff (fifo_flush)     !fifo_full |-> ##[1:3] !fifo_empty"}
{"id": "2_9_0041", "name": "prop_9", "sva": "@(posedge clk)      reset_asserted |-> ##[1:4] all_registers_zero", "ori_sva": "property prop_9;\n@(posedge clk)      reset_asserted |-> ##[1:4] all_registers_zero\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_9  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reset_asserted`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] all_registers_zero`  ", "sva_signals": ["clk", "rst_n", "[0:0] reset_asserted", "[0:0] all_registers_zero"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         reset_asserted |-> ##[1:4] all_registers_zero", "sva_name": "prop_37", "full_property": "property prop_9;\n@(posedge clk)         reset_asserted |-> ##[1:4] all_registers_zero;\nendproperty\nassert_prop_9:assert property (prop_9) else $error(\"\");", "task_id": "2_1697", "predict_sva": "@(posedge clk)     reset_asserted |-> ##[1:4] all_registers_zero"}
{"id": "15_9_0697", "name": "p_counter_overflow", "sva": "@(posedge clk) disable iff(counter_reset)     counter == max_count |=> counter == 0", "ori_sva": "property p_counter_overflow;\n@(posedge clk) disable iff(counter_reset)     counter == max_count |=> counter == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_counter_overflow  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (counter_reset)  \n**Antecedent (LHS of Implication)**: `counter == max_count`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `counter == 0`  ", "sva_signals": ["clk", "rst_n", "[0:0] counter_reset", "[0:0] counter", "[0:0] max_count"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (counter_reset)         counter == max_count |=> counter == 0", "sva_name": "p_Counter_Reset_After_Max", "full_property": "property p_counter_overflow;\n@(posedge clk) disable iff (counter_reset)         counter == max_count |=> counter == 0;\nendproperty\nassert_p_counter_overflow:assert property (p_counter_overflow) else $error(\"\");", "task_id": "2_1596", "predict_sva": "@(posedge clk) disable iff (counter_reset)         (!counter_reset && (counter == max_count)) |-> ##1 (counter == 0)"}
{"id": "1_26_0034", "name": "p_fixed_delay_26", "sva": "@(posedge clk)     threshold_exceeded |-> ##4 alert", "ori_sva": "property p_fixed_delay_26;\n@(posedge clk)     threshold_exceeded |-> ##4 alert;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `threshold_exceeded == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 alert == 1'b1`  \n\n(Note: The assertion checks that if `threshold_exceeded` is high at a clock edge, then exactly 4 clock cycles later, `alert` must be high.)", "sva_signals": ["clk", "rst_n", "[0:0] threshold_exceeded", "[0:0] alert"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         threshold_exceeded == 1'b1 |-> ##4 alert == 1'b1", "sva_name": "p_fixed_delay_35", "full_property": "property p_fixed_delay_26;\n@(posedge clk)         threshold_exceeded == 1'b1 |-> ##4 alert == 1'b1;\nendproperty\nassert_p_fixed_delay_26:assert property (p_fixed_delay_26) else $error(\"\");", "task_id": "2_1614", "predict_sva": "@(posedge clk)         threshold_exceeded == 1'b1 |-> ##4 alert == 1'b1"}
{"id": "2_13_0046", "name": "prop_13", "sva": "@(posedge clk)      branch_taken |-> ##[4:8] pc_updated", "ori_sva": "property prop_13;\n@(posedge clk)      branch_taken |-> ##[4:8] pc_updated\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_13  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `branch_taken == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:8] pc_updated == 1'b1`  \n\n(Note: The consequent specifies that `pc_updated` must be true within 4 to 8 clock cycles after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] branch_taken", "[0:0] pc_updated"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         branch_taken == 1'b1 |-> ##[4:8] pc_updated == 1'b1", "sva_name": "prop_27", "full_property": "property prop_13;\n@(posedge clk)         branch_taken == 1'b1 |-> ##[4:8] pc_updated == 1'b1;\nendproperty\nassert_prop_13:assert property (prop_13) else $error(\"\");", "task_id": "2_1650", "predict_sva": "@(posedge clk)         branch_taken == 1'b1 |-> ##[4:8] pc_updated == 1'b1"}
{"id": "2_5_0077", "name": "prop_5", "sva": "@(posedge clk)      packet_start |-> ##[3:7] packet_end", "ori_sva": "property prop_5;\n@(posedge clk)      packet_start |-> ##[3:7] packet_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] packet_end` (packet_end must occur between 3 to 7 clock cycles after packet_start)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         packet_start == 1'b1 |-> ##[3:7] packet_end", "sva_name": "prop_40", "full_property": "property prop_5;\n@(posedge clk)         packet_start == 1'b1 |-> ##[3:7] packet_end;\nendproperty\nassert_prop_5:assert property (prop_5) else $error(\"\");", "task_id": "2_1692", "predict_sva": "@(posedge clk)     packet_start == 1'b1 |-> ##[3:7] packet_end"}
{"id": "2_15_0028", "name": "prop_15", "sva": "@(posedge clk)      timer_start |-> ##[6:12] timer_expired", "ori_sva": "property prop_15;\n@(posedge clk)      timer_start |-> ##[6:12] timer_expired\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_15  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timer_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[6:12] timer_expired == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] timer_start", "[0:0] timer_expired"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     timer_start == 1'b1 |-> ##[6:12] timer_expired == 1'b1", "sva_name": "prop_40", "full_property": "property prop_15;\n@(posedge clk)     timer_start == 1'b1 |-> ##[6:12] timer_expired == 1'b1;\nendproperty\nassert_prop_15:assert property (prop_15) else $error(\"\");", "task_id": "2_1652", "predict_sva": "@(posedge clk)     timer_start == 1'b1 |-> ##[6:12] timer_expired == 1'b1"}
{"id": "3_5_0099", "name": "p_overlap_5", "sva": "@(posedge clk)     (error_code != 0) |-> error_flag", "ori_sva": "property p_overlap_5;\n@(posedge clk)     (error_code != 0) |-> error_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_code != 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_flag`", "sva_signals": ["clk", "rst_n", "[0:0] error_flag", "[15:0] error_code"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         error_code != 0 |-> error_flag", "sva_name": "p_error_flag_assertion", "full_property": "property p_overlap_5;\n@(posedge clk)         error_code != 0 |-> error_flag;\nendproperty\nassert_p_overlap_5:assert property (p_overlap_5) else $error(\"\");", "task_id": "2_1742", "predict_sva": "@(posedge clk)         error_code != 0 |-> error_flag"}
{"id": "2_24_0020", "name": "prop_24", "sva": "@(posedge clk)      state_idle |-> ##[3:8] state_active", "ori_sva": "property prop_24;\n@(posedge clk)      state_idle |-> ##[3:8] state_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_24  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `state_idle == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:8] state_active == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] state_idle", "[0:0] state_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         state_idle == 1'b1 |-> ##[3:8] state_active == 1'b1", "sva_name": "prop_40", "full_property": "property prop_24;\n@(posedge clk)         state_idle == 1'b1 |-> ##[3:8] state_active == 1'b1;\nendproperty\nassert_prop_24:assert property (prop_24) else $error(\"\");", "task_id": "2_1662", "predict_sva": "@(posedge clk)     state_idle == 1'b1 |-> ##[3:8] state_active == 1'b1"}
{"id": "2_7_0052", "name": "prop_7", "sva": "@(posedge clk)      write_req |-> ##[2:6] write_complete", "ori_sva": "property prop_7;\n@(posedge clk)      write_req |-> ##[2:6] write_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_7  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:6] write_complete == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] write_req", "[0:0] write_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         write_req == 1'b1 |-> ##[2:6] write_complete == 1'b1", "sva_name": "p_write_complete_after_req", "full_property": "property prop_7;\n@(posedge clk)         write_req == 1'b1 |-> ##[2:6] write_complete == 1'b1;\nendproperty\nassert_prop_7:assert property (prop_7) else $error(\"\");", "task_id": "2_1694", "predict_sva": "@(posedge clk)     write_req == 1'b1 |-> ##[2:6] write_complete == 1'b1"}
{"id": "5_8_0214", "name": "p8", "sva": "@(posedge clk)     $rose(interrupt)[*4] |-> ##4 int_handler_active", "ori_sva": "property p8;\n@(posedge clk)     $rose(interrupt)[*4] |-> ##4 int_handler_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(interrupt)[*4]` (interrupt signal rises 4 consecutive times)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 int_handler_active` (4 clock cycles after the antecedent, `int_handler_active` must be true)", "sva_signals": ["clk", "rst_n", "[0:0] interrupt", "[0:0] int_handler_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(interrupt)[*4] |-> ##4 int_handler_active", "sva_name": "p_Interrupt_Handler_Activation", "full_property": "property p8;\n@(posedge clk)     $rose(interrupt)[*4] |-> ##4 int_handler_active;\nendproperty\nassert_p8:assert property (p8) else $error(\"\");", "task_id": "2_1801", "predict_sva": "@(posedge clk)     $rose(interrupt)[*4] |-> ##4 int_handler_active"}
{"id": "6_47_0267", "name": "p_var_rep_47", "sva": "@(posedge clk)     (mem_write && !mem_ready)[*3:7] |-> write_pending", "ori_sva": "property p_var_rep_47;\n@(posedge clk)     (mem_write && !mem_ready)[*3:7] |-> write_pending;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_47  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(mem_write && !mem_ready)[*3:7]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `write_pending`  ", "sva_signals": ["clk", "rst_n", "[0:0] mem_write", "[0:0] mem_ready", "[0:0] write_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (mem_write && !mem_ready)[*3:7] |-> write_pending", "sva_name": "p_var_rep_30", "full_property": "property p_var_rep_47;\n@(posedge clk)         (mem_write && !mem_ready)[*3:7] |-> write_pending;\nendproperty\nassert_p_var_rep_47:assert property (p_var_rep_47) else $error(\"\");", "task_id": "2_1841", "predict_sva": "@(posedge clk)     (mem_write && !mem_ready)[*3:7] |-> write_pending"}
{"id": "6_3_0244", "name": "p_var_rep_3", "sva": "@(posedge clk)     start[*3:8] |-> done[*1:4]", "ori_sva": "property p_var_rep_3;\n@(posedge clk)     start[*3:8] |-> done[*1:4];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start` signal is high for 3 to 8 consecutive clock cycles (`start[*3:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `done` signal is high for 1 to 4 consecutive clock cycles (`done[*1:4]`)", "sva_signals": ["clk", "rst_n", "[2:0] start", "[1:0] done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     start[*3:8] |-> done[*1:4]", "sva_name": "p_var_rep_46", "full_property": "property p_var_rep_3;\n@(posedge clk)     start[*3:8] |-> done[*1:4];\nendproperty\nassert_p_var_rep_3:assert property (p_var_rep_3) else $error(\"\");", "task_id": "2_1831", "predict_sva": "@(posedge clk)     start[*3:8] |-> done[*1:4]"}
{"id": "11_19_0536", "name": "p_and_19", "sva": "@(posedge clk)     (addr_match && !protect) && (rw == READ) |-> ##1 mem_read", "ori_sva": "property p_and_19;\n@(posedge clk)     (addr_match && !protect) && (rw == READ) |-> ##1 mem_read\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_19  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(addr_match && !protect) && (rw == READ)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 mem_read`", "sva_signals": ["clk", "rst_n", "[0:0] addr_match", "[0:0] protect", "[0:0] rw", "[0:0] mem_read", "[0:0] READ"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (addr_match && !protect) && (rw == READ) |-> ##1 mem_read", "sva_name": "p_and_46", "full_property": "property p_and_19;\n@(posedge clk)         (addr_match && !protect) && (rw == READ) |-> ##1 mem_read;\nendproperty\nassert_p_and_19:assert property (p_and_19) else $error(\"\");", "task_id": "2_2045", "predict_sva": "@(posedge clk)         (addr_match && !protect) && (rw == READ) |-> ##1 mem_read"}
{"id": "11_25_0532", "name": "p_and_25", "sva": "@(posedge clk)     (key_pressed && !locked) && (valid_code) |-> ##1 access_granted", "ori_sva": "property p_and_25;\n@(posedge clk)     (key_pressed && !locked) && (valid_code) |-> ##1 access_granted\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_25  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(key_pressed && !locked) && valid_code`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 access_granted`", "sva_signals": ["clk", "rst_n", "[0:0] key_pressed", "[0:0] locked", "[0:0] valid_code", "[0:0] access_granted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (key_pressed && !locked && valid_code) |-> ##1 access_granted", "sva_name": "p_and_46", "full_property": "property p_and_25;\n@(posedge clk)         (key_pressed && !locked && valid_code) |-> ##1 access_granted;\nendproperty\nassert_p_and_25:assert property (p_and_25) else $error(\"\");", "task_id": "2_2052", "predict_sva": "@(posedge clk)         (key_pressed && !locked && valid_code) |-> ##1 access_granted"}
{"id": "11_36_0545", "name": "p_and_36", "sva": "@(posedge clk)     (checksum_ok && !parity_error) && (packet_complete) |-> packet_ok", "ori_sva": "property p_and_36;\n@(posedge clk)     (checksum_ok && !parity_error) && (packet_complete) |-> packet_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_36  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(checksum_ok && !parity_error) && (packet_complete)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `packet_ok`", "sva_signals": ["clk", "rst_n", "[0:0] checksum_ok", "[0:0] parity_error", "[0:0] packet_complete", "[0:0] packet_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (checksum_ok && !parity_error) && packet_complete |-> packet_ok", "sva_name": "p_and_48", "full_property": "property p_and_36;\n@(posedge clk)         (checksum_ok && !parity_error) && packet_complete |-> packet_ok;\nendproperty\nassert_p_and_36:assert property (p_and_36) else $error(\"\");", "task_id": "2_2064", "predict_sva": "@(posedge clk)         (checksum_ok && !parity_error) && packet_complete |-> packet_ok"}
{"id": "7_44_0344", "name": "p_rose_44", "sva": "@(posedge clk) $rose(dma_request) |-> ##2 dma_acknowledge", "ori_sva": "property p_rose_44;\n@(posedge clk) $rose(dma_request) |-> ##2 dma_acknowledge;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_44  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(dma_request)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 dma_acknowledge`", "sva_signals": ["clk", "rst_n", "[0:0] dma_request", "[0:0] dma_acknowledge"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(dma_request) |-> ##2 dma_acknowledge", "sva_name": "p_rose_dma_request_dma_acknowledge", "full_property": "property p_rose_44;\n@(posedge clk)         $rose(dma_request) |-> ##2 dma_acknowledge;\nendproperty\nassert_p_rose_44:assert property (p_rose_44) else $error(\"\");", "task_id": "2_1882", "predict_sva": "@(posedge clk)         $rose(dma_request) |-> ##2 dma_acknowledge"}
{"id": "10_6_0443", "name": "p_past_data_match_after_5cyc", "sva": "@(posedge clk)     $past(data_in, 5) == data_out", "ori_sva": "property p_past_data_match_after_5cyc;\n@(posedge clk)     $past(data_in, 5) == data_out;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_data_match_after_5cyc  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple property without an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `$past(data_in, 5) == data_out`  \n**Description**: The property checks that the value of `data_out` matches the value of `data_in` sampled 5 clock cycles earlier (`$past(data_in, 5)`). This is a direct comparison without any implication or conditional trigger.", "sva_signals": ["clk", "rst_n", "[7:0] data_in", "[7:0] data_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(data_in, 5) == data_out", "sva_name": "p_data_out_past_data_in", "full_property": "property p_past_data_match_after_5cyc;\n@(posedge clk)     $past(data_in, 5) == data_out;\nendproperty\nassert_p_past_data_match_after_5cyc:assert property (p_past_data_match_after_5cyc) else $error(\"\");", "task_id": "2_2035", "predict_sva": "@(posedge clk)     data_out == $past(data_in, 5)"}
{"id": "9_39_0455", "name": "p_stable_margin_after_test", "sva": "@(posedge clk)     margin_test_done |=> $stable(timing_margin)", "ori_sva": "property p_stable_margin_after_test;\n@(posedge clk)     margin_test_done |=> $stable(timing_margin);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_margin_after_test  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `margin_test_done == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(timing_margin)`  \n\n(Note: `|=>` indicates that the consequent is checked **one clock cycle after** the antecedent is true, and `$stable(timing_margin)` ensures that `timing_margin` does not change from its previous value.)", "sva_signals": ["clk", "rst_n", "[0:0] margin_test_done", "timing_margin"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         margin_test_done == 1'b1 |=> $stable(timing_margin)", "sva_name": "p_stable_timing_margin_after_test", "full_property": "property p_stable_margin_after_test;\n@(posedge clk)         margin_test_done == 1'b1 |=> $stable(timing_margin);\nendproperty\nassert_p_stable_margin_after_test:assert property (p_stable_margin_after_test) else $error(\"\");", "task_id": "2_1971", "predict_sva": "@(posedge clk)     margin_test_done == 1'b1 |-> ##1 $stable(timing_margin)"}
{"id": "10_38_0491", "name": "p_past_data_compression_ratio", "sva": "@(posedge clk)     $past(compress_en, 1) |-> compressed_size <= $past(data_size, 1)/2", "ori_sva": "property p_past_data_compression_ratio;\n@(posedge clk)     $past(compress_en, 1) |-> compressed_size <= $past(data_size, 1)/2;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_data_compression_ratio  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(compress_en, 1)` (compress_en was high in the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `compressed_size <= $past(data_size, 1)/2` (the current compressed_size must be less than or equal to half of the data_size from the previous clock cycle)", "sva_signals": ["clk", "rst_n", "[0:0] compress_en", "[0:0] compressed_size", "[0:0] data_size"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(compress_en, 1) |-> compressed_size <= ($past(data_size, 1)/2)", "sva_name": "p_past_compression_ratio", "full_property": "property p_past_data_compression_ratio;\n@(posedge clk)     $past(compress_en, 1) |-> compressed_size <= ($past(data_size, 1)/2);\nendproperty\nassert_p_past_data_compression_ratio:assert property (p_past_data_compression_ratio) else $error(\"\");", "task_id": "2_2016", "predict_sva": "@(posedge clk)         $past(compress_en, 1) |-> compressed_size <= ($past(data_size, 1) / 2)"}
{"id": "6_44_0297", "name": "p_var_rep_44", "sva": "@(posedge clk)     (link_up && !link_active)[*2:5] |-> link_idle", "ori_sva": "property p_var_rep_44;\n@(posedge clk)     (link_up && !link_active)[*2:5] |-> link_idle;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_44  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(link_up && !link_active)` holds true for 2 to 5 consecutive clock cycles  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `link_idle` is true in the same cycle as the antecedent sequence completes  \n\n(Note: The antecedent uses the `[*2:5]` sequence repetition operator, which means the condition `(link_up && !link_active)` must be true for **at least 2 and at most 5** consecutive cycles before the implication is evaluated. The consequent `link_idle` is checked in the cycle immediately after the repetition completes.)", "sva_signals": ["clk", "rst_n", "[0:0] link_up", "[0:0] link_active", "[0:0] link_idle"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (link_up && !link_active)[*2:5] |-> link_idle", "sva_name": "p_link_idle_after_inactive", "full_property": "property p_var_rep_44;\n@(posedge clk)     (link_up && !link_active)[*2:5] |-> link_idle;\nendproperty\nassert_p_var_rep_44:assert property (p_var_rep_44) else $error(\"\");", "task_id": "2_1837", "predict_sva": "@(posedge clk)     (link_up && !link_active)[*2:5] |-> ##1 link_idle"}
{"id": "12_22_0594", "name": "p_or_22", "sva": "@(posedge clk)     config_err || runtime_err |-> system_halt", "ori_sva": "property p_or_22;\n@(posedge clk)     config_err || runtime_err |-> system_halt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_22  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `config_err || runtime_err`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `system_halt`", "sva_signals": ["clk", "rst_n", "[0:0] config_err", "[0:0] runtime_err", "[0:0] system_halt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (config_err || runtime_err) |-> system_halt", "sva_name": "p_or_47", "full_property": "property p_or_22;\n@(posedge clk)         (config_err || runtime_err) |-> system_halt;\nendproperty\nassert_p_or_22:assert property (p_or_22) else $error(\"\");", "task_id": "2_2096", "predict_sva": "@(posedge clk)         (config_err || runtime_err) |-> system_halt"}
{"id": "12_29_0593", "name": "p_or_29", "sva": "@(posedge clk)     timeout_1 || timeout_2 |-> retry", "ori_sva": "property p_or_29;\n@(posedge clk)     timeout_1 || timeout_2 |-> retry;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_29  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timeout_1 || timeout_2`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `retry`", "sva_signals": ["clk", "rst_n", "[0:0] timeout_1", "[0:0] timeout_2", "[0:0] retry"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (timeout_1 || timeout_2) |-> retry", "sva_name": "p_or_40", "full_property": "property p_or_29;\n@(posedge clk)         (timeout_1 || timeout_2) |-> retry;\nendproperty\nassert_p_or_29:assert property (p_or_29) else $error(\"\");", "task_id": "2_2104", "predict_sva": "@(posedge clk)         (timeout_1 || timeout_2) |-> retry"}
{"id": "12_48_0599", "name": "p_or_48", "sva": "@(posedge clk)     config_ok || default_cfg |-> operational", "ori_sva": "property p_or_48;\n@(posedge clk)     config_ok || default_cfg |-> operational;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_48  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `config_ok || default_cfg`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `operational`", "sva_signals": ["clk", "rst_n", "[0:0] config_ok", "[0:0] default_cfg", "[0:0] operational"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (config_ok || default_cfg) |-> operational", "sva_name": "p_Operational_Config", "full_property": "property p_or_48;\n@(posedge clk)         (config_ok || default_cfg) |-> operational;\nendproperty\nassert_p_or_48:assert property (p_or_48) else $error(\"\");", "task_id": "2_2126", "predict_sva": "@(posedge clk)         (config_ok || default_cfg) |-> operational"}
{"id": "11_8_0509", "name": "p_and_8", "sva": "@(posedge clk)     $fell(clock_enable) && (counter > 100) |-> counter_stop", "ori_sva": "property p_and_8;\n@(posedge clk)     $fell(clock_enable) && (counter > 100) |-> counter_stop\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clock_enable) && (counter > 100)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `counter_stop`", "sva_signals": ["clk", "rst_n", "[0:0] clock_enable", "[7:0] counter", "[0:0] counter_stop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($fell(clock_enable) && (counter > 100)) |-> counter_stop", "sva_name": "p_Counter_Stop_On_Clock_Disable", "full_property": "property p_and_8;\n@(posedge clk)         ($fell(clock_enable) && (counter > 100)) |-> counter_stop;\nendproperty\nassert_p_and_8:assert property (p_and_8) else $error(\"\");", "task_id": "2_2083", "predict_sva": "@(posedge clk)     ($fell(clock_enable) && (counter > 100)) |-> counter_stop"}
{"id": "13_14_0610", "name": "p_not_14", "sva": "@(negedge clk)     !(!tx_ready || rx_overflow) |-> tx_start", "ori_sva": "property p_not_14;\n@(negedge clk)     !(!tx_ready || rx_overflow) |-> tx_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_14  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!tx_ready || rx_overflow)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tx_start`", "sva_signals": ["clk", "rst_n", "[0:0] tx_ready", "[0:0] rx_overflow", "[0:0] tx_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)         !(!tx_ready || rx_overflow) |-> tx_start", "sva_name": "p_overlap_48", "full_property": "property p_not_14;\n@(negedge clk)         !(!tx_ready || rx_overflow) |-> tx_start;\nendproperty\nassert_p_not_14:assert property (p_not_14) else $error(\"\");", "task_id": "2_2138", "predict_sva": "@(negedge clk)     (tx_ready && !rx_overflow) |-> tx_start"}
{"id": "13_17_0613", "name": "p_not_17", "sva": "@(negedge clk)     !(!power_down && sleep_mode) |-> clock_off", "ori_sva": "property p_not_17;\n@(negedge clk)     !(!power_down && sleep_mode) |-> clock_off\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_17  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!power_down && sleep_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `clock_off`", "sva_signals": ["clk", "rst_n", "[0:0] power_down", "[0:0] sleep_mode", "[0:0] clock_off"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     !(!power_down && sleep_mode) |-> clock_off", "sva_name": "p_not_40", "full_property": "property p_not_17;\n@(negedge clk)     !(!power_down && sleep_mode) |-> clock_off;\nendproperty\nassert_p_not_17:assert property (p_not_17) else $error(\"\");", "task_id": "2_2143", "predict_sva": "@(negedge clk)     !(!power_down && sleep_mode) |-> clock_off"}
{"id": "13_38_0644", "name": "p_not_38", "sva": "@(negedge clk)     !(packet_start && !packet_valid) |-> packet_drop", "ori_sva": "property p_not_38;\n@(negedge clk)     !(packet_start && !packet_valid) |-> packet_drop\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_38  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(packet_start && !packet_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `packet_drop`", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_valid", "[0:0] packet_drop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     !(packet_start && !packet_valid) |-> packet_drop", "sva_name": "p_not_45", "full_property": "property p_not_38;\n@(negedge clk)     !(packet_start && !packet_valid) |-> packet_drop;\nendproperty\nassert_p_not_38:assert property (p_not_38) else $error(\"\");", "task_id": "2_2165", "predict_sva": "@(negedge clk)         !(packet_start && !packet_valid) |-> packet_drop"}
{"id": "13_3_0621", "name": "p_not_3", "sva": "@(posedge clk)     $fell(!data_valid) |-> ##[1:3] error", "ori_sva": "property p_not_3;\n@(posedge clk)     $fell(!data_valid) |-> ##[1:3] error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(!data_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] error`  ", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[0:0] error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(!data_valid) |-> ##[1:3] error", "sva_name": "p_not_16", "full_property": "property p_not_3;\n@(posedge clk)         $fell(!data_valid) |-> ##[1:3] error;\nendproperty\nassert_p_not_3:assert property (p_not_3) else $error(\"\");", "task_id": "2_2167", "predict_sva": "@(posedge clk)         $fell(!data_valid) |-> ##[1:3] error"}
{"id": "2_26_0036", "name": "prop_26", "sva": "@(posedge clk)     clock_switch |-> ##[2:4] clock_stable", "ori_sva": "property prop_26;\n@(posedge clk)     clock_switch |-> ##[2:4] clock_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `clock_switch == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] clock_stable` (The signal `clock_stable` must be true within 2 to 4 clock cycles after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] clock_switch", "[0:0] clock_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         clock_switch == 1'b1 |-> ##[2:4] clock_stable", "sva_name": "prop_30", "full_property": "property prop_26;\n@(posedge clk)         clock_switch == 1'b1 |-> ##[2:4] clock_stable;\nendproperty\nassert_prop_26:assert property (prop_26) else $error(\"\");", "task_id": "2_2324", "predict_sva": "@(posedge clk)     clock_switch == 1'b1 |-> ##[2:4] clock_stable"}
{"id": "15_8_0699", "name": "p8", "sva": "@(negedge clk) disable iff(bypass_mode)     $changed(addr) |-> ##1 $stable(addr)", "ori_sva": "property p8;\n@(negedge clk) disable iff(bypass_mode)     $changed(addr) |-> ##1 $stable(addr)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p8  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: disable iff (bypass_mode)  \n**Antecedent (LHS of Implication)**: `$changed(addr)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(addr)`  ", "sva_signals": ["clk", "rst_n", "bypass_mode", "addr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (bypass_mode)     $changed(addr) |-> ##1 $stable(addr)", "sva_name": "p_reset_disable_40", "full_property": "property p8;\n@(negedge clk) disable iff (bypass_mode)     $changed(addr) |-> ##1 $stable(addr);\nendproperty\nassert_p8:assert property (p8) else $error(\"\");", "task_id": "2_2257", "predict_sva": "@(negedge clk) disable iff (bypass_mode)     $changed(addr) |-> ##1 $stable(addr)"}
{"id": "2_35_0082", "name": "prop_35", "sva": "@(posedge clk)     $fell(authenticated) |-> ##[1:3] access_denied", "ori_sva": "property prop_35;\n@(posedge clk)     $fell(authenticated) |-> ##[1:3] access_denied;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_35  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(authenticated)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] access_denied`  ", "sva_signals": ["clk", "rst_n", "[0:0] authenticated", "[0:0] access_denied"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(authenticated) |-> ##[1:3] access_denied", "sva_name": "prop_48", "full_property": "property prop_35;\n@(posedge clk)         $fell(authenticated) |-> ##[1:3] access_denied;\nendproperty\nassert_prop_35:assert property (prop_35) else $error(\"\");", "task_id": "2_2335", "predict_sva": "@(posedge clk)         $fell(authenticated) |-> ##[1:3] access_denied"}
{"id": "1_16_0078", "name": "p_fixed_delay_16", "sva": "@(posedge clk) (voltage_low && !battery_backup) |-> ##2 power_fail", "ori_sva": "property p_fixed_delay_16;\n@(posedge clk) (voltage_low && !battery_backup) |-> ##2 power_fail;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_16  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_low && !battery_backup`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 power_fail`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_low", "[0:0] battery_backup", "[0:0] power_fail"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (voltage_low && !battery_backup) |-> ##2 power_fail", "sva_name": "p_fixed_delay_46", "full_property": "property p_fixed_delay_16;\n@(posedge clk)         (voltage_low && !battery_backup) |-> ##2 power_fail;\nendproperty\nassert_p_fixed_delay_16:assert property (p_fixed_delay_16) else $error(\"\");", "task_id": "2_2265", "predict_sva": "@(posedge clk)         (voltage_low && !battery_backup) |-> ##2 power_fail"}
{"id": "3_29_0119", "name": "p_overlap_29", "sva": "@(posedge clk)     (voltage_drop && !buck_en) |-> buck_boost", "ori_sva": "property p_overlap_29;\n@(posedge clk)     (voltage_drop && !buck_en) |-> buck_boost\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_29  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_drop && !buck_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `buck_boost`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_drop", "[0:0] buck_en", "[0:0] buck_boost"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (voltage_drop && !buck_en) |-> buck_boost", "sva_name": "p_overlap_47", "full_property": "property p_overlap_29;\n@(posedge clk)         (voltage_drop && !buck_en) |-> buck_boost;\nendproperty\nassert_p_overlap_29:assert property (p_overlap_29) else $error(\"\");", "task_id": "2_2375", "predict_sva": "@(posedge clk)         (voltage_drop && !buck_en) |-> buck_boost"}
{"id": "1_23_0069", "name": "p_fixed_delay_23", "sva": "@(posedge clk) (encryption_start && key_loaded) |-> ##8 data_encrypted", "ori_sva": "property p_fixed_delay_23;\n@(posedge clk) (encryption_start && key_loaded) |-> ##8 data_encrypted;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_23  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_start && key_loaded`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 data_encrypted`  ", "sva_signals": ["clk", "rst_n", "[0:0] encryption_start", "[0:0] key_loaded", "[0:0] data_encrypted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (encryption_start && key_loaded) |-> ##8 data_encrypted", "sva_name": "p_fixed_delay_49", "full_property": "property p_fixed_delay_23;\n@(posedge clk)         (encryption_start && key_loaded) |-> ##8 data_encrypted;\nendproperty\nassert_p_fixed_delay_23:assert property (p_fixed_delay_23) else $error(\"\");", "task_id": "2_2271", "predict_sva": "@(posedge clk)         (encryption_start && key_loaded) |-> ##8 data_encrypted"}
{"id": "3_30_0136", "name": "p_overlap_30", "sva": "@(posedge clk)     (sensor_alert && !snooze) |-> wakeup_signal", "ori_sva": "property p_overlap_30;\n@(posedge clk)     (sensor_alert && !snooze) |-> wakeup_signal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_30  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_alert && !snooze`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wakeup_signal`", "sva_signals": ["clk", "rst_n", "[0:0] sensor_alert", "[0:0] snooze", "[0:0] wakeup_signal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sensor_alert && !snooze) |-> wakeup_signal", "sva_name": "p_overlap_45", "full_property": "property p_overlap_30;\n@(posedge clk)         (sensor_alert && !snooze) |-> wakeup_signal;\nendproperty\nassert_p_overlap_30:assert property (p_overlap_30) else $error(\"\");", "task_id": "2_2377", "predict_sva": "@(posedge clk)         (sensor_alert && !snooze) |-> wakeup_signal"}
{"id": "3_31_0105", "name": "p_overlap_31", "sva": "@(posedge clk)     (debug_halt && debug_en) |-> debug_ack", "ori_sva": "property p_overlap_31;\n@(posedge clk)     (debug_halt && debug_en) |-> debug_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_31  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `debug_halt && debug_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `debug_ack`", "sva_signals": ["clk", "rst_n", "[0:0] debug_halt", "[0:0] debug_en", "[0:0] debug_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (debug_halt && debug_en) |-> debug_ack", "sva_name": "p_overlap_47", "full_property": "property p_overlap_31;\n@(posedge clk)         (debug_halt && debug_en) |-> debug_ack;\nendproperty\nassert_p_overlap_31:assert property (p_overlap_31) else $error(\"\");", "task_id": "2_2378", "predict_sva": "@(posedge clk)         (debug_halt && debug_en) |-> debug_ack"}
{"id": "1_32_0061", "name": "p_fixed_delay_32", "sva": "@(posedge clk) (data_request && buffer_ready) |-> ##3 data_available", "ori_sva": "property p_fixed_delay_32;\n@(posedge clk) (data_request && buffer_ready) |-> ##3 data_available;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_32  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_request && buffer_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 data_available`  ", "sva_signals": ["clk", "rst_n", "[0:0] data_request", "[0:0] buffer_ready", "[0:0] data_available"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (data_request && buffer_ready) |-> ##3 data_available", "sva_name": "p_fixed_delay_46", "full_property": "property p_fixed_delay_32;\n@(posedge clk)         (data_request && buffer_ready) |-> ##3 data_available;\nendproperty\nassert_p_fixed_delay_32:assert property (p_fixed_delay_32) else $error(\"\");", "task_id": "2_2281", "predict_sva": "@(posedge clk)         (data_request && buffer_ready) |-> ##3 data_available"}
{"id": "1_41_0075", "name": "p_fixed_delay_41", "sva": "@(posedge clk) (packet_received && crc_check) |-> ##3 packet_valid", "ori_sva": "property p_fixed_delay_41;\n@(posedge clk) (packet_received && crc_check) |-> ##3 packet_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_41  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_received && crc_check`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 packet_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] packet_received", "[0:0] crc_check", "[0:0] packet_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (packet_received && crc_check) |-> ##3 packet_valid", "sva_name": "p_and_47", "full_property": "property p_fixed_delay_41;\n@(posedge clk)         (packet_received && crc_check) |-> ##3 packet_valid;\nendproperty\nassert_p_fixed_delay_41:assert property (p_fixed_delay_41) else $error(\"\");", "task_id": "2_2291", "predict_sva": "@(posedge clk)         (packet_received && crc_check) |-> ##3 packet_valid"}
{"id": "3_38_0143", "name": "p_overlap_38", "sva": "@(posedge clk)     (bit_error && ecc_en) |-> ecc_trigger", "ori_sva": "property p_overlap_38;\n@(posedge clk)     (bit_error && ecc_en) |-> ecc_trigger\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_38  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bit_error && ecc_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecc_trigger`", "sva_signals": ["clk", "rst_n", "[0:0] bit_error", "[0:0] ecc_en", "[0:0] ecc_trigger"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (bit_error && ecc_en) |-> ecc_trigger", "sva_name": "p_overlap_47", "full_property": "property p_overlap_38;\n@(posedge clk)         (bit_error && ecc_en) |-> ecc_trigger;\nendproperty\nassert_p_overlap_38:assert property (p_overlap_38) else $error(\"\");", "task_id": "2_2385", "predict_sva": "@(posedge clk)         (bit_error && ecc_en) |-> ecc_trigger"}
{"id": "3_5_0091", "name": "p_overlap_5", "sva": "@(posedge clk)     (wr_en && full) |-> overflow", "ori_sva": "property p_overlap_5;\n@(posedge clk)     (wr_en && full) |-> overflow\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wr_en && full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `overflow`", "sva_signals": ["clk", "rst_n", "[0:0] wr_en", "[0:0] full", "[0:0] overflow"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         wr_en && full |-> overflow", "sva_name": "p_and_40", "full_property": "property p_overlap_5;\n@(posedge clk)         wr_en && full |-> overflow;\nendproperty\nassert_p_overlap_5:assert property (p_overlap_5) else $error(\"\");", "task_id": "2_2400", "predict_sva": "@(posedge clk)         (wr_en && full) |-> overflow"}
{"id": "1_46_0009", "name": "p_fixed_delay_46", "sva": "@(posedge clk) (signal_edge && capture_en) |-> ##2 data_captured", "ori_sva": "property p_fixed_delay_46;\n@(posedge clk) (signal_edge && capture_en) |-> ##2 data_captured;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_46  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `signal_edge && capture_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 data_captured`", "sva_signals": ["clk", "rst_n", "[0:0] signal_edge", "[0:0] capture_en", "[0:0] data_captured"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     signal_edge && capture_en |-> ##2 data_captured", "sva_name": "p_fixed_delay_48", "full_property": "property p_fixed_delay_46;\n@(posedge clk)     signal_edge && capture_en |-> ##2 data_captured;\nendproperty\nassert_p_fixed_delay_46:assert property (p_fixed_delay_46) else $error(\"\");", "task_id": "2_2296", "predict_sva": "@(posedge clk)         (signal_edge && capture_en) |-> ##2 data_captured"}
{"id": "3_41_0150", "name": "p_overlap_41", "sva": "@(posedge clk)     (power_state_trans && !stable) |-> glitch_filter", "ori_sva": "property p_overlap_41;\n@(posedge clk)     (power_state_trans && !stable) |-> glitch_filter\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_41  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_state_trans && !stable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `glitch_filter`", "sva_signals": ["clk", "rst_n", "[0:0] power_state_trans", "[0:0] stable", "[0:0] glitch_filter"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         power_state_trans && !stable |-> glitch_filter", "sva_name": "p_overlap_47", "full_property": "property p_overlap_41;\n@(posedge clk)         power_state_trans && !stable |-> glitch_filter;\nendproperty\nassert_p_overlap_41:assert property (p_overlap_41) else $error(\"\");", "task_id": "2_2389", "predict_sva": "@(posedge clk)         (power_state_trans && !stable) |-> glitch_filter"}
{"id": "2_25_0005", "name": "prop_25", "sva": "@(posedge clk)     test_mode_entry |-> ##[5:10] test_pattern", "ori_sva": "property prop_25;\n@(posedge clk)     test_mode_entry |-> ##[5:10] test_pattern;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_25  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `test_mode_entry == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] test_pattern == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] test_mode_entry", "[0:0] test_pattern"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         test_mode_entry == 1'b1 |-> ##[5:10] test_pattern == 1'b1", "sva_name": "prop_47", "full_property": "property prop_25;\n@(posedge clk)         test_mode_entry == 1'b1 |-> ##[5:10] test_pattern == 1'b1;\nendproperty\nassert_prop_25:assert property (prop_25) else $error(\"\");", "task_id": "2_2322", "predict_sva": "@(posedge clk)     test_mode_entry == 1'b1 |-> ##[5:10] test_pattern == 1'b1"}
{"id": "2_34_0098", "name": "prop_34", "sva": "@(posedge clk)     temperature_high |-> ##[3:6] cooling_active", "ori_sva": "property prop_34;\n@(posedge clk)     temperature_high |-> ##[3:6] cooling_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_34  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temperature_high == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] cooling_active == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] temperature_high", "[0:0] cooling_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         temperature_high == 1'b1 |-> ##[3:6] cooling_active == 1'b1", "sva_name": "prop_47", "full_property": "property prop_34;\n@(posedge clk)         temperature_high == 1'b1 |-> ##[3:6] cooling_active == 1'b1;\nendproperty\nassert_prop_34:assert property (prop_34) else $error(\"\");", "task_id": "2_2333", "predict_sva": "@(posedge clk)     temperature_high == 1'b1 |-> ##[3:6] cooling_active == 1'b1"}
{"id": "5_11_0228", "name": "prop_11", "sva": "@(posedge clk) $fell(interrupt_line)[*3] |-> interrupt_handled", "ori_sva": "property prop_11;\n@(posedge clk) $fell(interrupt_line)[*3] |-> interrupt_handled;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_11  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(interrupt_line)[*3]` (The `interrupt_line` signal falls 3 consecutive times)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interrupt_handled` (The `interrupt_handled` signal must be asserted)  ", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_line", "[0:0] interrupt_handled"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(interrupt_line)[*3] |-> interrupt_handled", "sva_name": "p_Interrupt_Handling", "full_property": "property prop_11;\n@(posedge clk)     $fell(interrupt_line)[*3] |-> interrupt_handled;\nendproperty\nassert_prop_11:assert property (prop_11) else $error(\"\");", "task_id": "2_2455", "predict_sva": "@(posedge clk)     $fell(interrupt_line)[*3] |-> interrupt_handled"}
{"id": "7_2_0312", "name": "p_rose_clk_ack", "sva": "@(posedge clk) $rose(clk) |=> ack", "ori_sva": "property p_rose_clk_ack;\n@(posedge clk) $rose(clk) |=> ack;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_rose_clk_ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(clk)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `ack`", "sva_signals": ["clk", "rst_n", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(clk) |=> ack", "sva_name": "p_rose_clk_ack", "full_property": "property p_rose_clk_ack;\n@(posedge clk)         $rose(clk) |=> ack;\nendproperty\nassert_p_rose_clk_ack:assert property (p_rose_clk_ack) else $error(\"\");", "task_id": "2_2567", "predict_sva": "@(posedge clk)         $rose(clk) |-> ack"}
{"id": "5_26_0213", "name": "prop_26", "sva": "@(posedge clk) (memory_initialized && !memory_error)[*5] |-> ready_for_access", "ori_sva": "property prop_26;\n@(posedge clk) (memory_initialized && !memory_error)[*5] |-> ready_for_access;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(memory_initialized && !memory_error)[*5]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ready_for_access`  ", "sva_signals": ["clk", "rst_n", "[0:0] memory_initialized", "[0:0] memory_error", "[0:0] ready_for_access"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (memory_initialized && !memory_error)[*5] |-> ready_for_access", "sva_name": "prop_47", "full_property": "property prop_26;\n@(posedge clk)     (memory_initialized && !memory_error)[*5] |-> ready_for_access;\nendproperty\nassert_prop_26:assert property (prop_26) else $error(\"\");", "task_id": "2_2470", "predict_sva": "@(posedge clk)     (memory_initialized && !memory_error)[*5] |-> ready_for_access"}
{"id": "11_15_0504", "name": "p_and_15", "sva": "@(posedge clk)     (sync_pulse && locked) |-> sync_ack", "ori_sva": "property p_and_15;\n@(posedge clk)     (sync_pulse && locked) |-> sync_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_15  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse && locked`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sync_ack`", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] locked", "[0:0] sync_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sync_pulse && locked) |-> sync_ack", "sva_name": "p_overlap_48", "full_property": "property p_and_15;\n@(posedge clk)         (sync_pulse && locked) |-> sync_ack;\nendproperty\nassert_p_and_15:assert property (p_and_15) else $error(\"\");", "task_id": "2_2739", "predict_sva": "@(posedge clk)         sync_pulse && locked |-> sync_ack"}
{"id": "14_31_0708", "name": "p_cond_boot_sequence", "sva": "@(posedge clk)     if(boot_mode) $rose(power_on) |-> ##[10:100] boot_complete else $rose(power_on) |-> ##[5:10] standby_mode", "ori_sva": "property p_cond_boot_sequence;\n@(posedge clk)     if(boot_mode) $rose(power_on) |-> ##[10:100] boot_complete else $rose(power_on) |-> ##[5:10] standby_mode\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cond_boot_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Conditional Antecedent (LHS of Implication)**:  \n- If `boot_mode` is true: `$rose(power_on)`  \n- Else: `$rose(power_on)`  \n**Implication Operator**: `|->`  \n**Conditional Consequent (RHS of Implication)**:  \n- If `boot_mode` is true: `##[10:100] boot_complete` (boot completes between 10 to 100 clock cycles after `power_on` rises)  \n- Else: `##[5:10] standby_mode` (standby mode is entered between 5 to 10 clock cycles after `power_on` rises)  \n\n### Notes:  \n- The property describes a conditional boot sequence behavior based on `boot_mode`.  \n- When `boot_mode` is active, the system checks if `boot_complete` occurs within 10 to 100 cycles after `power_on` rises.  \n- When `boot_mode` is inactive, the system checks if `standby_mode` is entered within 5 to 10 cycles after `power_on` rises.", "sva_signals": ["clk", "rst_n", "[0:0] boot_mode", "[0:0] power_on", "[0:0] boot_complete", "[0:0] standby_mode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     if (boot_mode)          $rose(power_on) |-> ##[10:100] boot_complete     else         $rose(power_on) |-> ##[5:10] standby_mode", "sva_name": "p_power_on_behavior", "full_property": "property p_cond_boot_sequence;\n@(posedge clk)     if (boot_mode)          $rose(power_on) |-> ##[10:100] boot_complete     else         $rose(power_on) |-> ##[5:10] standby_mode;\nendproperty\nassert_p_cond_boot_sequence:assert property (p_cond_boot_sequence) else $error(\"\");", "task_id": "2_2197", "predict_sva": "@(posedge clk)    $rose(power_on) |-> (boot_mode ? ##[10:100] boot_complete : ##[5:10] standby_mode)"}
{"id": "10_1_0421", "name": "p_past_data_stable_1", "sva": "@(posedge clk)     $past(data_valid, 1) |-> data == $past(data, 1)", "ori_sva": "property p_past_data_stable_1;\n@(posedge clk)     $past(data_valid, 1) |-> data == $past(data, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_data_stable_1  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(data_valid, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data == $past(data, 1)`", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[0:0] data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(data_valid, 1) |-> data == $past(data, 1)", "sva_name": "p_past_data_stable", "full_property": "property p_past_data_stable_1;\n@(posedge clk)     $past(data_valid, 1) |-> data == $past(data, 1);\nendproperty\nassert_p_past_data_stable_1:assert property (p_past_data_stable_1) else $error(\"\");", "task_id": "2_2698", "predict_sva": "@(posedge clk)         $past(data_valid, 1) |-> $past(data, 1) == data"}
{"id": "7_38_0338", "name": "p_rose_duty_calculate", "sva": "@(posedge clk) $rose(duty) |=> calculate", "ori_sva": "property p_rose_duty_calculate;\n@(posedge clk) $rose(duty) |=> calculate;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_duty_calculate  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(duty)` (a rising edge is detected on the signal `duty`)  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `calculate` (the signal `calculate` must be true in the next clock cycle)", "sva_signals": ["clk", "rst_n", "[0:0] duty", "[0:0] calculate"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(duty) |=> calculate", "sva_name": "p_rose_duty_calculate", "full_property": "property p_rose_duty_calculate;\n@(posedge clk)     $rose(duty) |=> calculate;\nendproperty\nassert_p_rose_duty_calculate:assert property (p_rose_duty_calculate) else $error(\"\");", "task_id": "2_2574", "predict_sva": "@(posedge clk)         $rose(duty) |-> ##1 calculate"}
{"id": "5_27_0235", "name": "prop_27", "sva": "@(posedge clk) (packet_start && !packet_abort)[*3] |-> packet_header_valid[*3]", "ori_sva": "property prop_27;\n@(posedge clk) (packet_start && !packet_abort)[*3] |-> packet_header_valid[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_27  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(packet_start && !packet_abort)[*3]` (The condition `packet_start` is true and `packet_abort` is false for three consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `packet_header_valid[*3]` (The signal `packet_header_valid` must be true for three consecutive clock cycles following the antecedent)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_abort", "[0:0] packet_header_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (packet_start && !packet_abort)[*3] |-> packet_header_valid[*3]", "sva_name": "prop_37", "full_property": "property prop_27;\n@(posedge clk)         (packet_start && !packet_abort)[*3] |-> packet_header_valid[*3];\nendproperty\nassert_prop_27:assert property (prop_27) else $error(\"\");", "task_id": "2_2471", "predict_sva": "@(posedge clk)     (packet_start && !packet_abort)[*3] |-> packet_header_valid[*3]"}
{"id": "11_18_0507", "name": "p_and_18", "sva": "@(posedge clk)     (tx_ready && rx_ready) && (baud_match) |-> uart_active", "ori_sva": "property p_and_18;\n@(posedge clk)     (tx_ready && rx_ready) && (baud_match) |-> uart_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_18  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(tx_ready && rx_ready) && (baud_match)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `uart_active`", "sva_signals": ["clk", "rst_n", "[0:0] tx_ready", "[0:0] rx_ready", "[0:0] baud_match", "[0:0] uart_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (tx_ready && rx_ready) && baud_match |-> uart_active", "sva_name": "p_and_45", "full_property": "property p_and_18;\n@(posedge clk)         (tx_ready && rx_ready) && baud_match |-> uart_active;\nendproperty\nassert_p_and_18:assert property (p_and_18) else $error(\"\");", "task_id": "2_2742", "predict_sva": "@(posedge clk)         ((tx_ready && rx_ready) && baud_match) |-> uart_active"}
{"id": "12_15_0552", "name": "p_or_15", "sva": "@(posedge clk)     (test_mode || debug_mode) |-> !normal_operation", "ori_sva": "property p_or_15;\n@(posedge clk)     (test_mode || debug_mode) |-> !normal_operation\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_15  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(test_mode || debug_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!normal_operation`", "sva_signals": ["clk", "rst_n", "[0:0] test_mode", "[0:0] debug_mode", "[0:0] normal_operation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (test_mode || debug_mode) |-> !normal_operation", "sva_name": "p_or_47", "full_property": "property p_or_15;\n@(posedge clk)         (test_mode || debug_mode) |-> !normal_operation;\nendproperty\nassert_p_or_15:assert property (p_or_15) else $error(\"\");", "task_id": "2_2788", "predict_sva": "@(posedge clk)         (test_mode || debug_mode) |-> !normal_operation"}
{"id": "9_14_0428", "name": "p_stable_cfg_after_prog", "sva": "@(posedge clk)     prog_done |=> $stable(device_cfg)", "ori_sva": "property p_stable_cfg_after_prog;\n@(posedge clk)     prog_done |=> $stable(device_cfg);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_cfg_after_prog  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `prog_done`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(device_cfg)`  \n\nExplanation:  \nThis assertion checks that once `prog_done` is asserted (high), the `device_cfg` signal must remain stable (unchanged) in the next clock cycle. The `|=>` operator ensures the consequent is checked one clock cycle after the antecedent is true. The `$stable` function verifies that `device_cfg` does not change between consecutive clock cycles.", "sva_signals": ["clk", "rst_n", "[0:0] prog_done", "device_cfg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         prog_done |=> $stable(device_cfg)", "sva_name": "p_stable_device_cfg_after_prog_done", "full_property": "property p_stable_cfg_after_prog;\n@(posedge clk)         prog_done |=> $stable(device_cfg);\nendproperty\nassert_p_stable_cfg_after_prog:assert property (p_stable_cfg_after_prog) else $error(\"\");", "task_id": "2_2647", "predict_sva": "@(posedge clk)     prog_done |=> $stable(device_cfg)"}
{"id": "5_50_0252", "name": "prop_50", "sva": "@(posedge clk) (register_renaming_active && !rename_stall)[*4] |-> rename_complete", "ori_sva": "property prop_50;\n@(posedge clk) (register_renaming_active && !rename_stall)[*4] |-> rename_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_50  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(register_renaming_active && !rename_stall)[*4]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `rename_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] register_renaming_active", "[0:0] rename_stall", "[0:0] rename_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (register_renaming_active && !rename_stall)[*4] |-> rename_complete", "sva_name": "prop_38", "full_property": "property prop_50;\n@(posedge clk)     (register_renaming_active && !rename_stall)[*4] |-> rename_complete;\nendproperty\nassert_prop_50:assert property (prop_50) else $error(\"\");", "task_id": "2_2495", "predict_sva": "@(posedge clk)     (register_renaming_active && !rename_stall)[*4] |-> rename_complete"}
{"id": "5_35_0224", "name": "prop_35", "sva": "@(posedge clk) (pwm_enabled && !pwm_disable)[*3] |-> pwm_output_active[*3]", "ori_sva": "property prop_35;\n@(posedge clk) (pwm_enabled && !pwm_disable)[*3] |-> pwm_output_active[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_35  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(pwm_enabled && !pwm_disable)` holds true for 3 consecutive clock cycles (`[*3]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pwm_output_active` holds true for 3 consecutive clock cycles (`[*3]`)  ", "sva_signals": ["clk", "rst_n", "[0:0] pwm_enabled", "[0:0] pwm_disable", "[0:0] pwm_output_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pwm_enabled && !pwm_disable)[*3] |-> pwm_output_active[*3]", "sva_name": "prop_48", "full_property": "property prop_35;\n@(posedge clk)         (pwm_enabled && !pwm_disable)[*3] |-> pwm_output_active[*3];\nendproperty\nassert_prop_35:assert property (prop_35) else $error(\"\");", "task_id": "2_2480", "predict_sva": "@(posedge clk)     (pwm_enabled && !pwm_disable)[*3] |-> pwm_output_active[*3]"}
{"id": "12_38_0563", "name": "p_or_38", "sva": "@(posedge clk)     (jitter_high || skew_high) |-> !clock_quality", "ori_sva": "property p_or_38;\n@(posedge clk)     (jitter_high || skew_high) |-> !clock_quality\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_38  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(jitter_high || skew_high)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!clock_quality`", "sva_signals": ["clk", "rst_n", "[0:0] jitter_high", "[0:0] skew_high", "[0:0] clock_quality"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (jitter_high || skew_high) |-> !clock_quality", "sva_name": "p_Clock_Quality_Check", "full_property": "property p_or_38;\n@(posedge clk)         (jitter_high || skew_high) |-> !clock_quality;\nendproperty\nassert_p_or_38:assert property (p_or_38) else $error(\"\");", "task_id": "2_2813", "predict_sva": "@(posedge clk)     (jitter_high || skew_high) |-> !clock_quality"}
{"id": "10_49_0512", "name": "p_past_thermal_throttle", "sva": "@(posedge clk)     $past(temp_high, 3) |-> throttle_en", "ori_sva": "property p_past_thermal_throttle;\n@(posedge clk)     $past(temp_high, 3) |-> throttle_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_thermal_throttle  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(temp_high, 3)` (The value of `temp_high` three clock cycles ago was true)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `throttle_en` (The `throttle_en` signal must be true in the current clock cycle)", "sva_signals": ["clk", "rst_n", "[0:0] throttle_en", "[0:0] temp_high"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(temp_high, 3) |-> throttle_en", "sva_name": "p_past_temp_threshold_met", "full_property": "property p_past_thermal_throttle;\n@(posedge clk)     $past(temp_high, 3) |-> throttle_en;\nendproperty\nassert_p_past_thermal_throttle:assert property (p_past_thermal_throttle) else $error(\"\");", "task_id": "2_2725", "predict_sva": "@(posedge clk)         $past(temp_high, 3) |-> throttle_en"}
{"id": "8_19_0375", "name": "p_fell_19", "sva": "@(posedge clk) $fell(update) |-> ##2 !dirty_bit", "ori_sva": "property p_fell_19;\n@(posedge clk) $fell(update) |-> ##2 !dirty_bit;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_19  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(update)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 !dirty_bit`  ", "sva_signals": ["clk", "rst_n", "[0:0] update", "[0:0] dirty_bit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(update) |-> ##2 !dirty_bit", "sva_name": "p_fell_update_dirty_bit", "full_property": "property p_fell_19;\n@(posedge clk)     $fell(update) |-> ##2 !dirty_bit;\nendproperty\nassert_p_fell_19:assert property (p_fell_19) else $error(\"\");", "task_id": "2_2607", "predict_sva": "@(posedge clk)         $fell(update) |-> ##2 !dirty_bit"}
{"id": "13_21_0608", "name": "p_not_21", "sva": "@(posedge clk) !(tx_busy || rx_busy) |-> ready", "ori_sva": "property p_not_21;\n@(posedge clk) !(tx_busy || rx_busy) |-> ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_21  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(tx_busy || rx_busy)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ready`", "sva_signals": ["clk", "rst_n", "[0:0] tx_busy", "[0:0] rx_busy", "[0:0] ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(tx_busy || rx_busy) |-> ready", "sva_name": "p_not_46", "full_property": "property p_not_21;\n@(posedge clk)         !(tx_busy || rx_busy) |-> ready;\nendproperty\nassert_p_not_21:assert property (p_not_21) else $error(\"\");", "task_id": "2_2840", "predict_sva": "@(posedge clk)         (!tx_busy && !rx_busy) |-> ready"}
{"id": "12_7_0558", "name": "p_or_7", "sva": "@(posedge clk)     $past(valid,2) || $past(valid,3) |-> current_valid", "ori_sva": "property p_or_7;\n@(posedge clk)     $past(valid,2) || $past(valid,3) |-> current_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_7  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(valid, 2) || $past(valid, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `current_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] current_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(valid, 2) || $past(valid, 3)) |-> current_valid", "sva_name": "p_or_47", "full_property": "property p_or_7;\n@(posedge clk)         ($past(valid, 2) || $past(valid, 3)) |-> current_valid;\nendproperty\nassert_p_or_7:assert property (p_or_7) else $error(\"\");", "task_id": "2_2828", "predict_sva": "@(posedge clk)         ($past(valid, 2) || $past(valid, 3)) |-> current_valid"}
{"id": "8_13_0349", "name": "p_fell_13", "sva": "@(posedge clk) $fell(hold) |-> ##1 !data_valid", "ori_sva": "property p_fell_13;\n@(posedge clk) $fell(hold) |-> ##1 !data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_13  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(hold)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !data_valid`", "sva_signals": ["clk", "rst_n", "[0:0] hold", "[0:0] data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(hold) |-> ##1 !data_valid", "sva_name": "p_fell_hold_no_data_valid", "full_property": "property p_fell_13;\n@(posedge clk)         $fell(hold) |-> ##1 !data_valid;\nendproperty\nassert_p_fell_13:assert property (p_fell_13) else $error(\"\");", "task_id": "2_2600", "predict_sva": "@(posedge clk)         $fell(hold) |-> ##1 !data_valid"}
{"id": "13_15_0650", "name": "p_not_15", "sva": "@(posedge clk) !(addr[7:0] == 8'hFF) |-> mem_select", "ori_sva": "property p_not_15;\n@(posedge clk) !(addr[7:0] == 8'hFF) |-> mem_select\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_15  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(addr[7:0] == 8'hFF)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mem_select`", "sva_signals": ["clk", "rst_n", "[7:0] addr", "[0:0] mem_select"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(addr[7:0] == 8'hFF) |-> mem_select", "sva_name": "p_not_46", "full_property": "property p_not_15;\n@(posedge clk)         !(addr[7:0] == 8'hFF) |-> mem_select;\nendproperty\nassert_p_not_15:assert property (p_not_15) else $error(\"\");", "task_id": "2_2835", "predict_sva": "@(posedge clk)         !(addr[7:0] == 8'hFF) |-> mem_select"}
{"id": "10_7_0464", "name": "p_past_data_unchanged", "sva": "@(posedge clk)     !$past(wr_en, 2) && !$past(wr_en, 1) |-> data_out == $past(data_out, 2)", "ori_sva": "property p_past_data_unchanged;\n@(posedge clk)     !$past(wr_en, 2) && !$past(wr_en, 1) |-> data_out == $past(data_out, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_data_unchanged  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!$past(wr_en, 2) && !$past(wr_en, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_out == $past(data_out, 2)`", "sva_signals": ["clk", "rst_n", "[0:0] wr_en", "[0:0] data_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !$past(wr_en, 2) && !$past(wr_en, 1) |-> data_out == $past(data_out, 2)", "sva_name": "p_past_data_integrity", "full_property": "property p_past_data_unchanged;\n@(posedge clk)     !$past(wr_en, 2) && !$past(wr_en, 1) |-> data_out == $past(data_out, 2);\nendproperty\nassert_p_past_data_unchanged:assert property (p_past_data_unchanged) else $error(\"\");", "task_id": "2_2731", "predict_sva": "@(posedge clk)         ($past(wr_en, 2) == 0 && $past(wr_en, 1) == 0) |-> ($past(data_out, 2) == data_out)"}
{"id": "13_3_0573", "name": "p_not_3", "sva": "@(posedge clk) !(err1 || err2) |-> ready", "ori_sva": "property p_not_3;\n@(posedge clk) !(err1 || err2) |-> ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(err1 || err2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ready`", "sva_signals": ["clk", "rst_n", "[0:0] err1", "[0:0] err2", "[0:0] ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(err1 || err2) |-> ready", "sva_name": "p_not_47", "full_property": "property p_not_3;\n@(posedge clk)         !(err1 || err2) |-> ready;\nendproperty\nassert_p_not_3:assert property (p_not_3) else $error(\"\");", "task_id": "2_2859", "predict_sva": "@(posedge clk)         !(err1 || err2) |-> ready"}
{"id": "13_29_0620", "name": "p_not_29", "sva": "@(negedge clk) !(power_down || reset) |-> operational", "ori_sva": "property p_not_29;\n@(negedge clk) !(power_down || reset) |-> operational\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_29  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(power_down || reset)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `operational`", "sva_signals": ["clk", "reset", "[0:0] power_down", "[0:0] operational"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     !(power_down || reset) |-> operational", "sva_name": "p_not_46", "full_property": "property p_not_29;\n@(negedge clk)     !(power_down || reset) |-> operational;\nendproperty\nassert_p_not_29:assert property (p_not_29) else $error(\"\");", "task_id": "2_2847", "predict_sva": "@(negedge clk)     !(power_down || reset) |-> operational"}
{"id": "3_26_0138", "name": "p_boundary_implies_capture", "sva": "@(posedge clk) boundary_trigger |-> data_capture", "ori_sva": "property p_boundary_implies_capture;\n@(posedge clk) boundary_trigger |-> data_capture;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_boundary_implies_capture  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `boundary_trigger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_capture`", "sva_signals": ["clk", "rst_n", "[0:0] boundary_trigger", "[0:0] data_capture"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         boundary_trigger |-> data_capture", "sva_name": "p_boundary_trigger_implies_data_capture", "full_property": "property p_boundary_implies_capture;\n@(posedge clk)         boundary_trigger |-> data_capture;\nendproperty\nassert_p_boundary_implies_capture:assert property (p_boundary_implies_capture) else $error(\"\");", "task_id": "2_3061", "predict_sva": "@(posedge clk)         boundary_trigger |-> data_capture"}
{"id": "3_24_0124", "name": "p_voltage_ok_implies_power_on", "sva": "@(posedge clk) voltage_stable |-> power_on", "ori_sva": "property p_voltage_ok_implies_power_on;\n@(posedge clk) voltage_stable |-> power_on;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_ok_implies_power_on  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_stable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `power_on`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_stable", "[0:0] power_on"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         voltage_stable |-> power_on", "sva_name": "p_voltage_stable_implies_power_on", "full_property": "property p_voltage_ok_implies_power_on;\n@(posedge clk)         voltage_stable |-> power_on;\nendproperty\nassert_p_voltage_ok_implies_power_on:assert property (p_voltage_ok_implies_power_on) else $error(\"\");", "task_id": "2_3059", "predict_sva": "@(posedge clk)         voltage_stable |-> power_on"}
{"id": "10_16_0457", "name": "p_past_handshake_complete", "sva": "@(posedge clk)     $past(req, 2) && $past(ack, 1) |-> !req", "ori_sva": "property p_past_handshake_complete;\n@(posedge clk)     $past(req, 2) && $past(ack, 1) |-> !req;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_handshake_complete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(req, 2) && $past(ack, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!req`  ", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(req, 2) && $past(ack, 1)) |-> !req", "sva_name": "p_Req_Ack_Handshake", "full_property": "property p_past_handshake_complete;\n@(posedge clk)         ($past(req, 2) && $past(ack, 1)) |-> !req;\nendproperty\nassert_p_past_handshake_complete:assert property (p_past_handshake_complete) else $error(\"\");", "task_id": "2_2893", "predict_sva": "@(posedge clk)         ($past(req, 2) && $past(ack, 1)) |-> !req"}
{"id": "1_1_0060", "name": "p_fixed_delay_1", "sva": "@(posedge clk) $rose(req) |-> ##3 ack", "ori_sva": "property p_fixed_delay_1;\n@(posedge clk) $rose(req) |-> ##3 ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_1  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(req) |-> ##3 ack", "sva_name": "p_rose_req_ack_follows", "full_property": "property p_fixed_delay_1;\n@(posedge clk)     $rose(req) |-> ##3 ack;\nendproperty\nassert_p_fixed_delay_1:assert property (p_fixed_delay_1) else $error(\"\");", "task_id": "2_2954", "predict_sva": "@(posedge clk)         $rose(req) |-> ##3 ack"}
{"id": "1_11_0030", "name": "p_fixed_delay_11", "sva": "@(posedge clk) (fifo_pop && !fifo_empty) |-> ##2 fifo_level_dec", "ori_sva": "property p_fixed_delay_11;\n@(posedge clk) (fifo_pop && !fifo_empty) |-> ##2 fifo_level_dec;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_fixed_delay_11  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_pop && !fifo_empty`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 fifo_level_dec`  \n\nExplanation:  \nThe assertion checks that whenever the FIFO is being popped (`fifo_pop` is high) and the FIFO is not empty (`!fifo_empty`), then exactly 2 clock cycles later, the `fifo_level_dec` signal must be asserted. This verifies a fixed 2-cycle delay between a valid pop operation and the corresponding FIFO level decrement indication.", "sva_signals": ["clk", "rst_n", "[0:0] fifo_pop", "[0:0] fifo_empty", "[0:0] fifo_level_dec"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_pop && !fifo_empty) |-> ##2 fifo_level_dec", "sva_name": "p_fifo_level_dec_after_pop", "full_property": "property p_fixed_delay_11;\n@(posedge clk)         (fifo_pop && !fifo_empty) |-> ##2 fifo_level_dec;\nendproperty\nassert_p_fixed_delay_11:assert property (p_fixed_delay_11) else $error(\"\");", "task_id": "2_2945", "predict_sva": "@(posedge clk)         (fifo_pop && !fifo_empty) |-> ##2 fifo_level_dec"}
{"id": "1_12_0063", "name": "p_fixed_delay_12", "sva": "@(posedge clk) (timeout_start && !timeout_clear) |-> ##8 timeout_event", "ori_sva": "property p_fixed_delay_12;\n@(posedge clk) (timeout_start && !timeout_clear) |-> ##8 timeout_event;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_12  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timeout_start && !timeout_clear`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 timeout_event`  \n\n(Note: The consequent specifies that exactly 8 clock cycles after the antecedent is true, `timeout_event` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] timeout_start", "[0:0] timeout_clear", "[0:0] timeout_event"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (timeout_start && !timeout_clear) |-> ##8 timeout_event", "sva_name": "p_fixed_delay_47", "full_property": "property p_fixed_delay_12;\n@(posedge clk)         (timeout_start && !timeout_clear) |-> ##8 timeout_event;\nendproperty\nassert_p_fixed_delay_12:assert property (p_fixed_delay_12) else $error(\"\");", "task_id": "2_2946", "predict_sva": "@(posedge clk)         (timeout_start && !timeout_clear) |-> ##8 timeout_event"}
{"id": "3_31_0129", "name": "p_sample_implies_convert", "sva": "@(posedge clk) sample_ready |-> start_conversion", "ori_sva": "property p_sample_implies_convert;\n@(posedge clk) sample_ready |-> start_conversion;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sample_implies_convert  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sample_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `start_conversion == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] sample_ready", "[0:0] start_conversion"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sample_ready == 1'b1 |-> start_conversion == 1'b1", "sva_name": "p_sample_ready_implies_start", "full_property": "property p_sample_implies_convert;\n@(posedge clk)         sample_ready == 1'b1 |-> start_conversion == 1'b1;\nendproperty\nassert_p_sample_implies_convert:assert property (p_sample_implies_convert) else $error(\"\");", "task_id": "2_3066", "predict_sva": "@(posedge clk)         sample_ready == 1'b1 |-> start_conversion == 1'b1"}
{"id": "15_16_0687", "name": "p_reset_disable_16", "sva": "@(posedge clk) disable iff(low_power_mode)     $fell(interrupt) |-> !interrupt_pending", "ori_sva": "property p_reset_disable_16;\n@(posedge clk) disable iff(low_power_mode)     $fell(interrupt) |-> !interrupt_pending;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_reset_disable_16  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (low_power_mode)  \n**Antecedent (LHS of Implication)**: `$fell(interrupt)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!interrupt_pending`  ", "sva_signals": ["clk", "rst_n", "[0:0] low_power_mode", "[0:0] interrupt", "[0:0] interrupt_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (low_power_mode)     $fell(interrupt) |-> !interrupt_pending", "sva_name": "p_Interrupt_Fell_No_Pending", "full_property": "property p_reset_disable_16;\n@(posedge clk) disable iff (low_power_mode)     $fell(interrupt) |-> !interrupt_pending;\nendproperty\nassert_p_reset_disable_16:assert property (p_reset_disable_16) else $error(\"\");", "task_id": "2_2902", "predict_sva": "@(posedge clk) disable iff (low_power_mode)     $fell(interrupt) |-> !interrupt_pending"}
{"id": "3_36_0118", "name": "p_decompression_implies_process", "sva": "@(posedge clk) decompression_done |-> process_data", "ori_sva": "property p_decompression_implies_process;\n@(posedge clk) decompression_done |-> process_data;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_decompression_implies_process  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `decompression_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `process_data == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] decompression_done", "[0:0] process_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         decompression_done == 1'b1 |-> process_data == 1'b1", "sva_name": "p_decompression_implies_data", "full_property": "property p_decompression_implies_process;\n@(posedge clk)         decompression_done == 1'b1 |-> process_data == 1'b1;\nendproperty\nassert_p_decompression_implies_process:assert property (p_decompression_implies_process) else $error(\"\");", "task_id": "2_3070", "predict_sva": "@(posedge clk)         decompression_done == 1'b1 |-> process_data == 1'b1"}
{"id": "3_3_0091", "name": "p_start_implies_ack", "sva": "@(posedge clk) transaction_start |-> immediate_ack", "ori_sva": "property p_start_implies_ack;\n@(posedge clk) transaction_start |-> immediate_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_start_implies_ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `transaction_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `immediate_ack == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] transaction_start", "[0:0] immediate_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         transaction_start == 1'b1 |-> immediate_ack == 1'b1", "sva_name": "p_overlap_47", "full_property": "property p_start_implies_ack;\n@(posedge clk)         transaction_start == 1'b1 |-> immediate_ack == 1'b1;\nendproperty\nassert_p_start_implies_ack:assert property (p_start_implies_ack) else $error(\"\");", "task_id": "2_3075", "predict_sva": "@(posedge clk)         transaction_start == 1'b1 |-> immediate_ack == 1'b1"}
{"id": "1_9_0134", "name": "p_fixed_delay_9", "sva": "@(posedge clk) (sync_pulse && enabled) |-> ##5 sync_done", "ori_sva": "property p_fixed_delay_9;\n@(posedge clk) (sync_pulse && enabled) |-> ##5 sync_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_9  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse && enabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 sync_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] enabled", "[0:0] sync_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sync_pulse && enabled) |-> ##5 sync_done", "sva_name": "p_and_47", "full_property": "property p_fixed_delay_9;\n@(posedge clk)         (sync_pulse && enabled) |-> ##5 sync_done;\nendproperty\nassert_p_fixed_delay_9:assert property (p_fixed_delay_9) else $error(\"\");", "task_id": "2_2993", "predict_sva": "@(posedge clk)         (sync_pulse && enabled) |-> ##5 sync_done"}
{"id": "1_33_0747", "name": "p_fixed_delay_33", "sva": "@(posedge clk) (freq_switch && pll_locked) |-> ##12 new_freq_stable", "ori_sva": "property p_fixed_delay_33;\n@(posedge clk) (freq_switch && pll_locked) |-> ##12 new_freq_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_33  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `freq_switch && pll_locked`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##12 new_freq_stable`  ", "sva_signals": ["clk", "rst_n", "[0:0] freq_switch", "[0:0] pll_locked", "[0:0] new_freq_stable"], "clock": "clk", "attempts_left": 9, "sva_result": "@(posedge clk)     (freq_switch && pll_locked) |-> ##12 new_freq_stable", "sva_name": "p_and_45", "full_property": "property p_fixed_delay_33;\n@(posedge clk)     (freq_switch && pll_locked) |-> ##12 new_freq_stable;\nendproperty\nassert_p_fixed_delay_33:assert property (p_fixed_delay_33) else $error(\"\");", "task_id": "2_2969", "predict_sva": "@(posedge clk)         (freq_switch && pll_locked) |-> ##12 new_freq_stable"}
{"id": "3_45_0172", "name": "p_dll_locked_implies_normal", "sva": "@(posedge clk) dll_locked |-> normal_operation", "ori_sva": "property p_dll_locked_implies_normal;\n@(posedge clk) dll_locked |-> normal_operation;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dll_locked_implies_normal  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dll_locked == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `normal_operation == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] dll_locked", "[0:0] normal_operation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         dll_locked == 1'b1 |-> normal_operation == 1'b1", "sva_name": "p_dll_locked_implies_normal_operation", "full_property": "property p_dll_locked_implies_normal;\n@(posedge clk)         dll_locked == 1'b1 |-> normal_operation == 1'b1;\nendproperty\nassert_p_dll_locked_implies_normal:assert property (p_dll_locked_implies_normal) else $error(\"\");", "task_id": "2_3081", "predict_sva": "@(posedge clk)         dll_locked == 1'b1 |-> normal_operation == 1'b1"}
{"id": "3_46_0142", "name": "p_calibration_start_implies_wait", "sva": "@(posedge clk) calibration_start |-> wait_cycles", "ori_sva": "property p_calibration_start_implies_wait;\n@(posedge clk) calibration_start |-> wait_cycles;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_calibration_start_implies_wait  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `calibration_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wait_cycles == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] calibration_start", "[0:0] wait_cycles"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         calibration_start == 1'b1 |-> wait_cycles == 1'b1", "sva_name": "p_calibration_start_implies_wait", "full_property": "property p_calibration_start_implies_wait;\n@(posedge clk)         calibration_start == 1'b1 |-> wait_cycles == 1'b1;\nendproperty\nassert_p_calibration_start_implies_wait:assert property (p_calibration_start_implies_wait) else $error(\"\");", "task_id": "2_3082", "predict_sva": "@(posedge clk)         calibration_start == 1'b1 |-> wait_cycles == 1'b1"}
{"id": "3_7_0094", "name": "p_crc_error_implies_retry", "sva": "@(posedge clk) crc_error |-> retry_request", "ori_sva": "property p_crc_error_implies_retry;\n@(posedge clk) crc_error |-> retry_request;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_error_implies_retry  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `retry_request == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] crc_error", "[0:0] retry_request"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         crc_error == 1'b1 |-> retry_request == 1'b1", "sva_name": "p_crc_error_retry", "full_property": "property p_crc_error_implies_retry;\n@(posedge clk)         crc_error == 1'b1 |-> retry_request == 1'b1;\nendproperty\nassert_p_crc_error_implies_retry:assert property (p_crc_error_implies_retry) else $error(\"\");", "task_id": "2_3089", "predict_sva": "@(posedge clk)         crc_error == 1'b1 |-> retry_request == 1'b1"}
{"id": "2_24_0028", "name": "prop_24", "sva": "@(posedge clk)     freq_switch |-> ##[10:20] pll_locked", "ori_sva": "property prop_24;\n@(posedge clk)     freq_switch |-> ##[10:20] pll_locked\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_24  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `freq_switch == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] pll_locked == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] freq_switch", "[0:0] pll_locked"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     freq_switch == 1'b1 |-> ##[10:20] pll_locked == 1'b1", "sva_name": "prop_47", "full_property": "property prop_24;\n@(posedge clk)     freq_switch == 1'b1 |-> ##[10:20] pll_locked == 1'b1;\nendproperty\nassert_prop_24:assert property (prop_24) else $error(\"\");", "task_id": "2_3009", "predict_sva": "@(posedge clk)     freq_switch == 1'b1 |-> ##[10:20] pll_locked == 1'b1"}
{"id": "2_36_0088", "name": "prop_36", "sva": "@(posedge clk)     ecc_correct |-> ##[8:16] data_corrected", "ori_sva": "property prop_36;\n@(posedge clk)     ecc_correct |-> ##[8:16] data_corrected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_36  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_correct == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] data_corrected == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] ecc_correct", "[0:0] data_corrected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ecc_correct == 1'b1 |-> ##[8:16] data_corrected == 1'b1", "sva_name": "prop_45", "full_property": "property prop_36;\n@(posedge clk)     ecc_correct == 1'b1 |-> ##[8:16] data_corrected == 1'b1;\nendproperty\nassert_prop_36:assert property (prop_36) else $error(\"\");", "task_id": "2_3021", "predict_sva": "@(posedge clk)     ecc_correct == 1'b1 |-> ##[8:16] data_corrected == 1'b1"}
{"id": "7_37_0329", "name": "p_rose_wait_go", "sva": "@(posedge clk) $rose(wait_sig) |-> go", "ori_sva": "property p_rose_wait_go;\n@(posedge clk) $rose(wait_sig) |-> go;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_wait_go  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(wait_sig)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `go`  ", "sva_signals": ["clk", "rst_n", "[0:0] wait_sig", "[0:0] go"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(wait_sig) |-> go", "sva_name": "p_rose_wait_sig_go", "full_property": "property p_rose_wait_go;\n@(posedge clk)         $rose(wait_sig) |-> go;\nendproperty\nassert_p_rose_wait_go:assert property (p_rose_wait_go) else $error(\"\");", "task_id": "2_3270", "predict_sva": "@(posedge clk)         $rose(wait_sig) |-> go"}
{"id": "3_8_0113", "name": "p_full_implies_stop", "sva": "@(posedge clk) buffer_full |-> write_stop", "ori_sva": "property p_full_implies_stop;\n@(posedge clk) buffer_full |-> write_stop;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_full_implies_stop  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `buffer_full == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `write_stop == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] buffer_full", "[0:0] write_stop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         buffer_full == 1'b1 |-> write_stop == 1'b1", "sva_name": "p_buffer_full_write_stop", "full_property": "property p_full_implies_stop;\n@(posedge clk)         buffer_full == 1'b1 |-> write_stop == 1'b1;\nendproperty\nassert_p_full_implies_stop:assert property (p_full_implies_stop) else $error(\"\");", "task_id": "2_3090", "predict_sva": "@(posedge clk)         buffer_full == 1'b1 |-> write_stop == 1'b1"}
{"id": "5_27_0223", "name": "p_27", "sva": "@(posedge clk)     (pll_lock[*5]) |-> ##5 pll_stable", "ori_sva": "property p_27;\n@(posedge clk)     (pll_lock[*5]) |-> ##5 pll_stable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_27  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pll_lock` is high for 5 consecutive clock cycles (`pll_lock[*5]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 5 clock cycles (`##5`), `pll_stable` must be high  \n\n(Note: The antecedent checks that `pll_lock` remains asserted for 5 consecutive cycles, and the consequent ensures `pll_stable` is asserted exactly 5 cycles after the start of the antecedent.)", "sva_signals": ["clk", "rst_n", "[0:0] pll_lock", "[0:0] pll_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     pll_lock[*5] |-> ##5 pll_stable", "sva_name": "p_37", "full_property": "property p_27;\n@(posedge clk)     pll_lock[*5] |-> ##5 pll_stable;\nendproperty\nassert_p_27:assert property (p_27) else $error(\"\");", "task_id": "2_3159", "predict_sva": "@(posedge clk)     pll_lock[*5] |-> ##5 pll_stable == 1'b1"}
{"id": "5_48_0230", "name": "p_48", "sva": "@(posedge clk)     (temp_alert[*2]) |-> ##2 temp_normal", "ori_sva": "property p_48;\n@(posedge clk)     (temp_alert[*2]) |-> ##2 temp_normal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_48  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_alert` is high for two consecutive clock cycles (`temp_alert[*2]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Two clock cycles after the antecedent is true (`##2`), `temp_normal` must be high (`temp_normal`)", "sva_signals": ["clk", "rst_n", "[0:0] temp_alert", "[0:0] temp_normal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     temp_alert[*2] |-> ##2 temp_normal", "sva_name": "p_temp_alert_to_normal", "full_property": "property p_48;\n@(posedge clk)     temp_alert[*2] |-> ##2 temp_normal;\nendproperty\nassert_p_48:assert property (p_48) else $error(\"\");", "task_id": "2_3183", "predict_sva": "@(posedge clk)     temp_alert[*2] |-> ##2 temp_normal == 1'b1"}
{"id": "5_12_0196", "name": "p_12", "sva": "@(posedge clk)     (sop && !eop)[*2] |-> ##2 eop", "ori_sva": "property p_12;\n@(posedge clk)     (sop && !eop)[*2] |-> ##2 eop\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_12  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(sop && !eop)[*2]` (Two consecutive cycles where `sop` is high and `eop` is low)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 eop` (Two cycles after the antecedent sequence, `eop` must be high)", "sva_signals": ["clk", "rst_n", "[0:0] sop", "[0:0] eop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (sop && !eop)[*2] |-> ##2 eop", "sva_name": "p_35", "full_property": "property p_12;\n@(posedge clk)     (sop && !eop)[*2] |-> ##2 eop;\nendproperty\nassert_p_12:assert property (p_12) else $error(\"\");", "task_id": "2_3144", "predict_sva": "@(posedge clk)     (sop && !eop)[*2] |-> ##2 eop"}
{"id": "7_30_0321", "name": "p_rose_debug_en_debug_data", "sva": "@(posedge clk) $rose(debug_en) |=> debug_data", "ori_sva": "property p_rose_debug_en_debug_data;\n@(posedge clk) $rose(debug_en) |=> debug_data;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_debug_en_debug_data  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(debug_en)` (debug_en transitions from low to high)  \n**Implication Operator**: `|=>` (overlapping implication with a 1-cycle delay)  \n**Consequent (RHS of Implication)**: `debug_data` (debug_data must be valid in the next clock cycle)", "sva_signals": ["clk", "rst_n", "[0:0] debug_en", "[0:0] debug_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(debug_en) |=> debug_data", "sva_name": "p_Debug_Data_Valid_After_Enable", "full_property": "property p_rose_debug_en_debug_data;\n@(posedge clk)     $rose(debug_en) |=> debug_data;\nendproperty\nassert_p_rose_debug_en_debug_data:assert property (p_rose_debug_en_debug_data) else $error(\"\");", "task_id": "2_3264", "predict_sva": "@(posedge clk)     $rose(debug_en) |-> ##1 debug_data"}
{"id": "6_4_0237", "name": "p_var_rep_4", "sva": "@(posedge clk)     data_ready[*4:10] |-> ##2 fifo_full", "ori_sva": "property p_var_rep_4;\n@(posedge clk)     data_ready[*4:10] |-> ##2 fifo_full\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_4  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_ready` is true for 4 to 10 consecutive clock cycles (`data_ready[*4:10]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Two clock cycles after the repetition ends (`##2`), `fifo_full` must be true (`fifo_full`)", "sva_signals": ["clk", "rst_n", "[3:0] data_ready", "[0:0] fifo_full"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         data_ready[*4:10] |-> ##2 fifo_full", "sva_name": "p_var_rep_37", "full_property": "property p_var_rep_4;\n@(posedge clk)         data_ready[*4:10] |-> ##2 fifo_full;\nendproperty\nassert_p_var_rep_4:assert property (p_var_rep_4) else $error(\"\");", "task_id": "2_3235", "predict_sva": "@(posedge clk)     data_ready[*4:10] |-> ##2 fifo_full"}
{"id": "8_32_0351", "name": "p_fell_reset_phase_complete", "sva": "@(posedge clk)     $fell(reset_phase) |-> ##1 normal_operation", "ori_sva": "property p_fell_reset_phase_complete;\n@(posedge clk)     $fell(reset_phase) |-> ##1 normal_operation;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_reset_phase_complete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(reset_phase)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 normal_operation`", "sva_signals": ["clk", "reset_phase", "[0:0] normal_operation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(reset_phase) |-> ##1 normal_operation", "sva_name": "p_fell_reset_phase", "full_property": "property p_fell_reset_phase_complete;\n@(posedge clk)         $fell(reset_phase) |-> ##1 normal_operation;\nendproperty\nassert_p_fell_reset_phase_complete:assert property (p_fell_reset_phase_complete) else $error(\"\");", "task_id": "2_3313", "predict_sva": "@(posedge clk)     $fell(reset_phase) |-> ##1 normal_operation"}
{"id": "8_46_0394", "name": "p_fell_voltage_drop_check", "sva": "@(posedge clk)     $fell(voltage_ok) |-> ##1 voltage_drop", "ori_sva": "property p_fell_voltage_drop_check;\n@(posedge clk)     $fell(voltage_ok) |-> ##1 voltage_drop;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_voltage_drop_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(voltage_ok)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 voltage_drop`  ", "sva_signals": ["clk", "rst_n", "[0:0] voltage_ok", "[0:0] voltage_drop"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(voltage_ok) |-> ##1 voltage_drop", "sva_name": "p_fell_voltage_ok_check", "full_property": "property p_fell_voltage_drop_check;\n@(posedge clk)         $fell(voltage_ok) |-> ##1 voltage_drop;\nendproperty\nassert_p_fell_voltage_drop_check:assert property (p_fell_voltage_drop_check) else $error(\"\");", "task_id": "2_3328", "predict_sva": "@(posedge clk)     $fell(voltage_ok) |-> ##1 voltage_drop"}
{"id": "11_16_0498", "name": "sdio_cmd_response_timeout", "sva": "@(posedge clk_sdio)     cmd_sent && !cmd_busy |-> ##[8:64] response_received || timeout_error", "ori_sva": "property sdio_cmd_response_timeout;\n@(posedge clk_sdio)     cmd_sent && !cmd_busy |-> ##[8:64] response_received || timeout_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sdio_cmd_response_timeout  \n**Trigger Condition**: At every rising edge of the `clk_sdio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_sent && !cmd_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:64] response_received || timeout_error`  \n\n", "sva_signals": ["clk_sdio", "cmd_sent", "cmd_busy", "response_received", "timeout_error"], "clock": "clk_sdio", "attempts_left": 10, "sva_result": "@(posedge clk_sdio)     (cmd_sent && !cmd_busy) |-> ##[8:64] (response_received || timeout_error)", "sva_name": "p_sdio_cmd_response_timeout_check", "full_property": "property sdio_cmd_response_timeout;\n@(posedge clk_sdio)     (cmd_sent && !cmd_busy) |-> ##[8:64] (response_received || timeout_error);\nendproperty\nassert_sdio_cmd_response_timeout:assert property (sdio_cmd_response_timeout) else $error(\"\");", "task_id": "2_3445", "predict_sva": "@(posedge clk_sdio)     (cmd_sent && !cmd_busy) |-> ##[8:64] (response_received || timeout_error)"}
{"id": "11_20_0515", "name": "adc_conversion_complete_check", "sva": "@(posedge clk_adc)     conv_start && !adc_busy |-> ##[10:20] data_valid && !overflow", "ori_sva": "property adc_conversion_complete_check;\n@(posedge clk_adc)     conv_start && !adc_busy |-> ##[10:20] data_valid && !overflow\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: adc_conversion_complete_check  \n**Trigger Condition**: At every rising edge of the `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `conv_start && !adc_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] data_valid && !overflow`  ", "sva_signals": ["clk_adc", "[0:0] conv_start", "[0:0] adc_busy", "[0:0] data_valid", "[0:0] overflow"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     (conv_start && !adc_busy) |-> ##[10:20] (data_valid && !overflow)", "sva_name": "p_adc_conversion_47", "full_property": "property adc_conversion_complete_check;\n@(posedge clk_adc)     (conv_start && !adc_busy) |-> ##[10:20] (data_valid && !overflow);\nendproperty\nassert_adc_conversion_complete_check:assert property (adc_conversion_complete_check) else $error(\"\");", "task_id": "2_3450", "predict_sva": "@(posedge clk_adc)     (conv_start && !adc_busy) |-> ##[10:20] (data_valid && !overflow)"}
{"id": "11_26_0510", "name": "dma_transfer_complete_check", "sva": "@(posedge clk_dma)     dma_en && !abort_req |-> ##[16:256] done_int && !error_status", "ori_sva": "property dma_transfer_complete_check;\n@(posedge clk_dma)     dma_en && !abort_req |-> ##[16:256] done_int && !error_status\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dma_transfer_complete_check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_en && !abort_req`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:256] done_int && !error_status`  ", "sva_signals": ["clk_dma", "abort_req", "dma_en", "done_int", "error_status"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma)         (dma_en && !abort_req) |-> ##[16:256] (done_int && !error_status)", "sva_name": "p_dma_transfer_check_47", "full_property": "property dma_transfer_complete_check;\n@(posedge clk_dma)         (dma_en && !abort_req) |-> ##[16:256] (done_int && !error_status);\nendproperty\nassert_dma_transfer_complete_check:assert property (dma_transfer_complete_check) else $error(\"\");", "task_id": "2_3455", "predict_sva": "@(posedge clk_dma)     (dma_en && !abort_req) |-> ##[16:256] (done_int && !error_status)"}
{"id": "1_27_0083", "name": "crypto_hash_complete", "sva": "@(posedge clk_crypto)      $rose(hash_start) |-> ##16 hash_done ##1 digest_match", "ori_sva": "property crypto_hash_complete;\n@(posedge clk_crypto)      $rose(hash_start) |-> ##16 hash_done ##1 digest_match\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: crypto_hash_complete  \n**Trigger Condition**: At every rising edge of `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(hash_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##16 hash_done ##1 digest_match`  ", "sva_signals": ["clk_crypto", "hash_start", "hash_done", "digest_match"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)     $rose(hash_start) |-> ##16 hash_done ##1 digest_match", "sva_name": "p_crypto_hash_completion_10", "full_property": "property crypto_hash_complete;\n@(posedge clk_crypto)     $rose(hash_start) |-> ##16 hash_done ##1 digest_match;\nendproperty\nassert_crypto_hash_complete:assert property (crypto_hash_complete) else $error(\"\");", "task_id": "2_3622", "predict_sva": "@(posedge clk_crypto)         $rose(hash_start) |-> ##16 hash_done ##1 digest_match"}
{"id": "11_47_0534", "name": "clock_monitor_failure_check", "sva": "@(posedge clk_ref)     monitor_en && !calibration_mode |-> ##[4:8] $stable(clock_status) || fail_detected", "ori_sva": "property clock_monitor_failure_check;\n@(posedge clk_ref)     monitor_en && !calibration_mode |-> ##[4:8] $stable(clock_status) || fail_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: clock_monitor_failure_check  \n**Trigger Condition**: At every rising edge of the `clk_ref`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `monitor_en && !calibration_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:8] $stable(clock_status) || fail_detected`  ", "sva_signals": ["clk", "rst_n", "[0:0] monitor_en", "[0:0] calibration_mode", "[0:0] clock_status", "[0:0] fail_detected", "clk_ref"], "clock": "clk_ref", "attempts_left": 10, "sva_result": "@(posedge clk_ref)     (monitor_en && !calibration_mode) |-> ##[4:8] ($stable(clock_status) || fail_detected)", "sva_name": "p_clock_monitor_36", "full_property": "property clock_monitor_failure_check;\n@(posedge clk_ref)     (monitor_en && !calibration_mode) |-> ##[4:8] ($stable(clock_status) || fail_detected);\nendproperty\nassert_clock_monitor_failure_check:assert property (clock_monitor_failure_check) else $error(\"\");", "task_id": "2_3473", "predict_sva": "@(posedge clk_ref)     (monitor_en && !calibration_mode) |-> ##[4:8] ($stable(clock_status) || fail_detected)"}
{"id": "11_44_0547", "name": "firmware_update_signature_check", "sva": "@(posedge clk_fw)     fw_update_start && !rollback_prevented |-> ##[64:128] update_done && !signature_fail", "ori_sva": "property firmware_update_signature_check;\n@(posedge clk_fw)     fw_update_start && !rollback_prevented |-> ##[64:128] update_done && !signature_fail\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: firmware_update_signature_check  \n**Trigger Condition**: At every rising edge of the `clk_fw`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fw_update_start && !rollback_prevented`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[64:128] update_done && !signature_fail`  ", "sva_signals": ["clk_fw", "rollback_prevented", "[0:0] fw_update_start", "[0:0] update_done", "[0:0] signature_fail"], "clock": "clk_fw", "attempts_left": 10, "sva_result": "@(posedge clk_fw)         (fw_update_start && !rollback_prevented) |-> ##[64:128] (update_done && !signature_fail)", "sva_name": "p_firmware_update_rollback_check", "full_property": "property firmware_update_signature_check;\n@(posedge clk_fw)         (fw_update_start && !rollback_prevented) |-> ##[64:128] (update_done && !signature_fail);\nendproperty\nassert_firmware_update_signature_check:assert property (firmware_update_signature_check) else $error(\"\");", "task_id": "2_3471", "predict_sva": "@(posedge clk_fw)     (fw_update_start && !rollback_prevented) |-> ##[64:128] (update_done && !signature_fail)"}
{"id": "15_10_0706", "name": "power_state_check_10", "sva": "@(posedge clk_pwr) disable iff(force_wakeup)     sleep_request |-> ##[3:8] deep_sleep_entry ##1 (voltage_level == low_power_mode)", "ori_sva": "property power_state_check_10;\n@(posedge clk_pwr) disable iff(force_wakeup)     sleep_request |-> ##[3:8] deep_sleep_entry ##1 (voltage_level == low_power_mode)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: power_state_check_10  \n**Trigger Condition**: At every rising edge of the `clk_pwr`  \n**Disable Condition**: `disable iff (force_wakeup)`  \n**Antecedent (LHS of Implication)**: `sleep_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:8] deep_sleep_entry ##1 (voltage_level == low_power_mode)`  ", "sva_signals": ["clk_pwr", "force_wakeup", "[0:0] sleep_request", "[0:0] deep_sleep_entry", "voltage_level", "low_power_mode"], "clock": "clk_pwr", "attempts_left": 10, "sva_result": "@(posedge clk_pwr) disable iff (force_wakeup)     sleep_request |-> ##[3:8] deep_sleep_entry ##1 (voltage_level == low_power_mode)", "sva_name": "p_low_power_mode_transition", "full_property": "property power_state_check_10;\n@(posedge clk_pwr) disable iff (force_wakeup)     sleep_request |-> ##[3:8] deep_sleep_entry ##1 (voltage_level == low_power_mode);\nendproperty\nassert_power_state_check_10:assert property (power_state_check_10) else $error(\"\");", "task_id": "2_3569", "predict_sva": "@(posedge clk_pwr) disable iff (force_wakeup)     sleep_request == 1'b1 |-> ##[3:8] deep_sleep_entry ##1 voltage_level == low_power_mode"}
{"id": "11_12_0505", "name": "spi_data_phase_validation", "sva": "@(posedge clk_spi)     csb_asserted && sck_active |-> ##1 mosi_data == $past(miso_data, 2)", "ori_sva": "property spi_data_phase_validation;\n@(posedge clk_spi)     csb_asserted && sck_active |-> ##1 mosi_data == $past(miso_data, 2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: spi_data_phase_validation  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `csb_asserted && sck_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 mosi_data == $past(miso_data, 2)`  ", "sva_signals": ["clk_spi", "csb_asserted", "sck_active", "mosi_data", "miso_data"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi)     (csb_asserted && sck_active) |-> ##1 (mosi_data == $past(miso_data, 2))", "sva_name": "spi_slave_data_check_10", "full_property": "property spi_data_phase_validation;\n@(posedge clk_spi)     (csb_asserted && sck_active) |-> ##1 (mosi_data == $past(miso_data, 2));\nendproperty\nassert_spi_data_phase_validation:assert property (spi_data_phase_validation) else $error(\"\");", "task_id": "2_3443", "predict_sva": "@(posedge clk_spi)     (csb_asserted && sck_active) |-> ##1 mosi_data == $past(miso_data, 2)"}
{"id": "11_17_0509", "name": "jtag_tap_state_machine_check", "sva": "@(posedge clk_jtag)     tms_high && tdi_valid |-> ##1 $changed(tap_state) && !bypass_mode", "ori_sva": "property jtag_tap_state_machine_check;\n@(posedge clk_jtag)     tms_high && tdi_valid |-> ##1 $changed(tap_state) && !bypass_mode\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: jtag_tap_state_machine_check  \n**Trigger Condition**: At every rising edge of the `clk_jtag`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tms_high && tdi_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $changed(tap_state) && !bypass_mode`  ", "sva_signals": ["clk_jtag", "[0:0] tms_high", "[0:0] tdi_valid", "[0:0] tap_state", "[0:0] bypass_mode"], "clock": "clk_jtag", "attempts_left": 10, "sva_result": "@(posedge clk_jtag)         tms_high && tdi_valid |-> ##1 ($changed(tap_state) && !bypass_mode)", "sva_name": "p_jtag_tap_state_transition", "full_property": "property jtag_tap_state_machine_check;\n@(posedge clk_jtag)         tms_high && tdi_valid |-> ##1 ($changed(tap_state) && !bypass_mode);\nendproperty\nassert_jtag_tap_state_machine_check:assert property (jtag_tap_state_machine_check) else $error(\"\");", "task_id": "2_3446", "predict_sva": "@(posedge clk_jtag)     (tms_high && tdi_valid) |-> ##1 ($changed(tap_state) && !bypass_mode)"}
{"id": "3_14_0091", "name": "pwm_period_edge_check", "sva": "@(posedge clk_pwm)     pwm_period_start |-> ##[20:25] pwm_period_end ##0 pwm_duty_valid", "ori_sva": "property pwm_period_edge_check;\n@(posedge clk_pwm)     pwm_period_start |-> ##[20:25] pwm_period_end ##0 pwm_duty_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pwm_period_edge_check  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwm_period_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[20:25] pwm_period_end ##0 pwm_duty_valid`  ", "sva_signals": ["clk_pwm", "pwm_period_start", "pwm_period_end", "pwm_duty_valid"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)     pwm_period_start == 1'b1 |-> ##[20:25] pwm_period_end ##0 pwm_duty_valid", "sva_name": "p_pwm_period_check_17", "full_property": "property pwm_period_edge_check;\n@(posedge clk_pwm)     pwm_period_start == 1'b1 |-> ##[20:25] pwm_period_end ##0 pwm_duty_valid;\nendproperty\nassert_pwm_period_edge_check:assert property (pwm_period_edge_check) else $error(\"\");", "task_id": "2_3694", "predict_sva": "@(posedge clk_pwm)     pwm_period_start == 1'b1 |-> ##[20:25] pwm_period_end ##0 pwm_duty_valid"}
{"id": "15_38_0746", "name": "rf_transceiver_check_38", "sva": "@(posedge clk_rf) disable iff(rf_disabled)     tx_enable |-> ##[5:10] rx_enable ##1 (frequency_synth == programmed_freq)", "ori_sva": "property rf_transceiver_check_38;\n@(posedge clk_rf) disable iff(rf_disabled)     tx_enable |-> ##[5:10] rx_enable ##1 (frequency_synth == programmed_freq)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: rf_transceiver_check_38  \n**Trigger Condition**: At every rising edge of the `clk_rf`  \n**Disable Condition**: `disable iff (rf_disabled)`  \n**Antecedent (LHS of Implication)**: `tx_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] rx_enable ##1 (frequency_synth == programmed_freq)`  ", "sva_signals": ["clk_rf", "rf_disabled", "[0:0] tx_enable", "[0:0] rx_enable", "frequency_synth", "programmed_freq"], "clock": "clk_rf", "attempts_left": 10, "sva_result": "@(posedge clk_rf) disable iff (rf_disabled)     tx_enable == 1'b1 |-> ##[5:10] rx_enable ##1 (frequency_synth == programmed_freq)", "sva_name": "rf_transceiver_check_46", "full_property": "property rf_transceiver_check_38;\n@(posedge clk_rf) disable iff (rf_disabled)     tx_enable == 1'b1 |-> ##[5:10] rx_enable ##1 (frequency_synth == programmed_freq);\nendproperty\nassert_rf_transceiver_check_38:assert property (rf_transceiver_check_38) else $error(\"\");", "task_id": "2_3591", "predict_sva": "@(posedge clk_rf) disable iff (rf_disabled)     tx_enable == 1'b1 |-> ##[5:10] rx_enable ##1 (frequency_synth == programmed_freq)"}
{"id": "11_25_0543", "name": "rtc_alarm_check", "sva": "@(posedge clk_rtc)     (current_time == alarm_time) && alarm_enabled |-> ##1 alarm_trigger", "ori_sva": "property rtc_alarm_check;\n@(posedge clk_rtc)     (current_time == alarm_time) && alarm_enabled |-> ##1 alarm_trigger\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: rtc_alarm_check  \n**Trigger Condition**: At every rising edge of the `clk_rtc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(current_time == alarm_time) && alarm_enabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 alarm_trigger`", "sva_signals": ["clk_rtc", "[0:0] current_time", "[0:0] alarm_time", "[0:0] alarm_enabled", "[0:0] alarm_trigger"], "clock": "clk_rtc", "attempts_left": 10, "sva_result": "@(posedge clk_rtc)     (current_time == alarm_time) && alarm_enabled |-> ##1 alarm_trigger", "sva_name": "alarm_trigger_check", "full_property": "property rtc_alarm_check;\n@(posedge clk_rtc)     (current_time == alarm_time) && alarm_enabled |-> ##1 alarm_trigger;\nendproperty\nassert_rtc_alarm_check:assert property (rtc_alarm_check) else $error(\"\");", "task_id": "2_4007", "predict_sva": "@(posedge clk_rtc)         ((current_time == alarm_time) && alarm_enabled) |-> ##1 alarm_trigger"}
{"id": "11_11_0510", "name": "dram_refresh_window", "sva": "@(posedge clk_dram_ctrl)     (refresh_req && !self_refresh) && !active_banks |-> ##[100:200] refresh_ack", "ori_sva": "property dram_refresh_window;\n@(posedge clk_dram_ctrl)     (refresh_req && !self_refresh) && !active_banks |-> ##[100:200] refresh_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dram_refresh_window  \n**Trigger Condition**: At every rising edge of the `clk_dram_ctrl`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(refresh_req && !self_refresh) && !active_banks`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:200] refresh_ack`  ", "sva_signals": ["clk_dram_ctrl", "[0:0] refresh_req", "[0:0] self_refresh", "[0:0] active_banks", "[0:0] refresh_ack"], "clock": "clk_dram_ctrl", "attempts_left": 10, "sva_result": "@(posedge clk_dram_ctrl)         (refresh_req && !self_refresh && !active_banks) |-> ##[100:200] refresh_ack", "sva_name": "p_dram_refresh_interval_check", "full_property": "property dram_refresh_window;\n@(posedge clk_dram_ctrl)         (refresh_req && !self_refresh && !active_banks) |-> ##[100:200] refresh_ack;\nendproperty\nassert_dram_refresh_window:assert property (dram_refresh_window) else $error(\"\");", "task_id": "2_3994", "predict_sva": "@(posedge clk_dram_ctrl)         (refresh_req && !self_refresh && !active_banks) |-> ##[100:200] refresh_ack"}
{"id": "7_13_0317", "name": "p_i2c_edge_det_start_condition", "sva": "@(posedge i2c_clk)     $rose(i2c_sda_in) |-> ##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in)", "ori_sva": "property p_i2c_edge_det_start_condition;\n@(posedge i2c_clk)     $rose(i2c_sda_in) |-> ##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_i2c_edge_det_start_condition  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(i2c_sda_in)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in)`  ", "sva_signals": ["i2c_clk", "i2c_sda_in", "i2c_scl_high"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     $rose(i2c_sda_in) |-> ##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in)", "sva_name": "p_i2c_start_condition_check", "full_property": "property p_i2c_edge_det_start_condition;\n@(posedge i2c_clk)     $rose(i2c_sda_in) |-> ##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in);\nendproperty\nassert_p_i2c_edge_det_start_condition:assert property (p_i2c_edge_det_start_condition) else $error(\"\");", "task_id": "2_3857", "predict_sva": "@(posedge i2c_clk)     $rose(i2c_sda_in) |-> ##1 i2c_scl_high ##[2:3] $fell(i2c_sda_in)"}
{"id": "6_44_0308", "name": "usb_phy_reset_check", "sva": "@(posedge clk_usb_phy)      phy_reset[*3:6] |-> ##[2:4] phy_ready[*1:3]", "ori_sva": "property usb_phy_reset_check;\n@(posedge clk_usb_phy)      phy_reset[*3:6] |-> ##[2:4] phy_ready[*1:3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_phy_reset_check  \n**Trigger Condition**: At every rising edge of the `clk_usb_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phy_reset` is asserted continuously for 3 to 6 clock cycles (`phy_reset[*3:6]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 2 to 4 clock cycles (`##[2:4]`), `phy_ready` is asserted continuously for 1 to 3 clock cycles (`phy_ready[*1:3]`)", "sva_signals": ["clk_usb_phy", "phy_reset", "phy_ready"], "clock": "clk_usb_phy", "attempts_left": 10, "sva_result": "@(posedge clk_usb_phy)     phy_reset[*3:6] |-> ##[2:4] phy_ready[*1:3]", "sva_name": "p_usb_phy_ready_check", "full_property": "property usb_phy_reset_check;\n@(posedge clk_usb_phy)     phy_reset[*3:6] |-> ##[2:4] phy_ready[*1:3];\nendproperty\nassert_usb_phy_reset_check:assert property (usb_phy_reset_check) else $error(\"\");", "task_id": "2_3845", "predict_sva": "@(posedge clk_usb_phy)     phy_reset[*3:6] |-> ##[2:4] phy_ready[*1:3]"}
{"id": "11_44_0529", "name": "video_line_buffer", "sva": "@(posedge clk_video_processing)     (line_start && !buffer_empty) && pixel_valid |-> ##[1280:1920] line_end", "ori_sva": "property video_line_buffer;\n@(posedge clk_video_processing)     (line_start && !buffer_empty) && pixel_valid |-> ##[1280:1920] line_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: video_line_buffer  \n**Trigger Condition**: At every rising edge of the `clk_video_processing`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(line_start && !buffer_empty) && pixel_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1280:1920] line_end`  ", "sva_signals": ["clk_video_processing", "rst_n", "[0:0] line_start", "[0:0] buffer_empty", "[0:0] pixel_valid", "[0:0] line_end"], "clock": "clk_video_processing", "attempts_left": 10, "sva_result": "@(posedge clk_video_processing)         (line_start && !buffer_empty) && pixel_valid |-> ##[1280:1920] line_end", "sva_name": "video_line_check_45", "full_property": "property video_line_buffer;\n@(posedge clk_video_processing)         (line_start && !buffer_empty) && pixel_valid |-> ##[1280:1920] line_end;\nendproperty\nassert_video_line_buffer:assert property (video_line_buffer) else $error(\"\");", "task_id": "2_4024", "predict_sva": "@(posedge clk_video_processing)     (line_start && !buffer_empty && pixel_valid) |-> ##[1280:1920] line_end"}
{"id": "11_22_0520", "name": "video_frame_sync_check", "sva": "@(posedge clk_pixel)     (vsync && hsync) && (pixel_cnt == 0) |-> ##[1920:2048] next_vsync", "ori_sva": "property video_frame_sync_check;\n@(posedge clk_pixel)     (vsync && hsync) && (pixel_cnt == 0) |-> ##[1920:2048] next_vsync\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: video_frame_sync_check  \n**Trigger Condition**: At every rising edge of the `clk_pixel`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(vsync && hsync) && (pixel_cnt == 0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1920:2048] next_vsync`  ", "sva_signals": ["clk_pixel", "vsync", "hsync", "pixel_cnt", "next_vsync"], "clock": "clk_pixel", "attempts_left": 10, "sva_result": "@(posedge clk_pixel)     (vsync && hsync) && (pixel_cnt == 0) |-> ##[1920:2048] next_vsync", "sva_name": "p_pixel_sync_check_37", "full_property": "property video_frame_sync_check;\n@(posedge clk_pixel)     (vsync && hsync) && (pixel_cnt == 0) |-> ##[1920:2048] next_vsync;\nendproperty\nassert_video_frame_sync_check:assert property (video_frame_sync_check) else $error(\"\");", "task_id": "2_4004", "predict_sva": "@(posedge clk_pixel)     ((vsync && hsync) && (pixel_cnt == 0)) |-> ##[1920:2048] next_vsync"}
{"id": "6_14_0261", "name": "voltage_droop_recovery_check", "sva": "@(posedge clk_pmu)      vdroop_detect[*1:2] |-> ##[2:5] vdd_stable[*3:6]", "ori_sva": "property voltage_droop_recovery_check;\n@(posedge clk_pmu)      vdroop_detect[*1:2] |-> ##[2:5] vdd_stable[*3:6]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: voltage_droop_recovery_check  \n**Trigger Condition**: At every rising edge of `clk_pmu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vdroop_detect` occurs consecutively for 1 to 2 clock cycles (`vdroop_detect[*1:2]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 2 to 5 clock cycles (`##[2:5]`), `vdd_stable` must remain high for 3 to 6 consecutive clock cycles (`vdd_stable[*3:6]`)", "sva_signals": ["clk_pmu", "[0:0] vdroop_detect", "[0:0] vdd_stable"], "clock": "clk_pmu", "attempts_left": 10, "sva_result": "@(posedge clk_pmu)     vdroop_detect[*1:2] |-> ##[2:5] vdd_stable[*3:6]", "sva_name": "p_vdroop_recovery_check", "full_property": "property voltage_droop_recovery_check;\n@(posedge clk_pmu)     vdroop_detect[*1:2] |-> ##[2:5] vdd_stable[*3:6];\nendproperty\nassert_voltage_droop_recovery_check:assert property (voltage_droop_recovery_check) else $error(\"\");", "task_id": "2_3815", "predict_sva": "@(posedge clk_pmu)     vdroop_detect[*1:2] |-> ##[2:5] vdd_stable[*3:6]"}
{"id": "10_41_0519", "name": "multi_cycle_data_pipeline", "sva": "@(posedge pipe_clk)     pipe_valid |-> $past(pipe_data,4) == $past(processed_data,2)", "ori_sva": "property multi_cycle_data_pipeline;\n@(posedge pipe_clk)     pipe_valid |-> $past(pipe_data,4) == $past(processed_data,2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: multi_cycle_data_pipeline  \n**Trigger Condition**: At every rising edge of the `pipe_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipe_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pipe_data,4) == $past(processed_data,2)`  \n\n(Note: The assertion checks that if `pipe_valid` is high at a rising clock edge, then the value of `pipe_data` from 4 cycles ago must equal the value of `processed_data` from 2 cycles ago.)", "sva_signals": ["pipe_clk", "[0:0] pipe_valid", "[7:0] pipe_data", "[7:0] processed_data"], "clock": "pipe_clk", "attempts_left": 10, "sva_result": "@(posedge pipe_clk)         pipe_valid == 1'b1 |-> $past(pipe_data,4) == $past(processed_data,2)", "sva_name": "multi_cycle_consistency", "full_property": "property multi_cycle_data_pipeline;\n@(posedge pipe_clk)         pipe_valid == 1'b1 |-> $past(pipe_data,4) == $past(processed_data,2);\nendproperty\nassert_multi_cycle_data_pipeline:assert property (multi_cycle_data_pipeline) else $error(\"\");", "task_id": "2_3979", "predict_sva": "@(posedge pipe_clk)     pipe_valid == 1'b1 |-> $past(pipe_data, 4) == $past(processed_data, 2)"}
{"id": "1_16_0047", "name": "mipi_csi_lane_sync_check", "sva": "@(posedge mipi_pclk)     mipi_lp00_to_lp11 && mipi_hs_mode |-> ##6 mipi_lane_sync && $onehot(mipi_byte_align)", "ori_sva": "property mipi_csi_lane_sync_check;\n@(posedge mipi_pclk)     mipi_lp00_to_lp11 && mipi_hs_mode |-> ##6 mipi_lane_sync && $onehot(mipi_byte_align)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mipi_csi_lane_sync_check  \n**Trigger Condition**: At every rising edge of the `mipi_pclk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mipi_lp00_to_lp11 && mipi_hs_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 mipi_lane_sync && $onehot(mipi_byte_align)`  ", "sva_signals": ["mipi_pclk", "mipi_lp00_to_lp11", "mipi_hs_mode", "mipi_lane_sync", "[0:0] mipi_byte_align"], "clock": "mipi_pclk", "attempts_left": 10, "sva_result": "@(posedge mipi_pclk)     (mipi_lp00_to_lp11 && mipi_hs_mode) |-> ##6 (mipi_lane_sync && $onehot(mipi_byte_align))", "sva_name": "mipi_dsi_hs_mode_check", "full_property": "property mipi_csi_lane_sync_check;\n@(posedge mipi_pclk)     (mipi_lp00_to_lp11 && mipi_hs_mode) |-> ##6 (mipi_lane_sync && $onehot(mipi_byte_align));\nendproperty\nassert_mipi_csi_lane_sync_check:assert property (mipi_csi_lane_sync_check) else $error(\"\");", "task_id": "2_4132", "predict_sva": "@(posedge mipi_pclk)     (mipi_lp00_to_lp11 && mipi_hs_mode) |-> ##6 (mipi_lane_sync && $onehot(mipi_byte_align))"}
{"id": "2_28_0063", "name": "usb_reset_check", "sva": "@(posedge clk_usb)      usb_reset |-> ##[5:15] usb_reset_done", "ori_sva": "property usb_reset_check;\n@(posedge clk_usb)      usb_reset |-> ##[5:15] usb_reset_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_reset_check  \n**Trigger Condition**: At every rising edge of the `clk_usb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_reset == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:15] usb_reset_done == 1'b1`  ", "sva_signals": ["clk_usb", "usb_reset", "usb_reset_done"], "clock": "clk_usb", "attempts_left": 10, "sva_result": "@(posedge clk_usb)     usb_reset == 1'b1 |-> ##[5:15] usb_reset_done == 1'b1", "sva_name": "p_usb_reset_completion_check", "full_property": "property usb_reset_check;\n@(posedge clk_usb)     usb_reset == 1'b1 |-> ##[5:15] usb_reset_done == 1'b1;\nendproperty\nassert_usb_reset_check:assert property (usb_reset_check) else $error(\"\");", "task_id": "2_4187", "predict_sva": "@(posedge clk_usb)     usb_reset == 1'b1 |-> ##[5:15] usb_reset_done == 1'b1"}
{"id": "3_29_0122", "name": "ethernet_collision_29", "sva": "@(posedge clk_mac)      tx_start |-> ##[1:2] (tx_done || collision_detected)", "ori_sva": "property ethernet_collision_29;\n@(posedge clk_mac)      tx_start |-> ##[1:2] (tx_done || collision_detected)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ethernet_collision_29  \n**Trigger Condition**: At every rising edge of the `clk_mac`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] (tx_done || collision_detected)`  ", "sva_signals": ["clk_mac", "[0:0] tx_start", "[0:0] tx_done", "[0:0] collision_detected"], "clock": "clk_mac", "attempts_left": 10, "sva_result": "@(posedge clk_mac)     tx_start == 1'b1 |-> ##[1:2] (tx_done || collision_detected)", "sva_name": "ethernet_mac_check_45", "full_property": "property ethernet_collision_29;\n@(posedge clk_mac)     tx_start == 1'b1 |-> ##[1:2] (tx_done || collision_detected);\nendproperty\nassert_ethernet_collision_29:assert property (ethernet_collision_29) else $error(\"\");", "task_id": "2_4234", "predict_sva": "@(posedge clk_mac)     tx_start == 1'b1 |-> ##[1:2] (tx_done || collision_detected)"}
{"id": "3_49_0119", "name": "smartcard_iso_49", "sva": "@(posedge clk_sc)      atr_received |-> ##[20:40] (pps_complete || protocol_error)", "ori_sva": "property smartcard_iso_49;\n@(posedge clk_sc)      atr_received |-> ##[20:40] (pps_complete || protocol_error)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: smartcard_iso_49  \n**Trigger Condition**: At every rising edge of the `clk_sc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atr_received == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[20:40] (pps_complete || protocol_error)`  \n\n", "sva_signals": ["clk_sc", "[0:0] atr_received", "[0:0] pps_complete", "[0:0] protocol_error"], "clock": "clk_sc", "attempts_left": 10, "sva_result": "@(posedge clk_sc)     atr_received == 1'b1 |-> ##[20:40] (pps_complete || protocol_error)", "sva_name": "atr_response_check", "full_property": "property smartcard_iso_49;\n@(posedge clk_sc)     atr_received == 1'b1 |-> ##[20:40] (pps_complete || protocol_error);\nendproperty\nassert_smartcard_iso_49:assert property (smartcard_iso_49) else $error(\"\");", "task_id": "2_4254", "predict_sva": "@(posedge clk_sc)     atr_received == 1'b1 |-> ##[20:40] (pps_complete || protocol_error)"}
{"id": "1_43_0030", "name": "nand_ecc_correction_check", "sva": "@(posedge nand_clk_50mhz)     $rose(nand_ecc_enable) && nand_read_active |-> ##9 nand_ecc_corrected && $stable(nand_ecc_count)", "ori_sva": "property nand_ecc_correction_check;\n@(posedge nand_clk_50mhz)     $rose(nand_ecc_enable) && nand_read_active |-> ##9 nand_ecc_corrected && $stable(nand_ecc_count)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: nand_ecc_correction_check  \n**Trigger Condition**: At every rising edge of `nand_clk_50mhz`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(nand_ecc_enable) && nand_read_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##9 nand_ecc_corrected && $stable(nand_ecc_count)`  ", "sva_signals": ["nand_clk_50mhz", "nand_ecc_enable", "nand_read_active", "nand_ecc_corrected", "nand_ecc_count"], "clock": "nand_clk_50mhz", "attempts_left": 10, "sva_result": "@(posedge nand_clk_50mhz)     ($rose(nand_ecc_enable) && nand_read_active) |-> ##9 (nand_ecc_corrected && $stable(nand_ecc_count))", "sva_name": "nand_ecc_check", "full_property": "property nand_ecc_correction_check;\n@(posedge nand_clk_50mhz)     ($rose(nand_ecc_enable) && nand_read_active) |-> ##9 (nand_ecc_corrected && $stable(nand_ecc_count));\nendproperty\nassert_nand_ecc_correction_check:assert property (nand_ecc_correction_check) else $error(\"\");", "task_id": "2_4156", "predict_sva": "@(posedge nand_clk_50mhz)     ($rose(nand_ecc_enable) && nand_read_active) |-> ##9 (nand_ecc_corrected && $stable(nand_ecc_count))"}
{"id": "1_39_0016", "name": "hdmi_hpd_pulse_check", "sva": "@(posedge hdmi_clk_148mhz)     $rose(hdmi_hpd_pulse) && hdmi_power_on |-> ##5 hdmi_hpd_status && $stable(hdmi_ddc_busy)", "ori_sva": "property hdmi_hpd_pulse_check;\n@(posedge hdmi_clk_148mhz)     $rose(hdmi_hpd_pulse) && hdmi_power_on |-> ##5 hdmi_hpd_status && $stable(hdmi_ddc_busy)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: hdmi_hpd_pulse_check  \n**Trigger Condition**: At every rising edge of `hdmi_clk_148mhz`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(hdmi_hpd_pulse) && hdmi_power_on`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 hdmi_hpd_status && $stable(hdmi_ddc_busy)`  ", "sva_signals": ["hdmi_clk_148mhz", "[0:0] hdmi_hpd_pulse", "[0:0] hdmi_power_on", "[0:0] hdmi_hpd_status", "[0:0] hdmi_ddc_busy"], "clock": "hdmi_clk_148mhz", "attempts_left": 10, "sva_result": "@(posedge hdmi_clk_148mhz)     ($rose(hdmi_hpd_pulse) && hdmi_power_on) |-> ##5 (hdmi_hpd_status && $stable(hdmi_ddc_busy))", "sva_name": "hdmi_hpd_detection", "full_property": "property hdmi_hpd_pulse_check;\n@(posedge hdmi_clk_148mhz)     ($rose(hdmi_hpd_pulse) && hdmi_power_on) |-> ##5 (hdmi_hpd_status && $stable(hdmi_ddc_busy));\nendproperty\nassert_hdmi_hpd_pulse_check:assert property (hdmi_hpd_pulse_check) else $error(\"\");", "task_id": "2_4152", "predict_sva": "@(posedge hdmi_clk_148mhz)     ($rose(hdmi_hpd_pulse) && hdmi_power_on) |-> ##5 (hdmi_hpd_status && $stable(hdmi_ddc_busy))"}
{"id": "1_33_0038", "name": "i2s_fifo_full_check", "sva": "@(posedge i2s_clk)     $rose(i2s_fifo_wr_en) && !i2s_fifo_full |-> ##2 i2s_fifo_almost_full && $stable(i2s_sample_data)", "ori_sva": "property i2s_fifo_full_check;\n@(posedge i2s_clk)     $rose(i2s_fifo_wr_en) && !i2s_fifo_full |-> ##2 i2s_fifo_almost_full && $stable(i2s_sample_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: i2s_fifo_full_check  \n**Trigger Condition**: At every rising edge of the `i2s_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(i2s_fifo_wr_en) && !i2s_fifo_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 i2s_fifo_almost_full && $stable(i2s_sample_data)`  ", "sva_signals": ["i2s_clk", "i2s_fifo_wr_en", "i2s_fifo_full", "i2s_fifo_almost_full", "[0:0] i2s_sample_data"], "clock": "i2s_clk", "attempts_left": 10, "sva_result": "@(posedge i2s_clk)     ($rose(i2s_fifo_wr_en) && !i2s_fifo_full) |-> ##2 (i2s_fifo_almost_full && $stable(i2s_sample_data))", "sva_name": "p_i2s_fifo_almost_full_check", "full_property": "property i2s_fifo_full_check;\n@(posedge i2s_clk)     ($rose(i2s_fifo_wr_en) && !i2s_fifo_full) |-> ##2 (i2s_fifo_almost_full && $stable(i2s_sample_data));\nendproperty\nassert_i2s_fifo_full_check:assert property (i2s_fifo_full_check) else $error(\"\");", "task_id": "2_4148", "predict_sva": "@(posedge i2s_clk)         ($rose(i2s_fifo_wr_en) && !i2s_fifo_full) |-> ##2 (i2s_fifo_almost_full && $stable(i2s_sample_data))"}
{"id": "2_15_0011", "name": "adc_conversion_check", "sva": "@(posedge clk_adc)      adc_start |-> ##[3:9] adc_done", "ori_sva": "property adc_conversion_check;\n@(posedge clk_adc)      adc_start |-> ##[3:9] adc_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: adc_conversion_check  \n**Trigger Condition**: At every rising edge of `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `adc_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:9] adc_done == 1'b1`  ", "sva_signals": ["clk_adc", "[0:0] adc_start", "[0:0] adc_done"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     adc_start == 1'b1 |-> ##[3:9] adc_done == 1'b1", "sva_name": "adc_sample_check_40", "full_property": "property adc_conversion_check;\n@(posedge clk_adc)     adc_start == 1'b1 |-> ##[3:9] adc_done == 1'b1;\nendproperty\nassert_adc_conversion_check:assert property (adc_conversion_check) else $error(\"\");", "task_id": "2_4172", "predict_sva": "@(posedge clk_adc)     adc_start == 1'b1 |-> ##[3:9] adc_done"}
{"id": "1_6_0037", "name": "i2c_start_stop_check", "sva": "@(posedge i2c_scl)     $fell(i2c_sda) && i2c_scl_high |-> ##2 i2c_start_detected ##1 !i2c_stop_detected", "ori_sva": "property i2c_start_stop_check;\n@(posedge i2c_scl)     $fell(i2c_sda) && i2c_scl_high |-> ##2 i2c_start_detected ##1 !i2c_stop_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: i2c_start_stop_check  \n**Trigger Condition**: At every rising edge of `i2c_scl`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(i2c_sda) && i2c_scl_high`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 i2c_start_detected ##1 !i2c_stop_detected`  ", "sva_signals": ["i2c_scl", "i2c_sda", "i2c_scl_high", "[0:0] i2c_start_detected", "[0:0] i2c_stop_detected"], "clock": "i2c_scl", "attempts_left": 10, "sva_result": "@(posedge i2c_scl)     ($fell(i2c_sda) && i2c_scl_high) |-> ##2 i2c_start_detected ##1 !i2c_stop_detected", "sva_name": "p_p_i2c_start_condition_check", "full_property": "property i2c_start_stop_check;\n@(posedge i2c_scl)     ($fell(i2c_sda) && i2c_scl_high) |-> ##2 i2c_start_detected ##1 !i2c_stop_detected;\nendproperty\nassert_i2c_start_stop_check:assert property (i2c_start_stop_check) else $error(\"\");", "task_id": "2_4165", "predict_sva": "@(posedge i2c_scl)     ($fell(i2c_sda) && i2c_scl_high) |-> ##2 i2c_start_detected ##1 !i2c_stop_detected"}
{"id": "3_50_0124", "name": "zigbee_ack_50", "sva": "@(posedge clk_zigbee)      tx_complete |-> ##[2:5] (ack_received || csma_fail)", "ori_sva": "property zigbee_ack_50;\n@(posedge clk_zigbee)      tx_complete |-> ##[2:5] (ack_received || csma_fail)\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: zigbee_ack_50  \n**Trigger Condition**: At every rising edge of the `clk_zigbee`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 2 to 5 clock cycles after the antecedent is true, either `ack_received` or `csma_fail` must be asserted (`ack_received || csma_fail`)", "sva_signals": ["clk_zigbee", "[0:0] tx_complete", "[0:0] ack_received", "[0:0] csma_fail"], "clock": "clk_zigbee", "attempts_left": 10, "sva_result": "@(posedge clk_zigbee)     tx_complete == 1'b1 |-> ##[2:5] (ack_received || csma_fail)", "sva_name": "zigbee_csma_check_46", "full_property": "property zigbee_ack_50;\n@(posedge clk_zigbee)     tx_complete == 1'b1 |-> ##[2:5] (ack_received || csma_fail);\nendproperty\nassert_zigbee_ack_50:assert property (zigbee_ack_50) else $error(\"\");", "task_id": "2_4255", "predict_sva": "@(posedge clk_zigbee)     tx_complete == 1'b1 |-> ##[2:5] (ack_received || csma_fail)"}
{"id": "10_23_0464", "name": "p_i2c_start_condition", "sva": "@(posedge i2c_clk)     $fell(sda_line) && scl_high |-> ##1 ($past(sda_line,2) == 1'b1) ##0 start_detected", "ori_sva": "property p_i2c_start_condition;\n@(posedge i2c_clk)     $fell(sda_line) && scl_high |-> ##1 ($past(sda_line,2) == 1'b1) ##0 start_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_i2c_start_condition  \n**Trigger Condition**: At every rising edge of `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(sda_line) && scl_high`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 ($past(sda_line, 2) == 1'b1) ##0 start_detected`  ", "sva_signals": ["i2c_clk", "sda_line", "scl_high", "start_detected"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     ($fell(sda_line) && scl_high) |-> ##1 ($past(sda_line, 2) == 1'b1) ##0 start_detected", "sva_name": "p_i2c_start_condition_check", "full_property": "property p_i2c_start_condition;\n@(posedge i2c_clk)     ($fell(sda_line) && scl_high) |-> ##1 ($past(sda_line, 2) == 1'b1) ##0 start_detected;\nendproperty\nassert_p_i2c_start_condition:assert property (p_i2c_start_condition) else $error(\"\");", "task_id": "2_3404", "predict_sva": "@(posedge i2c_clk)    ($fell(sda_line) && scl_high) |-> ##1 ($past(sda_line, 2) == 1'b1) ##0 start_detected"}
{"id": "6_42_0272", "name": "memory_ecc_check", "sva": "@(posedge clk_ecc)      mem_read[*4:8] |-> ##[2:3] ecc_status[*1:2]", "ori_sva": "property memory_ecc_check;\n@(posedge clk_ecc)      mem_read[*4:8] |-> ##[2:3] ecc_status[*1:2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: memory_ecc_check  \n**Trigger Condition**: At every rising edge of `clk_ecc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_read` is continuously true for 4 to 8 clock cycles (`mem_read[*4:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After a delay of 2 to 3 clock cycles (`##[2:3]`), `ecc_status` is continuously true for 1 to 2 clock cycles (`ecc_status[*1:2]`)", "sva_signals": ["clk_ecc", "[0:0] mem_read", "[0:0] ecc_status"], "clock": "clk_ecc", "attempts_left": 10, "sva_result": "@(posedge clk_ecc)     mem_read[*4:8] |-> ##[2:3] ecc_status[*1:2]", "sva_name": "mem_read_ecc_check_p6", "full_property": "property memory_ecc_check;\n@(posedge clk_ecc)     mem_read[*4:8] |-> ##[2:3] ecc_status[*1:2];\nendproperty\nassert_memory_ecc_check:assert property (memory_ecc_check) else $error(\"\");", "task_id": "2_3844", "predict_sva": "@(posedge clk_ecc)     mem_read[*4:8] |-> ##[2:3] ecc_status[*1:2]"}
{"id": "150_6_1147", "name": "pipeline_stall_prop", "sva": "@(posedge core_clk)     disable iff(scan_enable)     pipeline_stall |=> ##1 !data_forward_en", "ori_sva": "property pipeline_stall_prop;\n@(posedge core_clk)     disable iff(scan_enable)     pipeline_stall |=> ##1 !data_forward_en;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Pipeline_Stall_No_Forward  \n**Trigger Condition**: At every rising edge of the `core_clk`  \n**Disable Condition**: disable iff (scan_enable)  \n**Antecedent (LHS of Implication)**: `pipeline_stall`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##1 !data_forward_en`  \n\n### Explanation:\n1. The property checks that whenever there is a pipeline stall (`pipeline_stall` is true), in the next clock cycle (`##1`), the data forwarding should be disabled (`!data_forward_en`).  \n2. The check is performed at every rising edge of `core_clk`.  \n3. The assertion is disabled when `scan_enable` is active.  \n4. The `|=>` operator is used, which means the consequent is evaluated in the next clock cycle after the antecedent is true.", "sva_signals": ["core_clk", "scan_enable", "[0:0] pipeline_stall", "[0:0] data_forward_en"], "clock": "core_clk", "attempts_left": 10, "sva_result": "@(posedge core_clk) disable iff (scan_enable)    pipeline_stall |=> ##1 !data_forward_en", "sva_name": "p_pipeline_stall_no_forward", "full_property": "property p_Pipeline_Stall_No_Forward;\n@(posedge core_clk) disable iff (scan_enable)    pipeline_stall |=> ##1 !data_forward_en\nendproperty\nassert_p_Pipeline_Stall_No_Forward:assert property (p_Pipeline_Stall_No_Forward) else $error(\"\");", "task_id": "3_151", "predict_sva": "@(posedge core_clk) disable iff (scan_enable)     pipeline_stall |-> ##1 !data_forward_en"}
{"id": "2_15_0020", "name": "bus_arbitration_check_15", "sva": "@(posedge clk_bus)      bus_request |-> ##[1:8] bus_grant || bus_timeout", "ori_sva": "property bus_arbitration_check_15;\n@(posedge clk_bus)      bus_request |-> ##[1:8] bus_grant || bus_timeout\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bus_arbitration_check_15  \n**Trigger Condition**: At every rising edge of `clk_bus`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bus_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] bus_grant || bus_timeout`  ", "sva_signals": ["clk_bus", "rst_n", "[0:0] bus_request", "[0:0] bus_grant", "[0:0] bus_timeout"], "clock": "clk_bus", "attempts_left": 10, "sva_result": "@(posedge clk_bus)         bus_request == 1'b1 |-> ##[1:8] (bus_grant || bus_timeout)", "sva_name": "p_bus_request_grant_check", "full_property": "property bus_arbitration_check_15;\n@(posedge clk_bus)         bus_request == 1'b1 |-> ##[1:8] (bus_grant || bus_timeout);\nendproperty\nassert_bus_arbitration_check_15:assert property (bus_arbitration_check_15) else $error(\"\");", "task_id": "2_3652", "predict_sva": "@(posedge clk_bus)    bus_request == 1'b1 |-> ##[1:8] (bus_grant || bus_timeout)"}
{"id": "1_48_0024", "name": "video_frame_buffer_check", "sva": "@(posedge video_clk_74mhz)     $rose(video_frame_start) && video_vsync_active |-> ##1024 video_frame_end && $stable(video_line_count)", "ori_sva": "property video_frame_buffer_check;\n@(posedge video_clk_74mhz)     $rose(video_frame_start) && video_vsync_active |-> ##1024 video_frame_end && $stable(video_line_count)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: video_frame_buffer_check  \n**Trigger Condition**: At every rising edge of the `video_clk_74mhz`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(video_frame_start) && video_vsync_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1024 video_frame_end && $stable(video_line_count)`  ", "sva_signals": ["video_clk_74mhz", "[0:0] video_frame_start", "[0:0] video_vsync_active", "[0:0] video_frame_end", "[0:0] video_line_count"], "clock": "video_clk_74mhz", "attempts_left": 10, "sva_result": "@(posedge video_clk_74mhz)     ($rose(video_frame_start) && video_vsync_active) |-> ##1024 (video_frame_end && $stable(video_line_count))", "sva_name": "p_video_frame_sync_check", "full_property": "property video_frame_buffer_check;\n@(posedge video_clk_74mhz)     ($rose(video_frame_start) && video_vsync_active) |-> ##1024 (video_frame_end && $stable(video_line_count));\nendproperty\nassert_video_frame_buffer_check:assert property (video_frame_buffer_check) else $error(\"\");", "task_id": "2_4298", "predict_sva": "@(posedge video_clk_74mhz)     ($rose(video_frame_start) && video_vsync_active) |-> ##1024 (video_frame_end && $stable(video_line_count))"}
{"id": "222_3_1845", "name": "ack_within_cycles", "sva": "@(posedge clk)     $fell(req_) |=> ##[1:8] ack_", "ori_sva": "property ack_within_cycles;\n@(posedge clk)     $fell(req_) |=> ##[1:8] ack_;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_req_ack  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(req_)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:8] ack_`  \n\n**Explanation**:  \n- The property checks that whenever there is a falling edge on `req_` (detected at the rising edge of `clk`), then **in the next clock cycle**, the `ack_` signal must be asserted within **1 to 8 clock cycles** thereafter.  \n- The `|=>` operator ensures the consequent is evaluated starting **one clock cycle after** the antecedent is true.  \n- The `##[1:8]` denotes a **time window** of 1 to 8 cycles for `ack_` to be asserted after the initial delay.", "sva_signals": ["clk", "rst_n", "[0:0] req_", "[0:0] ack_"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $fell(req_) |=> ##[1:8] ack_", "sva_name": "p_req_fall_to_ack", "full_property": "property p_fell_req_ack;\n@(posedge clk)        $fell(req_) |=> ##[1:8] ack_\nendproperty\nassert_p_fell_req_ack:assert property (p_fell_req_ack) else $error(\"\");", "task_id": "3_695", "predict_sva": "@(posedge clk)     $fell(req_) |-> ##[1:8] ack_"}
{"id": "179_5_1429", "name": "dma_req_until_ack", "sva": "@(posedge clk)     dma_req_i |-> dma_req_i throughout dma_ack_o[->1]", "ori_sva": "property dma_req_until_ack;\n@(posedge clk)     dma_req_i |-> dma_req_i throughout dma_ack_o[->1];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_req_ack  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_req_i == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dma_req_i throughout dma_ack_o[->1]`  \n\n**Explanation of Consequent**:  \nThe consequent uses the `throughout` operator combined with a goto repetition (`[->1]`). This means:  \n- `dma_req_i` must remain **continuously true** (`throughout`)  \n- Until the first occurrence (`[->1]`) of `dma_ack_o` being asserted (i.e., `dma_ack_o == 1'b1`).  \n\nIn natural language: *\"Whenever `dma_req_i` is high at a clock edge, it must stay high until (and including) the cycle where `dma_ack_o` is first asserted.\"*", "sva_signals": ["clk", "rst_n", "[0:0] dma_req_i", "[0:0] dma_ack_o"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        dma_req_i == 1'b1 |-> dma_req_i throughout dma_ack_o[->1]", "sva_name": "p_dma_req_until_ack", "full_property": "property p_dma_req_ack;\n@(posedge clk)        dma_req_i == 1'b1 |-> dma_req_i throughout dma_ack_o[->1]\nendproperty\nassert_p_dma_req_ack:assert property (p_dma_req_ack) else $error(\"\");", "task_id": "3_378", "predict_sva": "@(posedge clk)        dma_req_i == 1'b1 |-> dma_req_i until_with dma_ack_o == 1'b1"}
{"id": "3_45_0091", "name": "p_non_overlap_15", "sva": "@(posedge clk)     (encrypt_start && key_loaded) |=> ##12 encrypt_done", "ori_sva": "property p_non_overlap_15;\n@(posedge clk)     (encrypt_start && key_loaded) |=> ##12 encrypt_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encrypt_done_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encrypt_start && key_loaded`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##12 encrypt_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] encrypt_start", "[0:0] key_loaded", "[0:0] encrypt_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (encrypt_start && key_loaded) |=> ##12 encrypt_done", "sva_name": "p_encrypt_done_after_start", "full_property": "property p_encrypt_done_after_start;\n@(posedge clk)     (encrypt_start && key_loaded) |=> ##12 encrypt_done;\nendproperty\nassert_p_encrypt_done_after_start:assert property (p_encrypt_done_after_start) else $error(\"\");", "task_id": "3_1581", "predict_sva": "@(posedge clk)         (encrypt_start && key_loaded) |-> ##12 encrypt_done"}
{"id": "118_10_0888", "name": "period_jitter_ratio_check", "sva": "@(posedge clk_signal)     $changed(period) |-> ##1 (jitter_peak_to_peak < ($past(period)>>4))", "ori_sva": "property period_jitter_ratio_check;\n@(posedge clk_signal)     $changed(period) |-> ##1 (jitter_peak_to_peak < ($past(period)>>4));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Jitter_Check  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(period)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (jitter_peak_to_peak < ($past(period)>>4))`  \n\n### Explanation:  \n- The property checks that whenever the `period` signal changes (`$changed(period)`), then in the next clock cycle (`##1`), the `jitter_peak_to_peak` must be less than one-sixteenth (`>>4`) of the previous value of `period` (`$past(period)`).  \n- The assertion is evaluated on every rising edge of `clk_signal` and has no disable condition.  \n- The implication ensures that the consequent is checked only when the antecedent (`$changed(period)`) is true.", "sva_signals": ["clk_signal", "[0:0] period", "[0:0] jitter_peak_to_peak"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $changed(period) |-> ##1 (jitter_peak_to_peak < ($past(period)>>4))", "sva_name": "p_Jitter_Check_After_Period_Change", "full_property": "property p_Jitter_Check;\n@(posedge clk_signal)    $changed(period) |-> ##1 (jitter_peak_to_peak < ($past(period)>>4))\nendproperty\nassert_p_Jitter_Check:assert property (p_Jitter_Check) else $error(\"\");", "task_id": "3_53", "predict_sva": "@(posedge clk_signal)    $changed(period) |-> ##1 (jitter_peak_to_peak < ($past(period)>>4))"}
{"id": "187_1_1508", "name": "fifo_full_check", "sva": "@(posedge clk)     (wr_ptr == rd_ptr + depth_minus_1) |-> !(wr_en && !rd_en)", "ori_sva": "property fifo_full_check;\n@(posedge clk)     (wr_ptr == rd_ptr + depth_minus_1) |-> !(wr_en && !rd_en);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_WrPtrRdPtrCheck  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(wr_ptr == rd_ptr + depth_minus_1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(wr_en && !rd_en)`  \n\n### Explanation:  \nThe property checks that whenever the write pointer (`wr_ptr`) equals the read pointer (`rd_ptr`) plus `depth_minus_1` (indicating the FIFO is almost full), it implies that the condition `wr_en && !rd_en` must **not** be true. This ensures that no write operation is allowed without a corresponding read operation when the FIFO is nearly full, preventing overflow.", "sva_signals": ["clk", "rst_n", "[0:0] wr_en", "[0:0] rd_en", "[0:0] depth_minus_1", "[0:0] wr_ptr", "[0:0] rd_ptr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    (wr_ptr == (rd_ptr + depth_minus_1)) |-> !(wr_en && !rd_en)", "sva_name": "p_FifoFullCheck", "full_property": "property p_WrPtrRdPtrCheck;\n@(posedge clk)    (wr_ptr == (rd_ptr + depth_minus_1)) |-> !(wr_en && !rd_en)\nendproperty\nassert_p_WrPtrRdPtrCheck:assert property (p_WrPtrRdPtrCheck) else $error(\"\");", "task_id": "3_446", "predict_sva": "@(posedge clk)        (wr_ptr == (rd_ptr + depth_minus_1)) |-> !(wr_en && !rd_en)"}
{"id": "3_52_0121", "name": "p_non_overlap_22", "sva": "@(posedge clk)     (dram_refresh && !low_power_mode) |=> ##15 refresh_complete", "ori_sva": "property p_non_overlap_22;\n@(posedge clk)     (dram_refresh && !low_power_mode) |=> ##15 refresh_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Refresh_Complete_After_Trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dram_refresh && !low_power_mode`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##15 refresh_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] dram_refresh", "[0:0] low_power_mode", "[0:0] refresh_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (dram_refresh && !low_power_mode) |=> ##15 refresh_complete", "sva_name": "p_Refresh_Completion", "full_property": "property p_Refresh_Complete_After_Trigger;\n@(posedge clk)         (dram_refresh && !low_power_mode) |=> ##15 refresh_complete;\nendproperty\nassert_p_Refresh_Complete_After_Trigger:assert property (p_Refresh_Complete_After_Trigger) else $error(\"\");", "task_id": "3_1589", "predict_sva": "@(posedge clk)         (dram_refresh && !low_power_mode) |-> ##15 refresh_complete"}
{"id": "190_5_1551", "name": "lo_pri_req_persistence", "sva": "@(posedge clk_arb)     lo_pri_req |-> lo_pri_req until lo_pri_grant", "ori_sva": "property lo_pri_req_persistence;\n@(posedge clk_arb)     lo_pri_req |-> lo_pri_req until lo_pri_grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_lo_pri_req_grant  \n**Trigger Condition**: At every rising edge of the `clk_arb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lo_pri_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `lo_pri_req until lo_pri_grant`  \n\n**Explanation of Consequent**:  \nThe `until` operator ensures that `lo_pri_req` remains asserted continuously (from the current clock cycle) until `lo_pri_grant` is asserted. Once `lo_pri_grant` is asserted, the property check completes successfully. If `lo_pri_req` deasserts before `lo_pri_grant` is asserted, the property will fail.  \n\n**Note**: The `until` operator here is a strong variant (default in SVA), meaning the sequence must eventually satisfy `lo_pri_grant` within the simulation bounds.", "sva_signals": ["clk_arb", "lo_pri_req", "lo_pri_grant"], "clock": "clk_arb", "attempts_left": 10, "sva_result": "@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req until lo_pri_grant", "sva_name": "p_lo_pri_req_until_grant", "full_property": "property p_lo_pri_req_grant;\n@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req until lo_pri_grant\nendproperty\nassert_p_lo_pri_req_grant:assert property (p_lo_pri_req_grant) else $error(\"\");", "task_id": "3_470", "predict_sva": "@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req until lo_pri_grant"}
{"id": "4_4_0048", "name": "p_wr_attempt_while_full", "sva": "@(posedge clk) disable iff (!rst_n)     fifo_full && wr_en |-> $past(!wr_en, 1)", "ori_sva": "property p_wr_attempt_while_full;\n\n    @(posedge clk) disable iff (!rst_n)\n    fifo_full && wr_en |-> $past(!wr_en, 1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_full_wr_en  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `fifo_full && wr_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(!wr_en, 1)`  \n\n### Explanation:  \n- The property checks that when `fifo_full` is high and `wr_en` is asserted (`fifo_full && wr_en`), the write enable signal (`wr_en`) must have been deasserted (`!wr_en`) in the previous clock cycle (`$past(!wr_en, 1)`).  \n- The assertion is disabled if the reset signal `rst_n` is low (`!rst_n`).  \n- The check occurs at every rising edge of `clk`.", "sva_signals": ["clk", "rst_n", "[0:0] fifo_full", "[0:0] wr_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)    (fifo_full && wr_en) |-> $past(!wr_en, 1)", "sva_name": "p_fifo_full_wr_en_check", "full_property": "property p_fifo_full_wr_en;\n@(posedge clk) disable iff (!rst_n)    (fifo_full && wr_en) |-> $past(!wr_en, 1)\nendproperty\nassert_p_fifo_full_wr_en:assert property (p_fifo_full_wr_en) else $error(\"\");", "task_id": "3_1241", "predict_sva": "@(posedge clk) disable iff (!rst_n)         fifo_full && wr_en |-> $past(!wr_en, 1)"}
{"id": "217_4_1799", "name": "interrupt_ack_sequence", "sva": "@(posedge clk)     $rose(irq_req) |-> ##[1:3] $rose(irq_ack)", "ori_sva": "property interrupt_ack_sequence;\n@(posedge clk)     $rose(irq_req) |-> ##[1:3] $rose(irq_ack);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_irq_ack_after_req  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(irq_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $rose(irq_ack)`  \n\n**Explanation**:  \nThis assertion checks that whenever there is a rising edge on the `irq_req` signal (indicating an interrupt request), then within 1 to 3 clock cycles, there must be a rising edge on the `irq_ack` signal (indicating the interrupt acknowledgment). The check is performed at every positive edge of the clock `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] irq_req", "[0:0] irq_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $rose(irq_req) |-> ##[1:3] $rose(irq_ack)", "sva_name": "p_irq_ack_after_req", "full_property": "property p_irq_ack_after_req;\n@(posedge clk)        $rose(irq_req) |-> ##[1:3] $rose(irq_ack)\nendproperty\nassert_p_irq_ack_after_req:assert property (p_irq_ack_after_req) else $error(\"\");", "task_id": "3_657", "predict_sva": "@(posedge clk)        $rose(irq_req) |-> ##[1:3] $rose(irq_ack)"}
{"id": "143_9_1073", "name": "readout_time_non_zero", "sva": "@(posedge clk_sys)     (pulse[->5] |-> $past(readout_time) > 0)", "ori_sva": "property readout_time_non_zero;\n@(posedge clk_sys)     (pulse[->5] |-> $past(readout_time) > 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pulse_Readout_Time_Check  \n**Trigger Condition**: At every posedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pulse[->5]` (fifth occurrence of `pulse` signal)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(readout_time) > 0` (value of `readout_time` at the previous clock cycle must be greater than 0)  \n\n### Explanation:  \nThe assertion checks that whenever the fifth occurrence of the `pulse` signal is detected (using the **goto repetition operator** `[->5]`), the value of `readout_time` from the **previous clock cycle** (`$past(readout_time)`) must be greater than 0. The check is performed on every rising edge of `clk_sys` and has no disable condition.", "sva_signals": ["clk_sys", "[0:0] pulse", "[0:0] readout_time"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)        pulse[->5] |-> $past(readout_time) > 0", "sva_name": "p_Pulse_Readout_Time_Check", "full_property": "property p_Pulse_Readout_Time_Check;\n@(posedge clk_sys)        pulse[->5] |-> $past(readout_time) > 0\nendproperty\nassert_p_Pulse_Readout_Time_Check:assert property (p_Pulse_Readout_Time_Check) else $error(\"\");", "task_id": "3_126", "predict_sva": "@(posedge clk_sys)    pulse[->5] |-> $past(readout_time) > 0"}
{"id": "3_32_0085", "name": "p_non_overlap_2", "sva": "@(posedge clk)     start_transaction |=> ##1 data_valid", "ori_sva": "property p_non_overlap_2;\n@(posedge clk)     start_transaction |=> ##1 data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_start_transaction_data_valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start_transaction == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##1 data_valid == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent should hold true starting from the next clock cycle after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] start_transaction", "[0:0] data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         start_transaction == 1'b1 |=> ##1 data_valid == 1'b1", "sva_name": "p_Start_Transaction_Data_Valid", "full_property": "property p_start_transaction_data_valid;\n@(posedge clk)         start_transaction == 1'b1 |=> ##1 data_valid == 1'b1;\nendproperty\nassert_p_start_transaction_data_valid:assert property (p_start_transaction_data_valid) else $error(\"\");", "task_id": "3_1570", "predict_sva": "@(posedge clk)         start_transaction == 1'b1 |-> ##1 data_valid == 1'b1"}
{"id": "218_9_1818", "name": "reset_propagation", "sva": "@(posedge clk_sys)      sys_reset |=> ##1 $fell(module_active)[*3]", "ori_sva": "property reset_propagation;\n@(posedge clk_sys)      sys_reset |=> ##1 $fell(module_active)[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_module_active_fell_after_reset  \n**Trigger Condition**: At every posedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sys_reset`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##1 $fell(module_active)[*3]`  \n\n### Explanation:  \n- The property checks that **after `sys_reset` is asserted**, the signal `module_active` must **fall (transition from 1 to 0)** **three consecutive times** starting **one clock cycle later**.  \n- `|=>` ensures the consequent is evaluated **one clock cycle after** the antecedent (`sys_reset`) is true.  \n- `$fell(module_active)[*3]` means the falling edge of `module_active` must occur **three times in succession** after the delay (`##1`).  \n\n### Key Notes:  \n1. **Non-overlapping Implication (`|=>`)**: The check for `$fell(module_active)` begins **on the next clock cycle** after `sys_reset`.  \n2. **Temporal Sequence (`[*3]`)**: The falling edge must repeat **three times** (e.g., on three consecutive clock edges).  \n3. **No Disable Condition**: The assertion is always active unless overridden by a global disable.  \n\nThis ensures the design correctly handles the deactivation sequence of `module_active` after a system reset.", "sva_signals": ["clk_sys", "sys_reset", "[0:0] module_active"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)        sys_reset |=> ##1 $fell(module_active)[*3]", "sva_name": "p_module_active_fall_after_reset", "full_property": "property p_module_active_fell_after_reset;\n@(posedge clk_sys)        sys_reset |=> ##1 $fell(module_active)[*3]\nendproperty\nassert_p_module_active_fell_after_reset:assert property (p_module_active_fell_after_reset) else $error(\"\");", "task_id": "3_667", "predict_sva": "@(posedge clk_sys)    sys_reset |=> $fell(module_active)[*3]"}
{"id": "26_2_0199", "name": "rvalid_unknown_implies_rready_low", "sva": "@(posedge clk) disable iff (!rst_n)     $isunknown(rvalid) |-> !rready", "ori_sva": "property rvalid_unknown_implies_rready_low;\n\n    @(posedge clk) disable iff (!rst_n)\n    $isunknown(rvalid) |-> !rready;\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_unknown_rvalid_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$isunknown(rvalid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!rready`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks behavior when `rvalid` is unknown (X or Z).  \n2. **Trigger**: Evaluated at every positive clock edge (`posedge clk`).  \n3. **Disable Condition**: Assertion is disabled if `rst_n` is low (asynchronous reset).  \n4. **Antecedent**: The condition `$isunknown(rvalid)` is true if `rvalid` has an unknown value (X/Z).  \n5. **Consequent**: When the antecedent holds, `rready` must be low (`!rready`) in the same cycle (no delay specified).  \n\nThis assertion ensures that the downstream logic (via `rready`) is not allowed to proceed when `rvalid` is in an unknown state.", "sva_signals": ["clk", "rst_n", "[0:0] rvalid", "[0:0] rready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)    $isunknown(rvalid) |-> !rready", "sva_name": "p_unknown_rvalid_check", "full_property": "property p_unknown_rvalid_check;\n@(posedge clk) disable iff (!rst_n)    $isunknown(rvalid) |-> !rready\nendproperty\nassert_p_unknown_rvalid_check:assert property (p_unknown_rvalid_check) else $error(\"\");", "task_id": "3_982", "predict_sva": "@(posedge clk) disable iff (!rst_n)    $isunknown(rvalid) |-> !rready"}
{"id": "3_39_0093", "name": "p_non_overlap_9", "sva": "@(posedge clk)     (cache_miss && cache_enable) |=> ##10 cache_fill_done", "ori_sva": "property p_non_overlap_9;\n@(posedge clk)     (cache_miss && cache_enable) |=> ##10 cache_fill_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_fill_after_miss  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_miss && cache_enable`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##10 cache_fill_done`  \n\n(Note: The `|=>` operator indicates that the consequent should be evaluated starting from the next clock cycle after the antecedent is true, and `##10` means the consequent is expected to hold 10 clock cycles after that.)", "sva_signals": ["clk", "rst_n", "[0:0] cache_miss", "[0:0] cache_enable", "[0:0] cache_fill_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (cache_miss && cache_enable) |=> ##10 cache_fill_done", "sva_name": "p_cache_fill_after_miss", "full_property": "property p_cache_fill_after_miss;\n@(posedge clk)         (cache_miss && cache_enable) |=> ##10 cache_fill_done;\nendproperty\nassert_p_cache_fill_after_miss:assert property (p_cache_fill_after_miss) else $error(\"\");", "task_id": "3_1576", "predict_sva": "@(posedge clk)         (cache_miss && cache_enable) |-> ##10 cache_fill_done"}
{"id": "3_44_0102", "name": "p_non_overlap_14", "sva": "@(posedge clk)     (write_back && dirty_bit) |=> ##7 write_back_complete", "ori_sva": "property p_non_overlap_14;\n@(posedge clk)     (write_back && dirty_bit) |=> ##7 write_back_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Write_Back_Complete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_back && dirty_bit`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##7 write_back_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] write_back", "[0:0] dirty_bit", "[0:0] write_back_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (write_back && dirty_bit) |=> ##7 write_back_complete", "sva_name": "p_write_back_complete", "full_property": "property p_Write_Back_Complete;\n@(posedge clk)         (write_back && dirty_bit) |=> ##7 write_back_complete;\nendproperty\nassert_p_Write_Back_Complete:assert property (p_Write_Back_Complete) else $error(\"\");", "task_id": "3_1580", "predict_sva": "@(posedge clk)         (write_back && dirty_bit) |-> ##7 write_back_complete"}
{"id": "204_3_1681", "name": "fifo_overflow_prot", "sva": "@(posedge clk)     $rose(fifo_full) |->      ##1 !fifo_write_en until $fell(fifo_full)", "ori_sva": "property fifo_overflow_prot;\n@(posedge clk)     $rose(fifo_full) |->      ##1 !fifo_write_en until $fell(fifo_full);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Write_Disable_When_Full  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(fifo_full)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !fifo_write_en until $fell(fifo_full)`  \n\n### Explanation:  \n- The property checks that when `fifo_full` transitions from low to high (`$rose(fifo_full)`), the following must hold:  \n  - After 1 clock cycle (`##1`), `fifo_write_en` must remain low (`!fifo_write_en`) **until** `fifo_full` transitions from high to low (`$fell(fifo_full)`).  \n- This ensures that no further writes are allowed (`fifo_write_en` is deasserted) while the FIFO is full, and writes can only resume after the FIFO is no longer full.", "sva_signals": ["clk", "rst_n", "[0:0] fifo_full", "[0:0] fifo_write_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $rose(fifo_full) |-> ##1 (!fifo_write_en) until $fell(fifo_full)", "sva_name": "p_fifo_full_write_en", "full_property": "property p_Fifo_Write_Disable_When_Full;\n@(posedge clk)        $rose(fifo_full) |-> ##1 (!fifo_write_en) until $fell(fifo_full)\nendproperty\nassert_p_Fifo_Write_Disable_When_Full:assert property (p_Fifo_Write_Disable_When_Full) else $error(\"\");", "task_id": "3_563", "predict_sva": "@(posedge clk)    $rose(fifo_full) |-> ##1 (!fifo_write_en) until $fell(fifo_full)"}
{"id": "25_2_0184", "name": "wvalid_change_requires_awvalid", "sva": "@(posedge clk) $changed(wvalid) |-> $past(awvalid)", "ori_sva": "property wvalid_change_requires_awvalid;\n\n    @(posedge clk) $changed(wvalid) |-> $past(awvalid);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wvalid_change_implies_past_awvalid  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(wvalid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(awvalid)`  \n\n**Explanation**:  \nThe property checks that whenever there is a change in the value of `wvalid` (detected by `$changed(wvalid)`), the value of `awvalid` from the previous clock cycle (`$past(awvalid)`) must hold true. The assertion is evaluated at every rising edge of `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] wvalid", "[0:0] awvalid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $changed(wvalid) |-> $past(awvalid)", "sva_name": "p_wvalid_change_awvalid_past", "full_property": "property p_wvalid_change_implies_past_awvalid;\n@(posedge clk)        $changed(wvalid) |-> $past(awvalid)\nendproperty\nassert_p_wvalid_change_implies_past_awvalid:assert property (p_wvalid_change_implies_past_awvalid) else $error(\"\");", "task_id": "3_944", "predict_sva": "@(posedge clk)        wvalid != $past(wvalid) |-> $past(awvalid)"}
{"id": "243_5_2092", "name": "mask_en_hold_after_req", "sva": "@(posedge clk)     $rose(int_req) && mask_en |=> mask_en throughout ##1 $rose(masked_status)", "ori_sva": "property mask_en_hold_after_req;\n@(posedge clk)     $rose(int_req) && mask_en |=> mask_en throughout ##1 $rose(masked_status);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Mask_Status_After_Request  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(int_req) && mask_en`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `mask_en throughout ##1 $rose(masked_status)`  \n\n### Explanation:  \n1. **Property Name**: Custom name indicating the check for masked status assertion after an interrupt request.  \n2. **Trigger Condition**: Evaluated at every rising edge of `clk`.  \n3. **Antecedent**: The property triggers when `int_req` rises (`$rose(int_req)`) and `mask_en` is active (`mask_en`).  \n4. **Implication**: `|=>` ensures the consequent is checked **one clock cycle after** the antecedent holds.  \n5. **Consequent**:  \n   - `mask_en throughout ##1`: Ensures `mask_en` remains active continuously during the delay (##1).  \n   - `$rose(masked_status)`: Requires `masked_status` to rise **one cycle after** the antecedent.  \n\nThis assertion verifies that when an interrupt request (`int_req`) rises while masking is enabled (`mask_en`), the `masked_status` signal must rise in the subsequent cycle, with `mask_en` remaining active throughout.", "sva_signals": ["clk", "rst_n", "[0:0] int_req", "[0:0] mask_en", "[0:0] masked_status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    ($rose(int_req) && mask_en) |=> (mask_en throughout ##1 $rose(masked_status))", "sva_name": "p_Masked_Interrupt_Status", "full_property": "property p_Mask_Status_After_Request;\n@(posedge clk)    ($rose(int_req) && mask_en) |=> (mask_en throughout ##1 $rose(masked_status))\nendproperty\nassert_p_Mask_Status_After_Request:assert property (p_Mask_Status_After_Request) else $error(\"\");", "task_id": "3_836", "predict_sva": "@(posedge clk)    ($rose(int_req) && mask_en) |-> ##1 $rose(masked_status) throughout mask_en"}
{"id": "20_6_0161", "name": "parity_behavior_combined", "sva": "@(posedge clk) $changed(data_in) |=> (parity_out == ^$past(data_in))", "ori_sva": "property parity_behavior_combined;\n\n    @(posedge clk) $changed(data_in) |=> (parity_out == ^$past(data_in));\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Check  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(data_in)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(parity_out == ^$past(data_in))`  \n\n### Explanation:  \n- The property checks that whenever `data_in` changes (`$changed(data_in)`), **in the next clock cycle** (`|=>`), the `parity_out` signal must equal the XOR (parity) of the previous value of `data_in` (`^$past(data_in)`).  \n- The `|=>` operator ensures the consequent is evaluated **one clock cycle after** the antecedent is true.  \n- No reset/disabling condition is specified for this property.", "sva_signals": ["clk", "rst_n", "[0:0] error", "[7:0] code", "[7:0] is_fatal", "[0:0] parity_out", "[0:0] data_in"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $changed(data_in) |=> (parity_out == ^$past(data_in))", "sva_name": "p_Parity_Check_After_Data_Change", "full_property": "property p_Parity_Check;\n@(posedge clk)    $changed(data_in) |=> (parity_out == ^$past(data_in))\nendproperty\nassert_p_Parity_Check:assert property (p_Parity_Check) else $error(\"\");", "task_id": "3_609", "predict_sva": "@(posedge clk)    $changed(data_in) |-> ##1 (parity_out == ^$past(data_in))"}
{"id": "7_20_0239", "name": "p_stable_test_mode", "sva": "@(posedge clk) test_mode_enable |-> $stable(test_config)[*6]", "ori_sva": "property p_stable_test_mode;\n@(posedge clk) test_mode_enable |-> $stable(test_config)[*6];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_test_mode_stable_config  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `test_mode_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(test_config)` must hold true for 6 consecutive clock cycles (`[*6]`)  \n\n(Note: `$stable(test_config)[*6]` means the value of `test_config` must remain unchanged for 6 consecutive clock cycles after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] test_mode_enable", "[0:0] test_config"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     test_mode_enable == 1'b1 |-> $stable(test_config)[*6]", "sva_name": "p_test_mode_stable_config", "full_property": "property p_test_mode_stable_config;\n@(posedge clk)     test_mode_enable == 1'b1 |-> $stable(test_config)[*6];\nendproperty\nassert_p_test_mode_stable_config:assert property (p_test_mode_stable_config) else $error(\"\");", "task_id": "3_1688", "predict_sva": "@(posedge clk)     test_mode_enable == 1'b1 |-> $stable(test_config)[*6]"}
{"id": "47_3_0348", "name": "tensor_load_stable_before_rise", "sva": "@(posedge clk)     $rose(tensor_load) |-> $stable(stride) throughout (1'b1 [*1])", "ori_sva": "property tensor_load_stable_before_rise;\n@(posedge clk)\n    $rose(tensor_load) |-> $stable(stride) throughout (1'b1 [*1]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Stride_After_Tensor_Load  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(tensor_load)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(stride) throughout (1'b1 [*1])`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks that `stride` remains stable when `tensor_load` rises.  \n2. **Trigger Condition**: Evaluated at every rising edge of `clk`.  \n3. **Antecedent**: The property triggers when `tensor_load` transitions from 0 to 1 (`$rose(tensor_load)`).  \n4. **Consequent**: Ensures `stride` does not change (`$stable(stride)`) for one clock cycle (`throughout (1'b1 [*1])`).  \n\n### Key Notes:  \n- `$rose(tensor_load)` detects the positive edge of `tensor_load`.  \n- `$stable(stride)` asserts that `stride` remains unchanged.  \n- `throughout (1'b1 [*1])` specifies the stability must hold for exactly one clock cycle.  \n\nThe property ensures `stride` is stable in the cycle immediately following a rising edge of `tensor_load`.", "sva_signals": ["clk", "rst_n", "[0:0] tensor_load", "[0:0] stride"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $rose(tensor_load) |-> $stable(stride) throughout (1'b1 [*1])", "sva_name": "p_stable_stride_after_tensor_load", "full_property": "property p_Stable_Stride_After_Tensor_Load;\n@(posedge clk)        $rose(tensor_load) |-> $stable(stride) throughout (1'b1 [*1])\nendproperty\nassert_p_Stable_Stride_After_Tensor_Load:assert property (p_Stable_Stride_After_Tensor_Load) else $error(\"\");", "task_id": "3_1225", "predict_sva": "@(posedge clk)        $rose(tensor_load) |-> ##1 $stable(stride)"}
{"id": "1_7_0026", "name": "interrupt_handling", "sva": "@(posedge clk) disable iff (!int_rst_n)     $rose(irq) && !int_mask |-> first_match(##[1:4] int_ack) or (##5 timeout)", "ori_sva": "property interrupt_handling;\n\n    @(posedge clk) disable iff (!int_rst_n)\n    $rose(irq) && !int_mask |-> first_match(##[1:4] int_ack) or (##5 timeout);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_irq_ack_or_timeout  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!int_rst_n)`  \n**Antecedent (LHS of Implication)**: `$rose(irq) && !int_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `first_match(##[1:4] int_ack) or (##5 timeout)`  \n\n### Explanation:  \n1. The property checks that when an interrupt request (`irq`) rises (`$rose(irq)`) and the interrupt is not masked (`!int_mask`), either:  \n   - The interrupt acknowledgment (`int_ack`) occurs within **1 to 4 clock cycles** (`##[1:4] int_ack`), with `first_match` ensuring only the earliest match is considered, **or**  \n   - A `timeout` occurs after exactly **5 clock cycles** (`##5 timeout`).  \n2. The property is **disabled** if the active-low reset `int_rst_n` is deasserted (`!int_rst_n`).  \n3. The check is evaluated at every rising edge of `clk`.", "sva_signals": ["clk", "int_rst_n", "[0:0] irq", "[0:0] int_mask", "[0:0] int_ack", "[0:0] timeout"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!int_rst_n)    ($rose(irq) && !int_mask) |-> first_match(##[1:4] int_ack) or (##5 timeout)", "sva_name": "p_irq_int_ack_timeout", "full_property": "property p_irq_ack_or_timeout;\n@(posedge clk) disable iff (!int_rst_n)    ($rose(irq) && !int_mask) |-> first_match(##[1:4] int_ack) or (##5 timeout)\nendproperty\nassert_p_irq_ack_or_timeout:assert property (p_irq_ack_or_timeout) else $error(\"\");", "task_id": "3_527", "predict_sva": "@(posedge clk) disable iff (!int_rst_n)    ($rose(irq) && !int_mask) |-> ##[1:4] int_ack ##1 $past(timeout, 5)"}
{"id": "7_11_0206", "name": "p_stable_ref_during_cal", "sva": "@(posedge clk) calibration_active |-> $stable(ref_voltage)[*7]", "ori_sva": "property p_stable_ref_during_cal;\n@(posedge clk) calibration_active |-> $stable(ref_voltage)[*7];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_CalibrationActive_StableRefVoltage  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `calibration_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(ref_voltage)[*7]` (The `ref_voltage` signal remains stable for 7 consecutive clock cycles)", "sva_signals": ["clk", "rst_n", "[0:0] calibration_active", "[0:0] ref_voltage"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     calibration_active == 1'b1 |-> $stable(ref_voltage)[*7]", "sva_name": "p_Stable_Ref_Voltage_During_Calibration", "full_property": "property p_CalibrationActive_StableRefVoltage;\n@(posedge clk)     calibration_active == 1'b1 |-> $stable(ref_voltage)[*7];\nendproperty\nassert_p_CalibrationActive_StableRefVoltage:assert property (p_CalibrationActive_StableRefVoltage) else $error(\"\");", "task_id": "3_1679", "predict_sva": "@(posedge clk)     calibration_active == 1'b1 |-> $stable(ref_voltage)[*7]"}
{"id": "219_6_1840", "name": "reset_sync", "sva": "@(posedge clk)     $rose(sys_rst_n) |-> ##[1:2] $rose(pll_lock)", "ori_sva": "property reset_sync;\n@(posedge clk)     $rose(sys_rst_n) |-> ##[1:2] $rose(pll_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Rose_PllLock_After_SysRst  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(sys_rst_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] $rose(pll_lock)`  \n\n### Explanation:  \nThe property checks that whenever there is a rising edge on `sys_rst_n` (indicating the de-assertion of the reset signal), the PLL lock signal (`pll_lock`) must rise within 1 to 2 clock cycles after the reset de-assertion. The assertion is evaluated at every rising edge of the clock (`clk`) and has no disable condition.", "sva_signals": ["clk", "sys_rst_n", "pll_lock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $rose(sys_rst_n) |-> ##[1:2] $rose(pll_lock)", "sva_name": "p_pll_lock_after_reset", "full_property": "property p_Rose_PllLock_After_SysRst;\n@(posedge clk)        $rose(sys_rst_n) |-> ##[1:2] $rose(pll_lock)\nendproperty\nassert_p_Rose_PllLock_After_SysRst:assert property (p_Rose_PllLock_After_SysRst) else $error(\"\");", "task_id": "3_671", "predict_sva": "@(posedge clk)        $rose(sys_rst_n) |-> ##[1:2] $rose(pll_lock)"}
{"id": "26_1_0177", "name": "addr_hs_to_rvalid_within_3_cycles", "sva": "@(posedge clk) disable iff (!rst_n)     $rose(arvalid && arready) |-> ##[1:3] rvalid", "ori_sva": "property addr_hs_to_rvalid_within_3_cycles;\n\n    @(posedge clk) disable iff (!rst_n)\n    $rose(arvalid && arready) |-> ##[1:3] rvalid;\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_arvalid_arready_to_rvalid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst_n)`  \n**Antecedent (LHS of Implication)**: `$rose(arvalid && arready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] rvalid`  \n\n### Explanation:  \n1. **Property Name**: The assertion is named `p_arvalid_arready_to_rvalid` to reflect its purpose of checking the relationship between `arvalid`, `arready`, and `rvalid`.  \n2. **Trigger Condition**: The property is evaluated at every positive edge of the clock signal `clk`.  \n3. **Disable Condition**: The property is disabled (not evaluated) when the reset signal `rst_n` is low (`!rst_n`), indicating an active-low reset condition.  \n4. **Antecedent**: The antecedent checks for a rising edge (`$rose`) of the logical AND of `arvalid` and `arready`. This means the condition is true when `arvalid` and `arready` transition from low to high.  \n5. **Implication Operator**: The `|->` operator ensures that if the antecedent is true, the consequent must hold.  \n6. **Consequent**: The consequent requires that `rvalid` must become true within 1 to 3 clock cycles (`##[1:3]`) after the antecedent is satisfied.  \n\nThis assertion ensures that after a valid handshake (`arvalid && arready` rising), the `rvalid` signal is asserted within the specified clock cycles, unless the system is in reset.", "sva_signals": ["clk", "rst_n", "[0:0] arvalid", "[0:0] arready", "[0:0] rvalid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)    $rose(arvalid && arready) |-> ##[1:3] rvalid", "sva_name": "p_arvalid_arready_rvalid", "full_property": "property p_arvalid_arready_to_rvalid;\n@(posedge clk) disable iff (!rst_n)    $rose(arvalid && arready) |-> ##[1:3] rvalid\nendproperty\nassert_p_arvalid_arready_to_rvalid:assert property (p_arvalid_arready_to_rvalid) else $error(\"\");", "task_id": "3_981", "predict_sva": "@(posedge clk) disable iff (!rst_n)    $rose(arvalid && arready) |-> ##[1:3] rvalid"}
{"id": "5_2_0146", "name": "p2", "sva": "@(posedge clk)     ($rose(data_valid) || $fell(reset_n)) |-> ack", "ori_sva": "property p2;\n@(posedge clk)     ($rose(data_valid) || $fell(reset_n)) |-> ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ack_on_data_valid_or_reset_fall  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `($rose(data_valid) || $fell(reset_n))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ack`  ", "sva_signals": ["clk", "reset_n", "[0:0] data_valid", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ($rose(data_valid) || $fell(reset_n)) |-> ack", "sva_name": "p_ack_after_data_valid_or_reset", "full_property": "property p_ack_on_data_valid_or_reset_fall;\n@(posedge clk)     ($rose(data_valid) || $fell(reset_n)) |-> ack;\nendproperty\nassert_p_ack_on_data_valid_or_reset_fall:assert property (p_ack_on_data_valid_or_reset_fall) else $error(\"\");", "task_id": "3_1641", "predict_sva": "@(posedge clk)         ($rose(data_valid) || $fell(reset_n)) |-> ack"}
{"id": "35_4_0296", "name": "irq_must_wait_after_ack", "sva": "@(posedge clk_signal)     ack_signal |=> !irq_req [*3]", "ori_sva": "property irq_must_wait_after_ack;\n@(posedge clk_signal)\n    ack_signal |=> !irq_req [*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ack_irq_req  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ack_signal`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `!irq_req [*3]` (irq_req remains low for 3 consecutive cycles after the antecedent is true)  \n\n### Explanation:  \n- The property checks that when `ack_signal` is high at a rising clock edge (`posedge clk_signal`), then **starting from the next clock cycle** (`|=>`), the `irq_req` signal must remain low (`!irq_req`) for **3 consecutive cycles** (`[*3]`).  \n- The assertion does not have a disable condition (e.g., no `disable iff`).  \n- The `|=>` operator ensures the consequent is evaluated **one clock cycle after** the antecedent holds.  \n- The `[*3]` repetition specifies that the consequent (`!irq_req`) must hold true for exactly 3 cycles.  \n\n### Notes:  \n- If `ack_signal` is not high, the property vacuously passes (no obligation to check `irq_req`).  \n- If `ack_signal` is high, the check enforces that `irq_req` stays low for the next 3 cycles.", "sva_signals": ["clk_signal", "ack_signal", "irq_req"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)        ack_signal |=> !irq_req [*3]", "sva_name": "p_ack_signal_irq_req", "full_property": "property p_ack_irq_req;\n@(posedge clk_signal)        ack_signal |=> !irq_req [*3]\nendproperty\nassert_p_ack_irq_req:assert property (p_ack_irq_req) else $error(\"\");", "task_id": "3_1168", "predict_sva": "@(posedge clk_signal)    ack_signal |-> ##1 !irq_req[*3]"}
{"id": "7_28_0237", "name": "p_stable_delay_setting", "sva": "@(posedge clk) delay_line_enabled |-> $stable(delay_setting)[*4]", "ori_sva": "property p_stable_delay_setting;\n@(posedge clk) delay_line_enabled |-> $stable(delay_setting)[*4];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_delay_setting_stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `delay_line_enabled == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(delay_setting)[*4]` (The value of `delay_setting` remains stable for 4 consecutive clock cycles)", "sva_signals": ["clk", "rst_n", "[0:0] delay_line_enabled", "[0:0] delay_setting"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     delay_line_enabled == 1'b1 |-> $stable(delay_setting)[*4]", "sva_name": "p_Stable_Delay_Setting_After_Enable", "full_property": "property p_delay_setting_stable;\n@(posedge clk)     delay_line_enabled == 1'b1 |-> $stable(delay_setting)[*4];\nendproperty\nassert_p_delay_setting_stable:assert property (p_delay_setting_stable) else $error(\"\");", "task_id": "3_1695", "predict_sva": "@(posedge clk)     delay_line_enabled == 1'b1 |-> $stable(delay_setting)[*4]"}
{"id": "13_8_0551", "name": "p_repeat_8", "sva": "@(posedge clk)     $stable(config_reg)[*3] |-> config_valid", "ori_sva": "property p_repeat_8;\n@(posedge clk)     $stable(config_reg)[*3] |-> config_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Config_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(config_reg)[*3]` (the value of `config_reg` remains stable for 3 consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `config_valid` (the signal `config_valid` must be asserted)", "sva_signals": ["clk", "rst_n", "[0:0] config_reg", "[0:0] config_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(config_reg)[*3] |-> config_valid", "sva_name": "p_stable_config_reg", "full_property": "property p_Stable_Config_Valid;\n@(posedge clk)     $stable(config_reg)[*3] |-> config_valid;\nendproperty\nassert_p_Stable_Config_Valid:assert property (p_Stable_Config_Valid) else $error(\"\");", "task_id": "3_1862", "predict_sva": "@(posedge clk)     $stable(config_reg)[*3] |-> config_valid"}
{"id": "7_29_0236", "name": "p_stable_mem_ctrl_during_refresh", "sva": "@(posedge clk) mem_refresh_cycle |-> $stable(mem_ctrl_settings)[*3]", "ori_sva": "property p_stable_mem_ctrl_during_refresh;\n@(posedge clk) mem_refresh_cycle |-> $stable(mem_ctrl_settings)[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_refresh_cycle_stability  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_refresh_cycle == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(mem_ctrl_settings)[*3]` (The `mem_ctrl_settings` signal must remain stable for 3 consecutive clock cycles)  ", "sva_signals": ["clk", "rst_n", "[0:0] mem_refresh_cycle", "[0:0] mem_ctrl_settings"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         mem_refresh_cycle == 1'b1 |-> $stable(mem_ctrl_settings)[*3]", "sva_name": "p_mem_refresh_stable_ctrl", "full_property": "property p_mem_refresh_cycle_stability;\n@(posedge clk)         mem_refresh_cycle == 1'b1 |-> $stable(mem_ctrl_settings)[*3];\nendproperty\nassert_p_mem_refresh_cycle_stability:assert property (p_mem_refresh_cycle_stability) else $error(\"\");", "task_id": "3_1696", "predict_sva": "@(posedge clk)     mem_refresh_cycle == 1'b1 |-> $stable(mem_ctrl_settings)[*3]"}
{"id": "4_7_0129", "name": "p_packet_sync", "sva": "@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start", "ori_sva": "property p_packet_sync;\n@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Pulse_To_Packet_Start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse` occurs consecutively for 2 clock cycles (`sync_pulse[*2]`)  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##2 packet_start` (2 clock cycles after the antecedent sequence completes, `packet_start` must be asserted)", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] packet_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start", "sva_name": "p_sync_pulse_to_packet_start", "full_property": "property p_Sync_Pulse_To_Packet_Start;\n@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start;\nendproperty\nassert_p_Sync_Pulse_To_Packet_Start:assert property (p_Sync_Pulse_To_Packet_Start) else $error(\"\");", "task_id": "3_1619", "predict_sva": "@(posedge clk)     sync_pulse[*2] |-> ##2 packet_start"}
{"id": "4_1_0111", "name": "p_consec_valid_3cycles", "sva": "@(posedge clk)     valid[*3] |-> done", "ori_sva": "property p_consec_valid_3cycles;\n@(posedge clk)     valid[*3] |-> done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_valid_3_cycles_to_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `valid` is high for 3 consecutive clock cycles (`valid[*3]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `done` is high in the same cycle as the third consecutive `valid`", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     valid[*3] |-> done", "sva_name": "p_valid_to_done", "full_property": "property p_valid_3_cycles_to_done;\n@(posedge clk)     valid[*3] |-> done;\nendproperty\nassert_p_valid_3_cycles_to_done:assert property (p_valid_3_cycles_to_done) else $error(\"\");", "task_id": "3_1608", "predict_sva": "@(posedge clk)     valid[*3] |-> done"}
{"id": "4_8_0024", "name": "p_empty_rd_block_cov", "sva": "@(posedge clk) disable iff (!rst_n)     fifo_empty |-> !rd_en throughout fifo_empty", "ori_sva": "property p_empty_rd_block_cov;\n\n    @(posedge clk) disable iff (!rst_n)\n    fifo_empty |-> !rd_en throughout fifo_empty;\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_empty_no_rd_en  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst_n)`  \n**Antecedent (LHS of Implication)**: `fifo_empty`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!rd_en throughout fifo_empty`  \n\n### Explanation:  \n- The property checks that when the FIFO is empty (`fifo_empty` is true), read enable (`rd_en`) must remain low (`!rd_en`) **throughout** the entire duration that `fifo_empty` is true.  \n- The assertion is evaluated at every rising edge of `clk` but is **disabled** if the reset signal `rst_n` is low (active-low reset).  \n- The `throughout` keyword ensures that `!rd_en` holds continuously as long as `fifo_empty` is true.", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] rd_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)    fifo_empty |-> !rd_en throughout fifo_empty", "sva_name": "p_fifo_empty_no_rd_en", "full_property": "property p_fifo_empty_no_rd_en;\n@(posedge clk) disable iff (!rst_n)    fifo_empty |-> !rd_en throughout fifo_empty\nendproperty\nassert_p_fifo_empty_no_rd_en:assert property (p_fifo_empty_no_rd_en) else $error(\"\");", "task_id": "3_1244", "predict_sva": "@(posedge clk) disable iff (!rst_n)    fifo_empty |-> !rd_en throughout fifo_empty"}
{"id": "1_1_0020", "name": "p1", "sva": "@(posedge clk)     $rose(req_valid) |-> ##3 ack_grant", "ori_sva": "property p1;\n@(posedge clk)     $rose(req_valid) |-> ##3 ack_grant\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Req_Valid_Ack_Grant  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(req_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 ack_grant`  \n\n(Note: The assertion checks that whenever `req_valid` rises, `ack_grant` must be high exactly 3 clock cycles later.)", "sva_signals": ["clk", "rst_n", "[0:0] req_valid", "[0:0] ack_grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(req_valid) |-> ##3 ack_grant", "sva_name": "p_req_valid_to_ack_grant", "full_property": "property p_Req_Valid_Ack_Grant;\n@(posedge clk)         $rose(req_valid) |-> ##3 ack_grant;\nendproperty\nassert_p_Req_Valid_Ack_Grant:assert property (p_Req_Valid_Ack_Grant) else $error(\"\");", "task_id": "3_1495", "predict_sva": "@(posedge clk)        $rose(req_valid) |-> ##3 ack_grant"}
{"id": "254_5_2172", "name": "pcie_deskew_diff_p5", "sva": "@(posedge ref_clk)     $rose(lane1_deskew_done) |-> ##[0:2] $rose(lane3_deskew_done)", "ori_sva": "property pcie_deskew_diff_p5;\n@(posedge ref_clk)     $rose(lane1_deskew_done) |-> ##[0:2] $rose(lane3_deskew_done)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_lane_deskew_sequence  \n**Trigger Condition**: At every posedge of the `ref_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(lane1_deskew_done)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] $rose(lane3_deskew_done)`  \n\n**Explanation**:  \nThis property checks that whenever there is a rising edge on `lane1_deskew_done` (indicating lane1 has completed deskew), then within 0 to 2 clock cycles (`##[0:2]`), there must also be a rising edge on `lane3_deskew_done` (indicating lane3 has completed deskew). The check is performed at every rising edge of `ref_clk`. There is no disable condition for this property.", "sva_signals": ["ref_clk", "lane1_deskew_done", "lane3_deskew_done"], "clock": "ref_clk", "attempts_left": 10, "sva_result": "@(posedge ref_clk)        $rose(lane1_deskew_done) |-> ##[0:2] $rose(lane3_deskew_done)", "sva_name": "p_lane_deskew_sync", "full_property": "property p_lane_deskew_sequence;\n@(posedge ref_clk)        $rose(lane1_deskew_done) |-> ##[0:2] $rose(lane3_deskew_done)\nendproperty\nassert_p_lane_deskew_sequence:assert property (p_lane_deskew_sequence) else $error(\"\");", "task_id": "3_911", "predict_sva": "@(posedge ref_clk)    $rose(lane1_deskew_done) |-> ##[0:2] $rose(lane3_deskew_done)"}
{"id": "78_6_0589", "name": "p_slot_length_non_zero", "sva": "@(posedge clk_signal)     $rose(static_slot) |-> $past(slot_length) > 2", "ori_sva": "property p_slot_length_non_zero;\n@(posedge clk_signal)\n    $rose(static_slot) |-> $past(slot_length) > 2;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Static_Slot_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(static_slot)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(slot_length) > 2`  \n\n**Explanation**:  \nThe assertion checks that whenever a rising edge is detected on the `static_slot` signal (indicating the start of a static slot), the value of `slot_length` from the previous clock cycle (`$past(slot_length)`) must be greater than 2. The check is performed at every rising edge of `clk_signal`, and there is no disable condition for this property.", "sva_signals": ["clk_signal", "[0:0] static_slot", "[2:0] slot_length"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)        $rose(static_slot) |-> $past(slot_length) > 2", "sva_name": "p_static_slot_rose_check", "full_property": "property p_Static_Slot_Check;\n@(posedge clk_signal)        $rose(static_slot) |-> $past(slot_length) > 2\nendproperty\nassert_p_Static_Slot_Check:assert property (p_Static_Slot_Check) else $error(\"\");", "task_id": "3_1380", "predict_sva": "@(posedge clk_signal)        $rose(static_slot) |-> ($past(slot_length) > 2)"}
{"id": "217_5_1831", "name": "power_down_sequence", "sva": "@(posedge clk)     $rose(pwr_down_req) |-> ##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack)", "ori_sva": "property power_down_sequence;\n@(posedge clk)     $rose(pwr_down_req) |-> ##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Pwr_Down_Sequence  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pwr_down_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack)`  \n\n**Explanation**:  \nThis property checks a power-down sequence. When a rising edge is detected on `pwr_down_req` (indicating a power-down request), the following sequence must occur:  \n1. After 1 clock cycle (`##1`), `core_active` must fall (transition from 1 to 0).  \n2. Between 1 to 3 clock cycles after `core_active` falls (`##[1:3]`), `pwr_down_ack` must rise (transition from 0 to 1), indicating acknowledgment of the power-down request.  \n\nThe assertion ensures the correct timing relationship between the power-down request, core deactivation, and acknowledgment.", "sva_signals": ["clk", "rst_n", "[0:0] pwr_down_req", "[0:0] core_active", "[0:0] pwr_down_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $rose(pwr_down_req) |-> ##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack)", "sva_name": "p_PowerDownSequence", "full_property": "property p_Pwr_Down_Sequence;\n@(posedge clk)    $rose(pwr_down_req) |-> ##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack)\nendproperty\nassert_p_Pwr_Down_Sequence:assert property (p_Pwr_Down_Sequence) else $error(\"\");", "task_id": "3_658", "predict_sva": "@(posedge clk)    $rose(pwr_down_req) |-> ##1 $fell(core_active) ##[1:3] $rose(pwr_down_ack)"}
{"id": "62_4_0442", "name": "p_no_slverr_with_stable_data", "sva": "@(posedge apb_clk)     $stable(p_rdata) or !p_slverr", "ori_sva": "property p_no_slverr_with_stable_data;\n@(posedge apb_clk)\n    $stable(p_rdata) or !p_slverr;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_rdata_or_no_slverr  \n**Trigger Condition**: At every posedge of the `apb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a concurrent assertion without an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `$stable(p_rdata) or !p_slverr`  \n\n**Description**:  \nThe assertion checks that at every rising edge of `apb_clk`, either the value of `p_rdata` remains stable (unchanged from the previous cycle) or `p_slverr` is not asserted (`!p_slverr`). This is a direct concurrent assertion without an implication operator.", "sva_signals": ["apb_clk", "p_slverr", "p_rdata"], "clock": "apb_clk", "attempts_left": 10, "sva_result": "@(posedge apb_clk)        $stable(p_rdata) or !p_slverr", "sva_name": "p_rdata_stable_or_no_error", "full_property": "property p_stable_rdata_or_no_slverr;\n@(posedge apb_clk)        $stable(p_rdata) or !p_slverr\nendproperty\nassert_p_stable_rdata_or_no_slverr:assert property (p_stable_rdata_or_no_slverr) else $error(\"\");", "task_id": "3_1307", "predict_sva": "@(posedge apb_clk)     $stable(p_rdata) || !p_slverr"}
{"id": "2_24_0224", "name": "p24", "sva": "@(posedge clk)     (sensor_trigger && !sensor_busy) |=> ##2 sensor_data_valid", "ori_sva": "property p24;\n@(posedge clk)     (sensor_trigger && !sensor_busy) |=> ##2 sensor_data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_data_valid_after_trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_trigger && !sensor_busy`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##2 sensor_data_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] sensor_trigger", "[0:0] sensor_busy", "[0:0] sensor_data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (sensor_trigger && !sensor_busy) |=> ##2 sensor_data_valid", "sva_name": "p_sensor_data_valid_after_trigger", "full_property": "property p_sensor_data_valid_after_trigger;\n@(posedge clk)     (sensor_trigger && !sensor_busy) |=> ##2 sensor_data_valid;\nendproperty\nassert_p_sensor_data_valid_after_trigger:assert property (p_sensor_data_valid_after_trigger) else $error(\"\");", "task_id": "3_1915", "predict_sva": "@(posedge clk)         (sensor_trigger && !sensor_busy) |-> ##2 sensor_data_valid"}
{"id": "28_4_0198", "name": "past_wvalid_after_wready_fell", "sva": "@(posedge clk) $fell(wready) |=> $past(wvalid, 1)", "ori_sva": "property past_wvalid_after_wready_fell;\n\n    @(posedge clk) $fell(wready) |=> $past(wvalid, 1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wvalid_after_wready_fall  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(wready)`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$past(wvalid, 1)`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks if `wvalid` was asserted in the cycle immediately preceding a falling edge of `wready`.  \n2. **Trigger Condition**: Evaluated on every rising edge of `clk`.  \n3. **Implication**: `|=>` ensures the consequent (`$past(wvalid, 1)`) is checked in the **next clock cycle** after the antecedent (`$fell(wready)`) is true.  \n4. **Consequent**: Verifies that `wvalid` was high (`1'b1`) in the cycle **one clock before** `wready` fell.  \n\n### Key Notes:  \n- `$fell(wready)` detects a high-to-low transition of `wready`.  \n- `$past(wvalid, 1)` retrieves the value of `wvalid` from the previous clock cycle.  \n- The assertion enforces that `wvalid` must have been active (`1'b1`) before `wready` deasserts.  \n\nThis ensures proper handshake behavior in protocols where `wvalid` should precede `wready` deassertion.", "sva_signals": ["clk", "rst_n", "[0:0] wready", "[0:0] wvalid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $fell(wready) |=> $past(wvalid, 1)", "sva_name": "p_Wvalid_After_Wready_Fall", "full_property": "property p_wvalid_after_wready_fall;\n@(posedge clk)        $fell(wready) |=> $past(wvalid, 1)\nendproperty\nassert_p_wvalid_after_wready_fall:assert property (p_wvalid_after_wready_fall) else $error(\"\");", "task_id": "3_1088", "predict_sva": "@(posedge clk)    $fell(wready) |-> $past(wvalid, 1) == 1'b1"}
{"id": "4_30_0296", "name": "p_non_overlap_15", "sva": "@(posedge clk)     test_mode_entry |=> ##3 test_signals_active", "ori_sva": "property p_non_overlap_15;\n@(posedge clk)     test_mode_entry |=> ##3 test_signals_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_test_signals_active_after_entry  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `test_mode_entry == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##3 test_signals_active == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent is checked starting from the next clock cycle after the antecedent is true, and `##3` means the consequent is expected to hold 3 clock cycles after that.)", "sva_signals": ["clk", "rst_n", "[0:0] test_mode_entry", "[0:0] test_signals_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         test_mode_entry == 1'b1 |=> ##3 test_signals_active == 1'b1", "sva_name": "p_test_signals_active_after_entry", "full_property": "property p_test_signals_active_after_entry;\n@(posedge clk)         test_mode_entry == 1'b1 |=> ##3 test_signals_active == 1'b1;\nendproperty\nassert_p_test_signals_active_after_entry:assert property (p_test_signals_active_after_entry) else $error(\"\");", "task_id": "3_2011", "predict_sva": "@(posedge clk)     test_mode_entry == 1'b1 |-> ##3 test_signals_active == 1'b1"}
{"id": "263_4_2258", "name": "usb_eop_se0_duration_exact_16", "sva": "@(posedge usb_clk)     $rose(usb_se0) |-> ##16 $fell(usb_se0) and not ##17 $fell(usb_se0)", "ori_sva": "property usb_eop_se0_duration_exact_16;\n@(posedge usb_clk)     $rose(usb_se0) |-> ##16 $fell(usb_se0) and not ##17 $fell(usb_se0);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_USB_SE0_Transition  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(usb_se0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##16 $fell(usb_se0) and not ##17 $fell(usb_se0)`  \n\n### Explanation:\n1. The property checks the timing relationship of USB SE0 (Single-Ended Zero) signal transitions.  \n2. When a rising edge of `usb_se0` is detected (`$rose(usb_se0)`), the assertion requires that:  \n   - Exactly 16 clock cycles later (`##16`), `usb_se0` must fall (`$fell(usb_se0)`), **and**  \n   - The signal must **not** fall again in the **next** clock cycle (i.e., cycle 17, `not ##17 $fell(usb_se0)`).  \n3. This enforces a specific pulse width (16 cycles) for the `usb_se0` signal after its rising edge.", "sva_signals": ["usb_clk", "usb_se0", "[0:0] rst_n"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)    $rose(usb_se0) |-> ##16 $fell(usb_se0) and not ##17 $fell(usb_se0)", "sva_name": "p_usb_se0_fall_after_rose", "full_property": "property p_USB_SE0_Transition;\n@(posedge usb_clk)    $rose(usb_se0) |-> ##16 $fell(usb_se0) and not ##17 $fell(usb_se0)\nendproperty\nassert_p_USB_SE0_Transition:assert property (p_USB_SE0_Transition) else $error(\"\");", "task_id": "3_965", "predict_sva": "@(posedge usb_clk)    $rose(usb_se0) |-> ##16 $fell(usb_se0) ##1 !$fell(usb_se0)"}
{"id": "4_14_0295", "name": "p_non_overlap_7", "sva": "@(posedge clk)     temperature_high |=> ##[1:5] cooling_active", "ori_sva": "property p_non_overlap_7;\n@(posedge clk)     temperature_high |=> ##[1:5] cooling_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temperature_high_to_cooling  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temperature_high == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:5] cooling_active == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] temperature_high", "[0:0] cooling_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     temperature_high == 1'b1 |=> ##[1:5] cooling_active == 1'b1", "sva_name": "p_temp_high_to_cooling_active", "full_property": "property p_temperature_high_to_cooling;\n@(posedge clk)     temperature_high == 1'b1 |=> ##[1:5] cooling_active == 1'b1;\nendproperty\nassert_p_temperature_high_to_cooling:assert property (p_temperature_high_to_cooling) else $error(\"\");", "task_id": "3_1993", "predict_sva": "@(posedge clk)     temperature_high == 1'b1 |-> ##[1:5] cooling_active == 1'b1"}
{"id": "7_20_0387", "name": "p_fell_security_lock", "sva": "@(posedge clk) disable iff (!rst_n)     $fell(security_lock) |-> ##1 $rose(access_granted)", "ori_sva": "property p_fell_security_lock;\n@(posedge clk) disable iff (!rst_n)     $fell(security_lock) |-> ##1 $rose(access_granted);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_security_lock_to_access_granted  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$fell(security_lock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $rose(access_granted)`", "sva_signals": ["clk", "rst_n", "[0:0] security_lock", "[0:0] access_granted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)         $fell(security_lock) |-> ##1 $rose(access_granted)", "sva_name": "p_security_lock_to_access_granted", "full_property": "property p_security_lock_to_access_granted;\n@(posedge clk) disable iff (!rst_n)         $fell(security_lock) |-> ##1 $rose(access_granted);\nendproperty\nassert_p_security_lock_to_access_granted:assert property (p_security_lock_to_access_granted) else $error(\"\");", "task_id": "3_2087", "predict_sva": "@(posedge clk) disable iff (!rst_n)     $fell(security_lock) |-> ##1 $rose(access_granted)"}
{"id": "4_1_0277", "name": "p_overlap_1", "sva": "@(posedge clk)     start |-> ##1 (data_valid && (data == prev_data + 1))", "ori_sva": "property p_overlap_1;\n@(posedge clk)     start |-> ##1 (data_valid && (data == prev_data + 1))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_valid_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (data_valid && (data == prev_data + 1))`  \n\n(Note: The assertion checks that one clock cycle after `start` is asserted, `data_valid` must be high and `data` must equal `prev_data + 1`.)", "sva_signals": ["clk", "rst_n", "[0:0] start", "[0:0] data_valid", "[7:0] data", "[7:0] prev_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         start == 1'b1 |-> ##1 (data_valid && (data == prev_data + 1))", "sva_name": "p_Start_Data_Valid_Check", "full_property": "property p_data_valid_after_start;\n@(posedge clk)         start == 1'b1 |-> ##1 (data_valid && (data == prev_data + 1));\nendproperty\nassert_p_data_valid_after_start:assert property (p_data_valid_after_start) else $error(\"\");", "task_id": "3_1999", "predict_sva": "@(posedge clk)         start == 1'b1 |-> ##1 (data_valid && (data == prev_data + 1))"}
{"id": "13_20_0559", "name": "p_repeat_20", "sva": "@(posedge clk)     security_check |-> (auth_pending[*2:3] ##1 access_granted)", "ori_sva": "property p_repeat_20;\n@(posedge clk)     security_check |-> (auth_pending[*2:3] ##1 access_granted);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_security_check_to_access  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `security_check == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `auth_pending` must hold true for 2 to 3 consecutive clock cycles, followed by `access_granted` being true in the next clock cycle (`[*2:3] ##1 access_granted`).  ", "sva_signals": ["clk", "rst_n", "[0:0] security_check", "[0:0] auth_pending", "[0:0] access_granted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     security_check == 1'b1 |-> auth_pending[*2:3] ##1 access_granted", "sva_name": "p_security_check_auth_access", "full_property": "property p_security_check_to_access;\n@(posedge clk)     security_check == 1'b1 |-> auth_pending[*2:3] ##1 access_granted;\nendproperty\nassert_p_security_check_to_access:assert property (p_security_check_to_access) else $error(\"\");", "task_id": "3_1851", "predict_sva": "@(posedge clk)     security_check == 1'b1 |-> auth_pending[*2:3] ##1 access_granted == 1'b1"}
{"id": "11_68_0923", "name": "p_no_x_in_flash_access", "sva": "@(posedge clk)      flash_read |-> !$isunknown(flash_address);", "sva_description": "### Assertion description:  \n**Property Name**: p_flash_read_address_known  \n**Trigger Condition**: At every simulation step (implicit, no clock edge specified)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flash_read == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(flash_address)`  \n\n**Explanation**:  \nThis assertion checks that whenever `flash_read` is active (high), the `flash_address` signal must not contain any unknown ('x' or 'z') bits. The check is performed immediately when `flash_read` becomes true, without waiting for a clock edge. The assertion has no disabling condition.", "sva_signals": ["flash_read", "[0:0] flash_address", "clk", "rst_n"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) flash_read == 1'b1 |-> !$isunknown(flash_address)", "sva_name": "p_flash_read_address_valid", "full_property": "property p_flash_read_address_known;\n@(posedge clk) flash_read == 1'b1 |-> !$isunknown(flash_address)\nendproperty\nassert_p_flash_read_address_known:assert property (p_flash_read_address_known) else $error(\"\");", "task_id": "3_2377", "predict_sva": "@(posedge clk) flash_read == 1'b1 |-> !$isunknown(flash_address)"}
{"id": "276_1_2285", "name": "temp_shutdown_3consecutive_samples", "sva": "@(posedge clk_sys)     $rose(temp_above_critical) ##1 temp_above_critical[*2] |-> ##[1:5] $rose(system_shutdown)", "ori_sva": "property temp_shutdown_3consecutive_samples;\n@(posedge clk_sys)     $rose(temp_above_critical) ##1 temp_above_critical[*2] |-> ##[1:5] $rose(system_shutdown);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_critical_shutdown  \n**Trigger Condition**: At every posedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(temp_above_critical) ##1 temp_above_critical[*2]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $rose(system_shutdown)`  \n\n### Explanation:  \n1. **Antecedent**:  \n   - `$rose(temp_above_critical)`: The property checks if `temp_above_critical` has risen from 0 to 1 at the current clock edge.  \n   - `##1 temp_above_critical[*2]`: After the rise, `temp_above_critical` must remain high for the next **two consecutive clock cycles**.  \n\n2. **Consequent**:  \n   - `##[1:5] $rose(system_shutdown)`: Within **1 to 5 clock cycles** after the antecedent is satisfied, `system_shutdown` must rise (transition from 0 to 1).  \n\n### Summary:  \nThe assertion ensures that if `temp_above_critical` rises and stays high for two cycles, the system must initiate a shutdown (indicated by `$rose(system_shutdown)`) within 1 to 5 clock cycles.", "sva_signals": ["clk_sys", "temp_above_critical", "system_shutdown"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)        $rose(temp_above_critical) ##1 temp_above_critical[*2] |-> ##[1:5] $rose(system_shutdown)", "sva_name": "p_temp_critical_to_shutdown", "full_property": "property p_temp_critical_shutdown;\n@(posedge clk_sys)        $rose(temp_above_critical) ##1 temp_above_critical[*2] |-> ##[1:5] $rose(system_shutdown)\nendproperty\nassert_p_temp_critical_shutdown:assert property (p_temp_critical_shutdown) else $error(\"\");", "task_id": "3_1001", "predict_sva": "@(posedge clk_sys)    $rose(temp_above_critical) ##1 temp_above_critical[*2] |-> ##[1:5] $rose(system_shutdown)"}
{"id": "210_1_1751", "name": "int_nesting_p1", "sva": "@(posedge clk_signal)      $rose(irq_0) |-> if (irq_1) (##[1:2] $rose(nested_int)) else (##[1:3] $rose(ack_signal))", "ori_sva": "property int_nesting_p1;\n@(posedge clk_signal)      $rose(irq_0) |-> if (irq_1) (##[1:2] $rose(nested_int)) else (##[1:3] $rose(ack_signal));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_irq_response  \n**Trigger Condition**: At every posedge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(irq_0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- If `irq_1` is true, then within 1 to 2 clock cycles, `$rose(nested_int)` must occur.  \n- Else (if `irq_1` is false), within 1 to 3 clock cycles, `$rose(ack_signal)` must occur.  \n\n### Explanation:  \n1. The property checks the response to a rising edge of `irq_0` (`$rose(irq_0)`).  \n2. If `irq_1` is asserted, the consequent requires a rising edge of `nested_int` within 1 or 2 clock cycles (`##[1:2] $rose(nested_int)`).  \n3. If `irq_1` is not asserted, the consequent requires a rising edge of `ack_signal` within 1 to 3 clock cycles (`##[1:3] $rose(ack_signal)`).  \n4. The check is triggered at every rising edge of `clk_signal` and has no disable condition.  \n\n### Notes:  \n- The `if-else` construct in the consequent dynamically selects the expected response based on `irq_1`.  \n- Time ranges (`##[1:2]`, `##[1:3]`) specify the valid latency windows for the expected signals.", "sva_signals": ["clk_signal", "irq_0", "irq_1", "nested_int", "ack_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $rose(irq_0) |->     if (irq_1)         ##[1:2] $rose(nested_int)    else        ##[1:3] $rose(ack_signal)", "sva_name": "p_irq_0_response", "full_property": "property p_irq_response;\n@(posedge clk_signal)    $rose(irq_0) |->     if (irq_1)         ##[1:2] $rose(nested_int)    else        ##[1:3] $rose(ack_signal)\nendproperty\nassert_p_irq_response:assert property (p_irq_response) else $error(\"\");", "task_id": "3_611", "predict_sva": "@(posedge clk_signal)    $rose(irq_0) |-> (irq_1 ? ##[1:2] $rose(nested_int) : ##[1:3] $rose(ack_signal))"}
{"id": "3_12_0021", "name": "p_throughout_12", "sva": "@(posedge clk)     !debug_mode throughout (##1 trace_enable ##[2:5] trace_complete)", "ori_sva": "property p_throughout_12;\n@(posedge clk)     !debug_mode throughout (##1 trace_enable ##[2:5] trace_complete);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Trace_Sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a sequence assertion, not an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `!debug_mode throughout (##1 trace_enable ##[2:5] trace_complete)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] debug_mode", "[0:0] trace_enable", "[0:0] trace_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !debug_mode throughout (##1 trace_enable ##[2:5] trace_complete)", "sva_name": "p_Debug_Mode_Check", "full_property": "property p_Trace_Sequence;\n@(posedge clk)     !debug_mode throughout (##1 trace_enable ##[2:5] trace_complete);\nendproperty\nassert_p_Trace_Sequence:assert property (p_Trace_Sequence) else $error(\"\");", "task_id": "3_1938", "predict_sva": "@(posedge clk)     (!debug_mode) throughout (##1 trace_enable ##[2:5] trace_complete)"}
{"id": "212_9_1777", "name": "adc_ref_voltage_stable", "sva": "@(posedge clk_adc)     $rose(cal_start) |-> $stable(vref_high) && $stable(vref_low) throughout cal_done[->1]", "ori_sva": "property adc_ref_voltage_stable;\n@(posedge clk_adc)     $rose(cal_start) |-> $stable(vref_high) && $stable(vref_low) throughout cal_done[->1];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_CalStart_StableVref  \n**Trigger Condition**: At every posedge of `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cal_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(vref_high) && $stable(vref_low) throughout cal_done[->1]`  \n\n### Explanation of Consequent:  \n- `$stable(vref_high) && $stable(vref_low)`: Both `vref_high` and `vref_low` must remain unchanged (stable) during the specified interval.  \n- `throughout cal_done[->1]`: The stability condition must hold continuously from the time `cal_start` rises until the **first occurrence** of `cal_done` being asserted (`cal_done[->1]`). The `throughout` operator ensures the stability is maintained over this entire interval.  \n\n### Key Notes:  \n1. **`$rose(cal_start)`**: The property triggers when `cal_start` transitions from 0 to 1 (rising edge).  \n2. **Temporal Requirement**: The consequent enforces that `vref_high` and `vref_low` must not change from the moment `cal_start` rises until the first subsequent assertion of `cal_done`.  \n3. **No Disable Condition**: The property is always active unless overridden by a global disable.", "sva_signals": ["clk", "rst_n", "[0:0] cal_start", "[0:0] vref_high", "[0:0] vref_low", "[0:0] cal_done", "clk_adc"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)    $rose(cal_start) |-> ($stable(vref_high) && $stable(vref_low)) throughout cal_done[->1]", "sva_name": "p_vref_stable_during_calibration", "full_property": "property p_CalStart_StableVref;\n@(posedge clk_adc)    $rose(cal_start) |-> ($stable(vref_high) && $stable(vref_low)) throughout cal_done[->1]\nendproperty\nassert_p_CalStart_StableVref:assert property (p_CalStart_StableVref) else $error(\"\");", "task_id": "3_627", "predict_sva": "@(posedge clk_adc)    $rose(cal_start) |-> ($stable(vref_high) && $stable(vref_low)) throughout cal_done[->1]"}
{"sva": "@(posedge clk) disable iff(!rst_n) pipeline_advance |-> $past(decode_valid, 2) |=> (!$past(hazard_detected) && $past(resource_available))", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_advance_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `pipeline_advance == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(decode_valid, 2) |=> (!$past(hazard_detected) && $past(resource_available))`  ", "sva_signals": ["clk", "rst_n", "[0:0] pipeline_advance", "[0:0] decode_valid", "[0:0] hazard_detected", "[0:0] resource_available"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     pipeline_advance == 1'b1 |-> $past(decode_valid, 2) |=> (!$past(hazard_detected) && $past(resource_available))", "sva_name": "p_Pipeline_Advance_Check", "id": "0051", "full_property": "property p_pipeline_advance_check;\n@(posedge clk) disable iff (!rst_n)     pipeline_advance == 1'b1 |-> $past(decode_valid, 2) |=> (!$past(hazard_detected) && $past(resource_available))\nendproperty\nassert_p_pipeline_advance_check:assert property (p_pipeline_advance_check) else $error(\"\");", "task_id": "3_3882", "predict_sva": "@(posedge clk) disable iff (!rst_n)     pipeline_advance == 1'b1 |->      $past(decode_valid, 2) |=> (!$past(hazard_detected) && $past(resource_available))"}
{"id": "10_74_0839", "name": "p_onehot0_or_all_zero_74", "sva": "@(posedge clk) firmware_update |=> $onehot0(firmware_sections);", "sva_description": "### Assertion description:  \n**Property Name**: p_firmware_update_onehot0  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `firmware_update == 1'b1`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$onehot0(firmware_sections)`  \n\n### Explanation:  \n1. **Property Name**: The assertion is named `p_firmware_update_onehot0` to reflect its purpose of checking the `firmware_sections` signal after a `firmware_update`.  \n2. **Trigger Condition**: The assertion evaluates at every positive edge of `clk`.  \n3. **Disable Condition**: No reset or disable condition is specified.  \n4. **Antecedent**: The property triggers when `firmware_update` is high (`1'b1`).  \n5. **Implication**: The `|=>` operator ensures the consequent is checked **one clock cycle after** the antecedent holds.  \n6. **Consequent**: The `$onehot0(firmware_sections)` function verifies that no bits (or at most one bit) in `firmware_sections` are high in the next cycle, ensuring no overlapping firmware sections are active.  \n\n### Key Notes:  \n- `$onehot0(x)` returns true if `x` is all zeros **or** has exactly one bit set (unlike `$onehot(x)`, which requires exactly one bit set).  \n- The non-overlapping implication (`|=>`) ensures a 1-cycle delay before checking the consequent.  \n- This assertion ensures that after a `firmware_update`, the `firmware_sections` signal is either idle (all zeros) or points to a single valid section in the next cycle.", "sva_signals": ["clk", "rst_n", "[0:0] firmware_update", "[0:0] firmware_sections"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     firmware_update == 1'b1 |=> $onehot0(firmware_sections)", "sva_name": "p_firmware_update_check", "full_property": "property p_firmware_update_onehot0;\n@(posedge clk)     firmware_update == 1'b1 |=> $onehot0(firmware_sections)\nendproperty\nassert_p_firmware_update_onehot0:assert property (p_firmware_update_onehot0) else $error(\"\");", "task_id": "3_2309", "predict_sva": "@(posedge clk)     firmware_update == 1'b1 |=> $onehot0(firmware_sections)"}
{"sva": "@(posedge clk) disable iff(!voltage_good) pwr_sequence |-> $past(rail_stable, 1) && ($past(seq_step, 2) && !$past(under_volt))", "sva_description": "### Assertion description:  \n**Property Name**: p_pwr_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!voltage_good)`  \n**Antecedent (LHS of Implication)**: `pwr_sequence`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(rail_stable, 1) && ($past(seq_step, 2) && !$past(under_volt))`  ", "sva_signals": ["clk", "[0:0] voltage_good", "[0:0] pwr_sequence", "[0:0] rail_stable", "[0:0] seq_step", "[0:0] under_volt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!voltage_good)     pwr_sequence |-> ($past(rail_stable, 1) && ($past(seq_step, 2) && !$past(under_volt)))", "sva_name": "p_pwr_sequence_check", "id": "0113", "full_property": "property p_pwr_sequence;\n@(posedge clk) disable iff (!voltage_good)     pwr_sequence |-> ($past(rail_stable, 1) && ($past(seq_step, 2) && !$past(under_volt)))\nendproperty\nassert_p_pwr_sequence:assert property (p_pwr_sequence) else $error(\"\");", "task_id": "3_3939", "predict_sva": "@(posedge clk) disable iff (!voltage_good)     pwr_sequence |-> $past(rail_stable, 1) && ($past(seq_step, 2) && !$past(under_volt))"}
{"sva": "@(posedge clk) disable iff(reset) spi_transfer |-> chip_select ? shift_data : tri_state_bus", "sva_description": "### Assertion description:\n**Property Name**: p_spi_transfer_with_chip_select  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (reset)  \n**Antecedent (LHS of Implication)**: `spi_transfer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `chip_select ? shift_data : tri_state_bus`  \n\n### Explanation:\n- The property checks that whenever `spi_transfer` is active (antecedent), then (implication) the output should be `shift_data` if `chip_select` is true, otherwise it should be `tri_state_bus`.\n- The check is performed at every rising edge of `clk` and is disabled if `reset` is active.\n- The consequent uses a conditional operator (`?:`) to select between two possible outcomes based on the value of `chip_select`.", "sva_signals": ["clk", "reset", "[0:0] spi_transfer", "[0:0] chip_select", "[0:0] shift_data", "[0:0] tri_state_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reset)    spi_transfer |-> (chip_select ? shift_data : tri_state_bus)", "sva_name": "p_spi_transfer_check", "id": "0058", "full_property": "property p_spi_transfer_with_chip_select;\n@(posedge clk) disable iff (reset)    spi_transfer |-> (chip_select ? shift_data : tri_state_bus)\nendproperty\nassert_p_spi_transfer_with_chip_select:assert property (p_spi_transfer_with_chip_select) else $error(\"\");", "task_id": "3_2924", "predict_sva": "@(posedge clk) disable iff (reset)    spi_transfer |-> (chip_select ? shift_data : tri_state_bus)"}
{"sva": "@(posedge clk) disable iff(!system_rst) cache_protocol |-> $past(snoop_request, 3) |=> ($past(coherency_action) || $past(invalidate_line))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_protocol_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!system_rst)  \n**Antecedent (LHS of Implication)**: `cache_protocol == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(snoop_request, 3) |=> ($past(coherency_action) || $past(invalidate_line))`  ", "sva_signals": ["clk", "system_rst", "[0:0] cache_protocol", "[0:0] snoop_request", "[0:0] coherency_action", "[0:0] invalidate_line"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!system_rst)     cache_protocol == 1'b1 |->      $past(snoop_request, 3) |=> ($past(coherency_action) || $past(invalidate_line))", "sva_name": "p_cache_protocol_check", "id": "0232", "full_property": "property p_cache_protocol_check;\n@(posedge clk) disable iff (!system_rst)     cache_protocol == 1'b1 |->      $past(snoop_request, 3) |=> ($past(coherency_action) || $past(invalidate_line))\nendproperty\nassert_p_cache_protocol_check:assert property (p_cache_protocol_check) else $error(\"\");", "task_id": "3_4051", "predict_sva": "@(posedge clk) disable iff (!system_rst)     cache_protocol == 1'b1 |->      $past(snoop_request, 3) |=> ($past(coherency_action) || $past(invalidate_line))"}
{"sva": "@(posedge clk_100mhz) disable iff(!hw_reset) cache_hit_event |-> $past(tag_compare) && ($past(cache_enable_bit, 1) || $past(bypass_active))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_hit_event_check  \n**Trigger Condition**: At every rising edge of the `clk_100mhz`  \n**Disable Condition**: disable iff (!hw_reset)  \n**Antecedent (LHS of Implication)**: `cache_hit_event == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tag_compare) && ($past(cache_enable_bit, 1) || $past(bypass_active))`  ", "sva_signals": ["clk_100mhz", "hw_reset", "[0:0] cache_hit_event", "[0:0] tag_compare", "[0:0] cache_enable_bit", "[0:0] bypass_active"], "clock": "clk_100mhz", "attempts_left": 10, "sva_result": "@(posedge clk_100mhz) disable iff (!hw_reset)     cache_hit_event == 1'b1 |->      $past(tag_compare) && ($past(cache_enable_bit, 1) || $past(bypass_active))", "sva_name": "p_cache_hit_event_check", "id": "0165", "full_property": "property p_cache_hit_event_check;\n@(posedge clk_100mhz) disable iff (!hw_reset)     cache_hit_event == 1'b1 |->      $past(tag_compare) && ($past(cache_enable_bit, 1) || $past(bypass_active))\nendproperty\nassert_p_cache_hit_event_check:assert property (p_cache_hit_event_check) else $error(\"\");", "task_id": "3_3988", "predict_sva": "@(posedge clk_100mhz) disable iff (!hw_reset)     cache_hit_event == 1'b1 |-> $past(tag_compare) && ($past(cache_enable_bit, 1) || $past(bypass_active))"}
{"sva": "@(posedge clk_pcie) disable iff(!pcie_reset_n) packet_layer |-> $past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Layer_Flow_Control  \n**Trigger Condition**: At every rising edge of `clk_pcie`  \n**Disable Condition**: `disable iff (!pcie_reset_n)`  \n**Antecedent (LHS of Implication)**: `packet_layer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))`  ", "sva_signals": ["clk_pcie", "pcie_reset_n", "[0:0] packet_layer", "[0:0] flow_control", "[0:0] link_layer_ready", "[0:0] credits_available"], "clock": "clk_pcie", "attempts_left": 10, "sva_result": "@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2)))", "sva_name": "p_Packet_Layer_Check", "id": "0242", "full_property": "property p_Packet_Layer_Flow_Control;\n@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2)))\nendproperty\nassert_p_Packet_Layer_Flow_Control:assert property (p_Packet_Layer_Flow_Control) else $error(\"\");", "task_id": "3_4061", "predict_sva": "@(posedge clk_pcie) disable iff (~pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready, 2) && $past(credits_available)))"}
{"sva": "@(posedge blockchain_clk) disable iff(consensus_failed) distributed_ledger |-> (proof_of_work ? mine_block : validate_transaction)", "sva_description": "### Assertion description:  \n**Property Name**: p_distributed_ledger_operation  \n**Trigger Condition**: At every rising edge of the `blockchain_clk`  \n**Disable Condition**: `disable iff (consensus_failed)`  \n**Antecedent (LHS of Implication)**: `distributed_ledger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(proof_of_work ? mine_block : validate_transaction)`  \n\n### Explanation:  \nThe property checks that whenever `distributed_ledger` is true at a rising edge of `blockchain_clk` (and `consensus_failed` is not active), the system must either:  \n- Perform `mine_block` if `proof_of_work` is true, or  \n- Perform `validate_transaction` if `proof_of_work` is false.  \n\nThe assertion is disabled if `consensus_failed` is asserted.", "sva_signals": ["blockchain_clk", "consensus_failed", "[0:0] distributed_ledger", "[2:0] proof_of_work", "[0:0] mine_block", "[0:0] validate_transaction"], "clock": "blockchain_clk", "attempts_left": 10, "sva_result": "@(posedge blockchain_clk) disable iff (consensus_failed)    distributed_ledger |-> (proof_of_work ? mine_block : validate_transaction)", "sva_name": "p_distributed_ledger_operation", "id": "0236", "full_property": "property p_distributed_ledger_operation;\n@(posedge blockchain_clk) disable iff (consensus_failed)    distributed_ledger |-> (proof_of_work ? mine_block : validate_transaction)\nendproperty\nassert_p_distributed_ledger_operation:assert property (p_distributed_ledger_operation) else $error(\"\");", "task_id": "3_3100", "predict_sva": "@(posedge blockchain_clk) disable iff (consensus_failed)    distributed_ledger |-> (proof_of_work ? mine_block : validate_transaction)"}
{"id": "7_3_0148", "name": "p_until_with_3", "sva": "@(posedge clk)     start_pulse until_with (##[2:10] done ##1 status)", "ori_sva": "property p_until_with_3;\n@(posedge clk)     start_pulse until_with (##[2:10] done ##1 status);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_start_pulse_until_done_status  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start_pulse`  \n**Implication Operator**: `until_with`  \n**Consequent (RHS of Implication)**: `##[2:10] done ##1 status`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] start_pulse", "[0:0] done", "[0:0] status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     start_pulse until_with (##[2:10] done ##1 status)", "sva_name": "p_Start_Pulse_Done_Status", "full_property": "property p_start_pulse_until_done_status;\n@(posedge clk)     start_pulse until_with (##[2:10] done ##1 status);\nendproperty\nassert_p_start_pulse_until_done_status:assert property (p_start_pulse_until_done_status) else $error(\"\");", "task_id": "3_1808", "predict_sva": "@(posedge clk)    start_pulse |-> ##[2:10] done ##1 status"}
{"id": "11_61_0929", "name": "p_no_x_in_past_wr_enable", "sva": "@(posedge clk)      !$isunknown($past(mem_wr_en, 1)) |-> mem_wr_ack;", "sva_description": "### Assertion description:\n**Property Name**: p_mem_wr_ack_after_known_wr_en  \n**Trigger Condition**: At every evaluation point (implicit, no clock specified)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!$isunknown($past(mem_wr_en, 1))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mem_wr_ack`  \n\nNote: This assertion checks that whenever the past value of `mem_wr_en` (1 cycle ago) is known (not 'x' or 'z'), then `mem_wr_ack` must be true in the current cycle. The assertion is evaluated at every simulation time step since no clock edge is specified.", "sva_signals": ["clk", "rst_n", "[0:0] mem_wr_en", "[0:0] mem_wr_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) !$isunknown($past(mem_wr_en, 1)) |-> mem_wr_ack", "sva_name": "p_mem_wr_ack_after_en", "full_property": "property p_mem_wr_ack_after_known_wr_en;\n@(posedge clk) !$isunknown($past(mem_wr_en, 1)) |-> mem_wr_ack\nendproperty\nassert_p_mem_wr_ack_after_known_wr_en:assert property (p_mem_wr_ack_after_known_wr_en) else $error(\"\");", "task_id": "3_2373", "predict_sva": "@(posedge clk) $isunknown($past(mem_wr_en, 1)) == 0 |-> mem_wr_ack"}
{"sva": "@(posedge clk_spatial_rendering) disable iff(head_tracking_lost) immersive_audio |-> ($past(listener_position_update, 2) && $past(sound_source_localization)) |=> !$past(spatial_aliasing)", "sva_description": "### Assertion description:  \n**Property Name**: p_Immersive_Audio_Check  \n**Trigger Condition**: At every rising edge of `clk_spatial_rendering`  \n**Disable Condition**: `disable iff (head_tracking_lost)`  \n**Antecedent (LHS of Implication)**: `immersive_audio == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(listener_position_update, 2) && $past(sound_source_localization)) |=> !$past(spatial_aliasing)`  ", "sva_signals": ["clk_spatial_rendering", "head_tracking_lost", "[0:0] immersive_audio", "listener_position_update", "sound_source_localization", "spatial_aliasing"], "clock": "clk_spatial_rendering", "attempts_left": 10, "sva_result": "@(posedge clk_spatial_rendering) disable iff (head_tracking_lost)     immersive_audio == 1'b1 |->      ($past(listener_position_update, 2) && $past(sound_source_localization)) |=> !$past(spatial_aliasing)", "sva_name": "p_Immersive_Audio_Check", "id": "0853", "full_property": "property p_Immersive_Audio_Check;\n@(posedge clk_spatial_rendering) disable iff (head_tracking_lost)     immersive_audio == 1'b1 |->      ($past(listener_position_update, 2) && $past(sound_source_localization)) |=> !$past(spatial_aliasing)\nendproperty\nassert_p_Immersive_Audio_Check:assert property (p_Immersive_Audio_Check) else $error(\"\");", "task_id": "3_4638", "predict_sva": "@(posedge clk_spatial_rendering) disable iff (head_tracking_lost)     immersive_audio == 1'b1 |->      ($past(listener_position_update, 2) && $past(sound_source_localization)) |=> !$past(spatial_aliasing)"}
{"sva": "@(negedge clk_extrusion) disable iff(!screw_configuration_optimal) food_extrusion |-> $past(barrel_temperature_zone_control, 3) |=> ($past(product_expansion_ratio) && !$past(nutritional_degradation))", "sva_description": "### Assertion description:  \n**Property Name**: p_food_extrusion_check  \n**Trigger Condition**: At every falling edge of the `clk_extrusion`  \n**Disable Condition**: disable iff (!screw_configuration_optimal)  \n**Antecedent (LHS of Implication)**: `food_extrusion`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(barrel_temperature_zone_control, 3) |=> ($past(product_expansion_ratio) && !$past(nutritional_degradation))`  ", "sva_signals": ["clk_extrusion", "[0:0] screw_configuration_optimal", "[0:0] food_extrusion", "barrel_temperature_zone_control", "[0:0] product_expansion_ratio", "[0:0] nutritional_degradation"], "clock": "clk_extrusion", "attempts_left": 10, "sva_result": "@(negedge clk_extrusion) disable iff (!screw_configuration_optimal)     food_extrusion |-> $past(barrel_temperature_zone_control, 3) |=>                        ($past(product_expansion_ratio) && !$past(nutritional_degradation))", "sva_name": "p_food_extrusion_check", "id": "0901", "full_property": "property p_food_extrusion_check;\n@(negedge clk_extrusion) disable iff (!screw_configuration_optimal)     food_extrusion |-> $past(barrel_temperature_zone_control, 3) |=>                        ($past(product_expansion_ratio) && !$past(nutritional_degradation))\nendproperty\nassert_p_food_extrusion_check:assert property (p_food_extrusion_check) else $error(\"\");", "task_id": "3_4682", "predict_sva": "@(negedge clk_extrusion) disable iff (!screw_configuration_optimal)     food_extrusion |-> $past(barrel_temperature_zone_control, 3) |=> ($past(product_expansion_ratio) && !$past(nutritional_degradation))"}
{"sva": "@(posedge library_clk) disable iff(!catalog_synchronized) information_system |-> (search_query_complex ? (ai_assistance_available ? intelligent_search : keyword_matching) : browse_categories)", "sva_description": "### Assertion description:  \n**Property Name**: p_Information_System_Response  \n**Trigger Condition**: At every rising edge of the `library_clk`  \n**Disable Condition**: `disable iff (!catalog_synchronized)`  \n**Antecedent (LHS of Implication)**: `information_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(search_query_complex ? (ai_assistance_available ? intelligent_search : keyword_matching) : browse_categories)`  \n\n### Explanation:  \nThe property checks the system's response based on conditions when `information_system` is active.  \n- If `search_query_complex` is true:  \n  - If `ai_assistance_available` is true, the system should use `intelligent_search`.  \n  - Else, it should use `keyword_matching`.  \n- If `search_query_complex` is false, the system should default to `browse_categories`.  \nThe check is disabled if `catalog_synchronized` is low.", "sva_signals": ["library_clk", "catalog_synchronized", "[0:0] information_system", "[0:0] search_query_complex", "[0:0] ai_assistance_available", "[0:0] intelligent_search", "[0:0] keyword_matching", "[0:0] browse_categories"], "clock": "library_clk", "attempts_left": 10, "sva_result": "@(posedge library_clk) disable iff (!catalog_synchronized)    information_system |->         (search_query_complex ?             (ai_assistance_available ? intelligent_search : keyword_matching)             : browse_categories)", "sva_name": "p_information_system_behavior", "id": "0560", "full_property": "property p_Information_System_Response;\n@(posedge library_clk) disable iff (!catalog_synchronized)    information_system |->         (search_query_complex ?             (ai_assistance_available ? intelligent_search : keyword_matching)             : browse_categories)\nendproperty\nassert_p_Information_System_Response:assert property (p_Information_System_Response) else $error(\"\");", "task_id": "3_3419", "predict_sva": "@(posedge library_clk) disable iff (!catalog_synchronized)    information_system |->         (search_query_complex ? (ai_assistance_available ? intelligent_search : keyword_matching) : browse_categories)"}
{"sva": "@(negedge clk_metaverse) disable iff(!virtual_world_persistence) metaverse_economy |-> $past(virtual_asset_ownership, 3) |=> ($past(cross_platform_interoperability) && $past(digital_scarcity_maintenance))", "sva_description": "### Assertion description:  \n**Property Name**: p_Metaverse_Economy_Check  \n**Trigger Condition**: At every falling edge of the `clk_metaverse`  \n**Disable Condition**: disable iff (`!virtual_world_persistence`)  \n**Antecedent (LHS of Implication)**: `metaverse_economy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(virtual_asset_ownership, 3) |=> ($past(cross_platform_interoperability) && $past(digital_scarcity_maintenance))`  ", "sva_signals": ["clk_metaverse", "virtual_world_persistence", "[0:0] metaverse_economy", "[0:0] virtual_asset_ownership", "[0:0] cross_platform_interoperability", "[0:0] digital_scarcity_maintenance"], "clock": "clk_metaverse", "attempts_left": 10, "sva_result": "@(negedge clk_metaverse) disable iff (!virtual_world_persistence)     metaverse_economy == 1'b1 |->      $past(virtual_asset_ownership, 3) |=> ($past(cross_platform_interoperability) && $past(digital_scarcity_maintenance))", "sva_name": "p_metaverse_economy_check", "id": "0830", "full_property": "property p_Metaverse_Economy_Check;\n@(negedge clk_metaverse) disable iff (!virtual_world_persistence)     metaverse_economy == 1'b1 |->      $past(virtual_asset_ownership, 3) |=> ($past(cross_platform_interoperability) && $past(digital_scarcity_maintenance))\nendproperty\nassert_p_Metaverse_Economy_Check:assert property (p_Metaverse_Economy_Check) else $error(\"\");", "task_id": "3_4617", "predict_sva": "@(negedge clk_metaverse) disable iff (!virtual_world_persistence)     metaverse_economy == 1'b1 |->      $past(virtual_asset_ownership, 3) |=> ($past(cross_platform_interoperability) && $past(digital_scarcity_maintenance))"}
{"sva": "@(negedge clk_i2c) disable iff(bus_error) i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_i2c_start_condition_check  \n**Trigger Condition**: At every falling edge of `clk_i2c`  \n**Disable Condition**: `disable iff (bus_error)`  \n**Antecedent (LHS of Implication)**: `i2c_start_condition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))`  ", "sva_signals": ["clk_i2c", "[0:0] bus_error", "[0:0] i2c_start_condition", "[0:0] bus_busy", "[0:0] scl_high", "[0:0] sda_high"], "clock": "clk_i2c", "attempts_left": 10, "sva_result": "@(negedge clk_i2c) disable iff (bus_error)     i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))", "sva_name": "p_p_i2c_start_condition_check", "id": "0079", "full_property": "property p_i2c_start_condition_check;\n@(negedge clk_i2c) disable iff (bus_error)     i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))\nendproperty\nassert_p_i2c_start_condition_check:assert property (p_i2c_start_condition_check) else $error(\"\");", "task_id": "3_3908", "predict_sva": "@(negedge clk_i2c) disable iff (bus_error)     i2c_start_condition |-> ($past(bus_busy, 1) == 0 && ($past(scl_high, 1) && $past(sda_high, 1)))"}
{"sva": "@(negedge clk_iconography) disable iff(symbolic_interpretation_contested) visual_culture_analysis |-> $past(iconographic_program_identification, 2) |=> ($past(cultural_context_integration) && $past(comparative_analysis_completion))", "sva_description": "### Assertion description:  \n**Property Name**: p_Visual_Culture_Analysis  \n**Trigger Condition**: At every falling edge of the `clk_iconography`  \n**Disable Condition**: disable iff (`symbolic_interpretation_contested`)  \n**Antecedent (LHS of Implication)**: `visual_culture_analysis == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(iconographic_program_identification, 2) |=> ($past(cultural_context_integration) && $past(comparative_analysis_completion))`  ", "sva_signals": ["clk_iconography", "symbolic_interpretation_contested", "[0:0] visual_culture_analysis", "iconographic_program_identification", "cultural_context_integration", "[0:0] comparative_analysis_completion"], "clock": "clk_iconography", "attempts_left": 10, "sva_result": "@(negedge clk_iconography) disable iff (symbolic_interpretation_contested)     visual_culture_analysis == 1'b1 |->      $past(iconographic_program_identification, 2) |=>      ($past(cultural_context_integration) && $past(comparative_analysis_completion))", "sva_name": "p_visual_culture_analysis", "id": "0999", "full_property": "property p_Visual_Culture_Analysis;\n@(negedge clk_iconography) disable iff (symbolic_interpretation_contested)     visual_culture_analysis == 1'b1 |->      $past(iconographic_program_identification, 2) |=>      ($past(cultural_context_integration) && $past(comparative_analysis_completion))\nendproperty\nassert_p_Visual_Culture_Analysis:assert property (p_Visual_Culture_Analysis) else $error(\"\");", "task_id": "3_4770", "predict_sva": "@(negedge clk_iconography) disable iff (symbolic_interpretation_contested)     visual_culture_analysis == 1'b1 |->      ##2 ($past(iconographic_program_identification) |=> ($past(cultural_context_integration) && $past(comparative_analysis_completion)))"}
{"sva": "@(posedge adaptation_clk) disable iff(environment_stable) reinforcement_learning |-> (exploration_rate[7:0] ? explore_action : exploit_knowledge)", "sva_description": "### Assertion description:  \n**Property Name**: p_Reinforcement_Learning_Action  \n**Trigger Condition**: At every rising edge of the `adaptation_clk`  \n**Disable Condition**: disable iff (`environment_stable`)  \n**Antecedent (LHS of Implication)**: `reinforcement_learning`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`exploration_rate[7:0] ? explore_action : exploit_knowledge`)  \n\n### Explanation:  \n- The property checks that whenever `reinforcement_learning` is active (antecedent), the action taken (consequent) depends on the value of `exploration_rate[7:0]`.  \n  - If `exploration_rate[7:0]` is non-zero, the action should be `explore_action`.  \n  - If `exploration_rate[7:0]` is zero, the action should be `exploit_knowledge`.  \n- The check is performed at every rising edge of `adaptation_clk` unless `environment_stable` is asserted (disable condition).", "sva_signals": ["adaptation_clk", "environment_stable", "[0:0] reinforcement_learning", "[7:0] exploration_rate", "[0:0] explore_action", "[0:0] exploit_knowledge"], "clock": "adaptation_clk", "attempts_left": 10, "sva_result": "@(posedge adaptation_clk) disable iff (environment_stable)    reinforcement_learning |-> (exploration_rate[7:0] ? explore_action : exploit_knowledge)", "sva_name": "p_Reinforcement_Learning_Action", "id": "0247", "full_property": "property p_Reinforcement_Learning_Action;\n@(posedge adaptation_clk) disable iff (environment_stable)    reinforcement_learning |-> (exploration_rate[7:0] ? explore_action : exploit_knowledge)\nendproperty\nassert_p_Reinforcement_Learning_Action:assert property (p_Reinforcement_Learning_Action) else $error(\"\");", "task_id": "3_3111", "predict_sva": "@(posedge adaptation_clk) disable iff (environment_stable)    reinforcement_learning |-> (exploration_rate[7:0] ? explore_action : exploit_knowledge)"}
{"sva": "@(posedge causal_clk) disable iff(!confounding_controlled) inference_engine |-> (randomized_experiment ? (treatment_effect_significant ? causal_relationship : correlation_only) : observational_adjustment)", "sva_description": "### Assertion description:  \n**Property Name**: p_Causal_Inference_Check  \n**Trigger Condition**: At every rising edge of the `causal_clk`  \n**Disable Condition**: `disable iff (!confounding_controlled)`  \n**Antecedent (LHS of Implication)**: `inference_engine`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(randomized_experiment ? (treatment_effect_significant ? causal_relationship : correlation_only) : observational_adjustment)`  \n\n### Explanation:  \n1. The property evaluates causal inference logic triggered by the clock `causal_clk`.  \n2. The assertion is **disabled** if `confounding_controlled` is low (active-low reset).  \n3. **Antecedent**: When `inference_engine` is true, the consequent must hold.  \n4. **Consequent**: A nested ternary condition:  \n   - If `randomized_experiment` is true:  \n     - Further checks `treatment_effect_significant`:  \n       - If true, outputs `causal_relationship`.  \n       - Else, outputs `correlation_only`.  \n   - If `randomized_experiment` is false, outputs `observational_adjustment`.  \n\nThis assertion ensures the inference engine's output aligns with the experimental design (`randomized_experiment`) and significance of results (`treatment_effect_significant`).", "sva_signals": ["causal_clk", "[0:0] confounding_controlled", "[0:0] inference_engine", "[0:0] randomized_experiment", "[0:0] treatment_effect_significant", "[0:0] causal_relationship", "[0:0] correlation_only", "[0:0] observational_adjustment"], "clock": "causal_clk", "attempts_left": 10, "sva_result": "@(posedge causal_clk) disable iff (!confounding_controlled)    inference_engine |->         (randomized_experiment ?             (treatment_effect_significant ? causal_relationship : correlation_only) :             observational_adjustment)", "sva_name": "p_inference_engine_check", "id": "0499", "full_property": "property p_Causal_Inference_Check;\n@(posedge causal_clk) disable iff (!confounding_controlled)    inference_engine |->         (randomized_experiment ?             (treatment_effect_significant ? causal_relationship : correlation_only) :             observational_adjustment)\nendproperty\nassert_p_Causal_Inference_Check:assert property (p_Causal_Inference_Check) else $error(\"\");", "task_id": "3_3359", "predict_sva": "@(posedge causal_clk) disable iff (!confounding_controlled)    inference_engine |->         (randomized_experiment ?             (treatment_effect_significant ? causal_relationship : correlation_only)             : observational_adjustment)"}
{"id": "17_64_1491", "name": "p_multi_clock_64", "sva": "@(posedge clk_fast) f_r |-> @(posedge clk_slow) s_a", "sva_description": "### Assertion description:  \n**Property Name**: p_f_r_to_s_a  \n**Trigger Condition**: At every posedge of the `clk_fast`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `f_r == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: At the next posedge of `clk_slow`, `s_a` must hold (be true).  \n\n### Explanation:  \n- The property checks that whenever `f_r` is high (`1'b1`) at a rising edge of `clk_fast`, then at the **next** rising edge of `clk_slow`, the signal `s_a` must also be high (`1'b1`).  \n- This is a **clock-domain crossing (CDC)** assertion, where the antecedent (`f_r`) is evaluated in the `clk_fast` domain, and the consequent (`s_a`) is evaluated in the `clk_slow` domain.  \n- The assertion does not have a disable condition (no `disable iff` clause).  \n- The implication (`|->`) ensures that the consequent is checked **only if** the antecedent is true.  \n\n### Key Notes:  \n1. The assertion spans two clock domains (`clk_fast` and `clk_slow`).  \n2. The consequent (`s_a`) is checked at the **next** posedge of `clk_slow` after `f_r` is detected high on `clk_fast`.  \n3. If `f_r` is not high, the assertion does not enforce any requirement on `s_a`.  \n\nWould you like any additional clarifications or modifications to the description?", "sva_signals": ["clk_fast", "clk_slow", "[0:0] f_r", "[0:0] s_a"], "clock": "clk_fast", "attempts_left": 10, "sva_result": "@(posedge clk_fast)     f_r == 1'b1 |-> @(posedge clk_slow) s_a == 1'b1", "sva_name": "p_f_r_to_s_a", "full_property": "property p_f_r_to_s_a;\n@(posedge clk_fast)     f_r == 1'b1 |-> @(posedge clk_slow) s_a == 1'b1\nendproperty\nassert_p_f_r_to_s_a:assert property (p_f_r_to_s_a) else $error(\"\");", "task_id": "3_2571", "predict_sva": "@(posedge clk_fast)     f_r == 1'b1 |-> @(posedge clk_slow) s_a"}
{"id": "22_41_1899", "name": "p_intersect_41", "sva": "@(posedge clk)      (security_key_load ##3 security_key_verify) intersect (access_grant ##3 access_deny);", "sva_description": "### Assertion description:  \n**Property Name**: p_security_key_access_sequence  \n**Trigger Condition**: The sequence is evaluated continuously (not tied to a specific clock edge)  \n**Disable Condition**: None  \n**Sequence Description**:  \nThe assertion checks for the intersection of two sequences:  \n1. First sequence: `security_key_load` followed by `security_key_verify` after 3 clock cycles (`##3`)  \n2. Second sequence: `access_grant` followed by `access_deny` after 3 clock cycles (`##3`)  \n\nThe `intersect` operator requires both sequences to:  \n- Start at the same time  \n- End at the same time  \n- Have all intermediate conditions match simultaneously  \n\n**Behavior**: The assertion passes only when both sequences occur simultaneously with identical timing - meaning `security_key_load` and `access_grant` happen at the same cycle, then exactly 3 cycles later both `security_key_verify` and `access_deny` occur simultaneously.  \n\nNote: This is a sequence rather than a property with implication, so it doesn't have antecedent/consequent parts. The evaluation is based purely on the temporal relationship between the signals in both sequences.", "sva_signals": ["clk", "rst_n", "[0:0] security_key_load", "[0:0] security_key_verify", "[0:0] access_grant", "[0:0] access_deny"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) (security_key_load ##3 security_key_verify) intersect (access_grant ##3 access_deny)", "sva_name": "p_security_key_access", "full_property": "property p_security_key_access_sequence;\n@(posedge clk) (security_key_load ##3 security_key_verify) intersect (access_grant ##3 access_deny)\nendproperty\nassert_p_security_key_access_sequence:assert property (p_security_key_access_sequence) else $error(\"\");", "task_id": "3_2826", "predict_sva": "@(posedge clk)     (security_key_load ##3 security_key_verify) intersect      (access_grant ##3 access_deny)"}
{"sva": "@(posedge docking_clk) disable iff(!proximity_sensors_valid) spacecraft_rendezvous |-> (relative_velocity[11:0] < 12'd100 ? final_approach : abort_sequence)", "sva_description": "### Assertion description:  \n**Property Name**: p_Spacecraft_Rendezvous  \n**Trigger Condition**: At every rising edge of the `docking_clk`  \n**Disable Condition**: disable iff (!proximity_sensors_valid)  \n**Antecedent (LHS of Implication)**: `spacecraft_rendezvous`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(relative_velocity[11:0] < 12'd100) ? final_approach : abort_sequence`  \n\n### Explanation:  \n- The property checks the behavior of the spacecraft rendezvous process.  \n- When `spacecraft_rendezvous` is true, the system must ensure that:  \n  - If the `relative_velocity[11:0]` is less than 100, the `final_approach` signal is activated.  \n  - Otherwise, the `abort_sequence` signal is triggered.  \n- The assertion is disabled if `proximity_sensors_valid` is false (i.e., proximity sensor data is invalid).  \n- The check occurs on every rising edge of `docking_clk`.", "sva_signals": ["docking_clk", "proximity_sensors_valid", "[0:0] spacecraft_rendezvous", "[11:0] relative_velocity", "[0:0] final_approach", "[0:0] abort_sequence"], "clock": "docking_clk", "attempts_left": 10, "sva_result": "@(posedge docking_clk) disable iff (!proximity_sensors_valid)    spacecraft_rendezvous |-> ((relative_velocity[11:0] < 12'd100) ? final_approach : abort_sequence)", "sva_name": "p_spacecraft_rendezvous_check", "id": "0368", "full_property": "property p_Spacecraft_Rendezvous;\n@(posedge docking_clk) disable iff (!proximity_sensors_valid)    spacecraft_rendezvous |-> ((relative_velocity[11:0] < 12'd100) ? final_approach : abort_sequence)\nendproperty\nassert_p_Spacecraft_Rendezvous:assert property (p_Spacecraft_Rendezvous) else $error(\"\");", "task_id": "3_3231", "predict_sva": "@(posedge docking_clk) disable iff (!proximity_sensors_valid)    spacecraft_rendezvous |-> (relative_velocity[11:0] < 12'd100 ? final_approach : abort_sequence)"}
{"sva": "@(posedge power_clk) disable iff(!supply_good) power_manager |-> (load_change ? (efficiency_mode ? adaptive_switching : fixed_frequency) : steady_load)", "sva_description": "### Assertion description:  \n**Property Name**: p_power_manager_control  \n**Trigger Condition**: At every rising edge of the `power_clk`  \n**Disable Condition**: disable iff (!supply_good)  \n**Antecedent (LHS of Implication)**: `power_manager`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(load_change ? (efficiency_mode ? adaptive_switching : fixed_frequency) : steady_load)`  \n\n### Explanation:  \n1. The property checks the behavior of the power management system.  \n2. It triggers on every positive edge of `power_clk` but is disabled if `supply_good` is low (active-low reset).  \n3. If `power_manager` is active (antecedent), the system must select the appropriate power mode (consequent):  \n   - If `load_change` is true, it checks `efficiency_mode`:  \n     - If `efficiency_mode` is true, selects `adaptive_switching`.  \n     - Else, selects `fixed_frequency`.  \n   - If `load_change` is false, the system maintains `steady_load`.  \n\nThe assertion ensures the power manager correctly switches modes based on load and efficiency conditions.", "sva_signals": ["power_clk", "[0:0] supply_good", "[0:0] power_manager", "[0:0] load_change", "[0:0] efficiency_mode", "[0:0] adaptive_switching", "[0:0] fixed_frequency", "[0:0] steady_load"], "clock": "power_clk", "attempts_left": 10, "sva_result": "@(posedge power_clk) disable iff (!supply_good)    power_manager |-> (load_change ? (efficiency_mode ? adaptive_switching : fixed_frequency) : steady_load)", "sva_name": "p_power_manager_check", "id": "0903", "full_property": "property p_power_manager_control;\n@(posedge power_clk) disable iff (!supply_good)    power_manager |-> (load_change ? (efficiency_mode ? adaptive_switching : fixed_frequency) : steady_load)\nendproperty\nassert_p_power_manager_control:assert property (p_power_manager_control) else $error(\"\");", "task_id": "3_3742", "predict_sva": "@(posedge power_clk) disable iff (!supply_good)    power_manager |-> (load_change ? (efficiency_mode ? adaptive_switching : fixed_frequency) : steady_load)"}
{"sva": "@(negedge clk_phase_change_material) disable iff(thermal_regulation_ineffective) temperature_adaptive_fabric |-> $past(pcm_microcapsule_integration, 2) |=> ($past(thermal_comfort_enhancement) && $past(durability_after_thermal_cycling))", "sva_description": "### Assertion description:  \n**Property Name**: p_Temperature_Adaptive_Fabric  \n**Trigger Condition**: At every falling edge of the `clk_phase_change_material`  \n**Disable Condition**: `disable iff (thermal_regulation_ineffective)`  \n**Antecedent (LHS of Implication)**: `temperature_adaptive_fabric == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pcm_microcapsule_integration, 2) |=> ($past(thermal_comfort_enhancement) && $past(durability_after_thermal_cycling))`  ", "sva_signals": ["clk_phase_change_material", "thermal_regulation_ineffective", "[0:0] temperature_adaptive_fabric", "[0:0] pcm_microcapsule_integration", "[0:0] thermal_comfort_enhancement", "[0:0] durability_after_thermal_cycling"], "clock": "clk_phase_change_material", "attempts_left": 10, "sva_result": "@(negedge clk_phase_change_material) disable iff (thermal_regulation_ineffective)     temperature_adaptive_fabric == 1'b1 |->     $past(pcm_microcapsule_integration, 2) |=> ($past(thermal_comfort_enhancement) && $past(durability_after_thermal_cycling))", "sva_name": "p_Temperature_Adaptive_Fabric_Check", "id": "0954", "full_property": "property p_Temperature_Adaptive_Fabric;\n@(negedge clk_phase_change_material) disable iff (thermal_regulation_ineffective)     temperature_adaptive_fabric == 1'b1 |->     $past(pcm_microcapsule_integration, 2) |=> ($past(thermal_comfort_enhancement) && $past(durability_after_thermal_cycling))\nendproperty\nassert_p_Temperature_Adaptive_Fabric:assert property (p_Temperature_Adaptive_Fabric) else $error(\"\");", "task_id": "3_4730", "predict_sva": "@(negedge clk_phase_change_material) disable iff (thermal_regulation_ineffective)     temperature_adaptive_fabric == 1'b1 |->      $past(pcm_microcapsule_integration, 2) |=> ($past(thermal_comfort_enhancement) && $past(durability_after_thermal_cycling))"}
{"sva": "@(posedge diagnostic_clk) disable iff(!reagent_stability_confirmed) lab_analyzer |-> (test_result_validity[9:0] ? (quality_control_passed ? report_results : repeat_analysis) : calibrate_instrument)", "sva_description": "### Assertion description:  \n**Property Name**: p_Diagnostic_Test_Result  \n**Trigger Condition**: At every rising edge of the `diagnostic_clk`  \n**Disable Condition**: `disable iff (!reagent_stability_confirmed)`  \n**Antecedent (LHS of Implication)**: `lab_analyzer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(test_result_validity[9:0] ? (quality_control_passed ? report_results : repeat_analysis) : calibrate_instrument)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional expression:  \n1. If `test_result_validity[9:0]` is true (non-zero), then:  \n   - If `quality_control_passed` is true, the expected outcome is `report_results`.  \n   - Else, the expected outcome is `repeat_analysis`.  \n2. If `test_result_validity[9:0]` is false (zero), the expected outcome is `calibrate_instrument`.  \n\n### Notes:  \n- The property checks that when `lab_analyzer` is active (true), the system must follow the specified conditional logic for handling test results.  \n- The assertion is disabled if `reagent_stability_confirmed` is false (i.e., when reagents are unstable).", "sva_signals": ["diagnostic_clk", "reagent_stability_confirmed", "lab_analyzer", "[9:0] test_result_validity", "quality_control_passed", "report_results", "repeat_analysis", "calibrate_instrument"], "clock": "diagnostic_clk", "attempts_left": 10, "sva_result": "@(posedge diagnostic_clk) disable iff (!reagent_stability_confirmed)    lab_analyzer |->         (test_result_validity[9:0] ?             (quality_control_passed ? report_results : repeat_analysis) :             calibrate_instrument)", "sva_name": "p_lab_analyzer_check", "id": "0543", "full_property": "property p_Diagnostic_Test_Result;\n@(posedge diagnostic_clk) disable iff (!reagent_stability_confirmed)    lab_analyzer |->         (test_result_validity[9:0] ?             (quality_control_passed ? report_results : repeat_analysis) :             calibrate_instrument)\nendproperty\nassert_p_Diagnostic_Test_Result:assert property (p_Diagnostic_Test_Result) else $error(\"\");", "task_id": "3_3402", "predict_sva": "@(posedge diagnostic_clk) disable iff (!reagent_stability_confirmed)    lab_analyzer |->         (test_result_validity[9:0] ?             (quality_control_passed ? report_results : repeat_analysis) :             calibrate_instrument)"}
{"sva": "@(posedge core_clk) disable iff(debug_mode) pipeline_stage |-> (hazard_detected ? (forwarding_possible ? bypass_data : insert_bubble) : advance_pipeline)", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_hazard_handling  \n**Trigger Condition**: At every rising edge of the `core_clk`  \n**Disable Condition**: `disable iff (debug_mode)`  \n**Antecedent (LHS of Implication)**: `pipeline_stage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(hazard_detected ? (forwarding_possible ? bypass_data : insert_bubble) : advance_pipeline)`  \n\n### Explanation:  \nThe property checks the behavior of pipeline hazard handling logic.  \n- When `pipeline_stage` is active (antecedent), the consequent evaluates a nested conditional:  \n  1. If `hazard_detected` is true:  \n     - If `forwarding_possible` is true, use `bypass_data`.  \n     - Else, `insert_bubble`.  \n  2. If no hazard is detected (`hazard_detected` is false), `advance_pipeline` is expected.  \n- The check is disabled during `debug_mode`.", "sva_signals": ["core_clk", "[0:0] debug_mode", "[0:0] pipeline_stage", "[0:0] hazard_detected", "[0:0] forwarding_possible", "[0:0] bypass_data", "[0:0] insert_bubble", "[0:0] advance_pipeline"], "clock": "core_clk", "attempts_left": 10, "sva_result": "@(posedge core_clk) disable iff (debug_mode)    pipeline_stage |-> (hazard_detected ? (forwarding_possible ? bypass_data : insert_bubble) : advance_pipeline)", "sva_name": "p_pipeline_hazard_handling", "id": "0873", "full_property": "property p_pipeline_hazard_handling;\n@(posedge core_clk) disable iff (debug_mode)    pipeline_stage |-> (hazard_detected ? (forwarding_possible ? bypass_data : insert_bubble) : advance_pipeline)\nendproperty\nassert_p_pipeline_hazard_handling:assert property (p_pipeline_hazard_handling) else $error(\"\");", "task_id": "3_3712", "predict_sva": "@(posedge core_clk) disable iff (debug_mode)    pipeline_stage |-> (hazard_detected ? (forwarding_possible ? bypass_data : insert_bubble) : advance_pipeline)"}
{"sva": "@(posedge baking_clk) disable iff(!oven_preheated) bread_maker |-> (dough_proofing[7:0] ? (yeast_activation_complete ? start_baking : extend_proofing) : prepare_dough)", "sva_description": "### Assertion description:  \n**Property Name**: p_bread_maker_operation  \n**Trigger Condition**: At every rising edge of the `baking_clk`  \n**Disable Condition**: `disable iff (!oven_preheated)`  \n**Antecedent (LHS of Implication)**: `bread_maker`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(dough_proofing[7:0] ? (yeast_activation_complete ? start_baking : extend_proofing) : prepare_dough)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional operation:  \n1. If `dough_proofing[7:0]` is non-zero (true), then:  \n   - If `yeast_activation_complete` is true, the action is `start_baking`.  \n   - Else, the action is `extend_proofing`.  \n2. If `dough_proofing[7:0]` is zero (false), the action is `prepare_dough`.  \n\n### Summary:  \nThe property asserts that whenever `bread_maker` is active (true) at a rising edge of `baking_clk` (and the oven is preheated), the system must:  \n- Check the dough proofing status (`dough_proofing[7:0]`).  \n   - If proofing is ongoing, check yeast activation:  \n     - If complete, start baking.  \n     - Else, extend proofing.  \n   - If no proofing is detected, prepare the dough.  \nThe assertion is disabled if `oven_preheated` is false.", "sva_signals": ["baking_clk", "[0:0] oven_preheated", "[0:0] bread_maker", "[7:0] dough_proofing", "[0:0] yeast_activation_complete", "[0:0] start_baking", "[0:0] extend_proofing", "[0:0] prepare_dough"], "clock": "baking_clk", "attempts_left": 10, "sva_result": "@(posedge baking_clk)    disable iff (!oven_preheated)    bread_maker |-> (        dough_proofing[7:0] ?             (yeast_activation_complete ? start_baking : extend_proofing)             : prepare_dough    )", "sva_name": "p_Bread_Maker_Condition", "id": "0544", "full_property": "property p_bread_maker_operation;\n@(posedge baking_clk)    disable iff (!oven_preheated)    bread_maker |-> (        dough_proofing[7:0] ?             (yeast_activation_complete ? start_baking : extend_proofing)             : prepare_dough    )\nendproperty\nassert_p_bread_maker_operation:assert property (p_bread_maker_operation) else $error(\"\");", "task_id": "3_3403", "predict_sva": "@(posedge baking_clk) disable iff (!oven_preheated)    bread_maker |->         (dough_proofing[7:0] ?             (yeast_activation_complete ? start_baking : extend_proofing) :             prepare_dough)"}
{"sva": "@(posedge valve_clk) disable iff(!actuator_power) valve_controller |-> (position_change ? (feedback_valid ? servo_control : open_loop) : valve_position_hold)", "sva_description": "### Assertion description:  \n**Property Name**: p_valve_controller_behavior  \n**Trigger Condition**: At every rising edge of the `valve_clk`  \n**Disable Condition**: disable iff (!actuator_power)  \n**Antecedent (LHS of Implication)**: `valve_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(position_change ? (feedback_valid ? servo_control : open_loop) : valve_position_hold)`  \n\n### Explanation:  \n- The property checks the behavior of the valve controller logic.  \n- When `valve_controller` is active (antecedent), the consequent evaluates:  \n  - If `position_change` is true:  \n    - If `feedback_valid` is true, the output should be `servo_control`.  \n    - Else, the output should be `open_loop`.  \n  - If `position_change` is false, the valve should hold its position (`valve_position_hold`).  \n- The assertion is disabled if `actuator_power` is inactive.", "sva_signals": ["valve_clk", "actuator_power", "[0:0] valve_controller", "[0:0] position_change", "[0:0] feedback_valid", "[0:0] servo_control", "[0:0] open_loop", "[0:0] valve_position_hold"], "clock": "valve_clk", "attempts_left": 10, "sva_result": "@(posedge valve_clk) disable iff (!actuator_power)    valve_controller |-> (position_change ? (feedback_valid ? servo_control : open_loop) : valve_position_hold)", "sva_name": "p_valve_controller_behavior", "id": "0912", "full_property": "property p_valve_controller_behavior;\n@(posedge valve_clk) disable iff (!actuator_power)    valve_controller |-> (position_change ? (feedback_valid ? servo_control : open_loop) : valve_position_hold)\nendproperty\nassert_p_valve_controller_behavior:assert property (p_valve_controller_behavior) else $error(\"\");", "task_id": "3_3751", "predict_sva": "@(posedge valve_clk) disable iff (!actuator_power)    valve_controller |-> (position_change ? (feedback_valid ? servo_control : open_loop) : valve_position_hold)"}
{"id": "2_20_0013", "name": "p_not_nested_sequence", "sva": "@(posedge clk)     not (level1 |-> (level2 |-> level3))", "ori_sva": "property p_not_nested_sequence;\n@(posedge clk)     not (level1 |-> (level2 |-> level3));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: (Not specified in the given SVA)  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `level1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(level2 |-> level3)`  \n**Overall Assertion**: The assertion checks that it is **never** true that if `level1` holds, then it must imply that if `level2` holds, then `level3` must also hold. In other words, the nested implication `level1 |-> (level2 |-> level3)` is forbidden (always false).  \n\n### Key Notes:  \n1. The assertion uses a negation (`not`) to invalidate the entire nested implication structure.  \n2. The nested implication means:  \n   - If `level1` is true, then `level2` must imply `level3`.  \n3. The assertion fails if the nested implication ever evaluates to true during simulation.  \n\n### Simplified Interpretation:  \nThe property ensures that the scenario where `level1` triggers a requirement for `level2` to imply `level3` **does not occur** at any point during verification.", "sva_signals": ["clk", "rst_n", "[0:0] level1", "[0:0] level2", "[0:0] level3"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     not (level1 |-> (level2 |-> level3))", "sva_name": "check_level_sequence", "full_property": "property p_forbid_nested_implication;\n@(posedge clk)     not (level1 |-> (level2 |-> level3));\nendproperty\nassert_p_forbid_nested_implication:assert property (p_forbid_nested_implication) else $error(\"\");", "task_id": "3_1903", "predict_sva": "@(posedge clk)     !(level1 |-> (level2 |-> level3))"}
{"sva": "@(negedge servo_clk) disable iff(feedback_lost) servo_driver |-> (position_command ? (error_small ? fine_control : coarse_control) : servo_idle)", "sva_description": "### Assertion description:\n**Property Name**: p_servo_driver_control  \n**Trigger Condition**: At every negedge of the `servo_clk`  \n**Disable Condition**: disable iff (feedback_lost)  \n**Antecedent (LHS of Implication)**: `servo_driver`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(position_command ? (error_small ? fine_control : coarse_control) : servo_idle)`  \n\n### Explanation:\n1. The property evaluates at every falling edge of `servo_clk`.  \n2. The check is disabled if `feedback_lost` is asserted (active-high asynchronous reset).  \n3. If `servo_driver` is true (antecedent), then:  \n   - If `position_command` is true, further checks:  \n     - If `error_small` is true, `fine_control` must be active.  \n     - Else, `coarse_control` must be active.  \n   - If `position_command` is false, `servo_idle` must be active.  \n\nThe consequent is a nested ternary conditional that dynamically selects the expected control state based on `position_command` and `error_small`.", "sva_signals": ["servo_clk", "feedback_lost", "servo_driver", "[0:0] position_command", "[0:0] error_small", "fine_control", "coarse_control", "servo_idle"], "clock": "servo_clk", "attempts_left": 10, "sva_result": "@(negedge servo_clk) disable iff (feedback_lost)    servo_driver |-> (position_command ? (error_small ? fine_control : coarse_control) : servo_idle)", "sva_name": "p_servo_driver_control", "id": "0893", "full_property": "property p_servo_driver_control;\n@(negedge servo_clk) disable iff (feedback_lost)    servo_driver |-> (position_command ? (error_small ? fine_control : coarse_control) : servo_idle)\nendproperty\nassert_p_servo_driver_control:assert property (p_servo_driver_control) else $error(\"\");", "task_id": "3_3732", "predict_sva": "@(negedge servo_clk) disable iff (feedback_lost)    servo_driver |-> (position_command ? (error_small ? fine_control : coarse_control) : servo_idle)"}
{"sva": "@(negedge performance_clock) disable iff(counter_overflow) performance_monitor |-> (event_threshold_exceeded[9:0] ? (profiling_active ? collect_samples : (interrupt_enabled ? performance_interrupt : silent_counting)) : baseline_monitoring)", "sva_description": "### Assertion description:  \n**Property Name**: p_performance_monitor_behavior  \n**Trigger Condition**: At every negedge of the `performance_clock`  \n**Disable Condition**: disable iff (`counter_overflow`)  \n**Antecedent (LHS of Implication)**: `performance_monitor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(event_threshold_exceeded[9:0] ? (profiling_active ? collect_samples : (interrupt_enabled ? performance_interrupt : silent_counting)) : baseline_monitoring)`  \n\n**Consequent Breakdown**:  \n1. If `event_threshold_exceeded[9:0]` is non-zero:  \n   - If `profiling_active` is true: Execute `collect_samples`.  \n   - Else:  \n     - If `interrupt_enabled` is true: Trigger `performance_interrupt`.  \n     - Else: Perform `silent_counting`.  \n2. Else (no threshold exceeded): Execute `baseline_monitoring`.  \n\n**Note**: The consequent is a nested conditional expression that defines the expected behavior of the performance monitor based on the values of `event_threshold_exceeded`, `profiling_active`, and `interrupt_enabled`.", "sva_signals": ["performance_clock", "[0:0] counter_overflow", "[0:0] performance_monitor", "[9:0] event_threshold_exceeded", "[0:0] profiling_active", "[0:0] collect_samples", "[0:0] interrupt_enabled", "[0:0] performance_interrupt", "[0:0] silent_counting", "[0:0] baseline_monitoring"], "clock": "performance_clock", "attempts_left": 10, "sva_result": "@(negedge performance_clock) disable iff (counter_overflow)    performance_monitor |-> (        (|event_threshold_exceeded[9:0]) ? (            profiling_active ? collect_samples : (                interrupt_enabled ? performance_interrupt : silent_counting            )        ) : baseline_monitoring    )", "sva_name": "p_performance_monitor", "id": "0739", "full_property": "property p_performance_monitor_behavior;\n@(negedge performance_clock) disable iff (counter_overflow)    performance_monitor |-> (        (|event_threshold_exceeded[9:0]) ? (            profiling_active ? collect_samples : (                interrupt_enabled ? performance_interrupt : silent_counting            )        ) : baseline_monitoring    )\nendproperty\nassert_p_performance_monitor_behavior:assert property (p_performance_monitor_behavior) else $error(\"\");", "task_id": "3_3593", "predict_sva": "@(negedge performance_clock) disable iff (counter_overflow)    performance_monitor |->         (event_threshold_exceeded[9:0] ?             (profiling_active ? collect_samples :                 (interrupt_enabled ? performance_interrupt : silent_counting))         : baseline_monitoring)"}
{"sva": "@(negedge refrigeration_clk) disable iff(compressor_failure) cold_storage |-> (temperature_stability[9:0] ? (energy_efficiency_optimal ? maintain_cooling : optimize_cycle) : backup_cooling)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cold_Storage_Condition  \n**Trigger Condition**: At every negedge of the `refrigeration_clk`  \n**Disable Condition**: disable iff (`compressor_failure`)  \n**Antecedent (LHS of Implication)**: `cold_storage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(temperature_stability[9:0] ? (energy_efficiency_optimal ? maintain_cooling : optimize_cycle) : backup_cooling)`  \n\n### Explanation:  \n1. The property evaluates on the **falling edge** of `refrigeration_clk`.  \n2. The assertion is **disabled** if `compressor_failure` is active (asynchronous reset).  \n3. If `cold_storage` is true (antecedent), the consequent checks:  \n   - If `temperature_stability[9:0]` is non-zero:  \n     - Further checks `energy_efficiency_optimal`:  \n       - If true: `maintain_cooling` must hold.  \n       - Else: `optimize_cycle` must hold.  \n   - Else (if `temperature_stability[9:0]` is zero): `backup_cooling` must hold.  \n\nThe consequent is a **nested ternary expression** encoding conditional cooling behavior based on sensor inputs.", "sva_signals": ["refrigeration_clk", "compressor_failure", "[0:0] cold_storage", "[9:0] temperature_stability", "[0:0] energy_efficiency_optimal", "[0:0] maintain_cooling", "[0:0] optimize_cycle", "[0:0] backup_cooling"], "clock": "refrigeration_clk", "attempts_left": 10, "sva_result": "@(negedge refrigeration_clk) disable iff (compressor_failure)    cold_storage |-> (temperature_stability[9:0] ?                      (energy_efficiency_optimal ? maintain_cooling : optimize_cycle) :                      backup_cooling)", "sva_name": "p_Cold_Storage_Condition", "id": "0550", "full_property": "property p_Cold_Storage_Condition;\n@(negedge refrigeration_clk) disable iff (compressor_failure)    cold_storage |-> (temperature_stability[9:0] ?                      (energy_efficiency_optimal ? maintain_cooling : optimize_cycle) :                      backup_cooling)\nendproperty\nassert_p_Cold_Storage_Condition:assert property (p_Cold_Storage_Condition) else $error(\"\");", "task_id": "3_3409", "predict_sva": "@(negedge refrigeration_clk) disable iff (compressor_failure)    cold_storage |->         (temperature_stability[9:0] ?             (energy_efficiency_optimal ? maintain_cooling : optimize_cycle) :             backup_cooling)"}
{"sva": "@(negedge research_clk) disable iff(database_maintenance) academic_portal |-> (citation_network[15:0] ? (peer_review_complete ? publish_findings : revision_required) : literature_review)", "sva_description": "### Assertion description:  \n**Property Name**: p_Academic_Portal_Citation_Check  \n**Trigger Condition**: At every negedge of the `research_clk`  \n**Disable Condition**: `disable iff (database_maintenance)`  \n**Antecedent (LHS of Implication)**: `academic_portal`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(citation_network[15:0] ? (peer_review_complete ? publish_findings : revision_required) : literature_review)`  \n\n### Explanation of Consequent Logic:  \nThe consequent is a nested ternary conditional operation:  \n1. If `citation_network[15:0]` is non-zero:  \n   - If `peer_review_complete` is true, the result is `publish_findings`.  \n   - Else, the result is `revision_required`.  \n2. If `citation_network[15:0]` is zero, the result is `literature_review`.  \n\nThis property asserts that whenever `academic_portal` is active (antecedent), the consequent logic must evaluate based on the conditions above at the negedge of `research_clk`, unless `database_maintenance` is active (disabling condition).", "sva_signals": ["research_clk", "database_maintenance", "[0:0] academic_portal", "[15:0] citation_network", "[0:0] peer_review_complete", "[0:0] publish_findings", "[0:0] revision_required", "[0:0] literature_review"], "clock": "research_clk", "attempts_left": 10, "sva_result": "@(negedge research_clk) disable iff (database_maintenance)    academic_portal |->         (citation_network[15:0] ? (peer_review_complete ? publish_findings : revision_required) : literature_review)", "sva_name": "p_Academic_Portal_Check", "id": "0563", "full_property": "property p_Academic_Portal_Citation_Check;\n@(negedge research_clk) disable iff (database_maintenance)    academic_portal |->         (citation_network[15:0] ? (peer_review_complete ? publish_findings : revision_required) : literature_review)\nendproperty\nassert_p_Academic_Portal_Citation_Check:assert property (p_Academic_Portal_Citation_Check) else $error(\"\");", "task_id": "3_3422", "predict_sva": "@(negedge research_clk) disable iff (database_maintenance)    academic_portal |->         (citation_network[15:0] ?             (peer_review_complete ? publish_findings : revision_required) :             literature_review)"}
{"sva": "@(negedge drilling_clk) disable iff(chip_evacuation_poor) hole_maker |-> (drill_bit_temperature[11:0] ? (cooling_sufficient ? continue_drilling : increase_coolant) : dry_cutting)", "sva_description": "### Assertion description:\n**Property Name**: p_Drilling_Condition_Check  \n**Trigger Condition**: At every negedge of the `drilling_clk`  \n**Disable Condition**: disable iff (chip_evacuation_poor)  \n**Antecedent (LHS of Implication)**: `hole_maker`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(drill_bit_temperature[11:0] ? (cooling_sufficient ? continue_drilling : increase_coolant) : dry_cutting)`  \n\n**Explanation of Consequent**:  \nThe consequent is a conditional (ternary) expression that checks:  \n1. If `drill_bit_temperature[11:0]` is non-zero (true), then:  \n   - If `cooling_sufficient` is true, the action is `continue_drilling`  \n   - Else, the action is `increase_coolant`  \n2. Else (if `drill_bit_temperature[11:0]` is zero), the action is `dry_cutting`  \n\n**Note**: The property asserts that whenever `hole_maker` is active (antecedent), the consequent condition must hold true at the next negedge of `drilling_clk`, unless disabled by `chip_evacuation_poor`.", "sva_signals": ["drilling_clk", "chip_evacuation_poor", "[0:0] hole_maker", "[11:0] drill_bit_temperature", "[0:0] cooling_sufficient", "[0:0] continue_drilling", "[0:0] increase_coolant", "[0:0] dry_cutting"], "clock": "drilling_clk", "attempts_left": 10, "sva_result": "@(negedge drilling_clk) disable iff (chip_evacuation_poor)    hole_maker |-> (drill_bit_temperature[11:0] ? (cooling_sufficient ? continue_drilling : increase_coolant) : dry_cutting)", "sva_name": "p_hole_maker_drilling_action", "id": "0522", "full_property": "property p_Drilling_Condition_Check;\n@(negedge drilling_clk) disable iff (chip_evacuation_poor)    hole_maker |-> (drill_bit_temperature[11:0] ? (cooling_sufficient ? continue_drilling : increase_coolant) : dry_cutting)\nendproperty\nassert_p_Drilling_Condition_Check:assert property (p_Drilling_Condition_Check) else $error(\"\");", "task_id": "3_3382", "predict_sva": "@(negedge drilling_clk) disable iff (chip_evacuation_poor)    $past(hole_maker, 1) |->     (drill_bit_temperature[11:0] ?         (cooling_sufficient ? continue_drilling : increase_coolant) :         dry_cutting)"}
{"sva": "@(negedge lidar_clk) disable iff(laser_safety_violated) distance_measurement |-> (point_cloud_density[9:0] ? (object_detection_reliable ? autonomous_navigation : manual_override) : scanning_pattern)", "sva_description": "### Assertion description:  \n**Property Name**: p_Distance_Measurement_Response  \n**Trigger Condition**: At every negedge of the `lidar_clk`  \n**Disable Condition**: `disable iff (laser_safety_violated)`  \n**Antecedent (LHS of Implication)**: `distance_measurement == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- If `point_cloud_density[9:0]` is non-zero:  \n  - If `object_detection_reliable` is true, execute `autonomous_navigation`  \n  - Else, execute `manual_override`  \n- Else (if `point_cloud_density[9:0]` is zero), execute `scanning_pattern`  \n\n### Notes:  \n1. The consequent is a conditional ternary expression (`? :`), hierarchically nested to evaluate `point_cloud_density` first, then `object_detection_reliable`.  \n2. The property is disabled when `laser_safety_violated` is asserted, overriding all checks.  \n3. The assertion triggers on the falling edge of `lidar_clk`, unlike the more common rising-edge-triggered examples.", "sva_signals": ["lidar_clk", "laser_safety_violated", "[9:0] point_cloud_density", "[0:0] object_detection_reliable", "[0:0] autonomous_navigation", "[0:0] manual_override", "[0:0] scanning_pattern", "[0:0] distance_measurement"], "clock": "lidar_clk", "attempts_left": 10, "sva_result": "@(negedge lidar_clk) disable iff (laser_safety_violated)    distance_measurement == 1'b1 |->    (point_cloud_density[9:0] != 10'b0) ?         (object_detection_reliable ? autonomous_navigation : manual_override) :         scanning_pattern", "sva_name": "p_distance_measurement_response", "id": "0692", "full_property": "property p_Distance_Measurement_Response;\n@(negedge lidar_clk) disable iff (laser_safety_violated)    distance_measurement == 1'b1 |->    (point_cloud_density[9:0] != 10'b0) ?         (object_detection_reliable ? autonomous_navigation : manual_override) :         scanning_pattern\nendproperty\nassert_p_Distance_Measurement_Response:assert property (p_Distance_Measurement_Response) else $error(\"\");", "task_id": "3_3548", "predict_sva": "@(negedge lidar_clk) disable iff (laser_safety_violated)    distance_measurement |->         (point_cloud_density[9:0] ?             (object_detection_reliable ? autonomous_navigation : manual_override) :             scanning_pattern)"}
{"sva": "@(negedge plasma_clk) disable iff(!containment_stable) fusion_reactor |-> (temperature_keV[23:0] > 24'd1000000 ? sustain_reaction : ramp_heating)", "sva_description": "### Assertion description:  \n**Property Name**: p_Fusion_Reactor_Temperature_Check  \n**Trigger Condition**: At every negedge of the `plasma_clk`  \n**Disable Condition**: disable iff (!containment_stable)  \n**Antecedent (LHS of Implication)**: `fusion_reactor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(temperature_keV[23:0] > 24'd1000000) ? sustain_reaction : ramp_heating`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks the behavior of the fusion reactor based on temperature conditions.  \n2. **Trigger Condition**: Evaluated on every falling edge of `plasma_clk` (unlike typical rising-edge assertions).  \n3. **Disable Condition**: The assertion is disabled if `containment_stable` is low (i.e., `!containment_stable` is true), indicating unstable containment.  \n4. **Antecedent**: The check activates when `fusion_reactor` is true (reactor is active).  \n5. **Consequent**:  \n   - If the 24-bit `temperature_keV` exceeds `1,000,000`, the reactor must `sustain_reaction`.  \n   - Otherwise, it must initiate `ramp_heating`.  \n   - The ternary operator (`? :`) encodes this conditional logic directly in the assertion.  \n\n### Key Notes:  \n- The assertion enforces a safety protocol: High temperatures trigger sustained reactions, while lower temperatures mandate heating.  \n- The `negedge` trigger might align with specific reactor control timing requirements.  \n- Disabling on `!containment_stable` ensures the check is skipped during unsafe conditions.", "sva_signals": ["plasma_clk", "containment_stable", "[0:0] fusion_reactor", "[23:0] temperature_keV", "[0:0] sustain_reaction", "[0:0] ramp_heating"], "clock": "plasma_clk", "attempts_left": 10, "sva_result": "@(negedge plasma_clk) disable iff (!containment_stable)    fusion_reactor |-> ((temperature_keV[23:0] > 24'd1000000) ? sustain_reaction : ramp_heating)", "sva_name": "p_Fusion_Reactor_Condition", "id": "0191", "full_property": "property p_Fusion_Reactor_Temperature_Check;\n@(negedge plasma_clk) disable iff (!containment_stable)    fusion_reactor |-> ((temperature_keV[23:0] > 24'd1000000) ? sustain_reaction : ramp_heating)\nendproperty\nassert_p_Fusion_Reactor_Temperature_Check:assert property (p_Fusion_Reactor_Temperature_Check) else $error(\"\");", "task_id": "3_3055", "predict_sva": "@(negedge plasma_clk) disable iff (!containment_stable)    fusion_reactor |-> (temperature_keV[23:0] > 24'd1000000 ? sustain_reaction : ramp_heating)"}
{"sva": "@(negedge sustainability_clk) disable iff(carbon_offset_unavailable) green_initiative |-> (emission_reduction[11:0] ? (target_achieved ? maintain_practices : intensify_efforts) : measurement_phase)", "sva_description": "### Assertion description:\n**Property Name**: p_Green_Initiative_Check  \n**Trigger Condition**: At every negedge of the `sustainability_clk`  \n**Disable Condition**: disable iff (`carbon_offset_unavailable`)  \n**Antecedent (LHS of Implication)**: `green_initiative`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(emission_reduction[11:0] ? (target_achieved ? maintain_practices : intensify_efforts) : measurement_phase)`  \n\n### Explanation of the Consequent:\nThe consequent is a conditional (ternary) expression that evaluates as follows:  \n1. If `emission_reduction[11:0]` is non-zero:  \n   - If `target_achieved` is true, then `maintain_practices` must hold.  \n   - Else, `intensify_efforts` must hold.  \n2. If `emission_reduction[11:0]` is zero, `measurement_phase` must hold.  \n\n### Key Notes:\n- The property checks behavior on the *falling edge* of `sustainability_clk`.  \n- The assertion is *disabled* if `carbon_offset_unavailable` is active.  \n- The consequent dynamically selects one of three outcomes based on `emission_reduction` and `target_achieved`.", "sva_signals": ["sustainability_clk", "carbon_offset_unavailable", "[0:0] green_initiative", "[11:0] emission_reduction", "[0:0] target_achieved", "[0:0] maintain_practices", "[0:0] intensify_efforts", "[0:0] measurement_phase"], "clock": "sustainability_clk", "attempts_left": 10, "sva_result": "@(negedge sustainability_clk) disable iff (carbon_offset_unavailable)    green_initiative |-> (        emission_reduction[11:0] != 0 ?             (target_achieved ? maintain_practices : intensify_efforts) :             measurement_phase    )", "sva_name": "p_Green_Initiative_Check", "id": "0599", "full_property": "property p_Green_Initiative_Check;\n@(negedge sustainability_clk) disable iff (carbon_offset_unavailable)    green_initiative |-> (        emission_reduction[11:0] != 0 ?             (target_achieved ? maintain_practices : intensify_efforts) :             measurement_phase    )\nendproperty\nassert_p_Green_Initiative_Check:assert property (p_Green_Initiative_Check) else $error(\"\");", "task_id": "3_3457", "predict_sva": "@(negedge sustainability_clk) disable iff (carbon_offset_unavailable)    green_initiative |->         (emission_reduction[11:0] ?             (target_achieved ? maintain_practices : intensify_efforts) :             measurement_phase)"}
{"sva": "@(negedge clk) disable iff(system_halt) sensor_reading && $past(calibration_done) |-> measurement_valid", "sva_description": "### Assertion description:  \n**Property Name**: p_Measurement_Valid_After_Calibration  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: `disable iff (system_halt)`  \n**Antecedent (LHS of Implication)**: `sensor_reading && $past(calibration_done)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `measurement_valid`", "sva_signals": ["clk", "system_halt", "sensor_reading", "calibration_done", "measurement_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (system_halt)         (sensor_reading && $past(calibration_done)) |-> measurement_valid", "sva_name": "p_sensor_measurement_valid", "id": "1071", "full_property": "property p_Measurement_Valid_After_Calibration;\n@(negedge clk) disable iff (system_halt)         (sensor_reading && $past(calibration_done)) |-> measurement_valid\nendproperty\nassert_p_Measurement_Valid_After_Calibration:assert property (p_Measurement_Valid_After_Calibration) else $error(\"\");", "task_id": "3_4837", "predict_sva": "@(negedge clk) disable iff (system_halt)         (sensor_reading && $past(calibration_done)) |-> measurement_valid"}
{"sva": "@(posedge clk) crypto_operation && $past(key_loaded) && $past(data_input_valid) |-> encrypt_start", "sva_description": "### Assertion description:  \n**Property Name**: p_Crypto_Operation_Start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crypto_operation && $past(key_loaded) && $past(data_input_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `encrypt_start`", "sva_signals": ["clk", "rst_n", "[0:0] crypto_operation", "[0:0] key_loaded", "[0:0] data_input_valid", "[0:0] encrypt_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     crypto_operation && $past(key_loaded) && $past(data_input_valid) |-> encrypt_start", "sva_name": "p_Crypto_Operation_Start", "id": "1041", "full_property": "property p_Crypto_Operation_Start;\n@(posedge clk)     crypto_operation && $past(key_loaded) && $past(data_input_valid) |-> encrypt_start\nendproperty\nassert_p_Crypto_Operation_Start:assert property (p_Crypto_Operation_Start) else $error(\"\");", "task_id": "3_4808", "predict_sva": "@(posedge clk)         (crypto_operation && $past(key_loaded) && $past(data_input_valid)) |-> encrypt_start"}
{"sva": "@(posedge clk) holographic_storage |-> ($past(reference_beam) && $past(object_beam, 1)) && !$past(interference_pattern_error, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_Holographic_Storage_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `holographic_storage == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(reference_beam) && $past(object_beam, 1)) && !$past(interference_pattern_error, 2)`  \n\n(Note: The property checks that when `holographic_storage` is active, the past values of `reference_beam` and `object_beam` (1 cycle prior) must both be true, and the `interference_pattern_error` signal must have been inactive 2 cycles prior.)", "sva_signals": ["clk", "rst_n", "[0:0] holographic_storage", "[0:0] reference_beam", "[0:0] object_beam", "[0:0] interference_pattern_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         holographic_storage == 1'b1 |-> ($past(reference_beam) && $past(object_beam, 1)) && !$past(interference_pattern_error, 2)", "sva_name": "p_Holographic_Storage_Check", "id": "0401", "full_property": "property p_Holographic_Storage_Check;\n@(posedge clk)         holographic_storage == 1'b1 |-> ($past(reference_beam) && $past(object_beam, 1)) && !$past(interference_pattern_error, 2)\nendproperty\nassert_p_Holographic_Storage_Check:assert property (p_Holographic_Storage_Check) else $error(\"\");", "task_id": "3_4213", "predict_sva": "@(posedge clk)     holographic_storage == 1'b1 |->      ($past(reference_beam, 1) &&       $past(object_beam, 2) &&       !$past(interference_pattern_error, 3))"}
{"sva": "@(posedge rtc_clk) disable iff(!crystal_oscillating) real_time_clock |-> (time_register[31:0] ^ alarm_register[31:0] ? (alarm_match ? trigger_interrupt : continue_counting) : time_corruption)", "sva_description": "### Assertion description:  \n**Property Name**: p_Real_Time_Clock_Check  \n**Trigger Condition**: At every rising edge of the `rtc_clk`  \n**Disable Condition**: `disable iff (!crystal_oscillating)`  \n**Antecedent (LHS of Implication)**: `real_time_clock`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(time_register[31:0] ^ alarm_register[31:0] ? (alarm_match ? trigger_interrupt : continue_counting) : time_corruption)`  \n\n### Explanation:  \n1. The property checks the behavior of the real-time clock (`real_time_clock`) on every rising edge of `rtc_clk`.  \n2. The assertion is disabled if `crystal_oscillating` is low (`!crystal_oscillating`).  \n3. If `real_time_clock` is true (antecedent), the consequent evaluates:  \n   - If `time_register[31:0]` and `alarm_register[31:0]` are not equal (`^` denotes XOR), then:  \n     - If `alarm_match` is true, `trigger_interrupt` should occur.  \n     - Else (`alarm_match` is false), `continue_counting` should occur.  \n   - If `time_register[31:0]` and `alarm_register[31:0]` are equal, `time_corruption` is expected.  \n\nThis assertion ensures correct handling of alarm matching and time corruption detection in the real-time clock logic.", "sva_signals": ["rtc_clk", "crystal_oscillating", "[31:0] real_time_clock", "[31:0] time_register", "[31:0] alarm_register", "[0:0] alarm_match", "[0:0] trigger_interrupt", "[0:0] continue_counting", "[0:0] time_corruption"], "clock": "rtc_clk", "attempts_left": 10, "sva_result": "@(posedge rtc_clk) disable iff (!crystal_oscillating)    real_time_clock |-> (        (time_register[31:0] ^ alarm_register[31:0]) ?             (alarm_match ? trigger_interrupt : continue_counting) :             time_corruption    )", "sva_name": "p_real_time_clock_check", "id": "0771", "full_property": "property p_Real_Time_Clock_Check;\n@(posedge rtc_clk) disable iff (!crystal_oscillating)    real_time_clock |-> (        (time_register[31:0] ^ alarm_register[31:0]) ?             (alarm_match ? trigger_interrupt : continue_counting) :             time_corruption    )\nendproperty\nassert_p_Real_Time_Clock_Check:assert property (p_Real_Time_Clock_Check) else $error(\"\");", "task_id": "3_3621", "predict_sva": "@(posedge rtc_clk) disable iff (!crystal_oscillating)    real_time_clock |->         ((time_register[31:0] != alarm_register[31:0]) ?             (alarm_match ? trigger_interrupt : continue_counting) :             time_corruption)"}
{"sva": "@(posedge reliability_clock) disable iff(!error_detection_active) fault_tolerance |-> (soft_error_detected[7:0] ? (ecc_correction_possible ? correct_error : (redundant_execution ? vote_result : uncorrectable_error)) : error_free_operation)", "sva_description": "### Assertion description:  \n**Property Name**: p_Fault_Tolerance_Error_Handling  \n**Trigger Condition**: At every rising edge of the `reliability_clock`  \n**Disable Condition**: `disable iff (!error_detection_active)`  \n**Antecedent (LHS of Implication)**: `fault_tolerance`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(soft_error_detected[7:0] ? (ecc_correction_possible ? correct_error : (redundant_execution ? vote_result : uncorrectable_error)) : error_free_operation)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested conditional expression that describes the expected error-handling behavior:  \n1. If any bit in `soft_error_detected[7:0]` is non-zero (error detected):  \n   - If `ecc_correction_possible` is true, execute `correct_error`.  \n   - Else, if `redundant_execution` is true, use `vote_result`.  \n   - Else, declare `uncorrectable_error`.  \n2. If no error is detected (`soft_error_detected[7:0] == 0`), proceed with `error_free_operation`.  \n\nThis property ensures that the fault-tolerance mechanism correctly handles errors based on the system's capabilities (ECC correction, redundant execution) or reports the appropriate outcome (uncorrectable error or error-free operation).", "sva_signals": ["reliability_clock", "error_detection_active", "[0:0] fault_tolerance", "[7:0] soft_error_detected", "[0:0] ecc_correction_possible", "[0:0] correct_error", "[0:0] redundant_execution", "[0:0] vote_result", "[0:0] uncorrectable_error", "[0:0] error_free_operation"], "clock": "reliability_clock", "attempts_left": 10, "sva_result": "@(posedge reliability_clock) disable iff (!error_detection_active)    fault_tolerance |-> (        (|soft_error_detected[7:0]) ?             (ecc_correction_possible ? correct_error :                 (redundant_execution ? vote_result : uncorrectable_error))         : error_free_operation    )", "sva_name": "p_Fault_Tolerance_Error_Handling", "id": "0726", "full_property": "property p_Fault_Tolerance_Error_Handling;\n@(posedge reliability_clock) disable iff (!error_detection_active)    fault_tolerance |-> (        (|soft_error_detected[7:0]) ?             (ecc_correction_possible ? correct_error :                 (redundant_execution ? vote_result : uncorrectable_error))         : error_free_operation    )\nendproperty\nassert_p_Fault_Tolerance_Error_Handling:assert property (p_Fault_Tolerance_Error_Handling) else $error(\"\");", "task_id": "3_3581", "predict_sva": "@(posedge reliability_clock) disable iff (!error_detection_active)    fault_tolerance |->         (soft_error_detected[7:0] ?             (ecc_correction_possible ? correct_error :                 (redundant_execution ? vote_result : uncorrectable_error))         : error_free_operation)"}
{"sva": "@(negedge clk) can_bus_transmit && $past(arbitration_won) && $past(stuff_bit_insert) |-> transmission_active", "sva_description": "### Assertion description:  \n**Property Name**: p_Transmission_Active  \n**Trigger Condition**: At every falling edge of the `clk`;  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_bus_transmit && $past(arbitration_won) && $past(stuff_bit_insert)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `transmission_active`", "sva_signals": ["clk", "rst_n", "[0:0] can_bus_transmit", "[0:0] arbitration_won", "[0:0] stuff_bit_insert", "[0:0] transmission_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (can_bus_transmit && $past(arbitration_won) && $past(stuff_bit_insert)) |-> transmission_active", "sva_name": "p_can_bus_transmit_condition", "id": "1064", "full_property": "property p_Transmission_Active;\n@(negedge clk)     (can_bus_transmit && $past(arbitration_won) && $past(stuff_bit_insert)) |-> transmission_active\nendproperty\nassert_p_Transmission_Active:assert property (p_Transmission_Active) else $error(\"\");", "task_id": "3_4830", "predict_sva": "@(negedge clk)     can_bus_transmit && $past(arbitration_won) && $past(stuff_bit_insert) |-> transmission_active"}
{"sva": "@(negedge spi_clk) disable iff(cs_deasserted) serial_interface |-> ((mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0] ? (transfer_complete ? latch_result : continue_shifting) : idle_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_serial_interface_behavior  \n**Trigger Condition**: At every negedge of the `spi_clk`  \n**Disable Condition**: disable iff (cs_deasserted)  \n**Antecedent (LHS of Implication)**: `serial_interface`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`((mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0]) ? (transfer_complete ? latch_result : continue_shifting) : idle_state`  \n\n### Explanation of the Consequent:  \nThe consequent is a conditional expression that evaluates as follows:  \n1. If `(mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0]` is **true**:  \n   - If `transfer_complete` is **true**, the result is `latch_result`.  \n   - Else (`transfer_complete` is **false`), the result is `continue_shifting`.  \n2. Else (the bitwise OR result is **false**), the result is `idle_state`.  \n\nThis assertion checks that whenever `serial_interface` is active (antecedent), the SPI behavior follows the specified shifting and state transition logic (consequent) on the falling edge of `spi_clk`, unless disabled by `cs_deasserted`.", "sva_signals": ["spi_clk", "[0:0] cs_deasserted", "[7:0] mosi_data", "[7:0] miso_data", "[2:0] shift_count", "[0:0] transfer_complete", "[0:0] latch_result", "[0:0] continue_shifting", "[0:0] idle_state", "[0:0] serial_interface"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(negedge spi_clk) disable iff (cs_deasserted)    serial_interface |->         ((mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0]) ?             (transfer_complete ? latch_result : continue_shifting) :             idle_state", "sva_name": "p_serial_interface_check", "id": "0774", "full_property": "property p_serial_interface_behavior;\n@(negedge spi_clk) disable iff (cs_deasserted)    serial_interface |->         ((mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0]) ?             (transfer_complete ? latch_result : continue_shifting) :             idle_state\nendproperty\nassert_p_serial_interface_behavior:assert property (p_serial_interface_behavior) else $error(\"\");", "task_id": "3_3623", "predict_sva": "@(negedge spi_clk) disable iff (cs_deasserted)    serial_interface |->         ((mosi_data[7:0] << shift_count[2:0]) | miso_data[7:0]) ?             (transfer_complete ? latch_result : continue_shifting) :             idle_state"}
{"sva": "@(posedge bch_clk) disable iff(field_error) bch_encoder |-> (message_polynomial[127:0] && generator_polynomial_valid ? (systematic_code ? append_parity : non_systematic) : polynomial_setup)", "sva_description": "### Assertion description:\n**Property Name**: p_bch_encoder_output  \n**Trigger Condition**: At every rising edge of the `bch_clk`  \n**Disable Condition**: disable iff (field_error)  \n**Antecedent (LHS of Implication)**: `bch_encoder`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(message_polynomial[127:0] && generator_polynomial_valid ? (systematic_code ? append_parity : non_systematic) : polynomial_setup)`  \n\n**Consequent Explanation**:  \nThe consequent is a conditional expression that evaluates to:  \n1. If `message_polynomial[127:0]` is non-zero AND `generator_polynomial_valid` is true:  \n   - When `systematic_code` is true, the result is `append_parity`  \n   - When `systematic_code` is false, the result is `non_systematic`  \n2. Otherwise (if either condition fails), the result is `polynomial_setup`", "sva_signals": ["bch_clk", "field_error", "[0:0] bch_encoder", "[127:0] message_polynomial", "[0:0] generator_polynomial_valid", "[0:0] systematic_code", "[0:0] append_parity", "[0:0] non_systematic", "[0:0] polynomial_setup"], "clock": "bch_clk", "attempts_left": 10, "sva_result": "@(posedge bch_clk) disable iff (field_error)    bch_encoder |-> (message_polynomial[127:0] && generator_polynomial_valid) ?                     (systematic_code ? append_parity : non_systematic) :                     polynomial_setup", "sva_name": "p_bch_encoder_check", "id": "0934", "full_property": "property p_bch_encoder_output;\n@(posedge bch_clk) disable iff (field_error)    bch_encoder |-> (message_polynomial[127:0] && generator_polynomial_valid) ?                     (systematic_code ? append_parity : non_systematic) :                     polynomial_setup\nendproperty\nassert_p_bch_encoder_output:assert property (p_bch_encoder_output) else $error(\"\");", "task_id": "3_3771", "predict_sva": "@(posedge bch_clk) disable iff (field_error)    bch_encoder |->         ((message_polynomial[127:0] && generator_polynomial_valid) ?             (systematic_code ? append_parity : non_systematic) :             polynomial_setup)"}
{"sva": "@(posedge compassion_clock) disable iff(!suffering_detector_active) empathy_amplifier |-> (pain_resonance[11:0] ? (deep_compassion ? loving_kindness : (sympathetic_concern ? caring_response : emotional_distance)) : indifferent_processing)", "sva_description": "### Assertion description:\n**Property Name**: p_Empathy_Response  \n**Trigger Condition**: At every posedge of the `compassion_clock`  \n**Disable Condition**: disable iff (`!suffering_detector_active`)  \n**Antecedent (LHS of Implication)**: `empathy_amplifier`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(pain_resonance[11:0] ? (deep_compassion ? loving_kindness : (sympathetic_concern ? caring_response : emotional_distance)) : indifferent_processing)`  \n\n### Explanation of Consequent Logic:\n1. If `pain_resonance[11:0]` is non-zero (true), then:  \n   - If `deep_compassion` is true, the output is `loving_kindness`.  \n   - Else, if `sympathetic_concern` is true, the output is `caring_response`.  \n   - Else, the output is `emotional_distance`.  \n2. If `pain_resonance[11:0]` is zero (false), the output is `indifferent_processing`.  \n\n### Notes:\n- The property evaluates the empathy response hierarchy based on `pain_resonance` and auxiliary signals (`deep_compassion`, `sympathetic_concern`).  \n- The assertion is disabled when `suffering_detector_active` is low.", "sva_signals": ["compassion_clock", "suffering_detector_active", "[0:0] empathy_amplifier", "[11:0] pain_resonance", "[0:0] deep_compassion", "[0:0] loving_kindness", "[0:0] sympathetic_concern", "[0:0] caring_response", "[0:0] emotional_distance", "[0:0] indifferent_processing"], "clock": "compassion_clock", "attempts_left": 10, "sva_result": "@(posedge compassion_clock) disable iff (!suffering_detector_active)    empathy_amplifier |->         (pain_resonance[11:0] ?             (deep_compassion ? loving_kindness :                 (sympathetic_concern ? caring_response : emotional_distance))             : indifferent_processing)", "sva_name": "p_Empathy_Response", "id": "0753", "full_property": "property p_Empathy_Response;\n@(posedge compassion_clock) disable iff (!suffering_detector_active)    empathy_amplifier |->         (pain_resonance[11:0] ?             (deep_compassion ? loving_kindness :                 (sympathetic_concern ? caring_response : emotional_distance))             : indifferent_processing)\nendproperty\nassert_p_Empathy_Response:assert property (p_Empathy_Response) else $error(\"\");", "task_id": "3_3606", "predict_sva": "@(posedge compassion_clock) disable iff (!suffering_detector_active)    empathy_amplifier |->         (pain_resonance[11:0] ?             (deep_compassion ? loving_kindness :                 (sympathetic_concern ? caring_response : emotional_distance))         : indifferent_processing)"}
{"sva": "@(posedge clk) disable iff(!reset_pin) retinal_scanner_identify && $past(pupil_tracking_stable, 7) |-> vascular_pattern_analysis", "sva_description": "### Assertion description:  \n**Property Name**: p_retinal_scanner_identify_with_stable_pupil  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff `(!reset_pin)`  \n**Antecedent (LHS of Implication)**: `retinal_scanner_identify && $past(pupil_tracking_stable, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `vascular_pattern_analysis`  \n\n", "sva_signals": ["clk", "reset_pin", "[0:0] retinal_scanner_identify", "[0:0] pupil_tracking_stable", "[0:0] vascular_pattern_analysis"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!reset_pin)         (retinal_scanner_identify && $past(pupil_tracking_stable, 7)) |-> vascular_pattern_analysis", "sva_name": "p_retinal_scanner_identify", "id": "1136", "full_property": "property p_retinal_scanner_identify_with_stable_pupil;\n@(posedge clk) disable iff (!reset_pin)         (retinal_scanner_identify && $past(pupil_tracking_stable, 7)) |-> vascular_pattern_analysis\nendproperty\nassert_p_retinal_scanner_identify_with_stable_pupil:assert property (p_retinal_scanner_identify_with_stable_pupil) else $error(\"\");", "task_id": "3_4900", "predict_sva": "@(posedge clk) disable iff (!reset_pin)     retinal_scanner_identify && $past(pupil_tracking_stable, 7) |-> vascular_pattern_analysis"}
{"sva": "@(posedge clk_start_stop_system) disable iff(rst_engine_restart == 1'b1) idle_elimination_strategy |-> $past(battery_capacity_verification, 8) && fuel_saving_activation", "sva_description": "### Assertion description:  \n**Property Name**: p_idle_elimination_strategy_check  \n**Trigger Condition**: At every rising edge of the `clk_start_stop_system`  \n**Disable Condition**: disable iff (`rst_engine_restart == 1'b1`)  \n**Antecedent (LHS of Implication)**: `idle_elimination_strategy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(battery_capacity_verification, 8) && fuel_saving_activation`  ", "sva_signals": ["clk", "rst_engine_restart", "[0:0] idle_elimination_strategy", "[15:0] battery_capacity_verification", "[0:0] fuel_saving_activation", "clk_start_stop_system"], "clock": "clk_start_stop_system", "attempts_left": 10, "sva_result": "@(posedge clk_start_stop_system) disable iff (rst_engine_restart == 1'b1)     idle_elimination_strategy |-> ($past(battery_capacity_verification, 8) && fuel_saving_activation)", "sva_name": "p_idle_elimination_strategy", "id": "1773", "full_property": "property p_idle_elimination_strategy_check;\n@(posedge clk_start_stop_system) disable iff (rst_engine_restart == 1'b1)     idle_elimination_strategy |-> ($past(battery_capacity_verification, 8) && fuel_saving_activation)\nendproperty\nassert_p_idle_elimination_strategy_check:assert property (p_idle_elimination_strategy_check) else $error(\"\");", "task_id": "3_5526", "predict_sva": "@(posedge clk_start_stop_system) disable iff (rst_engine_restart == 1'b1)     idle_elimination_strategy |-> $past(battery_capacity_verification, 8) && fuel_saving_activation"}
{"sva": "@(negedge clk_tx) disable iff(loopback_mode) packet_retry |=> $past(nak_received | timeout_expired, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_retry_condition  \n**Trigger Condition**: At every falling edge of the `clk_tx`  \n**Disable Condition**: `disable iff (loopback_mode)`  \n**Antecedent (LHS of Implication)**: `packet_retry`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(nak_received | timeout_expired, 1)`  ", "sva_signals": ["clk_tx", "loopback_mode", "[0:0] packet_retry", "[0:0] nak_received", "[0:0] timeout_expired"], "clock": "clk_tx", "attempts_left": 10, "sva_result": "@(negedge clk_tx) disable iff (loopback_mode)     packet_retry |=> $past(nak_received | timeout_expired, 1)", "sva_name": "p_packet_retry_cause", "id": "2096", "full_property": "property p_packet_retry_condition;\n@(negedge clk_tx) disable iff (loopback_mode)     packet_retry |=> $past(nak_received | timeout_expired, 1)\nendproperty\nassert_p_packet_retry_condition:assert property (p_packet_retry_condition) else $error(\"\");", "task_id": "3_5844", "predict_sva": "@(negedge clk_tx) disable iff (loopback_mode)     packet_retry == 1'b1 |-> ($past(nak_received) || $past(timeout_expired))"}
{"sva": "@(posedge clk_image_sensor) disable iff(rst_cmos_sensor) rolling_shutter_readout && $past(exposure_time_control_stable, 8) |-> pixel_analog_digital_conversion", "sva_description": "### Assertion description:  \n**Property Name**: p_rolling_shutter_readout_stable_conversion  \n**Trigger Condition**: At every rising edge of the `clk_image_sensor`  \n**Disable Condition**: `disable iff (rst_cmos_sensor)`  \n**Antecedent (LHS of Implication)**: `rolling_shutter_readout && $past(exposure_time_control_stable, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pixel_analog_digital_conversion`  ", "sva_signals": ["clk_image_sensor", "rst_cmos_sensor", "[0:0] rolling_shutter_readout", "[0:0] exposure_time_control_stable", "[0:0] pixel_analog_digital_conversion"], "clock": "clk_image_sensor", "attempts_left": 10, "sva_result": "@(posedge clk_image_sensor) disable iff (rst_cmos_sensor)         (rolling_shutter_readout && $past(exposure_time_control_stable, 8)) |-> pixel_analog_digital_conversion", "sva_name": "p_rolling_shutter_readout_conversion", "id": "1260", "full_property": "property p_rolling_shutter_readout_stable_conversion;\n@(posedge clk_image_sensor) disable iff (rst_cmos_sensor)         (rolling_shutter_readout && $past(exposure_time_control_stable, 8)) |-> pixel_analog_digital_conversion\nendproperty\nassert_p_rolling_shutter_readout_stable_conversion:assert property (p_rolling_shutter_readout_stable_conversion) else $error(\"\");", "task_id": "3_5020", "predict_sva": "@(posedge clk_image_sensor) disable iff (rst_cmos_sensor)     (rolling_shutter_readout && $past(exposure_time_control_stable, 8)) |-> pixel_analog_digital_conversion"}
{"sva": "@(posedge sys_clock) disable iff(!enable_monitor) spi_conflict |-> $past(cs_active & miso_drive, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_conflict_check  \n**Trigger Condition**: At every rising edge of the `sys_clock`  \n**Disable Condition**: disable iff `(!enable_monitor)`  \n**Antecedent (LHS of Implication)**: `spi_conflict`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cs_active & miso_drive, 1)`  \n\n(Note: The consequent checks that one clock cycle earlier, both `cs_active` and `miso_drive` were asserted.)", "sva_signals": ["sys_clock", "enable_monitor", "[0:0] spi_conflict", "[0:0] cs_active", "[0:0] miso_drive"], "clock": "sys_clock", "attempts_left": 10, "sva_result": "@(posedge sys_clock) disable iff (!enable_monitor)     spi_conflict |-> $past(cs_active & miso_drive, 1)", "sva_name": "p_spi_conflict_check", "id": "2100", "full_property": "property p_spi_conflict_check;\n@(posedge sys_clock) disable iff (!enable_monitor)     spi_conflict |-> $past(cs_active & miso_drive, 1)\nendproperty\nassert_p_spi_conflict_check:assert property (p_spi_conflict_check) else $error(\"\");", "task_id": "3_5847", "predict_sva": "@(posedge sys_clock) disable iff (!enable_monitor)     spi_conflict |-> $past(cs_active & miso_drive, 1)"}
{"sva": "@(negedge holographic_clk) disable iff(interference_lost) holographic_processor |-> ((reference_beam[31:0] ^ object_beam[31:0]) | phase_conjugate[31:0] ? (hologram_formed ? information_storage : (coherence_lost ? noise_pattern : partial_hologram)) : no_interference)", "sva_description": "### Assertion description:  \n**Property Name**: p_Holographic_Interference  \n**Trigger Condition**: At every negedge of the `holographic_clk`  \n**Disable Condition**: disable iff (`interference_lost`)  \n**Antecedent (LHS of Implication)**: `holographic_processor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`((reference_beam[31:0] ^ object_beam[31:0]) | phase_conjugate[31:0]) ?`  \n`(hologram_formed ? information_storage : (coherence_lost ? noise_pattern : partial_hologram)) : no_interference)`  \n\n### Explanation of the Consequent:  \nThe consequent is a conditional expression with nested ternary operators:  \n1. The primary condition checks whether the bitwise XOR of `reference_beam[31:0]` and `object_beam[31:0]` ORed with `phase_conjugate[31:0]` evaluates to true (non-zero).  \n   - If **true**, it further evaluates:  \n     - If `hologram_formed` is true, the result is `information_storage`.  \n     - Else, if `coherence_lost` is true, the result is `noise_pattern`; otherwise, it is `partial_hologram`.  \n   - If **false**, the result is `no_interference`.  \n\nThis property ensures that the holographic processor's output follows the expected interference pattern logic under the specified conditions.", "sva_signals": ["holographic_clk", "[0:0] interference_lost", "[0:0] holographic_processor", "[31:0] reference_beam", "[31:0] object_beam", "[31:0] phase_conjugate", "[0:0] hologram_formed", "[0:0] information_storage", "[0:0] coherence_lost", "[0:0] noise_pattern", "[0:0] partial_hologram", "[0:0] no_interference"], "clock": "holographic_clk", "attempts_left": 10, "sva_result": "@(negedge holographic_clk) disable iff (interference_lost)    holographic_processor |->     ((reference_beam[31:0] ^ object_beam[31:0]) | phase_conjugate[31:0]) ?     (hologram_formed ? information_storage : (coherence_lost ? noise_pattern : partial_hologram)) :     no_interference", "sva_name": "p_Holographic_Processor_Check", "id": "0801", "full_property": "property p_Holographic_Interference;\n@(negedge holographic_clk) disable iff (interference_lost)    holographic_processor |->     ((reference_beam[31:0] ^ object_beam[31:0]) | phase_conjugate[31:0]) ?     (hologram_formed ? information_storage : (coherence_lost ? noise_pattern : partial_hologram)) :     no_interference\nendproperty\nassert_p_Holographic_Interference:assert property (p_Holographic_Interference) else $error(\"\");", "task_id": "3_3644", "predict_sva": "@(negedge holographic_clk) disable iff (interference_lost)    holographic_processor |->     ((reference_beam[31:0] ^ object_beam[31:0]) | phase_conjugate[31:0]) ?     (hologram_formed ? information_storage : (coherence_lost ? noise_pattern : partial_hologram)) : no_interference"}
{"sva": "@(posedge clk_vehicle_localization) disable iff(!inertial_navigation_reset) global_positioning_fusion && $past(dead_reckoning_error_correction, 6) |-> precise_position_determination", "sva_description": "### Assertion description:  \n**Property Name**: p_Precise_Position_Determination  \n**Trigger Condition**: At every rising edge of the `clk_vehicle_localization`  \n**Disable Condition**: disable iff (`!inertial_navigation_reset`)  \n**Antecedent (LHS of Implication)**: `global_positioning_fusion && $past(dead_reckoning_error_correction, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `precise_position_determination`", "sva_signals": ["clk_vehicle_localization", "inertial_navigation_reset", "[0:0] global_positioning_fusion", "[0:0] dead_reckoning_error_correction", "[0:0] precise_position_determination"], "clock": "clk_vehicle_localization", "attempts_left": 10, "sva_result": "@(posedge clk_vehicle_localization) disable iff (!inertial_navigation_reset)         (global_positioning_fusion && $past(dead_reckoning_error_correction, 6)) |-> precise_position_determination", "sva_name": "p_precise_position_determination", "id": "1833", "full_property": "property p_Precise_Position_Determination;\n@(posedge clk_vehicle_localization) disable iff (!inertial_navigation_reset)         (global_positioning_fusion && $past(dead_reckoning_error_correction, 6)) |-> precise_position_determination\nendproperty\nassert_p_Precise_Position_Determination:assert property (p_Precise_Position_Determination) else $error(\"\");", "task_id": "3_5586", "predict_sva": "@(posedge clk_vehicle_localization) disable iff (!inertial_navigation_reset)         (global_positioning_fusion && $past(dead_reckoning_error_correction, 6)) |-> precise_position_determination"}
{"sva": "@(posedge clk_netting_agreement) disable iff(rst_exposure_calculation == 1'b1) master_agreement_framework |-> $past(close_out_netting_validation, 7) && credit_risk_reduction", "sva_description": "### Assertion description:  \n**Property Name**: p_master_agreement_framework_check  \n**Trigger Condition**: At every rising edge of the `clk_netting_agreement`  \n**Disable Condition**: `disable iff (rst_exposure_calculation == 1'b1)`  \n**Antecedent (LHS of Implication)**: `master_agreement_framework == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(close_out_netting_validation, 7) && credit_risk_reduction`  ", "sva_signals": ["clk_netting_agreement", "rst_exposure_calculation", "[0:0] master_agreement_framework", "[0:0] close_out_netting_validation", "[0:0] credit_risk_reduction"], "clock": "clk_netting_agreement", "attempts_left": 10, "sva_result": "@(posedge clk_netting_agreement) disable iff (rst_exposure_calculation == 1'b1)     master_agreement_framework == 1'b1 |-> $past(close_out_netting_validation, 7) && credit_risk_reduction", "sva_name": "p_master_agreement_credit_risk", "id": "1714", "full_property": "property p_master_agreement_framework_check;\n@(posedge clk_netting_agreement) disable iff (rst_exposure_calculation == 1'b1)     master_agreement_framework == 1'b1 |-> $past(close_out_netting_validation, 7) && credit_risk_reduction\nendproperty\nassert_p_master_agreement_framework_check:assert property (p_master_agreement_framework_check) else $error(\"\");", "task_id": "3_5469", "predict_sva": "@(posedge clk_netting_agreement) disable iff (rst_exposure_calculation == 1'b1)     master_agreement_framework == 1'b1 |-> $past(close_out_netting_validation, 7) && credit_risk_reduction"}
{"sva": "@(negedge clk_touch) disable iff(!capacitive_ready) touch_detection_threshold |-> $past(capacitance_delta[11:0] > detection_level, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_touch_detection_threshold  \n**Trigger Condition**: At every falling edge of the `clk_touch`  \n**Disable Condition**: disable iff (!capacitive_ready)  \n**Antecedent (LHS of Implication)**: `touch_detection_threshold`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(capacitance_delta[11:0] > detection_level, 1)`  \n\n(Note: The assertion checks that whenever `touch_detection_threshold` is true at the falling edge of `clk_touch` (while `capacitive_ready` is active), the past value of `capacitance_delta[11:0]` from one cycle earlier must have been greater than `detection_level`.)", "sva_signals": ["clk_touch", "capacitive_ready", "[0:0] touch_detection_threshold", "[11:0] capacitance_delta", "[11:0] detection_level"], "clock": "clk_touch", "attempts_left": 10, "sva_result": "@(negedge clk_touch) disable iff (!capacitive_ready)     touch_detection_threshold |-> $past(capacitance_delta[11:0] > detection_level, 1)", "sva_name": "p_touch_detection_threshold", "id": "2167", "full_property": "property p_touch_detection_threshold;\n@(negedge clk_touch) disable iff (!capacitive_ready)     touch_detection_threshold |-> $past(capacitance_delta[11:0] > detection_level, 1)\nendproperty\nassert_p_touch_detection_threshold:assert property (p_touch_detection_threshold) else $error(\"\");", "task_id": "3_5911", "predict_sva": "@(negedge clk_touch) disable iff (!capacitive_ready)     touch_detection_threshold |-> $past(capacitance_delta[11:0] > detection_level, 1)"}
{"sva": "@(negedge clk_touch) disable iff(!touch_ready) capacitive_drift |-> $past(baseline_value[11:0] != calibrated_baseline[11:0], 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_Capacitive_Drift_Check  \n**Trigger Condition**: At every falling edge of `clk_touch`  \n**Disable Condition**: disable iff (`!touch_ready`)  \n**Antecedent (LHS of Implication)**: `capacitive_drift`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(baseline_value[11:0] != calibrated_baseline[11:0], 2)`  ", "sva_signals": ["clk_touch", "touch_ready", "[0:0] capacitive_drift", "[11:0] baseline_value", "[11:0] calibrated_baseline"], "clock": "clk_touch", "attempts_left": 10, "sva_result": "@(negedge clk_touch) disable iff (!touch_ready)     capacitive_drift |-> $past(baseline_value[11:0] != calibrated_baseline[11:0], 2)", "sva_name": "p_Capacitive_Drift_Check", "id": "2140", "full_property": "property p_Capacitive_Drift_Check;\n@(negedge clk_touch) disable iff (!touch_ready)     capacitive_drift |-> $past(baseline_value[11:0] != calibrated_baseline[11:0], 2)\nendproperty\nassert_p_Capacitive_Drift_Check:assert property (p_Capacitive_Drift_Check) else $error(\"\");", "task_id": "3_5885", "predict_sva": "@(negedge clk_touch) disable iff (!touch_ready)     capacitive_drift |-> $past(baseline_value[11:0] != calibrated_baseline[11:0], 2)"}
{"sva": "@(posedge clk_codec) disable iff(!codec_power) sample_interpolation |=> ($past(input_sample[15:0], 1) != $past(output_sample[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Sample_Interpolation_Check  \n**Trigger Condition**: At every rising edge of the `clk_codec`  \n**Disable Condition**: `disable iff (!codec_power)`  \n**Antecedent (LHS of Implication)**: `sample_interpolation`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(input_sample[15:0], 1) != $past(output_sample[15:0], 1)`  ", "sva_signals": ["clk_codec", "codec_power", "[0:0] sample_interpolation", "[15:0] input_sample", "[15:0] output_sample"], "clock": "clk_codec", "attempts_left": 10, "sva_result": "@(posedge clk_codec) disable iff (!codec_power)     sample_interpolation |=> $past(input_sample[15:0], 1) != $past(output_sample[15:0], 1)", "sva_name": "p_sample_interpolation_check", "id": "2159", "full_property": "property p_Sample_Interpolation_Check;\n@(posedge clk_codec) disable iff (!codec_power)     sample_interpolation |=> $past(input_sample[15:0], 1) != $past(output_sample[15:0], 1)\nendproperty\nassert_p_Sample_Interpolation_Check:assert property (p_Sample_Interpolation_Check) else $error(\"\");", "task_id": "3_5903", "predict_sva": "@(posedge clk_codec) disable iff (!codec_power)     sample_interpolation |-> ($past(input_sample[15:0], 1) != $past(output_sample[15:0], 1))"}
{"sva": "@(negedge clk_pcm) disable iff(!audio_interface) pulse_code_modulation_sync |-> $past(frame_sync_pulse & bit_clock_active, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_pulse_code_modulation_sync  \n**Trigger Condition**: At every falling edge of the `clk_pcm`  \n**Disable Condition**: `disable iff (!audio_interface)`  \n**Antecedent (LHS of Implication)**: `pulse_code_modulation_sync`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(frame_sync_pulse & bit_clock_active, 1)`  ", "sva_signals": ["clk_pcm", "[0:0] audio_interface", "[0:0] pulse_code_modulation_sync", "[0:0] frame_sync_pulse", "[0:0] bit_clock_active"], "clock": "clk_pcm", "attempts_left": 10, "sva_result": "@(negedge clk_pcm) disable iff (!audio_interface)     pulse_code_modulation_sync |-> $past(frame_sync_pulse & bit_clock_active, 1)", "sva_name": "p_pulse_code_modulation_sync", "id": "2215", "full_property": "property p_pulse_code_modulation_sync;\n@(negedge clk_pcm) disable iff (!audio_interface)     pulse_code_modulation_sync |-> $past(frame_sync_pulse & bit_clock_active, 1)\nendproperty\nassert_p_pulse_code_modulation_sync:assert property (p_pulse_code_modulation_sync) else $error(\"\");", "task_id": "3_5957", "predict_sva": "@(negedge clk_pcm) disable iff (!audio_interface)     pulse_code_modulation_sync |-> $past(frame_sync_pulse & bit_clock_active, 1)"}
{"sva": "@(negedge clk_cybersecurity_manufacturing) disable iff(rst_industrial_firewall) network_intrusion_detection && $past(anomalous_traffic_pattern_analysis, 9) |-> operational_technology_protection", "sva_description": "### Assertion description:  \n**Property Name**: p_Operational_Technology_Protection  \n**Trigger Condition**: At every falling edge of the `clk_cybersecurity_manufacturing`  \n**Disable Condition**: disable iff (`rst_industrial_firewall`)  \n**Antecedent (LHS of Implication)**: `network_intrusion_detection && $past(anomalous_traffic_pattern_analysis, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `operational_technology_protection`", "sva_signals": ["clk_cybersecurity_manufacturing", "rst_industrial_firewall", "[0:0] network_intrusion_detection", "[0:0] anomalous_traffic_pattern_analysis", "[0:0] operational_technology_protection"], "clock": "clk_cybersecurity_manufacturing", "attempts_left": 10, "sva_result": "@(negedge clk_cybersecurity_manufacturing) disable iff (rst_industrial_firewall)         (network_intrusion_detection && $past(anomalous_traffic_pattern_analysis, 9)) |-> operational_technology_protection", "sva_name": "p_Operational_Technology_Protection", "id": "1906", "full_property": "property p_Operational_Technology_Protection;\n@(negedge clk_cybersecurity_manufacturing) disable iff (rst_industrial_firewall)         (network_intrusion_detection && $past(anomalous_traffic_pattern_analysis, 9)) |-> operational_technology_protection\nendproperty\nassert_p_Operational_Technology_Protection:assert property (p_Operational_Technology_Protection) else $error(\"\");", "task_id": "3_5656", "predict_sva": "@(negedge clk_cybersecurity_manufacturing) disable iff (rst_industrial_firewall)         (network_intrusion_detection && $past(anomalous_traffic_pattern_analysis, 9)) |-> operational_technology_protection"}
{"sva": "@(negedge clk_pwm) disable iff(!pwm_enable) duty_cycle_violation |-> $past(compare_value[15:0] > period_value[15:0], 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_duty_cycle_violation  \n**Trigger Condition**: At every falling edge of the `clk_pwm`  \n**Disable Condition**: disable iff (!pwm_enable)  \n**Antecedent (LHS of Implication)**: `duty_cycle_violation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(compare_value[15:0] > period_value[15:0], 1)`  \n\n(Note: The assertion checks that whenever `duty_cycle_violation` is high at the falling edge of `clk_pwm` (and `pwm_enable` is active), the comparison between the past value of `compare_value[15:0]` and `period_value[15:0]` must have been true one clock cycle earlier.)", "sva_signals": ["clk_pwm", "pwm_enable", "[0:0] duty_cycle_violation", "[15:0] compare_value", "[15:0] period_value"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(negedge clk_pwm) disable iff (!pwm_enable)     duty_cycle_violation == 1'b1 |-> $past(compare_value[15:0] > period_value[15:0], 1)", "sva_name": "p_duty_cycle_violation_check", "id": "2157", "full_property": "property p_duty_cycle_violation;\n@(negedge clk_pwm) disable iff (!pwm_enable)     duty_cycle_violation == 1'b1 |-> $past(compare_value[15:0] > period_value[15:0], 1)\nendproperty\nassert_p_duty_cycle_violation:assert property (p_duty_cycle_violation) else $error(\"\");", "task_id": "3_5901", "predict_sva": "@(negedge clk_pwm) disable iff (!pwm_enable)     duty_cycle_violation == 1'b1 |-> $past(compare_value[15:0] > period_value[15:0], 1)"}
{"sva": "@(negedge clk_ceilometer) disable iff(!cloud_height_enable) cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_cloud_base_height_measurement  \n**Trigger Condition**: At every falling edge of the `clk_ceilometer`  \n**Disable Condition**: disable iff (`!cloud_height_enable`)  \n**Antecedent (LHS of Implication)**: `cloud_base_height_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)`  ", "sva_signals": ["clk_ceilometer", "cloud_height_enable", "[15:0] cloud_base_height_measurement", "[15:0] laser_pulse_backscatter", "[11:0] cloud_layer_detection", "[0:0] vertical_visibility"], "clock": "clk_ceilometer", "attempts_left": 10, "sva_result": "@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)", "sva_name": "p_cloud_base_height_measurement", "id": "2707", "full_property": "property p_cloud_base_height_measurement;\n@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)\nendproperty\nassert_p_cloud_base_height_measurement:assert property (p_cloud_base_height_measurement) else $error(\"\");", "task_id": "3_6367", "predict_sva": "@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)"}
{"sva": "@(negedge clk_dark_matter) disable iff(!dark_matter_enable) weakly_interacting_massive_particle_detector |=> $past(nuclear_recoil_energy[11:0] & background_discrimination & seasonal_modulation, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_WeaklyInteractingMassiveParticleDetection  \n**Trigger Condition**: At every falling edge of `clk_dark_matter`  \n**Disable Condition**: `disable iff (!dark_matter_enable)`  \n**Antecedent (LHS of Implication)**: `weakly_interacting_massive_particle_detector`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(nuclear_recoil_energy[11:0] & background_discrimination & seasonal_modulation, 1)`  ", "sva_signals": ["clk_dark_matter", "dark_matter_enable", "[0:0] weakly_interacting_massive_particle_detector", "[11:0] nuclear_recoil_energy", "[0:0] background_discrimination", "[0:0] seasonal_modulation"], "clock": "clk_dark_matter", "attempts_left": 10, "sva_result": "@(negedge clk_dark_matter) disable iff (!dark_matter_enable)     weakly_interacting_massive_particle_detector |=>      $past(nuclear_recoil_energy[11:0] & background_discrimination & seasonal_modulation, 1)", "sva_name": "p_weakly_interacting_massive_particle_detection", "id": "2635", "full_property": "property p_WeaklyInteractingMassiveParticleDetection;\n@(negedge clk_dark_matter) disable iff (!dark_matter_enable)     weakly_interacting_massive_particle_detector |=>      $past(nuclear_recoil_energy[11:0] & background_discrimination & seasonal_modulation, 1)\nendproperty\nassert_p_WeaklyInteractingMassiveParticleDetection:assert property (p_WeaklyInteractingMassiveParticleDetection) else $error(\"\");", "task_id": "3_6307", "predict_sva": "@(negedge clk_dark_matter) disable iff (!dark_matter_enable)     weakly_interacting_massive_particle_detector |->          $past(nuclear_recoil_energy[11:0] & background_discrimination & seasonal_modulation, 1)"}
{"sva": "@(posedge clk_nor_ctrl) disable iff(!nor_flash_ready) nor_flash_memory_interface |=> ($past(sector_erase_command, 1) && $past(program_suspend_resume, 1) && $past(status_register_polling, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_nor_flash_memory_interface  \n**Trigger Condition**: At every rising edge of `clk_nor_ctrl`  \n**Disable Condition**: `disable iff (!nor_flash_ready)`  \n**Antecedent (LHS of Implication)**: `nor_flash_memory_interface`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(sector_erase_command, 1) && $past(program_suspend_resume, 1) && $past(status_register_polling, 1)`  ", "sva_signals": ["clk", "rst_n", "nor_flash_ready", "nor_flash_memory_interface", "[0:0] sector_erase_command", "[0:0] program_suspend_resume", "[0:0] status_register_polling", "clk_nor_ctrl"], "clock": "clk_nor_ctrl", "attempts_left": 10, "sva_result": "@(posedge clk_nor_ctrl) disable iff (!nor_flash_ready)     nor_flash_memory_interface |=>      ($past(sector_erase_command, 1) && $past(program_suspend_resume, 1) && $past(status_register_polling, 1))", "sva_name": "p_nor_flash_memory_interface", "id": "2453", "full_property": "property p_nor_flash_memory_interface;\n@(posedge clk_nor_ctrl) disable iff (!nor_flash_ready)     nor_flash_memory_interface |=>      ($past(sector_erase_command, 1) && $past(program_suspend_resume, 1) && $past(status_register_polling, 1))\nendproperty\nassert_p_nor_flash_memory_interface:assert property (p_nor_flash_memory_interface) else $error(\"\");", "task_id": "3_6156", "predict_sva": "@(posedge clk_nor_ctrl) disable iff (!nor_flash_ready)     nor_flash_memory_interface |->          ($past(sector_erase_command, 1) &&           $past(program_suspend_resume, 1) &&           $past(status_register_polling, 1))"}
{"sva": "@(posedge clk) disable iff(factory_test) ecc_correction_limit |-> $past(single_bit_errors) > max_correctable && $past(ecc_enabled)", "sva_description": "### Assertion description:  \n**Property Name**: p_ecc_correction_limit  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (factory_test)`  \n**Antecedent (LHS of Implication)**: `ecc_correction_limit == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(single_bit_errors) > max_correctable && $past(ecc_enabled)`  ", "sva_signals": ["clk", "rst_n", "[0:0] factory_test", "[0:0] ecc_correction_limit", "[0:0] single_bit_errors", "[0:0] max_correctable", "[0:0] ecc_enabled"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)", "sva_name": "p_ecc_correction_limit", "id": "3129", "full_property": "property p_ecc_correction_limit;\n@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)\nendproperty\nassert_p_ecc_correction_limit:assert property (p_ecc_correction_limit) else $error(\"\");", "task_id": "3_6732", "predict_sva": "@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)"}
{"sva": "@(posedge clk) disable iff(photomechanical) photomechanical_actuator_response |-> ($past(photoisomerization[7:0], 1) && $past(molecular_orientation[11:0], 1) && $past(optical_power_density[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_photomechanical_actuator_response  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (photomechanical)`  \n**Antecedent (LHS of Implication)**: `photomechanical_actuator_response`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(photoisomerization[7:0], 1) && $past(molecular_orientation[11:0], 1) && $past(optical_power_density[15:0], 1))`  ", "sva_signals": ["clk", "photomechanical", "[0:0] photomechanical_actuator_response", "[7:0] photoisomerization", "[11:0] molecular_orientation", "[15:0] optical_power_density"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (photomechanical)     photomechanical_actuator_response |->          ($past(photoisomerization[7:0], 1) &&           $past(molecular_orientation[11:0], 1) &&           $past(optical_power_density[15:0], 1))", "sva_name": "p_photomechanical_actuator_response", "id": "2569", "full_property": "property p_photomechanical_actuator_response;\n@(posedge clk) disable iff (photomechanical)     photomechanical_actuator_response |->          ($past(photoisomerization[7:0], 1) &&           $past(molecular_orientation[11:0], 1) &&           $past(optical_power_density[15:0], 1))\nendproperty\nassert_p_photomechanical_actuator_response:assert property (p_photomechanical_actuator_response) else $error(\"\");", "task_id": "3_6251", "predict_sva": "@(posedge clk) disable iff (photomechanical)     photomechanical_actuator_response |->          ($past(photoisomerization[7:0], 1) &&           $past(molecular_orientation[11:0], 1) &&           $past(optical_power_density[15:0], 1))"}
{"sva": "@(posedge clk) disable iff(structural_geology) structural_analysis_measurement |-> ($past(joint_orientation[15:0], 1) && $past(fold_axis_plunge[11:0], 1) && $past(lineation_trend[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Structural_Analysis_Measurement  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (structural_geology)`  \n**Antecedent (LHS of Implication)**: `structural_analysis_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(joint_orientation[15:0], 1) && $past(fold_axis_plunge[11:0], 1) && $past(lineation_trend[7:0], 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] structural_geology", "[0:0] structural_analysis_measurement", "[15:0] joint_orientation", "[11:0] fold_axis_plunge", "[7:0] lineation_trend"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (structural_geology)     structural_analysis_measurement |->          ($past(joint_orientation[15:0], 1) &&           $past(fold_axis_plunge[11:0], 1) &&           $past(lineation_trend[7:0], 1))", "sva_name": "p_structural_analysis_measurement", "id": "2796", "full_property": "property p_Structural_Analysis_Measurement;\n@(posedge clk) disable iff (structural_geology)     structural_analysis_measurement |->          ($past(joint_orientation[15:0], 1) &&           $past(fold_axis_plunge[11:0], 1) &&           $past(lineation_trend[7:0], 1))\nendproperty\nassert_p_Structural_Analysis_Measurement:assert property (p_Structural_Analysis_Measurement) else $error(\"\");", "task_id": "3_6446", "predict_sva": "@(posedge clk) disable iff (structural_geology)     structural_analysis_measurement |->          ($past(joint_orientation[15:0], 1) &&           $past(fold_axis_plunge[11:0], 1) &&           $past(lineation_trend[7:0], 1))"}
{"sva": "@(posedge clk_valleytronics) disable iff(!valley_rst_n) valley_degree_of_freedom_device |-> ($past(valley_polarization[7:0], 1) && $past(berry_curvature[11:0], 1) && $past(valley_hall_effect[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_valley_degree_of_freedom_device  \n**Trigger Condition**: At every rising edge of the `clk_valleytronics`  \n**Disable Condition**: `disable iff (!valley_rst_n)`  \n**Antecedent (LHS of Implication)**: `valley_degree_of_freedom_device`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(valley_polarization[7:0], 1) && $past(berry_curvature[11:0], 1) && $past(valley_hall_effect[7:0], 1))`  \n\nThe assertion checks that whenever `valley_degree_of_freedom_device` is true at a rising edge of `clk_valleytronics` (and the system is not in reset, i.e., `valley_rst_n` is high), then the conjunction of the past values of `valley_polarization[7:0]`, `berry_curvature[11:0]`, and `valley_hall_effect[7:0]` (from the previous clock cycle) must also be true.", "sva_signals": ["clk_valleytronics", "valley_rst_n", "[0:0] valley_degree_of_freedom_device", "[7:0] valley_polarization", "[11:0] berry_curvature", "[7:0] valley_hall_effect"], "clock": "clk_valleytronics", "attempts_left": 10, "sva_result": "@(posedge clk_valleytronics) disable iff (!valley_rst_n)     valley_degree_of_freedom_device |->          ($past(valley_polarization[7:0], 1) &&           $past(berry_curvature[11:0], 1) &&           $past(valley_hall_effect[7:0], 1))", "sva_name": "p_valley_degree_of_freedom_device", "id": "2516", "full_property": "property p_valley_degree_of_freedom_device;\n@(posedge clk_valleytronics) disable iff (!valley_rst_n)     valley_degree_of_freedom_device |->          ($past(valley_polarization[7:0], 1) &&           $past(berry_curvature[11:0], 1) &&           $past(valley_hall_effect[7:0], 1))\nendproperty\nassert_p_valley_degree_of_freedom_device:assert property (p_valley_degree_of_freedom_device) else $error(\"\");", "task_id": "3_6207", "predict_sva": "@(posedge clk_valleytronics) disable iff (!valley_rst_n)     valley_degree_of_freedom_device |->          ($past(valley_polarization[7:0], 1) &&           $past(berry_curvature[11:0], 1) &&           $past(valley_hall_effect[7:0], 1))"}
{"sva": "@(posedge clk) disable iff(scan_chain_active) metastability_detection |-> $past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin)", "sva_description": "### Assertion description:  \n**Property Name**: p_metastability_detection  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (scan_chain_active)`  \n**Antecedent (LHS of Implication)**: `metastability_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin)`  ", "sva_signals": ["clk", "scan_chain_active", "async_input_changed", "[0:0] metastability_detection", "setup_time_margin", "min_setup_margin"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (scan_chain_active)     metastability_detection |-> ($past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin))", "sva_name": "p_metastability_detection", "id": "3220", "full_property": "property p_metastability_detection;\n@(posedge clk) disable iff (scan_chain_active)     metastability_detection |-> ($past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin))\nendproperty\nassert_p_metastability_detection:assert property (p_metastability_detection) else $error(\"\");", "task_id": "3_6814", "predict_sva": "@(posedge clk) disable iff (scan_chain_active)     metastability_detection |-> $past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin)"}
{"sva": "@(posedge clk_i2c_core) disable iff(!i2c_rst_n) inter_integrated_circuit_controller |-> ($past(scl_generation, 1) && $past(sda_control, 1) && $past(arbitration_logic, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_inter_integrated_circuit_controller  \n**Trigger Condition**: At every rising edge of the `clk_i2c_core`  \n**Disable Condition**: `disable iff (!i2c_rst_n)`  \n**Antecedent (LHS of Implication)**: `inter_integrated_circuit_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(scl_generation, 1) && $past(sda_control, 1) && $past(arbitration_logic, 1))`  ", "sva_signals": ["clk_i2c_core", "i2c_rst_n", "[0:0] inter_integrated_circuit_controller", "[0:0] scl_generation", "[0:0] sda_control", "[0:0] arbitration_logic"], "clock": "clk_i2c_core", "attempts_left": 10, "sva_result": "@(posedge clk_i2c_core) disable iff (!i2c_rst_n)     inter_integrated_circuit_controller |->      ($past(scl_generation, 1) && $past(sda_control, 1) && $past(arbitration_logic, 1))", "sva_name": "p_inter_integrated_circuit_controller", "id": "2352", "full_property": "property p_inter_integrated_circuit_controller;\n@(posedge clk_i2c_core) disable iff (!i2c_rst_n)     inter_integrated_circuit_controller |->      ($past(scl_generation, 1) && $past(sda_control, 1) && $past(arbitration_logic, 1))\nendproperty\nassert_p_inter_integrated_circuit_controller:assert property (p_inter_integrated_circuit_controller) else $error(\"\");", "task_id": "3_6078", "predict_sva": "@(posedge clk_i2c_core) disable iff (!i2c_rst_n)     inter_integrated_circuit_controller |->          ($past(scl_generation, 1) && $past(sda_control, 1) && $past(arbitration_logic, 1))"}
{"sva": "@(posedge clk_fluoroscopy) disable iff(!fluoroscopy_rst_n) real_time_x_ray_imaging |=> ($past(image_intensifier[15:0], 1) && $past(automatic_brightness_control[11:0], 1) && $past(radiation_dose_monitoring[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_RealTimeXRayImaging  \n**Trigger Condition**: At every rising edge of the `clk_fluoroscopy`  \n**Disable Condition**: `disable iff (!fluoroscopy_rst_n)`  \n**Antecedent (LHS of Implication)**: `real_time_x_ray_imaging`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**:  \n`($past(image_intensifier[15:0], 1) && $past(automatic_brightness_control[11:0], 1) && $past(radiation_dose_monitoring[7:0], 1))`  ", "sva_signals": ["clk_fluoroscopy", "fluoroscopy_rst_n", "[0:0] real_time_x_ray_imaging", "[15:0] image_intensifier", "[11:0] automatic_brightness_control", "[7:0] radiation_dose_monitoring"], "clock": "clk_fluoroscopy", "attempts_left": 10, "sva_result": "@(posedge clk_fluoroscopy) disable iff (!fluoroscopy_rst_n)     real_time_x_ray_imaging |=>      ($past(image_intensifier[15:0], 1) && $past(automatic_brightness_control[11:0], 1) && $past(radiation_dose_monitoring[7:0], 1))", "sva_name": "p_RealTimeXRayImaging", "id": "2605", "full_property": "property p_RealTimeXRayImaging;\n@(posedge clk_fluoroscopy) disable iff (!fluoroscopy_rst_n)     real_time_x_ray_imaging |=>      ($past(image_intensifier[15:0], 1) && $past(automatic_brightness_control[11:0], 1) && $past(radiation_dose_monitoring[7:0], 1))\nendproperty\nassert_p_RealTimeXRayImaging:assert property (p_RealTimeXRayImaging) else $error(\"\");", "task_id": "3_6281", "predict_sva": "@(posedge clk_fluoroscopy) disable iff (!fluoroscopy_rst_n)     real_time_x_ray_imaging |->          ($past(image_intensifier[15:0], 1) &&           $past(automatic_brightness_control[11:0], 1) &&           $past(radiation_dose_monitoring[7:0], 1))"}
{"sva": "@(negedge clk_gyroscope) disable iff(gyro_calibration) angular_velocity_spike |-> ($past(rotation_rate) - $past(rotation_rate, 3)) > spike_threshold", "sva_description": "### Assertion description:  \n**Property Name**: p_Angular_Velocity_Spike_Check  \n**Trigger Condition**: At every falling edge of `clk_gyroscope`  \n**Disable Condition**: `disable iff (gyro_calibration)`  \n**Antecedent (LHS of Implication)**: `angular_velocity_spike == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(rotation_rate) - $past(rotation_rate, 3)) > spike_threshold`  ", "sva_signals": ["clk_gyroscope", "gyro_calibration", "[0:0] angular_velocity_spike", "[15:0] rotation_rate", "[15:0] spike_threshold"], "clock": "clk_gyroscope", "attempts_left": 10, "sva_result": "@(negedge clk_gyroscope) disable iff (gyro_calibration)     angular_velocity_spike == 1'b1 |-> ($past(rotation_rate) - $past(rotation_rate, 3)) > spike_threshold", "sva_name": "p_Angular_Velocity_Spike_Check", "id": "3164", "full_property": "property p_Angular_Velocity_Spike_Check;\n@(negedge clk_gyroscope) disable iff (gyro_calibration)     angular_velocity_spike == 1'b1 |-> ($past(rotation_rate) - $past(rotation_rate, 3)) > spike_threshold\nendproperty\nassert_p_Angular_Velocity_Spike_Check:assert property (p_Angular_Velocity_Spike_Check) else $error(\"\");", "task_id": "3_6764", "predict_sva": "@(negedge clk_gyroscope) disable iff (gyro_calibration)     angular_velocity_spike == 1'b1 |->      ($past(rotation_rate) - $past(rotation_rate, 3)) > spike_threshold"}
{"sva": "@(negedge clk_sequence_stratigraphy) disable iff(!sequence_analysis_enable) sequence_stratigraphic_interpretation |-> $past(sea_level_curve[31:0] & accommodation_space[15:0] & systems_tract, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_sequence_stratigraphic_interpretation  \n**Trigger Condition**: At every falling edge of `clk_sequence_stratigraphy`  \n**Disable Condition**: `disable iff (!sequence_analysis_enable)`  \n**Antecedent (LHS of Implication)**: `sequence_stratigraphic_interpretation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sea_level_curve[31:0] & accommodation_space[15:0] & systems_tract, 1)`  ", "sva_signals": ["clk", "sequence_analysis_enable", "clk_sequence_stratigraphy", "[0:0] sequence_stratigraphic_interpretation", "[31:0] sea_level_curve", "[15:0] accommodation_space", "[0:0] systems_tract"], "clock": "clk_sequence_stratigraphy", "attempts_left": 10, "sva_result": "@(negedge clk_sequence_stratigraphy) disable iff (!sequence_analysis_enable)     sequence_stratigraphic_interpretation == 1'b1 |->     $past(sea_level_curve[31:0] & accommodation_space[15:0] & systems_tract, 1)", "sva_name": "p_sequence_stratigraphic_interpretation", "id": "2834", "full_property": "property p_sequence_stratigraphic_interpretation;\n@(negedge clk_sequence_stratigraphy) disable iff (!sequence_analysis_enable)     sequence_stratigraphic_interpretation == 1'b1 |->     $past(sea_level_curve[31:0] & accommodation_space[15:0] & systems_tract, 1)\nendproperty\nassert_p_sequence_stratigraphic_interpretation:assert property (p_sequence_stratigraphic_interpretation) else $error(\"\");", "task_id": "3_6478", "predict_sva": "@(negedge clk_sequence_stratigraphy) disable iff (!sequence_analysis_enable)     sequence_stratigraphic_interpretation == 1'b1 |->      $past(sea_level_curve[31:0] & accommodation_space[15:0] & systems_tract, 1)"}
{"sva": "@(posedge clk) disable iff(solar_irradiance) total_solar_irradiance_monitor |-> ($past(radiometer_measurement[15:0], 1) && $past(degradation_correction[11:0], 1) && $past(solar_constant[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_total_solar_irradiance_monitor  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (solar_irradiance)`  \n**Antecedent (LHS of Implication)**: `total_solar_irradiance_monitor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(radiometer_measurement[15:0], 1) && $past(degradation_correction[11:0], 1) && $past(solar_constant[7:0], 1))`  ", "sva_signals": ["clk", "solar_irradiance", "[0:0] total_solar_irradiance_monitor", "[15:0] radiometer_measurement", "[11:0] degradation_correction", "[7:0] solar_constant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (solar_irradiance)     total_solar_irradiance_monitor |->          ($past(radiometer_measurement[15:0], 1) &&           $past(degradation_correction[11:0], 1) &&           $past(solar_constant[7:0], 1))", "sva_name": "p_Total_Solar_Irradiance_Monitor", "id": "2676", "full_property": "property p_total_solar_irradiance_monitor;\n@(posedge clk) disable iff (solar_irradiance)     total_solar_irradiance_monitor |->          ($past(radiometer_measurement[15:0], 1) &&           $past(degradation_correction[11:0], 1) &&           $past(solar_constant[7:0], 1))\nendproperty\nassert_p_total_solar_irradiance_monitor:assert property (p_total_solar_irradiance_monitor) else $error(\"\");", "task_id": "3_6341", "predict_sva": "@(posedge clk) disable iff (solar_irradiance)     total_solar_irradiance_monitor |->          ($past(radiometer_measurement[15:0], 1) &&           $past(degradation_correction[11:0], 1) &&           $past(solar_constant[7:0], 1))"}
{"sva": "@(posedge clk_routing) disable iff(routing_reset) congestion_control_fail |-> ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)", "sva_description": "### Assertion description:  \n**Property Name**: p_congestion_control_fail  \n**Trigger Condition**: At every rising edge of the `clk_routing`  \n**Disable Condition**: `disable iff (routing_reset)`  \n**Antecedent (LHS of Implication)**: `congestion_control_fail == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)`  ", "sva_signals": ["clk_routing", "routing_reset", "[0:0] congestion_control_fail", "[0:0] packet_queue_depth", "[0:0] congestion_threshold", "[0:0] flow_control_applied"], "clock": "clk_routing", "attempts_left": 10, "sva_result": "@(posedge clk_routing) disable iff (routing_reset)     congestion_control_fail == 1'b1 |->      ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)", "sva_name": "p_Congestion_Control_Fail", "id": "3216", "full_property": "property p_congestion_control_fail;\n@(posedge clk_routing) disable iff (routing_reset)     congestion_control_fail == 1'b1 |->      ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)\nendproperty\nassert_p_congestion_control_fail:assert property (p_congestion_control_fail) else $error(\"\");", "task_id": "3_6810", "predict_sva": "@(posedge clk_routing) disable iff (routing_reset)     congestion_control_fail == 1'b1 |->      $past(packet_queue_depth) > congestion_threshold && !$past(flow_control_applied)"}
{"sva": "@(negedge clk_crystallography) disable iff(!protein_crystal_enable) protein_crystallography_diffraction |=> $past(crystal_lattice_parameters[31:0] & diffraction_pattern[63:0] & phase_problem_solution, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Protein_Crystallography_Diffraction  \n**Trigger Condition**: At every falling edge of the `clk_crystallography`  \n**Disable Condition**: disable iff (`!protein_crystal_enable`)  \n**Antecedent (LHS of Implication)**: `protein_crystallography_diffraction`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(crystal_lattice_parameters[31:0] & diffraction_pattern[63:0] & phase_problem_solution, 1)`  ", "sva_signals": ["clk_crystallography", "protein_crystal_enable", "protein_crystallography_diffraction", "[31:0] crystal_lattice_parameters", "[63:0] diffraction_pattern", "[63:0] phase_problem_solution"], "clock": "clk_crystallography", "attempts_left": 10, "sva_result": "@(negedge clk_crystallography) disable iff (!protein_crystal_enable)     protein_crystallography_diffraction |=>      ($past(crystal_lattice_parameters[31:0] & diffraction_pattern[63:0] & phase_problem_solution, 1))", "sva_name": "p_protein_crystallography_diffraction", "id": "2903", "full_property": "property p_Protein_Crystallography_Diffraction;\n@(negedge clk_crystallography) disable iff (!protein_crystal_enable)     protein_crystallography_diffraction |=>      ($past(crystal_lattice_parameters[31:0] & diffraction_pattern[63:0] & phase_problem_solution, 1))\nendproperty\nassert_p_Protein_Crystallography_Diffraction:assert property (p_Protein_Crystallography_Diffraction) else $error(\"\");", "task_id": "3_6534", "predict_sva": "@(negedge clk_crystallography) disable iff (!protein_crystal_enable)     protein_crystallography_diffraction |->          $past(crystal_lattice_parameters[31:0] & diffraction_pattern[63:0] & phase_problem_solution, 1)"}
{"sva": "@(negedge clk_eeg) disable iff(eeg_disable) electroencephalogram_signal_processor |=> $past(alpha_wave_detection[11:0] & beta_wave_analysis[11:0] & gamma_oscillation[11:0], 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_eeg_signal_processing  \n**Trigger Condition**: At every falling edge of the `clk_eeg`  \n**Disable Condition**: `disable iff (eeg_disable)`  \n**Antecedent (LHS of Implication)**: `electroencephalogram_signal_processor`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(alpha_wave_detection[11:0] & beta_wave_analysis[11:0] & gamma_oscillation[11:0], 1)`  ", "sva_signals": ["clk_eeg", "eeg_disable", "[0:0] electroencephalogram_signal_processor", "[11:0] alpha_wave_detection", "[11:0] beta_wave_analysis", "[11:0] gamma_oscillation"], "clock": "clk_eeg", "attempts_left": 10, "sva_result": "@(negedge clk_eeg) disable iff (eeg_disable)     electroencephalogram_signal_processor |=>          $past(alpha_wave_detection[11:0] & beta_wave_analysis[11:0] & gamma_oscillation[11:0], 1)", "sva_name": "p_electroencephalogram_signal_processor", "id": "2608", "full_property": "property p_eeg_signal_processing;\n@(negedge clk_eeg) disable iff (eeg_disable)     electroencephalogram_signal_processor |=>          $past(alpha_wave_detection[11:0] & beta_wave_analysis[11:0] & gamma_oscillation[11:0], 1)\nendproperty\nassert_p_eeg_signal_processing:assert property (p_eeg_signal_processing) else $error(\"\");", "task_id": "3_6284", "predict_sva": "@(negedge clk_eeg) disable iff (eeg_disable)     electroencephalogram_signal_processor |->          $past(alpha_wave_detection[11:0] & beta_wave_analysis[11:0] & gamma_oscillation[11:0], 1)"}
{"sva": "@(posedge clk_security_system) disable iff(security_threat_level_elevated) vital_area_protection |-> $past(unauthorized_access_attempt) && ($past(security_response_time) > max_response_time)", "sva_description": "### Assertion description:  \n**Property Name**: p_Vital_Area_Protection  \n**Trigger Condition**: At every rising edge of the `clk_security_system`  \n**Disable Condition**: `disable iff (security_threat_level_elevated)`  \n**Antecedent (LHS of Implication)**: `vital_area_protection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(unauthorized_access_attempt) && ($past(security_response_time) > max_response_time)`", "sva_signals": ["clk_security_system", "security_threat_level_elevated", "[0:0] vital_area_protection", "[0:0] unauthorized_access_attempt", "[0:0] security_response_time", "[0:0] max_response_time"], "clock": "clk_security_system", "attempts_left": 10, "sva_result": "@(posedge clk_security_system) disable iff (security_threat_level_elevated)     vital_area_protection |-> ($past(unauthorized_access_attempt) && ($past(security_response_time) > max_response_time))", "sva_name": "p_Vital_Area_Protection", "id": "3333", "full_property": "property p_Vital_Area_Protection;\n@(posedge clk_security_system) disable iff (security_threat_level_elevated)     vital_area_protection |-> ($past(unauthorized_access_attempt) && ($past(security_response_time) > max_response_time))\nendproperty\nassert_p_Vital_Area_Protection:assert property (p_Vital_Area_Protection) else $error(\"\");", "task_id": "3_6921", "predict_sva": "@(posedge clk_security_system) disable iff (security_threat_level_elevated)     vital_area_protection |-> $past(unauthorized_access_attempt) && ($past(security_response_time) > max_response_time)"}
{"sva": "@(negedge clk_palm_storm) disable iff(!single_molecule_enable) photoactivated_localization_microscopy |-> $past(photoactivatable_fluorophore[15:0] & single_molecule_localization[31:0] & reconstruction_algorithm, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Photoactivated_Localization_Microscopy  \n**Trigger Condition**: At every falling edge of the `clk_palm_storm`  \n**Disable Condition**: `disable iff (!single_molecule_enable)`  \n**Antecedent (LHS of Implication)**: `photoactivated_localization_microscopy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(photoactivatable_fluorophore[15:0] & single_molecule_localization[31:0] & reconstruction_algorithm, 1)`  ", "sva_signals": ["clk_palm_storm", "single_molecule_enable", "[0:0] photoactivated_localization_microscopy", "[15:0] photoactivatable_fluorophore", "[31:0] single_molecule_localization", "[0:0] reconstruction_algorithm"], "clock": "clk_palm_storm", "attempts_left": 10, "sva_result": "@(negedge clk_palm_storm) disable iff (!single_molecule_enable)     photoactivated_localization_microscopy == 1'b1 |->     $past(photoactivatable_fluorophore[15:0] & single_molecule_localization[31:0] & reconstruction_algorithm, 1)", "sva_name": "p_photoactivated_localization_microscopy", "id": "2990", "full_property": "property p_Photoactivated_Localization_Microscopy;\n@(negedge clk_palm_storm) disable iff (!single_molecule_enable)     photoactivated_localization_microscopy == 1'b1 |->     $past(photoactivatable_fluorophore[15:0] & single_molecule_localization[31:0] & reconstruction_algorithm, 1)\nendproperty\nassert_p_Photoactivated_Localization_Microscopy:assert property (p_Photoactivated_Localization_Microscopy) else $error(\"\");", "task_id": "3_6606", "predict_sva": "@(negedge clk_palm_storm) disable iff (!single_molecule_enable)     photoactivated_localization_microscopy == 1'b1 |->      $past(photoactivatable_fluorophore[15:0] & single_molecule_localization[31:0] & reconstruction_algorithm, 1)"}
{"sva": "@(negedge clk_communication) disable iff(radio_silence_ordered) secure_communication_protocol |-> $past(encryption_key_expired) && !$past(key_rotation_completed, 15) && $past(message_transmission_pending)", "sva_description": "### Assertion description:  \n**Property Name**: p_Secure_Communication_Protocol  \n**Trigger Condition**: At every falling edge of the `clk_communication`  \n**Disable Condition**: `disable iff (radio_silence_ordered)`  \n**Antecedent (LHS of Implication)**: `secure_communication_protocol`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(encryption_key_expired) && !$past(key_rotation_completed, 15) && $past(message_transmission_pending)`  ", "sva_signals": ["clk_communication", "radio_silence_ordered", "[0:0] secure_communication_protocol", "[0:0] encryption_key_expired", "[0:0] key_rotation_completed", "[0:0] message_transmission_pending"], "clock": "clk_communication", "attempts_left": 10, "sva_result": "@(negedge clk_communication) disable iff (radio_silence_ordered)     secure_communication_protocol |->          $past(encryption_key_expired) &&          !$past(key_rotation_completed, 15) &&          $past(message_transmission_pending)", "sva_name": "p_secure_communication_protocol", "id": "3399", "full_property": "property p_Secure_Communication_Protocol;\n@(negedge clk_communication) disable iff (radio_silence_ordered)     secure_communication_protocol |->          $past(encryption_key_expired) &&          !$past(key_rotation_completed, 15) &&          $past(message_transmission_pending)\nendproperty\nassert_p_Secure_Communication_Protocol:assert property (p_Secure_Communication_Protocol) else $error(\"\");", "task_id": "3_6984", "predict_sva": "@(negedge clk_communication) disable iff (radio_silence_ordered)     secure_communication_protocol |->          $past(encryption_key_expired) &&          !$past(key_rotation_completed, 15) &&          $past(message_transmission_pending)"}
{"sva": "@(negedge clk_helioseismology) disable iff(!helioseismology_enable) solar_oscillation_investigation |-> $past(velocity_oscillation[15:0] & p_mode_frequency[11:0] & solar_interior_structure, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_solar_oscillation_investigation  \n**Trigger Condition**: At every falling edge of the `clk_helioseismology`  \n**Disable Condition**: disable iff (`!helioseismology_enable`)  \n**Antecedent (LHS of Implication)**: `solar_oscillation_investigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(velocity_oscillation[15:0] & p_mode_frequency[11:0] & solar_interior_structure, 1)`  \n\nThe assertion checks that whenever `solar_oscillation_investigation` is true at the falling edge of `clk_helioseismology` (and `helioseismology_enable` is active), the past value (one clock cycle earlier) of the bitwise AND of `velocity_oscillation[15:0]`, `p_mode_frequency[11:0]`, and `solar_interior_structure` must hold. The check is disabled if `helioseismology_enable` is low.", "sva_signals": ["clk_helioseismology", "helioseismology_enable", "[0:0] solar_oscillation_investigation", "[15:0] velocity_oscillation", "[11:0] p_mode_frequency", "[0:0] solar_interior_structure"], "clock": "clk_helioseismology", "attempts_left": 10, "sva_result": "@(negedge clk_helioseismology) disable iff (!helioseismology_enable)     solar_oscillation_investigation |->      $past(velocity_oscillation[15:0] & p_mode_frequency[11:0] & solar_interior_structure, 1)", "sva_name": "p_solar_oscillation_investigation", "id": "2672", "full_property": "property p_solar_oscillation_investigation;\n@(negedge clk_helioseismology) disable iff (!helioseismology_enable)     solar_oscillation_investigation |->      $past(velocity_oscillation[15:0] & p_mode_frequency[11:0] & solar_interior_structure, 1)\nendproperty\nassert_p_solar_oscillation_investigation:assert property (p_solar_oscillation_investigation) else $error(\"\");", "task_id": "3_6337", "predict_sva": "@(negedge clk_helioseismology) disable iff (!helioseismology_enable)     solar_oscillation_investigation |->          $past(velocity_oscillation[15:0] & p_mode_frequency[11:0] & solar_interior_structure, 1)"}
{"sva": "@(negedge clk_interferometry) disable iff(!interferometer_enable) plasma_interferometry_density |-> $past(phase_shift_measurement[15:0] & line_integrated_density[31:0] & fringe_counting, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_plasma_interferometry_density_check  \n**Trigger Condition**: At every falling edge of the `clk_interferometry`  \n**Disable Condition**: disable iff (`!interferometer_enable`)  \n**Antecedent (LHS of Implication)**: `plasma_interferometry_density`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(phase_shift_measurement[15:0] & line_integrated_density[31:0] & fringe_counting, 1)`  \n\n(Note: The consequent checks that the past value (1 clock cycle ago) of the bitwise AND of `phase_shift_measurement[15:0]`, `line_integrated_density[31:0]`, and `fringe_counting` holds true when the antecedent is satisfied.)", "sva_signals": ["clk_interferometry", "interferometer_enable", "plasma_interferometry_density", "[15:0] phase_shift_measurement", "[31:0] line_integrated_density", "[0:0] fringe_counting"], "clock": "clk_interferometry", "attempts_left": 10, "sva_result": "@(negedge clk_interferometry) disable iff (!interferometer_enable)     plasma_interferometry_density |->          ($past(phase_shift_measurement[15:0] & line_integrated_density[31:0] & fringe_counting, 1))", "sva_name": "p_plasma_interferometry_density", "id": "2879", "full_property": "property p_plasma_interferometry_density_check;\n@(negedge clk_interferometry) disable iff (!interferometer_enable)     plasma_interferometry_density |->          ($past(phase_shift_measurement[15:0] & line_integrated_density[31:0] & fringe_counting, 1))\nendproperty\nassert_p_plasma_interferometry_density_check:assert property (p_plasma_interferometry_density_check) else $error(\"\");", "task_id": "3_6512", "predict_sva": "@(negedge clk_interferometry) disable iff (!interferometer_enable)     plasma_interferometry_density |-> $past(phase_shift_measurement[15:0] & line_integrated_density[31:0] & fringe_counting, 1)"}
{"sva": "@(negedge clk_fusion_reactor) disable iff(reactor_emergency_shutdown) plasma_instability_detected |-> $past(beta_limit_exceeded) && ($past(magnetic_reconnection) || $past(tearing_mode_active))", "sva_description": "### Assertion description:  \n**Property Name**: p_Plasma_Instability_Check  \n**Trigger Condition**: At every falling edge of the `clk_fusion_reactor`  \n**Disable Condition**: `disable iff (reactor_emergency_shutdown)`  \n**Antecedent (LHS of Implication)**: `plasma_instability_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(beta_limit_exceeded) && ($past(magnetic_reconnection) || $past(tearing_mode_active))`  ", "sva_signals": ["clk_fusion_reactor", "reactor_emergency_shutdown", "[0:0] plasma_instability_detected", "[0:0] beta_limit_exceeded", "[0:0] magnetic_reconnection", "[0:0] tearing_mode_active"], "clock": "clk_fusion_reactor", "attempts_left": 10, "sva_result": "@(negedge clk_fusion_reactor) disable iff (reactor_emergency_shutdown)     plasma_instability_detected == 1'b1 |->      $past(beta_limit_exceeded) && ($past(magnetic_reconnection) || $past(tearing_mode_active))", "sva_name": "p_plasma_instability_check", "id": "3185", "full_property": "property p_Plasma_Instability_Check;\n@(negedge clk_fusion_reactor) disable iff (reactor_emergency_shutdown)     plasma_instability_detected == 1'b1 |->      $past(beta_limit_exceeded) && ($past(magnetic_reconnection) || $past(tearing_mode_active))\nendproperty\nassert_p_Plasma_Instability_Check:assert property (p_Plasma_Instability_Check) else $error(\"\");", "task_id": "3_6783", "predict_sva": "@(negedge clk_fusion_reactor) disable iff (reactor_emergency_shutdown)     plasma_instability_detected == 1'b1 |->      $past(beta_limit_exceeded) && ($past(magnetic_reconnection) || $past(tearing_mode_active))"}
{"sva": "@(posedge clk_bioluminescence) disable iff(!luciferase_ready) bioluminescence_imaging_system |-> ($past(luciferase_expression[31:0], 1) && $past(luciferin_substrate[15:0], 1) && $past(photon_emission[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_bioluminescence_imaging  \n**Trigger Condition**: At every rising edge of the `clk_bioluminescence`  \n**Disable Condition**: disable iff (`!luciferase_ready`)  \n**Antecedent (LHS of Implication)**: `bioluminescence_imaging_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(luciferase_expression[31:0], 1) && $past(luciferin_substrate[15:0], 1) && $past(photon_emission[11:0], 1))`  ", "sva_signals": ["clk_bioluminescence", "luciferase_ready", "[0:0] bioluminescence_imaging_system", "[31:0] luciferase_expression", "[15:0] luciferin_substrate", "[11:0] photon_emission"], "clock": "clk_bioluminescence", "attempts_left": 10, "sva_result": "@(posedge clk_bioluminescence) disable iff (!luciferase_ready)     bioluminescence_imaging_system |->          ($past(luciferase_expression[31:0], 1) &&           $past(luciferin_substrate[15:0], 1) &&           $past(photon_emission[11:0], 1))", "sva_name": "p_bioluminescence_imaging", "id": "2970", "full_property": "property p_bioluminescence_imaging;\n@(posedge clk_bioluminescence) disable iff (!luciferase_ready)     bioluminescence_imaging_system |->          ($past(luciferase_expression[31:0], 1) &&           $past(luciferin_substrate[15:0], 1) &&           $past(photon_emission[11:0], 1))\nendproperty\nassert_p_bioluminescence_imaging:assert property (p_bioluminescence_imaging) else $error(\"\");", "task_id": "3_6590", "predict_sva": "@(posedge clk_bioluminescence) disable iff (!luciferase_ready)     bioluminescence_imaging_system |->          ($past(luciferase_expression[31:0], 1) &&           $past(luciferin_substrate[15:0], 1) &&           $past(photon_emission[11:0], 1))"}
{"sva": "@(posedge clk_dct) disable iff(!dct_enable) transform_coefficient_overflow |-> ($past(input_block[63:0]) > dct_input_max) && $past(transform_active)", "sva_description": "### Assertion description:  \n**Property Name**: p_transform_coefficient_overflow_check  \n**Trigger Condition**: At every rising edge of the `clk_dct`  \n**Disable Condition**: disable iff (!dct_enable)  \n**Antecedent (LHS of Implication)**: `transform_coefficient_overflow`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: ($past(input_block[63:0]) > dct_input_max) && $past(transform_active)", "sva_signals": ["clk_dct", "dct_enable", "transform_coefficient_overflow", "[63:0] input_block", "[63:0] dct_input_max", "transform_active"], "clock": "clk_dct", "attempts_left": 10, "sva_result": "@(posedge clk_dct) disable iff (!dct_enable)     transform_coefficient_overflow |->          ($past(input_block[63:0]) > dct_input_max) && $past(transform_active)", "sva_name": "p_transform_coefficient_overflow", "id": "3191", "full_property": "property p_transform_coefficient_overflow_check;\n@(posedge clk_dct) disable iff (!dct_enable)     transform_coefficient_overflow |->          ($past(input_block[63:0]) > dct_input_max) && $past(transform_active)\nendproperty\nassert_p_transform_coefficient_overflow_check:assert property (p_transform_coefficient_overflow_check) else $error(\"\");", "task_id": "3_6789", "predict_sva": "@(posedge clk_dct) disable iff (!dct_enable)     transform_coefficient_overflow |->          ($past(input_block[63:0] > dct_input_max, 1) && $past(transform_active, 1))"}
{"sva": "@(posedge clk) disable iff(environmental_monitoring_sensor_malfunction) controlled_atmosphere_storage |-> ($past(humidity_level_deviation) > storage_specification_tolerance) && !$past(climate_control_adjustment_initiated, 9)", "sva_description": "### Assertion description:  \n**Property Name**: p_Controlled_Atmosphere_Storage  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (environmental_monitoring_sensor_malfunction)`  \n**Antecedent (LHS of Implication)**: `controlled_atmosphere_storage == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(humidity_level_deviation) > storage_specification_tolerance) && !$past(climate_control_adjustment_initiated, 9)`  ", "sva_signals": ["clk", "rst_n", "[0:0] environmental_monitoring_sensor_malfunction", "[0:0] controlled_atmosphere_storage", "[0:0] climate_control_adjustment_initiated", "[0:0] storage_specification_tolerance", "[0:0] humidity_level_deviation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (environmental_monitoring_sensor_malfunction)     controlled_atmosphere_storage == 1'b1 |->      ($past(humidity_level_deviation) > storage_specification_tolerance) &&      !$past(climate_control_adjustment_initiated, 9)", "sva_name": "p_Controlled_Atmosphere_Storage_Check", "id": "3496", "full_property": "property p_Controlled_Atmosphere_Storage;\n@(posedge clk) disable iff (environmental_monitoring_sensor_malfunction)     controlled_atmosphere_storage == 1'b1 |->      ($past(humidity_level_deviation) > storage_specification_tolerance) &&      !$past(climate_control_adjustment_initiated, 9)\nendproperty\nassert_p_Controlled_Atmosphere_Storage:assert property (p_Controlled_Atmosphere_Storage) else $error(\"\");", "task_id": "3_7079", "predict_sva": "@(posedge clk) disable iff (environmental_monitoring_sensor_malfunction)     controlled_atmosphere_storage == 1'b1 |->      ($past(humidity_level_deviation) > storage_specification_tolerance) &&      !$past(climate_control_adjustment_initiated, 9)"}
{"sva": "@(posedge clk_artificial_pancreas) disable iff(!closed_loop_rst_n) closed_loop_artificial_pancreas |-> ($past(glucose_prediction_algorithm[31:0], 1) && $past(insulin_glucagon_dosing[15:0], 1) && $past(hypoglycemia_prevention[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_closed_loop_artificial_pancreas  \n**Trigger Condition**: At every rising edge of the `clk_artificial_pancreas`  \n**Disable Condition**: disable iff `(!closed_loop_rst_n)`  \n**Antecedent (LHS of Implication)**: `closed_loop_artificial_pancreas`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(glucose_prediction_algorithm[31:0], 1) && $past(insulin_glucagon_dosing[15:0], 1) && $past(hypoglycemia_prevention[11:0], 1))`  \n\n", "sva_signals": ["clk_artificial_pancreas", "closed_loop_rst_n", "[0:0] closed_loop_artificial_pancreas", "[31:0] glucose_prediction_algorithm", "[15:0] insulin_glucagon_dosing", "[11:0] hypoglycemia_prevention"], "clock": "clk_artificial_pancreas", "attempts_left": 10, "sva_result": "@(posedge clk_artificial_pancreas) disable iff (!closed_loop_rst_n)     closed_loop_artificial_pancreas |->          ($past(glucose_prediction_algorithm[31:0], 1) &&           $past(insulin_glucagon_dosing[15:0], 1) &&           $past(hypoglycemia_prevention[11:0], 1))", "sva_name": "p_closed_loop_artificial_pancreas", "id": "2959", "full_property": "property p_closed_loop_artificial_pancreas;\n@(posedge clk_artificial_pancreas) disable iff (!closed_loop_rst_n)     closed_loop_artificial_pancreas |->          ($past(glucose_prediction_algorithm[31:0], 1) &&           $past(insulin_glucagon_dosing[15:0], 1) &&           $past(hypoglycemia_prevention[11:0], 1))\nendproperty\nassert_p_closed_loop_artificial_pancreas:assert property (p_closed_loop_artificial_pancreas) else $error(\"\");", "task_id": "3_6581", "predict_sva": "@(posedge clk_artificial_pancreas) disable iff (!closed_loop_rst_n)     closed_loop_artificial_pancreas |->          ($past(glucose_prediction_algorithm[31:0], 1) &&           $past(insulin_glucagon_dosing[15:0], 1) &&           $past(hypoglycemia_prevention[11:0], 1))"}
{"sva": "@(negedge clk_theta_pinch) disable iff(!theta_pinch_enable) theta_pinch_magnetic_compression |=> $past(magnetic_flux_compression[15:0] & adiabatic_heating[11:0] & shock_wave_formation, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_theta_pinch_magnetic_compression  \n**Trigger Condition**: At every falling edge of the `clk_theta_pinch`  \n**Disable Condition**: disable iff (`!theta_pinch_enable`)  \n**Antecedent (LHS of Implication)**: `theta_pinch_magnetic_compression`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(magnetic_flux_compression[15:0] & adiabatic_heating[11:0] & shock_wave_formation, 1)`  ", "sva_signals": ["clk_theta_pinch", "theta_pinch_enable", "[0:0] theta_pinch_magnetic_compression", "[15:0] magnetic_flux_compression", "[11:0] adiabatic_heating", "[0:0] shock_wave_formation"], "clock": "clk_theta_pinch", "attempts_left": 10, "sva_result": "@(negedge clk_theta_pinch) disable iff (!theta_pinch_enable)     theta_pinch_magnetic_compression |=>      $past(magnetic_flux_compression[15:0] & adiabatic_heating[11:0] & shock_wave_formation, 1)", "sva_name": "p_theta_pinch_magnetic_compression", "id": "2858", "full_property": "property p_theta_pinch_magnetic_compression;\n@(negedge clk_theta_pinch) disable iff (!theta_pinch_enable)     theta_pinch_magnetic_compression |=>      $past(magnetic_flux_compression[15:0] & adiabatic_heating[11:0] & shock_wave_formation, 1)\nendproperty\nassert_p_theta_pinch_magnetic_compression:assert property (p_theta_pinch_magnetic_compression) else $error(\"\");", "task_id": "3_6496", "predict_sva": "@(negedge clk_theta_pinch) disable iff (!theta_pinch_enable)     theta_pinch_magnetic_compression |=>      ($past(magnetic_flux_compression[15:0] & adiabatic_heating[11:0] & shock_wave_formation, 1))"}
{"sva": "@(posedge clk_tectonics) disable iff(!active_tectonics_rst_n) active_fault_characterization |-> ($past(fault_geometry[31:0], 1) && $past(kinematic_indicators[15:0], 1) && $past(stress_orientation[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_active_fault_characterization  \n**Trigger Condition**: At every rising edge of the `clk_tectonics`  \n**Disable Condition**: `disable iff (!active_tectonics_rst_n)`  \n**Antecedent (LHS of Implication)**: `active_fault_characterization == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe logical AND of the following past values (sampled at the previous clock cycle):  \n- `fault_geometry[31:0]`  \n- `kinematic_indicators[15:0]`  \n- `stress_orientation[11:0]`  \n\nThe assertion checks that when `active_fault_characterization` is high, the concatenated past values of `fault_geometry`, `kinematic_indicators`, and `stress_orientation` (from the previous clock cycle) must all be logically true (non-zero).", "sva_signals": ["clk_tectonics", "active_tectonics_rst_n", "[0:0] active_fault_characterization", "[31:0] fault_geometry", "[15:0] kinematic_indicators", "[11:0] stress_orientation"], "clock": "clk_tectonics", "attempts_left": 10, "sva_result": "@(posedge clk_tectonics) disable iff (!active_tectonics_rst_n)     active_fault_characterization == 1'b1 |->     ($past(fault_geometry) != 32'b0) &&      ($past(kinematic_indicators) != 16'b0) &&      ($past(stress_orientation) != 12'b0)", "sva_name": "p_active_fault_characterization", "id": "2798", "full_property": "property p_active_fault_characterization;\n@(posedge clk_tectonics) disable iff (!active_tectonics_rst_n)     active_fault_characterization == 1'b1 |->     ($past(fault_geometry) != 32'b0) &&      ($past(kinematic_indicators) != 16'b0) &&      ($past(stress_orientation) != 12'b0)\nendproperty\nassert_p_active_fault_characterization:assert property (p_active_fault_characterization) else $error(\"\");", "task_id": "3_6448", "predict_sva": "@(posedge clk_tectonics) disable iff (!active_tectonics_rst_n)     active_fault_characterization == 1'b1 |->      ($past(fault_geometry[31:0], 1) && $past(kinematic_indicators[15:0], 1) && $past(stress_orientation[11:0], 1))"}
{"sva": "@(negedge clk_cvt) disable iff(!continuously_variable_enable) continuously_variable_transmission |-> $past(pulley_ratio_control[15:0] & belt_tension_monitoring[11:0] & efficiency_optimization, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_continuously_variable_transmission  \n**Trigger Condition**: At every falling edge of `clk_cvt`  \n**Disable Condition**: `disable iff (!continuously_variable_enable)`  \n**Antecedent (LHS of Implication)**: `continuously_variable_transmission == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pulley_ratio_control[15:0] & belt_tension_monitoring[11:0] & efficiency_optimization, 1)`  \n\n(Note: The consequent checks that the past value of the bitwise AND of `pulley_ratio_control[15:0]`, `belt_tension_monitoring[11:0]`, and `efficiency_optimization` at the previous clock edge evaluates to true.)", "sva_signals": ["clk_cvt", "continuously_variable_enable", "[0:0] continuously_variable_transmission", "[15:0] pulley_ratio_control", "[11:0] belt_tension_monitoring", "[0:0] efficiency_optimization"], "clock": "clk_cvt", "attempts_left": 10, "sva_result": "@(negedge clk_cvt) disable iff (!continuously_variable_enable)     continuously_variable_transmission == 1'b1 |->          $past(pulley_ratio_control[15:0] & belt_tension_monitoring[11:0] & efficiency_optimization, 1)", "sva_name": "p_Continuously_Variable_Transmission", "id": "3024", "full_property": "property p_continuously_variable_transmission;\n@(negedge clk_cvt) disable iff (!continuously_variable_enable)     continuously_variable_transmission == 1'b1 |->          $past(pulley_ratio_control[15:0] & belt_tension_monitoring[11:0] & efficiency_optimization, 1)\nendproperty\nassert_p_continuously_variable_transmission:assert property (p_continuously_variable_transmission) else $error(\"\");", "task_id": "3_6637", "predict_sva": "@(negedge clk_cvt) disable iff (!continuously_variable_enable)     continuously_variable_transmission == 1'b1 |->      $past(pulley_ratio_control[15:0] & belt_tension_monitoring[11:0] & efficiency_optimization, 1)"}
{"sva": "@(posedge clk_garment_logistics) disable iff(!rfid_tracking_system_enabled) apparel_inventory_management |-> $past(garment_location_tracking_accuracy) && ($past(inventory_discrepancy_resolution_time) > acceptable_reconciliation_duration)", "sva_description": "### Assertion description:  \n**Property Name**: p_Apparel_Inventory_Management  \n**Trigger Condition**: At every rising edge of the `clk_garment_logistics`  \n**Disable Condition**: `disable iff (!rfid_tracking_system_enabled)`  \n**Antecedent (LHS of Implication)**: `apparel_inventory_management == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(garment_location_tracking_accuracy) && ($past(inventory_discrepancy_resolution_time) > acceptable_reconciliation_duration)`", "sva_signals": ["clk_garment_logistics", "rfid_tracking_system_enabled", "[0:0] apparel_inventory_management", "[0:0] garment_location_tracking_accuracy", "[0:0] inventory_discrepancy_resolution_time", "[0:0] acceptable_reconciliation_duration"], "clock": "clk_garment_logistics", "attempts_left": 10, "sva_result": "@(posedge clk_garment_logistics) disable iff (!rfid_tracking_system_enabled)     apparel_inventory_management == 1'b1 |->      $past(garment_location_tracking_accuracy) &&      ($past(inventory_discrepancy_resolution_time) > acceptable_reconciliation_duration)", "sva_name": "p_apparel_inventory_management", "id": "3667", "full_property": "property p_Apparel_Inventory_Management;\n@(posedge clk_garment_logistics) disable iff (!rfid_tracking_system_enabled)     apparel_inventory_management == 1'b1 |->      $past(garment_location_tracking_accuracy) &&      ($past(inventory_discrepancy_resolution_time) > acceptable_reconciliation_duration)\nendproperty\nassert_p_Apparel_Inventory_Management:assert property (p_Apparel_Inventory_Management) else $error(\"\");", "task_id": "3_7247", "predict_sva": "@(posedge clk_garment_logistics) disable iff (!rfid_tracking_system_enabled)     apparel_inventory_management == 1'b1 |->      $past(garment_location_tracking_accuracy) &&      ($past(inventory_discrepancy_resolution_time) > acceptable_reconciliation_duration)"}
{"id": "324_8_0235", "name": "p_sync_done_handshake_clkB", "sva": "@(posedge clk_B)     $fell(sync_done_clkA) |-> !sync_done_clkB[*1:$] ##1 sync_done_clkB", "ori_sva": "property p_sync_done_handshake_clkB;\n@(posedge clk_B)     $fell(sync_done_clkA) |-> !sync_done_clkB[*1:$] ##1 sync_done_clkB;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_done_fall_check  \n**Trigger Condition**: At every rising edge of the `clk_B`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(sync_done_clkA)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!sync_done_clkB[*1:$] ##1 sync_done_clkB`  ", "sva_signals": ["clk_B", "sync_done_clkA", "sync_done_clkB"], "clock": "clk_B", "attempts_left": 10, "sva_result": "@(posedge clk_B)     $fell(sync_done_clkA) |-> !sync_done_clkB[*1:$] ##1 sync_done_clkB", "sva_name": "sync_pulse_alignment", "full_property": "property p_sync_done_fall_check;\n@(posedge clk_B)     $fell(sync_done_clkA) |-> !sync_done_clkB[*1:$] ##1 sync_done_clkB\nendproperty\nassert_p_sync_done_fall_check:assert property (p_sync_done_fall_check) else $error(\"\");", "task_id": "3_7778", "predict_sva": "@(posedge clk_B)     $fell(sync_done_clkA) |-> !sync_done_clkB[*1:$] ##1 sync_done_clkB"}
{"sva": "@(posedge clk_coastal_erosion) disable iff(!shoreline_monitoring_system_operational) beach_nourishment_effectiveness |-> ($past(sand_volume_loss_rate) > sustainable_erosion_threshold) && ($past(sediment_replenishment_schedule) == replenishment_overdue)", "sva_description": "### Assertion description:  \n**Property Name**: p_beach_nourishment_effectiveness  \n**Trigger Condition**: At every rising edge of the `clk_coastal_erosion`  \n**Disable Condition**: disable iff (`!shoreline_monitoring_system_operational`)  \n**Antecedent (LHS of Implication)**: `beach_nourishment_effectiveness`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(sand_volume_loss_rate) > sustainable_erosion_threshold) && ($past(sediment_replenishment_schedule) == replenishment_overdue)`", "sva_signals": ["clk_coastal_erosion", "shoreline_monitoring_system_operational", "[0:0] beach_nourishment_effectiveness", "[0:0] sand_volume_loss_rate", "[0:0] sustainable_erosion_threshold", "[0:0] sediment_replenishment_schedule", "[0:0] replenishment_overdue"], "clock": "clk_coastal_erosion", "attempts_left": 10, "sva_result": "@(posedge clk_coastal_erosion) disable iff (!shoreline_monitoring_system_operational)     beach_nourishment_effectiveness |->          ($past(sand_volume_loss_rate) > sustainable_erosion_threshold) &&          ($past(sediment_replenishment_schedule) == replenishment_overdue)", "sva_name": "p_Beach_Nourishment_Effectiveness", "id": "3570", "full_property": "property p_beach_nourishment_effectiveness;\n@(posedge clk_coastal_erosion) disable iff (!shoreline_monitoring_system_operational)     beach_nourishment_effectiveness |->          ($past(sand_volume_loss_rate) > sustainable_erosion_threshold) &&          ($past(sediment_replenishment_schedule) == replenishment_overdue)\nendproperty\nassert_p_beach_nourishment_effectiveness:assert property (p_beach_nourishment_effectiveness) else $error(\"\");", "task_id": "3_7152", "predict_sva": "@(posedge clk_coastal_erosion) disable iff (!shoreline_monitoring_system_operational)     beach_nourishment_effectiveness |->          ($past(sand_volume_loss_rate) > sustainable_erosion_threshold) &&          ($past(sediment_replenishment_schedule) == replenishment_overdue)"}
{"sva": "@(negedge clk_embroidery) disable iff(!computerized_embroidery_design_loaded) decorative_stitching_precision |-> ($past(thread_color_change_sequence) && $past(needle_positioning_accuracy)) && ($past(design_registration_error) > embroidery_tolerance_specification)", "sva_description": "### Assertion description:  \n**Property Name**: p_Decorative_Stitching_Precision  \n**Trigger Condition**: At every falling edge of the `clk_embroidery`  \n**Disable Condition**: `disable iff (!computerized_embroidery_design_loaded)`  \n**Antecedent (LHS of Implication)**: `decorative_stitching_precision`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(thread_color_change_sequence) && $past(needle_positioning_accuracy)) && ($past(design_registration_error) > embroidery_tolerance_specification)`", "sva_signals": ["clk_embroidery", "computerized_embroidery_design_loaded", "[0:0] decorative_stitching_precision", "thread_color_change_sequence", "needle_positioning_accuracy", "design_registration_error", "embroidery_tolerance_specification"], "clock": "clk_embroidery", "attempts_left": 10, "sva_result": "@(negedge clk_embroidery) disable iff (!computerized_embroidery_design_loaded)     decorative_stitching_precision |->          ($past(thread_color_change_sequence) && $past(needle_positioning_accuracy)) &&          ($past(design_registration_error) > embroidery_tolerance_specification)", "sva_name": "p_Decorative_Stitching_Precision", "id": "3676", "full_property": "property p_Decorative_Stitching_Precision;\n@(negedge clk_embroidery) disable iff (!computerized_embroidery_design_loaded)     decorative_stitching_precision |->          ($past(thread_color_change_sequence) && $past(needle_positioning_accuracy)) &&          ($past(design_registration_error) > embroidery_tolerance_specification)\nendproperty\nassert_p_Decorative_Stitching_Precision:assert property (p_Decorative_Stitching_Precision) else $error(\"\");", "task_id": "3_7254", "predict_sva": "@(negedge clk_embroidery) disable iff (!computerized_embroidery_design_loaded)     decorative_stitching_precision |->          ($past(thread_color_change_sequence) && $past(needle_positioning_accuracy)) &&          ($past(design_registration_error) > embroidery_tolerance_specification)"}
{"id": "333_2_0270", "name": "p_alert_implies_protect", "sva": "@(negedge clk_prot)     (temp_alert || voltage_alert || current_alert) |=> ##1 protect_action", "ori_sva": "property p_alert_implies_protect;\n@(negedge clk_prot)     (temp_alert || voltage_alert || current_alert) |=> ##1 protect_action;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Alert_Protect_Action  \n**Trigger Condition**: At every falling edge of the `clk_prot`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(temp_alert || voltage_alert || current_alert)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##1 protect_action`  ", "sva_signals": ["clk_prot", "temp_alert", "voltage_alert", "current_alert", "protect_action"], "clock": "clk_prot", "attempts_left": 10, "sva_result": "@(negedge clk_prot)     (temp_alert || voltage_alert || current_alert) |=> ##1 protect_action", "sva_name": "p_Alert_To_Protect_Action", "full_property": "property p_Alert_Protect_Action;\n@(negedge clk_prot)     (temp_alert || voltage_alert || current_alert) |=> ##1 protect_action\nendproperty\nassert_p_Alert_Protect_Action:assert property (p_Alert_Protect_Action) else $error(\"\");", "task_id": "3_7818", "predict_sva": "@(negedge clk_prot)     (temp_alert || voltage_alert || current_alert) |-> ##1 protect_action"}
{"sva": "@(posedge clk) disable iff(international_waters_jurisdiction_dispute) maritime_law_enforcement |-> $past(vessel_inspection_authority_challenge) && ($past(boarding_party_safety_protocol_compliance) != international_maritime_law_adherence_verified)", "sva_description": "### Assertion description:  \n**Property Name**: p_maritime_law_enforcement_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (international_waters_jurisdiction_dispute)  \n**Antecedent (LHS of Implication)**: `maritime_law_enforcement == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(vessel_inspection_authority_challenge) && ($past(boarding_party_safety_protocol_compliance) != international_maritime_law_adherence_verified)`  ", "sva_signals": ["clk", "rst_n", "[0:0] international_waters_jurisdiction_dispute", "[0:0] maritime_law_enforcement", "[0:0] vessel_inspection_authority_challenge", "[0:0] boarding_party_safety_protocol_compliance", "[0:0] international_maritime_law_adherence_verified"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (international_waters_jurisdiction_dispute)     maritime_law_enforcement == 1'b1 |->      $past(vessel_inspection_authority_challenge) &&      ($past(boarding_party_safety_protocol_compliance) != international_maritime_law_adherence_verified)", "sva_name": "p_Maritime_Law_Enforcement_Check", "id": "3604", "full_property": "property p_maritime_law_enforcement_check;\n@(posedge clk) disable iff (international_waters_jurisdiction_dispute)     maritime_law_enforcement == 1'b1 |->      $past(vessel_inspection_authority_challenge) &&      ($past(boarding_party_safety_protocol_compliance) != international_maritime_law_adherence_verified)\nendproperty\nassert_p_maritime_law_enforcement_check:assert property (p_maritime_law_enforcement_check) else $error(\"\");", "task_id": "3_7184", "predict_sva": "@(posedge clk) disable iff (international_waters_jurisdiction_dispute)     maritime_law_enforcement == 1'b1 |->      $past(vessel_inspection_authority_challenge) &&      ($past(boarding_party_safety_protocol_compliance) != international_maritime_law_adherence_verified)"}
{"sva": "@(negedge clk_silage_bunker) disable iff(forage_preservation_quality_assessment_pending) silage_fermentation_monitoring |-> ($past(silage_ph_level_measurement) > optimal_fermentation_ph_range) && !$past(silage_additive_application_adjustment, 7)", "sva_description": "### Assertion description:  \n**Property Name**: p_Silage_Fermentation_Monitoring  \n**Trigger Condition**: At every falling edge of the `clk_silage_bunker`  \n**Disable Condition**: `disable iff (forage_preservation_quality_assessment_pending)`  \n**Antecedent (LHS of Implication)**: `silage_fermentation_monitoring`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(silage_ph_level_measurement) > optimal_fermentation_ph_range) && !$past(silage_additive_application_adjustment, 7)`  ", "sva_signals": ["clk_silage_bunker", "forage_preservation_quality_assessment_pending", "[0:0] silage_fermentation_monitoring", "[0:0] silage_ph_level_measurement", "[0:0] optimal_fermentation_ph_range", "[0:0] silage_additive_application_adjustment"], "clock": "clk_silage_bunker", "attempts_left": 10, "sva_result": "@(negedge clk_silage_bunker) disable iff (forage_preservation_quality_assessment_pending)     silage_fermentation_monitoring |->          ($past(silage_ph_level_measurement) > optimal_fermentation_ph_range) &&          !$past(silage_additive_application_adjustment, 7)", "sva_name": "p_Silage_Fermentation_Monitoring", "id": "3662", "full_property": "property p_Silage_Fermentation_Monitoring;\n@(negedge clk_silage_bunker) disable iff (forage_preservation_quality_assessment_pending)     silage_fermentation_monitoring |->          ($past(silage_ph_level_measurement) > optimal_fermentation_ph_range) &&          !$past(silage_additive_application_adjustment, 7)\nendproperty\nassert_p_Silage_Fermentation_Monitoring:assert property (p_Silage_Fermentation_Monitoring) else $error(\"\");", "task_id": "3_7242", "predict_sva": "@(negedge clk_silage_bunker) disable iff (forage_preservation_quality_assessment_pending)     silage_fermentation_monitoring |->          ($past(silage_ph_level_measurement) > optimal_fermentation_ph_range) &&          !$past(silage_additive_application_adjustment, 7)"}
{"sva": "@(posedge clk) disable iff(construction_performance_measurement_system_calibration_overdue) project_performance_optimization |-> ($past(performance_indicator_accuracy_validation) && $past(benchmark_comparison_analysis_reliability)) && ($past(performance_improvement_target_achievement) == construction_excellence_objective_realization_shortfall)", "sva_description": "### Assertion description:  \n**Property Name**: p_Performance_Optimization_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (construction_performance_measurement_system_calibration_overdue)`  \n**Antecedent (LHS of Implication)**: `project_performance_optimization == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(performance_indicator_accuracy_validation) && $past(benchmark_comparison_analysis_reliability)) && ($past(performance_improvement_target_achievement) == construction_excellence_objective_realization_shortfall)`  ", "sva_signals": ["clk", "[0:0] construction_performance_measurement_system_calibration_overdue", "[0:0] project_performance_optimization", "[0:0] performance_indicator_accuracy_validation", "[0:0] benchmark_comparison_analysis_reliability", "[0:0] performance_improvement_target_achievement", "[0:0] construction_excellence_objective_realization_shortfall"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (construction_performance_measurement_system_calibration_overdue)     project_performance_optimization == 1'b1 |->      ($past(performance_indicator_accuracy_validation) &&       $past(benchmark_comparison_analysis_reliability)) &&      ($past(performance_improvement_target_achievement) == construction_excellence_objective_realization_shortfall)", "sva_name": "p_project_performance_optimization", "id": "3792", "full_property": "property p_Performance_Optimization_Check;\n@(posedge clk)     disable iff (construction_performance_measurement_system_calibration_overdue)     project_performance_optimization == 1'b1 |->      ($past(performance_indicator_accuracy_validation) &&       $past(benchmark_comparison_analysis_reliability)) &&      ($past(performance_improvement_target_achievement) == construction_excellence_objective_realization_shortfall)\nendproperty\nassert_p_Performance_Optimization_Check:assert property (p_Performance_Optimization_Check) else $error(\"\");", "task_id": "3_7367", "predict_sva": "@(posedge clk) disable iff (construction_performance_measurement_system_calibration_overdue)     project_performance_optimization |->      ($past(performance_indicator_accuracy_validation) && $past(benchmark_comparison_analysis_reliability)) &&     ($past(performance_improvement_target_achievement) == construction_excellence_objective_realization_shortfall)"}
{"id": "333_3_0251", "name": "p_no_protect_without_alert", "sva": "@(posedge clk_mon)     protect_action |-> $past(temp_alert || voltage_alert || current_alert)", "ori_sva": "property p_no_protect_without_alert;\n@(posedge clk_mon)     protect_action |-> $past(temp_alert || voltage_alert || current_alert);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_protect_action_alert  \n**Trigger Condition**: At every rising edge of the `clk_mon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `protect_action == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(temp_alert || voltage_alert || current_alert)`  ", "sva_signals": ["clk_mon", "[0:0] protect_action", "[0:0] temp_alert", "[0:0] voltage_alert", "[0:0] current_alert"], "clock": "clk_mon", "attempts_left": 10, "sva_result": "@(posedge clk_mon)     protect_action == 1'b1 |-> $past(temp_alert || voltage_alert || current_alert)", "sva_name": "p_protect_action_trigger", "full_property": "property p_protect_action_alert;\n@(posedge clk_mon)     protect_action == 1'b1 |-> $past(temp_alert || voltage_alert || current_alert)\nendproperty\nassert_p_protect_action_alert:assert property (p_protect_action_alert) else $error(\"\");", "task_id": "3_7819", "predict_sva": "@(posedge clk_mon)     protect_action == 1'b1 |-> $past(temp_alert | voltage_alert | current_alert, 1)"}
{"sva": "@(posedge clk_game_analytics) disable iff(player_data_privacy_mode_enabled) behavioral_pattern_analysis |-> $past(player_engagement_metric_collection) && ($past(gameplay_optimization_insight_generation) == insufficient_data_analysis_depth)", "sva_description": "### Assertion description:  \n**Property Name**: p_Behavioral_Pattern_Analysis  \n**Trigger Condition**: At every rising edge of the `clk_game_analytics`  \n**Disable Condition**: `disable iff (player_data_privacy_mode_enabled)`  \n**Antecedent (LHS of Implication)**: `behavioral_pattern_analysis == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(player_engagement_metric_collection) && ($past(gameplay_optimization_insight_generation) == insufficient_data_analysis_depth)`  ", "sva_signals": ["clk_game_analytics", "player_data_privacy_mode_enabled", "[0:0] behavioral_pattern_analysis", "[0:0] player_engagement_metric_collection", "[0:0] gameplay_optimization_insight_generation", "[0:0] insufficient_data_analysis_depth"], "clock": "clk_game_analytics", "attempts_left": 10, "sva_result": "@(posedge clk_game_analytics) disable iff (player_data_privacy_mode_enabled)     behavioral_pattern_analysis == 1'b1 |->      $past(player_engagement_metric_collection) &&      ($past(gameplay_optimization_insight_generation) == insufficient_data_analysis_depth)", "sva_name": "p_Behavioral_Pattern_Analysis", "id": "3815", "full_property": "property p_Behavioral_Pattern_Analysis;\n@(posedge clk_game_analytics) disable iff (player_data_privacy_mode_enabled)     behavioral_pattern_analysis == 1'b1 |->      $past(player_engagement_metric_collection) &&      ($past(gameplay_optimization_insight_generation) == insufficient_data_analysis_depth)\nendproperty\nassert_p_Behavioral_Pattern_Analysis:assert property (p_Behavioral_Pattern_Analysis) else $error(\"\");", "task_id": "3_7389", "predict_sva": "@(posedge clk_game_analytics) disable iff (player_data_privacy_mode_enabled)     behavioral_pattern_analysis == 1'b1 |->      $past(player_engagement_metric_collection) &&      ($past(gameplay_optimization_insight_generation) == insufficient_data_analysis_depth)"}
{"sva": "@(posedge clk_construction_innovation) disable iff(!emerging_technology_feasibility_assessment_complete) construction_industry_modernization |-> $past(innovation_adoption_readiness_evaluation) && ($past(technology_integration_success_rate) < industry_transformation_advancement_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Construction_Industry_Modernization  \n**Trigger Condition**: At every rising edge of the `clk_construction_innovation`  \n**Disable Condition**: `disable iff (!emerging_technology_feasibility_assessment_complete)`  \n**Antecedent (LHS of Implication)**: `construction_industry_modernization`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(innovation_adoption_readiness_evaluation) && ($past(technology_integration_success_rate) < industry_transformation_advancement_target)`", "sva_signals": ["clk_construction_innovation", "emerging_technology_feasibility_assessment_complete", "[0:0] construction_industry_modernization", "[0:0] innovation_adoption_readiness_evaluation", "[0:0] technology_integration_success_rate", "[0:0] industry_transformation_advancement_target"], "clock": "clk_construction_innovation", "attempts_left": 10, "sva_result": "@(posedge clk_construction_innovation) disable iff (!emerging_technology_feasibility_assessment_complete)     construction_industry_modernization |->      ($past(innovation_adoption_readiness_evaluation) &&       ($past(technology_integration_success_rate) < industry_transformation_advancement_target))", "sva_name": "p_construction_industry_modernization_check", "id": "3795", "full_property": "property p_Construction_Industry_Modernization;\n@(posedge clk_construction_innovation) disable iff (!emerging_technology_feasibility_assessment_complete)     construction_industry_modernization |->      ($past(innovation_adoption_readiness_evaluation) &&       ($past(technology_integration_success_rate) < industry_transformation_advancement_target))\nendproperty\nassert_p_Construction_Industry_Modernization:assert property (p_Construction_Industry_Modernization) else $error(\"\");", "task_id": "3_7370", "predict_sva": "@(posedge clk_construction_innovation) disable iff (!emerging_technology_feasibility_assessment_complete)     construction_industry_modernization |->          $past(innovation_adoption_readiness_evaluation) &&          ($past(technology_integration_success_rate) < industry_transformation_advancement_target)"}
{"sva": "@(negedge clk_augmented_reality) disable iff(!ar_tracking_system_calibration_valid) augmented_reality_object_registration |-> ($past(real_world_coordinate_mapping_accuracy) && $past(virtual_object_alignment_precision)) && ($past(ar_experience_immersion_quality) < augmented_reality_fidelity_benchmark)", "sva_description": "### Assertion description:  \n**Property Name**: p_augmented_reality_object_registration  \n**Trigger Condition**: At every negedge of the `clk_augmented_reality`  \n**Disable Condition**: disable iff (!ar_tracking_system_calibration_valid)  \n**Antecedent (LHS of Implication)**: `augmented_reality_object_registration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: ($past(real_world_coordinate_mapping_accuracy) && $past(virtual_object_alignment_precision)) && ($past(ar_experience_immersion_quality) < augmented_reality_fidelity_benchmark)", "sva_signals": ["clk_augmented_reality", "ar_tracking_system_calibration_valid", "[0:0] augmented_reality_object_registration", "real_world_coordinate_mapping_accuracy", "virtual_object_alignment_precision", "ar_experience_immersion_quality", "augmented_reality_fidelity_benchmark"], "clock": "clk_augmented_reality", "attempts_left": 10, "sva_result": "@(negedge clk_augmented_reality) disable iff (!ar_tracking_system_calibration_valid)     augmented_reality_object_registration |->          ($past(real_world_coordinate_mapping_accuracy) && $past(virtual_object_alignment_precision)) &&          ($past(ar_experience_immersion_quality) < augmented_reality_fidelity_benchmark)", "sva_name": "p_augmented_reality_object_registration", "id": "3806", "full_property": "property p_augmented_reality_object_registration;\n@(negedge clk_augmented_reality) disable iff (!ar_tracking_system_calibration_valid)     augmented_reality_object_registration |->          ($past(real_world_coordinate_mapping_accuracy) && $past(virtual_object_alignment_precision)) &&          ($past(ar_experience_immersion_quality) < augmented_reality_fidelity_benchmark)\nendproperty\nassert_p_augmented_reality_object_registration:assert property (p_augmented_reality_object_registration) else $error(\"\");", "task_id": "3_7380", "predict_sva": "@(negedge clk_augmented_reality) disable iff (!ar_tracking_system_calibration_valid)     augmented_reality_object_registration |->          ($past(real_world_coordinate_mapping_accuracy) && $past(virtual_object_alignment_precision)) &&          ($past(ar_experience_immersion_quality) < augmented_reality_fidelity_benchmark)"}
{"id": "339_5_0320", "name": "p_reset_valid_5", "sva": "@(posedge clk_sys)     $fell(power_good) |-> ##[1:3] $fell(rst_n)", "ori_sva": "property p_reset_valid_5;\n@(posedge clk_sys)     $fell(power_good) |-> ##[1:3] $fell(rst_n);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PowerGood_Fell_To_RstN_Fell  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(power_good)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $fell(rst_n)`  ", "sva_signals": ["clk_sys", "rst_n", "power_good"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(power_good) |-> ##[1:3] $fell(rst_n)", "sva_name": "p_PowerGood_Fell_RstN_Fell", "full_property": "property p_PowerGood_Fell_To_RstN_Fell;\n@(posedge clk_sys)     $fell(power_good) |-> ##[1:3] $fell(rst_n)\nendproperty\nassert_p_PowerGood_Fell_To_RstN_Fell:assert property (p_PowerGood_Fell_To_RstN_Fell) else $error(\"\");", "task_id": "3_7861", "predict_sva": "@(posedge clk_sys)     $fell(power_good) |-> ##[1:3] $fell(rst_n)"}
{"id": "376_5_0629", "name": "p_dual_reg_xor_transition", "sva": "@(posedge clk_signal)     $rose(reg_primary) |-> (reg_backup == reg_primary)", "ori_sva": "property p_dual_reg_xor_transition;\n@(posedge clk_signal)     $rose(reg_primary) |-> (reg_backup == reg_primary);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_RegBackupMatchPrimary  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(reg_primary)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `reg_backup == reg_primary`", "sva_signals": ["clk_signal", "reg_primary", "reg_backup"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(reg_primary) |-> reg_backup == reg_primary", "sva_name": "p_RegPrimary_RegBackup", "full_property": "property p_RegBackupMatchPrimary;\n@(posedge clk_signal)         $rose(reg_primary) |-> reg_backup == reg_primary\nendproperty\nassert_p_RegBackupMatchPrimary:assert property (p_RegBackupMatchPrimary) else $error(\"\");", "task_id": "3_8114", "predict_sva": "@(posedge clk_signal)         $rose(reg_primary) |-> (reg_backup == reg_primary)"}
{"id": "348_4_0391", "name": "p_fault_protection_cover", "sva": "@(posedge clk_sys)     fault_detected ##0 !sensitive_op_active", "ori_sva": "property p_fault_protection_cover;\n@(posedge clk_sys)     fault_detected ##0 !sensitive_op_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fault_detected_no_sensitive_op  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fault_detected`  \n**Implication Operator**: `##0` (overlapping with the same clock cycle)  \n**Consequent (RHS of Implication)**: `!sensitive_op_active`  \n\n(Note: Since `##0` is used, this is not a traditional implication but rather a concurrent check that both `fault_detected` and `!sensitive_op_active` must hold at the same clock edge.)", "sva_signals": ["clk_sys", "[0:0] fault_detected", "[0:0] sensitive_op_active"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     fault_detected ##0 !sensitive_op_active", "sva_name": "p_Fault_Detected_Check", "full_property": "property p_fault_detected_no_sensitive_op;\n@(posedge clk_sys)     fault_detected ##0 !sensitive_op_active\nendproperty\nassert_p_fault_detected_no_sensitive_op:assert property (p_fault_detected_no_sensitive_op) else $error(\"\");", "task_id": "3_7930", "predict_sva": "@(posedge clk_sys)     fault_detected == 1'b1 |-> !sensitive_op_active"}
{"id": "331_5_0263", "name": "auth_pass_phases_no_glitch", "sva": "@(posedge clk_signal)     $rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) |->      auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3 [*3]", "ori_sva": "property auth_pass_phases_no_glitch;\n@(posedge clk_signal)     $rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) |->      auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3 [*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_auth_pass_phases  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3 [*3]`  ", "sva_signals": ["clk", "rst_n", "[0:0] auth_pass_phase1", "[0:0] auth_pass_phase2", "[0:0] auth_pass_phase3", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) |->          (auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) [*3]", "sva_name": "p_auth_pass_phases", "full_property": "property p_auth_pass_phases;\n@(posedge clk_signal)         $rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) |->          (auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) [*3]\nendproperty\nassert_p_auth_pass_phases:assert property (p_auth_pass_phases) else $error(\"\");", "task_id": "3_7809", "predict_sva": "@(posedge clk_signal)     $rose(auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3) |->      (auth_pass_phase1 && auth_pass_phase2 && auth_pass_phase3)[*3]"}
{"sva": "@(negedge clk_quality_control) disable iff(third_party_inspection_agency_unavailable) construction_quality_assurance_verification |-> ($past(material_testing_laboratory_certification_current) && $past(inspection_checklist_completion_documentation)) && ($past(quality_standard_compliance_validation) != construction_excellence_benchmark_achievement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Construction_Quality_Assurance_Verification  \n**Trigger Condition**: At every falling edge of `clk_quality_control`  \n**Disable Condition**: `disable iff (third_party_inspection_agency_unavailable)`  \n**Antecedent (LHS of Implication)**: `construction_quality_assurance_verification`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(material_testing_laboratory_certification_current) && $past(inspection_checklist_completion_documentation)) && ($past(quality_standard_compliance_validation) != construction_excellence_benchmark_achievement)`  ", "sva_signals": ["clk_quality_control", "third_party_inspection_agency_unavailable", "[0:0] construction_quality_assurance_verification", "material_testing_laboratory_certification_current", "inspection_checklist_completion_documentation", "quality_standard_compliance_validation", "construction_excellence_benchmark_achievement"], "clock": "clk_quality_control", "attempts_left": 10, "sva_result": "@(negedge clk_quality_control) disable iff (third_party_inspection_agency_unavailable)     construction_quality_assurance_verification |->          ($past(material_testing_laboratory_certification_current) &&           $past(inspection_checklist_completion_documentation)) &&          ($past(quality_standard_compliance_validation) != construction_excellence_benchmark_achievement)", "sva_name": "p_Construction_Quality_Assurance_Verification", "id": "3776", "full_property": "property p_Construction_Quality_Assurance_Verification;\n@(negedge clk_quality_control) disable iff (third_party_inspection_agency_unavailable)     construction_quality_assurance_verification |->          ($past(material_testing_laboratory_certification_current) &&           $past(inspection_checklist_completion_documentation)) &&          ($past(quality_standard_compliance_validation) != construction_excellence_benchmark_achievement)\nendproperty\nassert_p_Construction_Quality_Assurance_Verification:assert property (p_Construction_Quality_Assurance_Verification) else $error(\"\");", "task_id": "3_7351", "predict_sva": "@(negedge clk_quality_control) disable iff (third_party_inspection_agency_unavailable)     construction_quality_assurance_verification |->      ($past(material_testing_laboratory_certification_current) && $past(inspection_checklist_completion_documentation)) &&     ($past(quality_standard_compliance_validation) != construction_excellence_benchmark_achievement)"}
{"sva": "@(posedge clk_mine_planning) disable iff(!production_scheduling_system_updated) mine_production_optimization |-> ($past(ore_grade_control_variance) > acceptable_grade_deviation) && ($past(mining_sequence_adjustment) == no_sequence_modification)", "sva_description": "### Assertion description:  \n**Property Name**: p_Mine_Production_Optimization  \n**Trigger Condition**: At every rising edge of the `clk_mine_planning`  \n**Disable Condition**: `disable iff (!production_scheduling_system_updated)`  \n**Antecedent (LHS of Implication)**: `mine_production_optimization == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(ore_grade_control_variance) > acceptable_grade_deviation)` **and**  \n- `($past(mining_sequence_adjustment) == no_sequence_modification)`  \n\nThe assertion checks that whenever `mine_production_optimization` is active, the past values of `ore_grade_control_variance` must exceed the `acceptable_grade_deviation` threshold, and the past `mining_sequence_adjustment` must indicate no sequence modification. The check is skipped if `production_scheduling_system_updated` is low (disable condition).", "sva_signals": ["clk_mine_planning", "production_scheduling_system_updated", "mine_production_optimization", "[0:0] ore_grade_control_variance", "[0:0] acceptable_grade_deviation", "[0:0] mining_sequence_adjustment", "[0:0] no_sequence_modification"], "clock": "clk_mine_planning", "attempts_left": 10, "sva_result": "@(posedge clk_mine_planning) disable iff (!production_scheduling_system_updated)     mine_production_optimization == 1'b1 |->          ($past(ore_grade_control_variance) > acceptable_grade_deviation) &&         ($past(mining_sequence_adjustment) == no_sequence_modification)", "sva_name": "p_Mine_Production_Optimization", "id": "3532", "full_property": "property p_Mine_Production_Optimization;\n@(posedge clk_mine_planning) disable iff (!production_scheduling_system_updated)     mine_production_optimization == 1'b1 |->          ($past(ore_grade_control_variance) > acceptable_grade_deviation) &&         ($past(mining_sequence_adjustment) == no_sequence_modification)\nendproperty\nassert_p_Mine_Production_Optimization:assert property (p_Mine_Production_Optimization) else $error(\"\");", "task_id": "3_7114", "predict_sva": "@(posedge clk_mine_planning) disable iff (!production_scheduling_system_updated)     mine_production_optimization == 1'b1 |->      ($past(ore_grade_control_variance) > acceptable_grade_deviation) &&      ($past(mining_sequence_adjustment) == no_sequence_modification)"}
{"sva": "@(posedge clk_icf_driver) disable iff(!inertial_confinement_enable) inertial_confinement_fusion_laser |-> ($past(pulse_shaping_profile[31:0], 1) && $past(target_illumination[15:0], 1) && $past(compression_symmetry[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Inertial_Confinement_Fusion_Laser  \n**Trigger Condition**: At every rising edge of the `clk_icf_driver`  \n**Disable Condition**: `disable iff (!inertial_confinement_enable)`  \n**Antecedent (LHS of Implication)**: `inertial_confinement_fusion_laser`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(pulse_shaping_profile[31:0], 1) && $past(target_illumination[15:0], 1) && $past(compression_symmetry[11:0], 1))`  \n\nThe assertion checks that when `inertial_confinement_fusion_laser` is active (LHS), the past values of `pulse_shaping_profile[31:0]`, `target_illumination[15:0]`, and `compression_symmetry[11:0]` (sampled at the previous clock cycle) must all be logically true (non-zero) on the RHS. The assertion is disabled if `inertial_confinement_enable` is low.", "sva_signals": ["clk_icf_driver", "inertial_confinement_enable", "inertial_confinement_fusion_laser", "[31:0] pulse_shaping_profile", "[15:0] target_illumination", "[11:0] compression_symmetry"], "clock": "clk_icf_driver", "attempts_left": 10, "sva_result": "@(posedge clk_icf_driver) disable iff (!inertial_confinement_enable)     inertial_confinement_fusion_laser |->          ($past(pulse_shaping_profile[31:0], 1) &&           $past(target_illumination[15:0], 1) &&           $past(compression_symmetry[11:0], 1))", "sva_name": "p_inertial_confinement_fusion", "id": "2828", "full_property": "property p_Inertial_Confinement_Fusion_Laser;\n@(posedge clk_icf_driver) disable iff (!inertial_confinement_enable)     inertial_confinement_fusion_laser |->          ($past(pulse_shaping_profile[31:0], 1) &&           $past(target_illumination[15:0], 1) &&           $past(compression_symmetry[11:0], 1))\nendproperty\nassert_p_Inertial_Confinement_Fusion_Laser:assert property (p_Inertial_Confinement_Fusion_Laser) else $error(\"\");", "task_id": "3_6472", "predict_sva": "@(posedge clk_icf_driver) disable iff (!inertial_confinement_enable)     inertial_confinement_fusion_laser |->          ($past(pulse_shaping_profile[31:0], 1) &&           $past(target_illumination[15:0], 1) &&           $past(compression_symmetry[11:0], 1))"}
{"id": "371_6_0587", "name": "p_dma_start_cond6", "sva": "@(posedge clk_i)     dma_en_i |-> (sw_trigger_i || hw_request_i) throughout dma_start_o", "ori_sva": "property p_dma_start_cond6;\n@(posedge clk_i)     dma_en_i |-> (sw_trigger_i || hw_request_i) throughout dma_start_o;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_en_trigger  \n**Trigger Condition**: At every rising edge of the `clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_en_i == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(sw_trigger_i || hw_request_i) throughout dma_start_o`  ", "sva_signals": ["clk_i", "rst_n", "[0:0] dma_en_i", "[0:0] sw_trigger_i", "[0:0] hw_request_i", "[0:0] dma_start_o"], "clock": "clk_i", "attempts_left": 10, "sva_result": "@(posedge clk_i)         dma_en_i == 1'b1 |-> (sw_trigger_i || hw_request_i) throughout dma_start_o", "sva_name": "p_dma_trigger_condition", "full_property": "property p_dma_en_trigger;\n@(posedge clk_i)         dma_en_i == 1'b1 |-> (sw_trigger_i || hw_request_i) throughout dma_start_o\nendproperty\nassert_p_dma_en_trigger:assert property (p_dma_en_trigger) else $error(\"\");", "task_id": "3_8087", "predict_sva": "@(posedge clk_i)     dma_en_i == 1'b1 |-> (sw_trigger_i || hw_request_i) throughout dma_start_o"}
{"sva": "@(posedge clk_navigation) disable iff(gps_signal_unavailable_deep_space) autonomous_navigation_system |-> ($past(inertial_navigation_drift_accumulation) && $past(celestial_navigation_accuracy)) && ($past(position_determination_confidence) < mission_navigation_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Autonomous_Navigation_Check  \n**Trigger Condition**: At every rising edge of the `clk_navigation`  \n**Disable Condition**: `disable iff (gps_signal_unavailable_deep_space)`  \n**Antecedent (LHS of Implication)**: `autonomous_navigation_system == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(inertial_navigation_drift_accumulation) && $past(celestial_navigation_accuracy)) && ($past(position_determination_confidence) < mission_navigation_requirement)`  ", "sva_signals": ["clk_navigation", "gps_signal_unavailable_deep_space", "[0:0] autonomous_navigation_system", "[0:0] inertial_navigation_drift_accumulation", "[0:0] celestial_navigation_accuracy", "[0:0] position_determination_confidence", "[0:0] mission_navigation_requirement"], "clock": "clk_navigation", "attempts_left": 10, "sva_result": "@(posedge clk_navigation) disable iff (gps_signal_unavailable_deep_space)     autonomous_navigation_system == 1'b1 |->      ($past(inertial_navigation_drift_accumulation) && $past(celestial_navigation_accuracy)) &&      ($past(position_determination_confidence) < mission_navigation_requirement)", "sva_name": "p_Autonomous_Navigation_Check", "id": "3938", "full_property": "property p_Autonomous_Navigation_Check;\n@(posedge clk_navigation) disable iff (gps_signal_unavailable_deep_space)     autonomous_navigation_system == 1'b1 |->      ($past(inertial_navigation_drift_accumulation) && $past(celestial_navigation_accuracy)) &&      ($past(position_determination_confidence) < mission_navigation_requirement)\nendproperty\nassert_p_Autonomous_Navigation_Check:assert property (p_Autonomous_Navigation_Check) else $error(\"\");", "task_id": "3_7509", "predict_sva": "@(posedge clk_navigation) disable iff (gps_signal_unavailable_deep_space)     autonomous_navigation_system == 1'b1 |->      ($past(inertial_navigation_drift_accumulation) && $past(celestial_navigation_accuracy)) &&      ($past(position_determination_confidence) < mission_navigation_requirement)"}
{"id": "438_10_1123", "name": "p_addr_change_only_with_new_trans", "sva": "@(posedge clk_core)     $changed(core_dest_addr) |-> !$past(core_comm_busy) && core_comm_enable", "ori_sva": "property p_addr_change_only_with_new_trans;\n@(posedge clk_core)     $changed(core_dest_addr) |-> !$past(core_comm_busy) && core_comm_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_core_dest_addr_change  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(core_dest_addr)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(core_comm_busy) && core_comm_enable`  ", "sva_signals": ["clk_core", "core_dest_addr", "core_comm_busy", "core_comm_enable"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $changed(core_dest_addr) |-> !$past(core_comm_busy) && core_comm_enable", "sva_name": "p_core_dest_addr_change", "full_property": "property p_core_dest_addr_change;\n@(posedge clk_core)     $changed(core_dest_addr) |-> !$past(core_comm_busy) && core_comm_enable\nendproperty\nassert_p_core_dest_addr_change:assert property (p_core_dest_addr_change) else $error(\"\");", "task_id": "3_8302", "predict_sva": "@(posedge clk_core)     $changed(core_dest_addr) |-> ($past(!core_comm_busy) && core_comm_enable)"}
{"id": "383_2_0667", "name": "p_any_alert_leads_to_protection", "sva": "@(posedge clk_signal)     $rose(temp_alert || voltage_alert || current_alert) |=> protection_trigger", "ori_sva": "property p_any_alert_leads_to_protection;\n@(posedge clk_signal)     $rose(temp_alert || voltage_alert || current_alert) |=> protection_trigger;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Protection_Trigger_On_Alert  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(temp_alert || voltage_alert || current_alert)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `protection_trigger`  ", "sva_signals": ["clk_signal", "[0:0] temp_alert", "[0:0] voltage_alert", "[0:0] current_alert", "[0:0] protection_trigger"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(temp_alert || voltage_alert || current_alert) |=> protection_trigger", "sva_name": "p_Alert_To_Protection_Trigger", "full_property": "property p_Protection_Trigger_On_Alert;\n@(posedge clk_signal)     $rose(temp_alert || voltage_alert || current_alert) |=> protection_trigger\nendproperty\nassert_p_Protection_Trigger_On_Alert:assert property (p_Protection_Trigger_On_Alert) else $error(\"\");", "task_id": "3_8150", "predict_sva": "@(posedge clk_signal)         $rose(temp_alert || voltage_alert || current_alert) |-> protection_trigger"}
{"id": "367_5_0573", "name": "key_integrity_check_5", "sva": "@(posedge clk_signal)     $rose(key_valid) |-> (key_reg ^ ~key_check) == 0", "ori_sva": "property key_integrity_check_5;\n@(posedge clk_signal)     $rose(key_valid) |-> (key_reg ^ ~key_check) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Key_Valid_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(key_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(key_reg ^ ~key_check) == 0`  ", "sva_signals": ["clk_signal", "[0:0] key_valid", "[0:0] key_reg", "[0:0] key_check"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(key_valid) |-> (key_reg ^ ~key_check) == 0", "sva_name": "p_Key_Valid_Check", "full_property": "property p_Key_Valid_Check;\n@(posedge clk_signal)     $rose(key_valid) |-> (key_reg ^ ~key_check) == 0\nendproperty\nassert_p_Key_Valid_Check:assert property (p_Key_Valid_Check) else $error(\"\");", "task_id": "3_8054", "predict_sva": "@(posedge clk_signal)     $rose(key_valid) |-> (key_reg ^ ~key_check) == 0"}
{"id": "355_1_0437", "name": "pwr_mutex_rise", "sva": "@(posedge clk_sys)     pwr_A_on ^ pwr_B_on", "ori_sva": "property pwr_mutex_rise;\n@(posedge clk_sys)     pwr_A_on ^ pwr_B_on;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Exclusive  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (direct assertion, no implication)  \n**Implication Operator**: None (direct assertion)  \n**Consequent (RHS of Implication)**: `pwr_A_on ^ pwr_B_on` (asserts that `pwr_A_on` and `pwr_B_on` are mutually exclusive at every rising edge of `clk_sys`)  ", "sva_signals": ["clk_sys", "[0:0] pwr_A_on", "[0:0] pwr_B_on"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     pwr_A_on ^ pwr_B_on", "sva_name": "p_Power_Exclusive_On", "full_property": "property p_Power_Exclusive;\n@(posedge clk_sys)     pwr_A_on ^ pwr_B_on\nendproperty\nassert_p_Power_Exclusive:assert property (p_Power_Exclusive) else $error(\"\");", "task_id": "3_7977", "predict_sva": "@(posedge clk_sys)     !(pwr_A_on && pwr_B_on)"}
{"sva": "@(negedge clk_high_frequency_trading) disable iff(market_microstructure_anomaly_detected) order_book_dynamics_analysis |-> ($past(bid_ask_spread_volatility) && $past(market_depth_liquidity_assessment)) && ($past(execution_algorithm_performance) == market_impact_minimization_target_missed)", "sva_description": "### Assertion description:  \n**Property Name**: p_order_book_dynamics_analysis  \n**Trigger Condition**: At every falling edge of `clk_high_frequency_trading`  \n**Disable Condition**: `disable iff (market_microstructure_anomaly_detected)`  \n**Antecedent (LHS of Implication)**: `order_book_dynamics_analysis`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n($past(bid_ask_spread_volatility) && $past(market_depth_liquidity_assessment)) &&  \n($past(execution_algorithm_performance) == market_impact_minimization_target_missed)", "sva_signals": ["clk_high_frequency_trading", "market_microstructure_anomaly_detected", "[0:0] order_book_dynamics_analysis", "bid_ask_spread_volatility", "market_depth_liquidity_assessment", "execution_algorithm_performance", "market_impact_minimization_target_missed"], "clock": "clk_high_frequency_trading", "attempts_left": 10, "sva_result": "@(negedge clk_high_frequency_trading) disable iff (market_microstructure_anomaly_detected)     order_book_dynamics_analysis |->      ($past(bid_ask_spread_volatility) && $past(market_depth_liquidity_assessment)) &&      ($past(execution_algorithm_performance) == market_impact_minimization_target_missed)", "sva_name": "p_Order_Book_Dynamics_Analysis", "id": "3931", "full_property": "property p_order_book_dynamics_analysis;\n@(negedge clk_high_frequency_trading) disable iff (market_microstructure_anomaly_detected)     order_book_dynamics_analysis |->      ($past(bid_ask_spread_volatility) && $past(market_depth_liquidity_assessment)) &&      ($past(execution_algorithm_performance) == market_impact_minimization_target_missed)\nendproperty\nassert_p_order_book_dynamics_analysis:assert property (p_order_book_dynamics_analysis) else $error(\"\");", "task_id": "3_7502", "predict_sva": "@(negedge clk_high_frequency_trading) disable iff (market_microstructure_anomaly_detected)     order_book_dynamics_analysis |->      ($past(bid_ask_spread_volatility) && $past(market_depth_liquidity_assessment)) &&     ($past(execution_algorithm_performance) == market_impact_minimization_target_missed)"}
{"sva": "@(posedge clk) disable iff(!financial_market_infrastructure_resilience_testing_complete) payment_system_operational_continuity |-> ($past(transaction_processing_capacity_stress_testing) && $past(disaster_recovery_procedure_effectiveness)) && ($past(financial_infrastructure_reliability_assurance) == payment_system_stability_objective_achievement_inadequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Payment_System_Continuity_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!financial_market_infrastructure_resilience_testing_complete)`  \n**Antecedent (LHS of Implication)**: `payment_system_operational_continuity`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(transaction_processing_capacity_stress_testing) && $past(disaster_recovery_procedure_effectiveness)) && ($past(financial_infrastructure_reliability_assurance) == payment_system_stability_objective_achievement_inadequacy)`  \n\n", "sva_signals": ["clk", "financial_market_infrastructure_resilience_testing_complete", "payment_system_operational_continuity", "[0:0] transaction_processing_capacity_stress_testing", "[0:0] disaster_recovery_procedure_effectiveness", "[0:0] financial_infrastructure_reliability_assurance", "[0:0] payment_system_stability_objective_achievement_inadequacy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (!financial_market_infrastructure_resilience_testing_complete)     payment_system_operational_continuity |->      ($past(transaction_processing_capacity_stress_testing) &&       $past(disaster_recovery_procedure_effectiveness)) &&      ($past(financial_infrastructure_reliability_assurance) ==       payment_system_stability_objective_achievement_inadequacy)", "sva_name": "p_Payment_System_Operational_Continuity", "id": "3925", "full_property": "property p_Payment_System_Continuity_Check;\n@(posedge clk)     disable iff (!financial_market_infrastructure_resilience_testing_complete)     payment_system_operational_continuity |->      ($past(transaction_processing_capacity_stress_testing) &&       $past(disaster_recovery_procedure_effectiveness)) &&      ($past(financial_infrastructure_reliability_assurance) ==       payment_system_stability_objective_achievement_inadequacy)\nendproperty\nassert_p_Payment_System_Continuity_Check:assert property (p_Payment_System_Continuity_Check) else $error(\"\");", "task_id": "3_7496", "predict_sva": "@(posedge clk) disable iff (!financial_market_infrastructure_resilience_testing_complete)     payment_system_operational_continuity |->      ($past(transaction_processing_capacity_stress_testing) && $past(disaster_recovery_procedure_effectiveness)) &&      ($past(financial_infrastructure_reliability_assurance) == payment_system_stability_objective_achievement_inadequacy)"}
{"id": "360_2_0506", "name": "async_rst_sync_release_p2", "sva": "@(negedge clk_signal)     !async_rst_n |-> $past(sync_rst_n) == sync_rst_n", "ori_sva": "property async_rst_sync_release_p2;\n@(negedge clk_signal)     !async_rst_n |-> $past(sync_rst_n) == sync_rst_n;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Async_Rst_Consistency  \n**Trigger Condition**: At every falling edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!async_rst_n` (async reset is active low)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sync_rst_n) == sync_rst_n` (The value of `sync_rst_n` at the previous clock edge equals its current value)  \n\n", "sva_signals": ["clk_signal", "async_rst_n", "sync_rst_n"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(negedge clk_signal)     !async_rst_n |-> ($past(sync_rst_n) == sync_rst_n)", "sva_name": "p_async_rst_sync_rst_stable", "full_property": "property p_Async_Rst_Consistency;\n@(negedge clk_signal)     !async_rst_n |-> ($past(sync_rst_n) == sync_rst_n)\nendproperty\nassert_p_Async_Rst_Consistency:assert property (p_Async_Rst_Consistency) else $error(\"\");", "task_id": "3_8004", "predict_sva": "@(negedge clk_signal)     !async_rst_n |-> $stable(sync_rst_n)"}
{"id": "400_4_0828", "name": "frame_sync_stable", "sva": "@(posedge clk_sys)     $stable(chA_sync) && $stable(chB_sync) |->      !frame_error && (chA_sync ^ chB_sync) == expected_sync", "ori_sva": "property frame_sync_stable;\n@(posedge clk_sys)     $stable(chA_sync) && $stable(chB_sync) |->      !frame_error && (chA_sync ^ chB_sync) == expected_sync;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_stability_check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(chA_sync) && $stable(chB_sync)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!frame_error && (chA_sync ^ chB_sync) == expected_sync`  ", "sva_signals": ["clk_sys", "[0:0] chA_sync", "[0:0] chB_sync", "[0:0] frame_error", "[0:0] expected_sync"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($stable(chA_sync) && $stable(chB_sync)) |-> (!frame_error && (chA_sync ^ chB_sync) == expected_sync)", "sva_name": "p_Sync_Stability_Check", "full_property": "property p_sync_stability_check;\n@(posedge clk_sys)     ($stable(chA_sync) && $stable(chB_sync)) |-> (!frame_error && (chA_sync ^ chB_sync) == expected_sync)\nendproperty\nassert_p_sync_stability_check:assert property (p_sync_stability_check) else $error(\"\");", "task_id": "3_8265", "predict_sva": "@(posedge clk_sys)     ($stable(chA_sync) && $stable(chB_sync)) |-> (!frame_error && ((chA_sync ^ chB_sync) == expected_sync))"}
{"id": "438_2_1149", "name": "p_addr_stable_during_comm", "sva": "@(posedge clk_core)     (core_comm_enable && $stable(core_dest_addr)) |=>      (core_comm_busy || $stable(core_dest_addr))", "ori_sva": "property p_addr_stable_during_comm;\n@(posedge clk_core)     (core_comm_enable && $stable(core_dest_addr)) |=>      (core_comm_busy || $stable(core_dest_addr));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_core_comm_stability  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `core_comm_enable && $stable(core_dest_addr)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(core_comm_busy || $stable(core_dest_addr))`  ", "sva_signals": ["clk_core", "core_comm_enable", "core_dest_addr", "core_comm_busy"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         (core_comm_enable && $stable(core_dest_addr)) |=> (core_comm_busy || $stable(core_dest_addr))", "sva_name": "p_p_core_communication", "full_property": "property p_core_comm_stability;\n@(posedge clk_core)         (core_comm_enable && $stable(core_dest_addr)) |=> (core_comm_busy || $stable(core_dest_addr))\nendproperty\nassert_p_core_comm_stability:assert property (p_core_comm_stability) else $error(\"\");", "task_id": "3_8303", "predict_sva": "@(posedge clk_core)     (core_comm_enable && $stable(core_dest_addr)) |-> ##1 (core_comm_busy || $stable(core_dest_addr))"}
{"sva": "@(posedge clk_slope_stability) disable iff(geotechnical_monitoring_suspended) open_pit_wall_stability |-> ($past(slope_displacement_measurement) > stability_threshold) && !$past(mining_operations_suspended_in_area, 12)", "sva_description": "### Assertion description:  \n**Property Name**: p_open_pit_wall_stability_check  \n**Trigger Condition**: At every rising edge of the `clk_slope_stability`  \n**Disable Condition**: disable iff (`geotechnical_monitoring_suspended`)  \n**Antecedent (LHS of Implication)**: `open_pit_wall_stability`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `slope_displacement_measurement` must be greater than `stability_threshold` (`$past(slope_displacement_measurement) > stability_threshold`)  \n- Mining operations must not have been suspended in the area for the past 12 cycles (`!$past(mining_operations_suspended_in_area, 12)`)  \n\nThe assertion ensures that if the open pit wall is stable (`open_pit_wall_stability` is true), then:  \n1. The previous slope displacement measurement exceeded the stability threshold, and  \n2. Mining operations were not suspended in the area for the last 12 clock cycles.  \nThe check is disabled if geotechnical monitoring is suspended (`geotechnical_monitoring_suspended` is true).", "sva_signals": ["clk", "geotechnical_monitoring_suspended", "open_pit_wall_stability", "slope_displacement_measurement", "stability_threshold", "mining_operations_suspended_in_area", "clk_slope_stability"], "clock": "clk_slope_stability", "attempts_left": 10, "sva_result": "@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)     open_pit_wall_stability |->          ($past(slope_displacement_measurement) > stability_threshold) &&         (!$past(mining_operations_suspended_in_area, 12))", "sva_name": "p_open_pit_wall_stability_check", "id": "3528", "full_property": "property p_open_pit_wall_stability_check;\n@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)     open_pit_wall_stability |->          ($past(slope_displacement_measurement) > stability_threshold) &&         (!$past(mining_operations_suspended_in_area, 12))\nendproperty\nassert_p_open_pit_wall_stability_check:assert property (p_open_pit_wall_stability_check) else $error(\"\");", "task_id": "3_7110", "predict_sva": "@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)     open_pit_wall_stability == 1'b1 |->      ($past(slope_displacement_measurement) > stability_threshold) &&     (!$past(mining_operations_suspended_in_area, 12))"}
{"sva": "@(posedge clk) disable iff(cosmic_consciousness_interface_calibration_incomplete) universal_intelligence_communication |-> ($past(consciousness_detection_algorithm_sensitivity) && $past(universal_communication_protocol_compatibility)) && ($past(cosmic_intelligence_contact_establishment_success) == universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification)", "sva_description": "### Assertion description:  \n**Property Name**: p_Universal_Intelligence_Communication_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (cosmic_consciousness_interface_calibration_incomplete)`  \n**Antecedent (LHS of Implication)**: `universal_intelligence_communication == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of two conditions must hold:  \n  1. `$past(consciousness_detection_algorithm_sensitivity) && $past(universal_communication_protocol_compatibility)`  \n  2. `$past(cosmic_intelligence_contact_establishment_success) == universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification`  ", "sva_signals": ["clk", "cosmic_consciousness_interface_calibration_incomplete", "universal_intelligence_communication", "consciousness_detection_algorithm_sensitivity", "universal_communication_protocol_compatibility", "cosmic_intelligence_contact_establishment_success", "universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (cosmic_consciousness_interface_calibration_incomplete)     universal_intelligence_communication == 1'b1 |->      ($past(consciousness_detection_algorithm_sensitivity) &&       $past(universal_communication_protocol_compatibility)) &&     ($past(cosmic_intelligence_contact_establishment_success) ==       universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification)", "sva_name": "p_Universal_Intelligence_Communication", "id": "4009", "full_property": "property p_Universal_Intelligence_Communication_Check;\n@(posedge clk)     disable iff (cosmic_consciousness_interface_calibration_incomplete)     universal_intelligence_communication == 1'b1 |->      ($past(consciousness_detection_algorithm_sensitivity) &&       $past(universal_communication_protocol_compatibility)) &&     ($past(cosmic_intelligence_contact_establishment_success) ==       universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification)\nendproperty\nassert_p_Universal_Intelligence_Communication_Check:assert property (p_Universal_Intelligence_Communication_Check) else $error(\"\");", "task_id": "3_7578", "predict_sva": "@(posedge clk) disable iff (cosmic_consciousness_interface_calibration_incomplete)     universal_intelligence_communication == 1'b1 |->      ($past(consciousness_detection_algorithm_sensitivity) && $past(universal_communication_protocol_compatibility)) &&      ($past(cosmic_intelligence_contact_establishment_success) == universal_consciousness_network_integration_objective_realization_comprehensive_inadequacy_identification)"}
{"sva": "@(posedge clk) disable iff(agricultural_commodity_futures_market_closure) crop_marketing_strategy_execution |-> $past(harvest_forward_contract_pricing) && ($past(delivery_commitment_fulfillment_capability) != contract_specification_compliance_assured)", "sva_description": "### Assertion description:  \n**Property Name**: p_Crop_Marketing_Strategy_Execution  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (agricultural_commodity_futures_market_closure)`  \n**Antecedent (LHS of Implication)**: `crop_marketing_strategy_execution`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(harvest_forward_contract_pricing) && ($past(delivery_commitment_fulfillment_capability) != contract_specification_compliance_assured)`  ", "sva_signals": ["clk", "agricultural_commodity_futures_market_closure", "crop_marketing_strategy_execution", "harvest_forward_contract_pricing", "delivery_commitment_fulfillment_capability", "contract_specification_compliance_assured"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (agricultural_commodity_futures_market_closure)     crop_marketing_strategy_execution |->          $past(harvest_forward_contract_pricing) &&          ($past(delivery_commitment_fulfillment_capability) != contract_specification_compliance_assured)", "sva_name": "p_Crop_Marketing_Strategy_Execution", "id": "3655", "full_property": "property p_Crop_Marketing_Strategy_Execution;\n@(posedge clk) disable iff (agricultural_commodity_futures_market_closure)     crop_marketing_strategy_execution |->          $past(harvest_forward_contract_pricing) &&          ($past(delivery_commitment_fulfillment_capability) != contract_specification_compliance_assured)\nendproperty\nassert_p_Crop_Marketing_Strategy_Execution:assert property (p_Crop_Marketing_Strategy_Execution) else $error(\"\");", "task_id": "3_7235", "predict_sva": "@(posedge clk) disable iff (agricultural_commodity_futures_market_closure)     crop_marketing_strategy_execution |->          $past(harvest_forward_contract_pricing) &&          ($past(delivery_commitment_fulfillment_capability) != contract_specification_compliance_assured)"}
{"id": "448_10_1209", "name": "wb_flush_effectiveness", "sva": "@(posedge clk_signal)     $rose(flush_enable) |=> (valid_data_count == 0)[*3]", "ori_sva": "property wb_flush_effectiveness;\n@(posedge clk_signal)     $rose(flush_enable) |=> (valid_data_count == 0)[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_flush_enable_valid_data_count  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(flush_enable)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(valid_data_count == 0)[*3]`  ", "sva_signals": ["clk_signal", "[0:0] flush_enable", "valid_data_count"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(flush_enable) |=> (valid_data_count == 0)[*3]", "sva_name": "p_Flush_Enable_Valid_Data_Count", "full_property": "property p_flush_enable_valid_data_count;\n@(posedge clk_signal)     $rose(flush_enable) |=> (valid_data_count == 0)[*3]\nendproperty\nassert_p_flush_enable_valid_data_count:assert property (p_flush_enable_valid_data_count) else $error(\"\");", "task_id": "3_8318", "predict_sva": "@(posedge clk_signal)     $rose(flush_enable) |-> (valid_data_count == 0) throughout (##[0:2] 1)"}
{"id": "400_5_0863", "name": "frame_sync_change", "sva": "@(posedge clk_sys)     $changed(chA_sync) || $changed(chB_sync) |->     !frame_error && (chA_sync ^ chB_sync) == expected_sync", "ori_sva": "property frame_sync_change;\n@(posedge clk_sys)     $changed(chA_sync) || $changed(chB_sync) |->     !frame_error && (chA_sync ^ chB_sync) == expected_sync;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Change_Check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(chA_sync) || $changed(chB_sync)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!frame_error && (chA_sync ^ chB_sync) == expected_sync`  ", "sva_signals": ["clk_sys", "chA_sync", "chB_sync", "[0:0] frame_error", "expected_sync"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($changed(chA_sync) || $changed(chB_sync)) |-> (!frame_error && ((chA_sync ^ chB_sync) == expected_sync))", "sva_name": "p_Sync_Change_No_Frame_Error", "full_property": "property p_Sync_Change_Check;\n@(posedge clk_sys)     ($changed(chA_sync) || $changed(chB_sync)) |-> (!frame_error && ((chA_sync ^ chB_sync) == expected_sync))\nendproperty\nassert_p_Sync_Change_Check:assert property (p_Sync_Change_Check) else $error(\"\");", "task_id": "3_8266", "predict_sva": "@(posedge clk_sys)     ($changed(chA_sync) || $changed(chB_sync)) |-> (!frame_error && ((chA_sync ^ chB_sync) == expected_sync))"}
{"id": "438_6_1128", "name": "p_no_simult_comm_to_same_core", "sva": "@(posedge clk_core)     !(core_comm_enable && $past(core_comm_enable) &&       (core_dest_addr == $past(core_dest_addr)))", "ori_sva": "property p_no_simult_comm_to_same_core;\n@(posedge clk_core)     !(core_comm_enable && $past(core_comm_enable) &&       (core_dest_addr == $past(core_dest_addr)));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Core_Comm_Conflict  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (Direct assertion, no implication)  \n**Implication Operator**: None (Direct assertion)  \n**Consequent (RHS of Implication)**: `!(core_comm_enable && $past(core_comm_enable) && (core_dest_addr == $past(core_dest_addr)))`  \n\n", "sva_signals": ["clk_core", "core_comm_enable", "core_dest_addr"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         !(core_comm_enable && $past(core_comm_enable) && (core_dest_addr == $past(core_dest_addr)))", "sva_name": "p_no_core_comm_conflict", "full_property": "property p_Core_Comm_Conflict;\n@(posedge clk_core)         !(core_comm_enable && $past(core_comm_enable) && (core_dest_addr == $past(core_dest_addr)))\nendproperty\nassert_p_Core_Comm_Conflict:assert property (p_Core_Comm_Conflict) else $error(\"\");", "task_id": "3_8305", "predict_sva": "@(posedge clk_core)     (core_comm_enable && $past(core_comm_enable) && (core_dest_addr == $past(core_dest_addr))) |-> 0"}
{"id": "473_3_1426", "name": "p_range_fft_valid_rise_after_phase", "sva": "@(posedge clk_signal)     $fell(adc_capture) |-> ##[2:257] $rose(range_fft_valid)", "ori_sva": "property p_range_fft_valid_rise_after_phase;\n@(posedge clk_signal)     $fell(adc_capture) |-> ##[2:257] $rose(range_fft_valid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fell_Adc_Capture_Rose_Range_FFT_Valid  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(adc_capture)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:257] $rose(range_fft_valid)`  ", "sva_signals": ["clk", "rst_n", "[0:0] adc_capture", "[0:0] range_fft_valid", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(adc_capture) |-> ##[2:257] $rose(range_fft_valid)", "sva_name": "p_adc_capture_to_range_fft_valid", "full_property": "property p_Fell_Adc_Capture_Rose_Range_FFT_Valid;\n@(posedge clk_signal)     $fell(adc_capture) |-> ##[2:257] $rose(range_fft_valid)\nendproperty\nassert_p_Fell_Adc_Capture_Rose_Range_FFT_Valid:assert property (p_Fell_Adc_Capture_Rose_Range_FFT_Valid) else $error(\"\");", "task_id": "3_8431", "predict_sva": "@(posedge clk_signal)     $fell(adc_capture) |-> ##[2:257] $rose(range_fft_valid)"}
{"id": "501_6_0001", "name": "hotspot_critical_prop", "sva": "@(posedge clk_sys)     $fell(thermal_event) |-> ##1 !hotspot_critical", "ori_sva": "property hotspot_critical_prop;\n@(posedge clk_sys)     $fell(thermal_event) |-> ##1 !hotspot_critical;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: hotspot_critical_prop  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(thermal_event)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !hotspot_critical`  ", "sva_signals": ["clk_sys", "thermal_event", "[0:0] hotspot_critical"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $fell(thermal_event) |-> ##1 !hotspot_critical", "sva_name": "p_thermal_event_fall_check", "full_property": "property hotspot_critical_prop;\n@(posedge clk_sys)         $fell(thermal_event) |-> ##1 !hotspot_critical\nendproperty\nassert_hotspot_critical_prop:assert property (hotspot_critical_prop) else $error(\"\");", "task_id": "3_8565", "predict_sva": "@(posedge clk_sys)     $fell(thermal_event) |-> ##1 !hotspot_critical"}
{"sva": "@(posedge clk) disable iff(!galactic_civilization_communication_protocol_established) intergalactic_exploration_mission |-> ($past(faster_than_light_communication_capability_demonstration) && $past(galactic_scale_navigation_system_development)) && ($past(type_iii_civilization_technology_readiness) == cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification)", "sva_description": "### Assertion description:  \n**Property Name**: p_Intergalactic_Exploration_Mission_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!galactic_civilization_communication_protocol_established)`  \n**Antecedent (LHS of Implication)**: `intergalactic_exploration_mission`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(faster_than_light_communication_capability_demonstration) && $past(galactic_scale_navigation_system_development)) && ($past(type_iii_civilization_technology_readiness) == cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification)`  ", "sva_signals": ["clk", "[0:0] galactic_civilization_communication_protocol_established", "[0:0] intergalactic_exploration_mission", "[0:0] faster_than_light_communication_capability_demonstration", "[0:0] galactic_scale_navigation_system_development", "[0:0] type_iii_civilization_technology_readiness", "[0:0] cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!galactic_civilization_communication_protocol_established)     intergalactic_exploration_mission |->      ($past(faster_than_light_communication_capability_demonstration) &&       $past(galactic_scale_navigation_system_development)) &&      ($past(type_iii_civilization_technology_readiness) == cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification)", "sva_name": "p_Intergalactic_Exploration_Mission", "id": "4008", "full_property": "property p_Intergalactic_Exploration_Mission_Check;\n@(posedge clk) disable iff (!galactic_civilization_communication_protocol_established)     intergalactic_exploration_mission |->      ($past(faster_than_light_communication_capability_demonstration) &&       $past(galactic_scale_navigation_system_development)) &&      ($past(type_iii_civilization_technology_readiness) == cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification)\nendproperty\nassert_p_Intergalactic_Exploration_Mission_Check:assert property (p_Intergalactic_Exploration_Mission_Check) else $error(\"\");", "task_id": "3_7577", "predict_sva": "@(posedge clk) disable iff (!galactic_civilization_communication_protocol_established)     intergalactic_exploration_mission |->      ($past(faster_than_light_communication_capability_demonstration) &&       $past(galactic_scale_navigation_system_development)) &&      ($past(type_iii_civilization_technology_readiness) == cosmic_scale_exploration_objective_achievement_comprehensive_realization_shortfall_identification)"}
{"id": "580_1_0553", "name": "simd_opcode_onehot_rise", "sva": "@(posedge clk_signal)     $rose(simd_issue) |-> $onehot(simd_opcode)", "ori_sva": "property simd_opcode_onehot_rise;\n@(posedge clk_signal)     $rose(simd_issue) |-> $onehot(simd_opcode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_opcode_onehot_rise  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(simd_opcode)`", "sva_signals": ["clk_signal", "[0:0] simd_issue", "[0:0] simd_opcode"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(simd_issue) |-> $onehot(simd_opcode)", "sva_name": "simd_opcode_onehot_rise_posedge", "full_property": "property simd_opcode_onehot_rise;\n@(posedge clk_signal)         $rose(simd_issue) |-> $onehot(simd_opcode)\nendproperty\nassert_simd_opcode_onehot_rise:assert property (simd_opcode_onehot_rise) else $error(\"\");", "task_id": "3_8699", "predict_sva": "@(posedge clk_signal)         $rose(simd_issue) |-> $onehot(simd_opcode)"}
{"id": "484_5_1503", "name": "p_hbm2e_refresh_done_rose", "sva": "@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[100:1000] $rose(refresh_done)", "ori_sva": "property p_hbm2e_refresh_done_rose;\n@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[100:1000] $rose(refresh_done);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Refresh_Done_After_Auto_Refresh_Fall  \n**Trigger Condition**: At every rising edge of the `clk_hbm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(auto_refresh)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:1000] $rose(refresh_done)`  ", "sva_signals": ["clk_hbm", "auto_refresh", "refresh_done"], "clock": "clk_hbm", "attempts_left": 10, "sva_result": "@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[100:1000] $rose(refresh_done)", "sva_name": "p_Refresh_Done_After_Fell", "full_property": "property p_Refresh_Done_After_Auto_Refresh_Fall;\n@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[100:1000] $rose(refresh_done)\nendproperty\nassert_p_Refresh_Done_After_Auto_Refresh_Fall:assert property (p_Refresh_Done_After_Auto_Refresh_Fall) else $error(\"\");", "task_id": "3_8472", "predict_sva": "@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[100:1000] $rose(refresh_done)"}
{"id": "581_6_0585", "name": "p_simd_store_alignment_past", "sva": "@(posedge clk)     $rose(simd_store) |-> ($past(mem_addr) % VLEN == 0)", "ori_sva": "property p_simd_store_alignment_past;\n@(posedge clk)     $rose(simd_store) |-> ($past(mem_addr) % VLEN == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_store_alignment_past  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_store)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(mem_addr) % VLEN == 0)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_store", "[0:0] mem_addr", "[0:0] VLEN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_store) |-> ($past(mem_addr) % VLEN == 0)", "sva_name": "p_simd_store_alignment_past", "full_property": "property p_simd_store_alignment_past;\n@(posedge clk)         $rose(simd_store) |-> ($past(mem_addr) % VLEN == 0)\nendproperty\nassert_p_simd_store_alignment_past:assert property (p_simd_store_alignment_past) else $error(\"\");", "task_id": "3_8709", "predict_sva": "@(posedge clk)         $rose(simd_store) |-> ($past(mem_addr) % VLEN == 0)"}
{"id": "580_8_0579", "name": "simd_opcode_onehot_with_enable", "sva": "@(posedge clk_signal)     $rose(simd_issue) && simd_enable_ |-> $onehot(simd_opcode)", "ori_sva": "property simd_opcode_onehot_with_enable;\n@(posedge clk_signal)     $rose(simd_issue) && simd_enable_ |-> $onehot(simd_opcode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_opcode_onehot_with_enable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue) && simd_enable_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(simd_opcode)`", "sva_signals": ["clk_signal", "[0:0] simd_issue", "[0:0] simd_enable_", "[0:0] simd_opcode"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(simd_issue) && simd_enable_ |-> $onehot(simd_opcode)", "sva_name": "simd_opcode_onehot_rise_posedge", "full_property": "property simd_opcode_onehot_with_enable;\n@(posedge clk_signal)         $rose(simd_issue) && simd_enable_ |-> $onehot(simd_opcode)\nendproperty\nassert_simd_opcode_onehot_with_enable:assert property (simd_opcode_onehot_with_enable) else $error(\"\");", "task_id": "3_8703", "predict_sva": "@(posedge clk_signal)         $rose(simd_issue) && simd_enable_ |-> $onehot(simd_opcode)"}
{"id": "492_3_1522", "name": "pmp_lock_rise_within_3_cycles", "sva": "@(posedge clk_signal)     $fell(pmp_update) |-> ##[1:3] $rose(pmp_lock)", "ori_sva": "property pmp_lock_rise_within_3_cycles;\n@(posedge clk_signal)     $fell(pmp_update) |-> ##[1:3] $rose(pmp_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PmpUpdateToLock  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(pmp_update)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $rose(pmp_lock)`  ", "sva_signals": ["clk_signal", "[0:0] pmp_update", "[0:0] pmp_lock"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(pmp_update) |-> ##[1:3] $rose(pmp_lock)", "sva_name": "p_PmpUpdate_Fell_To_PmpLock_Rose", "full_property": "property p_PmpUpdateToLock;\n@(posedge clk_signal)     $fell(pmp_update) |-> ##[1:3] $rose(pmp_lock)\nendproperty\nassert_p_PmpUpdateToLock:assert property (p_PmpUpdateToLock) else $error(\"\");", "task_id": "3_8512", "predict_sva": "@(posedge clk_signal)     $fell(pmp_update) |-> ##[1:3] $rose(pmp_lock)"}
{"id": "589_3_0631", "name": "simd_xor_correct_p3", "sva": "@(posedge clk)     $changed(simd_xor) && simd_xor |-> (simd_out == (src0 ^ src1))", "ori_sva": "property simd_xor_correct_p3;\n@(posedge clk)     $changed(simd_xor) && simd_xor |-> (simd_out == (src0 ^ src1));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_xor_correct_p3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(simd_xor) && simd_xor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `simd_out == (src0 ^ src1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_xor", "[0:0] simd_out", "[0:0] src0", "[0:0] src1"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($changed(simd_xor) && simd_xor) |-> (simd_out == (src0 ^ src1))", "sva_name": "simd_xor_correct_p6", "full_property": "property simd_xor_correct_p3;\n@(posedge clk)         ($changed(simd_xor) && simd_xor) |-> (simd_out == (src0 ^ src1))\nendproperty\nassert_simd_xor_correct_p3:assert property (simd_xor_correct_p3) else $error(\"\");", "task_id": "3_8743", "predict_sva": "@(posedge clk)         $changed(simd_xor) && simd_xor |-> simd_out == (src0 ^ src1)"}
{"id": "488_8_1511", "name": "p_data_return_fall_after_ack", "sva": "@(posedge clk)     $rose(snoop_ack) |-> ##1 $fell(data_return)", "ori_sva": "property p_data_return_fall_after_ack;\n@(posedge clk)     $rose(snoop_ack) |-> ##1 $fell(data_return);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Snoop_Ack_Data_Return  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(snoop_ack)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(data_return)`  ", "sva_signals": ["clk", "rst_n", "[0:0] snoop_ack", "[0:0] data_return"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(snoop_ack) |-> ##1 $fell(data_return)", "sva_name": "p_Snoop_Ack_Data_Return", "full_property": "property p_Snoop_Ack_Data_Return;\n@(posedge clk)     $rose(snoop_ack) |-> ##1 $fell(data_return)\nendproperty\nassert_p_Snoop_Ack_Data_Return:assert property (p_Snoop_Ack_Data_Return) else $error(\"\");", "task_id": "3_8499", "predict_sva": "@(posedge clk)         $rose(snoop_ack) |-> ##1 $fell(data_return)"}
{"id": "368_6_0567", "name": "wakeup_stable_after_trigger_p", "sva": "@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##1 system_wakeup[*2]", "ori_sva": "property wakeup_stable_after_trigger_p;\n@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##1 system_wakeup[*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Wakeup_Trigger  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(gpio_wakeup || rtc_wakeup || comm_wakeup)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 system_wakeup[*2]` (system_wakeup must be high for two consecutive clock cycles starting from the next cycle)", "sva_signals": ["clk_sys", "[0:0] gpio_wakeup", "[0:0] rtc_wakeup", "[0:0] comm_wakeup", "[0:0] system_wakeup"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##1 system_wakeup[*2]", "sva_name": "p_Wakeup_Sequence", "full_property": "property p_Wakeup_Trigger;\n@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##1 system_wakeup[*2]\nendproperty\nassert_p_Wakeup_Trigger:assert property (p_Wakeup_Trigger) else $error(\"\");", "task_id": "3_8064", "predict_sva": "@(posedge clk_sys)    (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##1 system_wakeup[*2]"}
{"id": "368_10_0571", "name": "wakeup_source_coverage_p", "sva": "@(posedge clk_sys)     $rose(gpio_wakeup) or $rose(rtc_wakeup) or $rose(comm_wakeup)", "ori_sva": "property wakeup_source_coverage_p;\n@(posedge clk_sys)     $rose(gpio_wakeup) or $rose(rtc_wakeup) or $rose(comm_wakeup);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Wakeup_Detection  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(gpio_wakeup) or $rose(rtc_wakeup) or $rose(comm_wakeup)`  \n**Implication Operator**: None (This is a standalone event detection assertion without implication)  \n**Consequent (RHS of Implication)**: Not applicable (No consequent as this is not an implication-based assertion)  \n\n### Notes:\n1. This assertion detects the rising edge of any wakeup signal (`gpio_wakeup`, `rtc_wakeup`, or `comm_wakeup`) synchronously with `clk_sys`.  \n2. Unlike the examples, this is not an implication-based property but a simple event-triggered assertion.", "sva_signals": ["clk_sys", "gpio_wakeup", "rtc_wakeup", "comm_wakeup"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $rose(gpio_wakeup) or $rose(rtc_wakeup) or $rose(comm_wakeup)", "sva_name": "p_Wakeup_Detection", "full_property": "property p_Wakeup_Detection;\n@(posedge clk_sys)     $rose(gpio_wakeup) or $rose(rtc_wakeup) or $rose(comm_wakeup)\nendproperty\nassert_p_Wakeup_Detection:assert property (p_Wakeup_Detection) else $error(\"\");", "task_id": "3_8058", "predict_sva": "@(posedge clk_sys)     $rose(gpio_wakeup || rtc_wakeup || comm_wakeup)"}
{"id": "594_2_0689", "name": "p_simd_dec_onehot_rise_negedge", "sva": "@(negedge clk_core)     $rose(simd_issue_i) |-> $onehot(simd_decoded_o)", "ori_sva": "property p_simd_dec_onehot_rise_negedge;\n@(negedge clk_core)     $rose(simd_issue_i) |-> $onehot(simd_decoded_o)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_dec_onehot_rise_negedge  \n**Trigger Condition**: At every falling edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue_i)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(simd_decoded_o)`", "sva_signals": ["clk_core", "[0:0] simd_issue_i", "[0:0] simd_decoded_o"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(negedge clk_core)     $rose(simd_issue_i) |-> $onehot(simd_decoded_o)", "sva_name": "p_simd_dec_onehot_fall", "full_property": "property p_simd_dec_onehot_rise_negedge;\n@(negedge clk_core)     $rose(simd_issue_i) |-> $onehot(simd_decoded_o)\nendproperty\nassert_p_simd_dec_onehot_rise_negedge:assert property (p_simd_dec_onehot_rise_negedge) else $error(\"\");", "task_id": "3_8773", "predict_sva": "@(negedge clk_core)     $rose(simd_issue_i) |-> $onehot(simd_decoded_o)"}
{"id": "354_2_0454", "name": "p_int_ctrl_resp_high_or_low_2", "sva": "@(posedge clk_sys)     (irq_high || irq_low) throughout (##1 int_ack [->1])", "ori_sva": "property p_int_ctrl_resp_high_or_low_2;\n@(posedge clk_sys)     (irq_high || irq_low) throughout (##1 int_ack [->1])\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Irq_Ack_Sequence  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(irq_high || irq_low)`  \n**Implication Operator**: `throughout`  \n**Consequent (RHS of Implication)**: `##1 int_ack [->1]`  ", "sva_signals": ["clk_sys", "irq_high", "irq_low", "int_ack"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (irq_high || irq_low) throughout ##1 int_ack[->1]", "sva_name": "p_irq_ack_sequence", "full_property": "property p_Irq_Ack_Sequence;\n@(posedge clk_sys)     (irq_high || irq_low) throughout ##1 int_ack[->1]\nendproperty\nassert_p_Irq_Ack_Sequence:assert property (p_Irq_Ack_Sequence) else $error(\"\");", "task_id": "3_7973", "predict_sva": "@(posedge clk_sys)    (irq_high || irq_low) |-> ##[1:$] int_ack[->1] throughout (irq_high || irq_low)"}
{"id": "595_8_0691", "name": "simd_exception_nonzero_code_p8", "sva": "@(posedge clk_signal)     $rose(simd_exception) |-> (exception_code != 0) [*2]", "ori_sva": "property simd_exception_nonzero_code_p8;\n@(posedge clk_signal)     $rose(simd_exception) |-> (exception_code != 0) [*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_exception_nonzero_code_p8  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_exception)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(exception_code != 0) [*2]` (The `exception_code` must be non-zero for the next two consecutive clock cycles after the rising edge of `simd_exception`.)", "sva_signals": ["clk_signal", "[0:0] simd_exception", "[0:0] exception_code"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(simd_exception) |-> (exception_code != 0) [*2]", "sva_name": "simd_exception_nonzero_code_p6", "full_property": "property simd_exception_nonzero_code_p8;\n@(posedge clk_signal)         $rose(simd_exception) |-> (exception_code != 0) [*2]\nendproperty\nassert_simd_exception_nonzero_code_p8:assert property (simd_exception_nonzero_code_p8) else $error(\"\");", "task_id": "3_8784", "predict_sva": "@(posedge clk_signal)     $rose(simd_exception) |-> (exception_code != 0) throughout (simd_exception[*2])"}
{"id": "601_2_0716", "name": "p_simd_vl_max_boundary", "sva": "@(posedge clk_signal)     $rose(simd_op) |-> (vl <= VLEN)", "ori_sva": "property p_simd_vl_max_boundary;\n@(posedge clk_signal)     $rose(simd_op) |-> (vl <= VLEN);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_vl_max_boundary  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_op)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `vl <= VLEN`", "sva_signals": ["clk", "rst_n", "[0:0] simd_op", "[0:0] vl", "[0:0] VLEN", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(simd_op) |-> vl <= VLEN", "sva_name": "p_simd_vl_not_exceed", "full_property": "property p_simd_vl_max_boundary;\n@(posedge clk_signal)         $rose(simd_op) |-> vl <= VLEN\nendproperty\nassert_p_simd_vl_max_boundary:assert property (p_simd_vl_max_boundary) else $error(\"\");", "task_id": "3_8814", "predict_sva": "@(posedge clk_signal)     $rose(simd_op) |-> (vl <= VLEN)"}
{"id": "596_1_0687", "name": "vreg_rw_mutex_1", "sva": "@(posedge clk_signal)     $rose(vreg_write) |-> !(vreg_read && vreg_write && (vreg_idx == vreg_idx_read))", "ori_sva": "property vreg_rw_mutex_1;\n@(posedge clk_signal)     $rose(vreg_write) |-> !(vreg_read && vreg_write && (vreg_idx == vreg_idx_read));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: vreg_rw_mutex_1  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(vreg_write)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(vreg_read && vreg_write && (vreg_idx == vreg_idx_read))`  ", "sva_signals": ["clk_signal", "[0:0] vreg_write", "[0:0] vreg_read", "[0:0] vreg_idx", "[0:0] vreg_idx_read"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(vreg_write) |-> !(vreg_read && vreg_write && (vreg_idx == vreg_idx_read))", "sva_name": "vreg_rw_mutex_7", "full_property": "property vreg_rw_mutex_1;\n@(posedge clk_signal)     $rose(vreg_write) |-> !(vreg_read && vreg_write && (vreg_idx == vreg_idx_read))\nendproperty\nassert_vreg_rw_mutex_1:assert property (vreg_rw_mutex_1) else $error(\"\");", "task_id": "3_8785", "predict_sva": "@(posedge clk_signal)         $rose(vreg_write) |-> !(vreg_read && vreg_write && (vreg_idx == vreg_idx_read))"}
{"id": "592_8_0690", "name": "simd_hazard_until_check", "sva": "@(posedge clk)     $rose(simd_issue) |-> (!simd_hazard) until simd_retire", "ori_sva": "property simd_hazard_until_check;\n@(posedge clk)     $rose(simd_issue) |-> (!simd_hazard) until simd_retire;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_hazard_until_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(!simd_hazard) until simd_retire`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] simd_hazard", "[0:0] simd_retire"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_issue) |-> (!simd_hazard) until simd_retire", "sva_name": "simd_hazard_window_check", "full_property": "property simd_hazard_until_check;\n@(posedge clk)         $rose(simd_issue) |-> (!simd_hazard) until simd_retire\nendproperty\nassert_simd_hazard_until_check:assert property (simd_hazard_until_check) else $error(\"\");", "task_id": "3_8769", "predict_sva": "@(posedge clk)         $rose(simd_issue) |-> !simd_hazard until simd_retire"}
{"id": "599_5_0717", "name": "p_simd_context_switch_consistency_5", "sva": "@(posedge clk_signal)     $rose(context_switch) |-> ##[1:3] (vreg_save == vreg_restore)", "ori_sva": "property p_simd_context_switch_consistency_5;\n@(posedge clk_signal)     $rose(context_switch) |-> ##[1:3] (vreg_save == vreg_restore);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_context_switch_consistency_5  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(context_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] (vreg_save == vreg_restore)`  ", "sva_signals": ["clk_signal", "[0:0] context_switch", "[0:0] vreg_save", "[0:0] vreg_restore"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(context_switch) |-> ##[1:3] (vreg_save == vreg_restore)", "sva_name": "p_simd_context_switch_consistency_6", "full_property": "property p_simd_context_switch_consistency_5;\n@(posedge clk_signal)     $rose(context_switch) |-> ##[1:3] (vreg_save == vreg_restore)\nendproperty\nassert_p_simd_context_switch_consistency_5:assert property (p_simd_context_switch_consistency_5) else $error(\"\");", "task_id": "3_8806", "predict_sva": "@(posedge clk_signal)     $rose(context_switch) |-> ##[1:3] (vreg_save == vreg_restore)"}
{"id": "591_2_0681", "name": "p_simd_compress_onehot_rise_negedge", "sva": "@(negedge clk)     $rose(simd_compress) |-> $onehot(compress_sel)", "ori_sva": "property p_simd_compress_onehot_rise_negedge;\n@(negedge clk)     $rose(simd_compress) |-> $onehot(compress_sel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_compress_onehot_rise_negedge  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_compress)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(compress_sel)`", "sva_signals": ["clk", "rst_n", "[0:0] simd_compress", "[0:0] compress_sel"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)         $rose(simd_compress) |-> $onehot(compress_sel)", "sva_name": "p_simd_compress_onehot_after_rise", "full_property": "property p_simd_compress_onehot_rise_negedge;\n@(negedge clk)         $rose(simd_compress) |-> $onehot(compress_sel)\nendproperty\nassert_p_simd_compress_onehot_rise_negedge:assert property (p_simd_compress_onehot_rise_negedge) else $error(\"\");", "task_id": "3_8756", "predict_sva": "@(negedge clk)     $rose(simd_compress) |-> $onehot(compress_sel)"}
{"id": "606_9_0757", "name": "simd_sync_flag_check_9", "sva": "@(posedge clk_signal)     $rose(simd_sync) |-> (sync_flag == 1) until_with $fell(simd_sync)", "ori_sva": "property simd_sync_flag_check_9;\n@(posedge clk_signal)     $rose(simd_sync) |-> (sync_flag == 1) until_with $fell(simd_sync);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_sync_flag_check_9  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_sync)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(sync_flag == 1) until_with $fell(simd_sync)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] simd_sync", "[0:0] sync_flag", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(simd_sync) |-> (sync_flag == 1) until_with $fell(simd_sync)", "sva_name": "simd_sync_flag_check_6", "full_property": "property simd_sync_flag_check_9;\n@(posedge clk_signal)         $rose(simd_sync) |-> (sync_flag == 1) until_with $fell(simd_sync)\nendproperty\nassert_simd_sync_flag_check_9:assert property (simd_sync_flag_check_9) else $error(\"\");", "task_id": "3_8838", "predict_sva": "@(posedge clk_signal)     $rose(simd_sync) |-> (sync_flag == 1) until $fell(simd_sync)"}
{"id": "610_4_0807", "name": "simd_exc_prio_stable_after_rose", "sva": "@(posedge clk)     $rose(simd_exception) |=> $stable(exception_prio)", "ori_sva": "property simd_exc_prio_stable_after_rose;\n@(posedge clk)     $rose(simd_exception) |=> $stable(exception_prio);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_exc_prio_stable_after_rose  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_exception)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(exception_prio)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] simd_exception", "[0:0] exception_prio"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_exception) |=> $stable(exception_prio)", "sva_name": "simd_exc_prio_stable_after_detect", "full_property": "property simd_exc_prio_stable_after_rose;\n@(posedge clk)     $rose(simd_exception) |=> $stable(exception_prio)\nendproperty\nassert_simd_exc_prio_stable_after_rose:assert property (simd_exc_prio_stable_after_rose) else $error(\"\");", "task_id": "3_8864", "predict_sva": "@(posedge clk)         $rose(simd_exception) |-> ##1 $stable(exception_prio)"}
{"sva": "@(posedge clk) disable iff(!game_industry_workforce_development_program_effectiveness_evaluated) gaming_talent_cultivation |-> ($past(skill_development_curriculum_industry_alignment_validation) && $past(professional_competency_development_outcome_assessment)) && ($past(gaming_industry_talent_pipeline_optimization) == workforce_development_excellence_objective_achievement_inadequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Gaming_Talent_Cultivation_Validation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!game_industry_workforce_development_program_effectiveness_evaluated)`  \n**Antecedent (LHS of Implication)**: `gaming_talent_cultivation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that both of the following conditions hold true:  \n  1. The past values of `skill_development_curriculum_industry_alignment_validation` and `professional_competency_development_outcome_assessment` are both `1'b1` (logical AND of their past states).  \n  2. The past value of `gaming_industry_talent_pipeline_optimization` equals the current value of `workforce_development_excellence_objective_achievement_inadequacy`.  \n\n**Note**: The consequent combines historical checks (using `$past`) with a comparison to a current signal, ensuring alignment between past program outcomes and current objectives.", "sva_signals": ["clk", "game_industry_workforce_development_program_effectiveness_evaluated", "gaming_talent_cultivation", "skill_development_curriculum_industry_alignment_validation", "professional_competency_development_outcome_assessment", "gaming_industry_talent_pipeline_optimization", "workforce_development_excellence_objective_achievement_inadequacy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!game_industry_workforce_development_program_effectiveness_evaluated)     gaming_talent_cultivation == 1'b1 |->     ($past(skill_development_curriculum_industry_alignment_validation) == 1'b1 &&      $past(professional_competency_development_outcome_assessment) == 1'b1) &&     ($past(gaming_industry_talent_pipeline_optimization) == workforce_development_excellence_objective_achievement_inadequacy)", "sva_name": "p_Gaming_Talent_Cultivation_Check", "id": "3838", "full_property": "property p_Gaming_Talent_Cultivation_Validation;\n@(posedge clk) disable iff (!game_industry_workforce_development_program_effectiveness_evaluated)     gaming_talent_cultivation == 1'b1 |->     ($past(skill_development_curriculum_industry_alignment_validation) == 1'b1 &&      $past(professional_competency_development_outcome_assessment) == 1'b1) &&     ($past(gaming_industry_talent_pipeline_optimization) == workforce_development_excellence_objective_achievement_inadequacy)\nendproperty\nassert_p_Gaming_Talent_Cultivation_Validation:assert property (p_Gaming_Talent_Cultivation_Validation) else $error(\"\");", "task_id": "3_7411", "predict_sva": "@(posedge clk) disable iff (!game_industry_workforce_development_program_effectiveness_evaluated)     gaming_talent_cultivation == 1'b1 |->      ($past(skill_development_curriculum_industry_alignment_validation) &&       $past(professional_competency_development_outcome_assessment)) &&     ($past(gaming_industry_talent_pipeline_optimization) == workforce_development_excellence_objective_achievement_inadequacy)"}
{"sva": "@(posedge clk_gaming_engine) disable iff(frame_rate_optimization_disabled) graphics_rendering_pipeline |-> ($past(polygon_count_per_frame) > gpu_processing_threshold) && !$past(level_of_detail_adjustment_applied, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_graphics_rendering_pipeline_check  \n**Trigger Condition**: At every rising edge of the `clk_gaming_engine`  \n**Disable Condition**: `disable iff (frame_rate_optimization_disabled)`  \n**Antecedent (LHS of Implication)**: `graphics_rendering_pipeline == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `polygon_count_per_frame` (sampled one clock cycle earlier) must be greater than `gpu_processing_threshold`.  \n- The past value of `level_of_detail_adjustment_applied` (sampled two clock cycles earlier) must be `0` (i.e., `!$past(level_of_detail_adjustment_applied, 2)`).  \n- Both conditions must hold true simultaneously (`&&`).  \n\n### Notes:  \n- The assertion ensures that when the `graphics_rendering_pipeline` is active, the GPU workload (measured by `polygon_count_per_frame`) exceeds a threshold, and no level-of-detail adjustment was applied two cycles prior.  \n- The check is skipped if `frame_rate_optimization_disabled` is asserted (active-high disable condition).", "sva_signals": ["clk_gaming_engine", "frame_rate_optimization_disabled", "graphics_rendering_pipeline", "[0:0] polygon_count_per_frame", "[0:0] gpu_processing_threshold", "[0:0] level_of_detail_adjustment_applied"], "clock": "clk_gaming_engine", "attempts_left": 10, "sva_result": "@(posedge clk_gaming_engine) disable iff (frame_rate_optimization_disabled)     graphics_rendering_pipeline == 1'b1 |->     ($past(polygon_count_per_frame, 1) > gpu_processing_threshold) &&     (!$past(level_of_detail_adjustment_applied, 2))", "sva_name": "p_graphics_pipeline_optimization", "id": "3828", "full_property": "property p_graphics_rendering_pipeline_check;\n@(posedge clk_gaming_engine) disable iff (frame_rate_optimization_disabled)     graphics_rendering_pipeline == 1'b1 |->     ($past(polygon_count_per_frame, 1) > gpu_processing_threshold) &&     (!$past(level_of_detail_adjustment_applied, 2))\nendproperty\nassert_p_graphics_rendering_pipeline_check:assert property (p_graphics_rendering_pipeline_check) else $error(\"\");", "task_id": "3_7401", "predict_sva": "@(posedge clk_gaming_engine) disable iff (frame_rate_optimization_disabled)     graphics_rendering_pipeline |->          ($past(polygon_count_per_frame) > gpu_processing_threshold) &&         ($past(level_of_detail_adjustment_applied, 2) == 0)"}
{"id": "615_2_0844", "name": "p_simd_ewidth_set_16", "sva": "@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 16)", "ori_sva": "property p_simd_ewidth_set_16;\n@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 16);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_ewidth_set_16  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_ewidth_set)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ewidth_cfg == 16`", "sva_signals": ["clk", "rst_n", "[0:0] simd_ewidth_set", "[4:0] ewidth_cfg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_ewidth_set) |-> ewidth_cfg == 16", "sva_name": "p_simd_ewidth_set_16", "full_property": "property p_simd_ewidth_set_16;\n@(posedge clk)     $rose(simd_ewidth_set) |-> ewidth_cfg == 16\nendproperty\nassert_p_simd_ewidth_set_16:assert property (p_simd_ewidth_set_16) else $error(\"\");", "task_id": "3_8894", "predict_sva": "@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg == 16"}
{"id": "637_3_1030", "name": "can_len_legal_p3", "sva": "@(negedge can_clk)     can_start_transfer |=> can_len <= CAN_MAX_LEN", "ori_sva": "property can_len_legal_p3;\n@(negedge can_clk)     can_start_transfer |=> can_len <= CAN_MAX_LEN;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_len_legal_p3  \n**Trigger Condition**: At every falling edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_start_transfer`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `can_len <= CAN_MAX_LEN`", "sva_signals": ["can_clk", "[0:0] can_start_transfer", "[0:0] can_len", "[0:0] CAN_MAX_LEN"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(negedge can_clk)         can_start_transfer |=> can_len <= CAN_MAX_LEN", "sva_name": "can_len_legal_p6", "full_property": "property can_len_legal_p3;\n@(negedge can_clk)         can_start_transfer |=> can_len <= CAN_MAX_LEN\nendproperty\nassert_can_len_legal_p3:assert property (can_len_legal_p3) else $error(\"\");", "task_id": "3_9002", "predict_sva": "@(negedge can_clk)     can_start_transfer |-> can_len <= CAN_MAX_LEN"}
{"id": "615_3_0831", "name": "p_simd_ewidth_set_32", "sva": "@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 32)", "ori_sva": "property p_simd_ewidth_set_32;\n@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 32);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_ewidth_set_32  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_ewidth_set)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ewidth_cfg == 32`", "sva_signals": ["clk", "rst_n", "[0:0] simd_ewidth_set", "[31:0] ewidth_cfg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_ewidth_set) |-> ewidth_cfg == 32", "sva_name": "p_simd_ewidth_set_32", "full_property": "property p_simd_ewidth_set_32;\n@(posedge clk)     $rose(simd_ewidth_set) |-> ewidth_cfg == 32\nendproperty\nassert_p_simd_ewidth_set_32:assert property (p_simd_ewidth_set_32) else $error(\"\");", "task_id": "3_8895", "predict_sva": "@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg == 32"}
{"id": "486_3_1484", "name": "p_wavelength_stable_to_link_aligned", "sva": "@(posedge clk_sys)     $stable(wavelength) |-> ##[100:500] $rose(link_aligned)", "ori_sva": "property p_wavelength_stable_to_link_aligned;\n@(posedge clk_sys)     $stable(wavelength) |-> ##[100:500] $rose(link_aligned);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Wavelength_To_Link_Aligned  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(wavelength)` (the value of `wavelength` remains unchanged from the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:500] $rose(link_aligned)` (within 100 to 500 clock cycles after the antecedent holds, a rising edge on `link_aligned` must occur)", "sva_signals": ["clk_sys", "wavelength", "link_aligned"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $stable(wavelength) |-> ##[100:500] $rose(link_aligned)", "sva_name": "p_Stable_Wavelength_To_Link_Aligned", "full_property": "property p_Stable_Wavelength_To_Link_Aligned;\n@(posedge clk_sys)     $stable(wavelength) |-> ##[100:500] $rose(link_aligned)\nendproperty\nassert_p_Stable_Wavelength_To_Link_Aligned:assert property (p_Stable_Wavelength_To_Link_Aligned) else $error(\"\");", "task_id": "3_8479", "predict_sva": "@(posedge clk_sys)    $stable(wavelength) |-> ##[100:500] $rose(link_aligned)"}
{"id": "640_2_1052", "name": "p_rose_event_flag_2", "sva": "@(posedge clk_sys)     $rose(signal_b) |-> ##1 event_flag_b", "ori_sva": "property p_rose_event_flag_2;\n@(posedge clk_sys)     $rose(signal_b) |-> ##1 event_flag_b\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_event_flag_2  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(signal_b)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 event_flag_b`", "sva_signals": ["clk_sys", "signal_b", "[0:0] event_flag_b"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(signal_b) |-> ##1 event_flag_b", "sva_name": "p_rose_event_flag_2", "full_property": "property p_rose_event_flag_2;\n@(posedge clk_sys)         $rose(signal_b) |-> ##1 event_flag_b\nendproperty\nassert_p_rose_event_flag_2:assert property (p_rose_event_flag_2) else $error(\"\");", "task_id": "3_9009", "predict_sva": "@(posedge clk_sys)         $rose(signal_b) |-> ##1 event_flag_b"}
{"id": "609_8_0780", "name": "simd_pwr_gate_past", "sva": "@(posedge clk)     $rose(simd_idle) |-> (power_gated == 1'b1) until $fell(simd_idle)", "ori_sva": "property simd_pwr_gate_past;\n@(posedge clk)     $rose(simd_idle) |-> (power_gated == 1'b1) until $fell(simd_idle);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_pwr_gate_past  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_idle)` (a rising edge on `simd_idle`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(power_gated == 1'b1) until $fell(simd_idle)` (the signal `power_gated` must remain `1'b1` until `simd_idle` has a falling edge).  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_idle", "[0:0] power_gated"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_idle) |-> (power_gated == 1'b1) until $fell(simd_idle)", "sva_name": "simd_pwr_gate_until_posedge", "full_property": "property simd_pwr_gate_past;\n@(posedge clk)     $rose(simd_idle) |-> (power_gated == 1'b1) until $fell(simd_idle)\nendproperty\nassert_simd_pwr_gate_past:assert property (simd_pwr_gate_past) else $error(\"\");", "task_id": "3_8861", "predict_sva": "@(posedge clk)     $rose(simd_idle) |-> (power_gated == 1'b1) until $fell(simd_idle)"}
{"id": "622_2_0886", "name": "p_norm_max_abs_stable", "sva": "@(posedge clk)     valid_in throughout (abs_data < norm_max)[*4]", "ori_sva": "property p_norm_max_abs_stable;\n@(posedge clk)     valid_in throughout (abs_data < norm_max)[*4];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_norm_max_abs_stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Property Behavior**: The signal `valid_in` must remain asserted (`1'b1`) continuously for 4 consecutive clock cycles, during which the condition `abs_data < norm_max` must also hold true for all those 4 cycles.  \n\n**Key Components**:  \n- **Temporal Operator**: `throughout` ensures `valid_in` is active while the sequence (`abs_data < norm_max`)[*4] is evaluated.  \n- **Sequence**: `(abs_data < norm_max)[*4]` checks if `abs_data` is less than `norm_max` for exactly 4 clock cycles.  \n- **No implication** is used; the property directly asserts the combined stability condition.  \n\n**Note**: Unlike implication-based properties, this assertion *directly requires* both `valid_in` persistence and the `abs_data` condition to be simultaneously true for the specified duration.", "sva_signals": ["clk", "rst_n", "[15:0] abs_data", "[15:0] norm_max", "[0:0] valid_in"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     valid_in throughout (abs_data < norm_max)[*4]", "sva_name": "p_norm_max_abs_pipeline", "full_property": "property p_norm_max_abs_stable;\n@(posedge clk)     valid_in throughout (abs_data < norm_max)[*4]\nendproperty\nassert_p_norm_max_abs_stable:assert property (p_norm_max_abs_stable) else $error(\"\");", "task_id": "3_8934", "predict_sva": "@(posedge clk)     (valid_in == 1'b1) throughout (abs_data < norm_max)[*4]"}
{"id": "646_3_1116", "name": "atomic_no_interrupt_3", "sva": "@(posedge sys_clk)     atomic_en |-> !interrupt until !atomic_en", "ori_sva": "property atomic_no_interrupt_3;\n@(posedge sys_clk)     atomic_en |-> !interrupt until !atomic_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: atomic_no_interrupt_3  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atomic_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!interrupt until !atomic_en`  \n\n(Note: The `until` operator ensures that `interrupt` remains low (`!interrupt`) continuously from the assertion trigger point until `atomic_en` becomes low (`!atomic_en`).)", "sva_signals": ["sys_clk", "atomic_en", "interrupt"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)         atomic_en == 1'b1 |-> !interrupt throughout (atomic_en [->1])", "sva_name": "atomic_no_interrupt_7", "full_property": "property atomic_no_interrupt_3;\n@(posedge sys_clk)         atomic_en == 1'b1 |-> !interrupt throughout (atomic_en [->1])\nendproperty\nassert_atomic_no_interrupt_3:assert property (atomic_no_interrupt_3) else $error(\"\");", "task_id": "3_9034", "predict_sva": "@(posedge sys_clk)     atomic_en == 1'b1 |-> !interrupt until !atomic_en"}
{"id": "646_5_1104", "name": "atomic_no_interrupt_5", "sva": "@(posedge clock)     atomic_en |-> (interrupt == 1'b0) throughout atomic_en", "ori_sva": "property atomic_no_interrupt_5;\n@(posedge clock)     atomic_en |-> (interrupt == 1'b0) throughout atomic_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: atomic_no_interrupt_5  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atomic_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(interrupt == 1'b0) throughout atomic_en`  ", "sva_signals": ["clock", "[0:0] atomic_en", "[0:0] interrupt"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock)     atomic_en == 1'b1 |-> (interrupt == 1'b0) throughout atomic_en", "sva_name": "atomic_no_interrupt_6", "full_property": "property atomic_no_interrupt_5;\n@(posedge clock)     atomic_en == 1'b1 |-> (interrupt == 1'b0) throughout atomic_en\nendproperty\nassert_atomic_no_interrupt_5:assert property (atomic_no_interrupt_5) else $error(\"\");", "task_id": "3_9036", "predict_sva": "@(posedge clock)         atomic_en == 1'b1 |-> !interrupt until !atomic_en"}
{"sva": "@(negedge clk_aging_research) disable iff(longevity_intervention_safety_assessment_incomplete) anti_aging_therapy_development |-> ($past(cellular_senescence_biomarker_measurement) && $past(healthspan_extension_efficacy_validation)) && ($past(aging_intervention_clinical_translation_readiness) < longevity_medicine_therapeutic_potential_realization_threshold)", "sva_description": "### Assertion description:  \n\n**Property Name**: p_Anti_Aging_Therapy_Development_Check  \n**Trigger Condition**: At every falling edge of `clk_aging_research`  \n**Disable Condition**: `disable iff (longevity_intervention_safety_assessment_incomplete)`  \n**Antecedent (LHS of Implication)**: `anti_aging_therapy_development == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `cellular_senescence_biomarker_measurement` must be true (`1'b1`), **and**  \n- The past value of `healthspan_extension_efficacy_validation` must be true (`1'b1`), **and**  \n- The past value of `aging_intervention_clinical_translation_readiness` must be less than `longevity_medicine_therapeutic_potential_realization_threshold`.  ", "sva_signals": ["clk_aging_research", "longevity_intervention_safety_assessment_incomplete", "anti_aging_therapy_development", "cellular_senescence_biomarker_measurement", "healthspan_extension_efficacy_validation", "aging_intervention_clinical_translation_readiness", "longevity_medicine_therapeutic_potential_realization_threshold"], "clock": "clk_aging_research", "attempts_left": 10, "sva_result": "@(negedge clk_aging_research) disable iff (longevity_intervention_safety_assessment_incomplete)     anti_aging_therapy_development == 1'b1 |->     $past(cellular_senescence_biomarker_measurement) == 1'b1 &&     $past(healthspan_extension_efficacy_validation) == 1'b1 &&     $past(aging_intervention_clinical_translation_readiness) < longevity_medicine_therapeutic_potential_realization_threshold", "sva_name": "p_AntiAgingTherapy_Development", "id": "4027", "full_property": "property p_Anti_Aging_Therapy_Development_Check;\n@(negedge clk_aging_research) disable iff (longevity_intervention_safety_assessment_incomplete)     anti_aging_therapy_development == 1'b1 |->     $past(cellular_senescence_biomarker_measurement) == 1'b1 &&     $past(healthspan_extension_efficacy_validation) == 1'b1 &&     $past(aging_intervention_clinical_translation_readiness) < longevity_medicine_therapeutic_potential_realization_threshold\nendproperty\nassert_p_Anti_Aging_Therapy_Development_Check:assert property (p_Anti_Aging_Therapy_Development_Check) else $error(\"\");", "task_id": "3_7596", "predict_sva": "@(negedge clk_aging_research) disable iff (longevity_intervention_safety_assessment_incomplete)     anti_aging_therapy_development == 1'b1 |->      ($past(cellular_senescence_biomarker_measurement) &&       $past(healthspan_extension_efficacy_validation)) &&     ($past(aging_intervention_clinical_translation_readiness) < longevity_medicine_therapeutic_potential_realization_threshold)"}
{"id": "646_7_1113", "name": "atomic_no_interrupt_7", "sva": "@(posedge main_clk)     atomic_en |-> !interrupt[*1:$] until !atomic_en", "ori_sva": "property atomic_no_interrupt_7;\n@(posedge main_clk)     atomic_en |-> !interrupt[*1:$] until !atomic_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: atomic_no_interrupt_7  \n**Trigger Condition**: At every rising edge of the `main_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atomic_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!interrupt[*1:$] until !atomic_en`  ", "sva_signals": ["main_clk", "[0:0] atomic_en", "[0:0] interrupt"], "clock": "main_clk", "attempts_left": 10, "sva_result": "@(posedge main_clk)     atomic_en == 1'b1 |-> !interrupt[*1:$] until !atomic_en", "sva_name": "atomic_no_interrupt_6", "full_property": "property atomic_no_interrupt_7;\n@(posedge main_clk)     atomic_en == 1'b1 |-> !interrupt[*1:$] until !atomic_en\nendproperty\nassert_atomic_no_interrupt_7:assert property (atomic_no_interrupt_7) else $error(\"\");", "task_id": "3_9038", "predict_sva": "@(posedge main_clk)     atomic_en == 1'b1 |-> !interrupt until !atomic_en"}
{"id": "480_7_1447", "name": "bit_error_free_period", "sva": "@(posedge clk_signal)     $fell(pim_exec) |-> (##1 !bit_error until $fell(pim_ready))", "ori_sva": "property bit_error_free_period;\n@(posedge clk_signal)     $fell(pim_exec) |-> (##1 !bit_error until $fell(pim_ready));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fell_Pim_Exec_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(pim_exec)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !bit_error until $fell(pim_ready)`  ", "sva_signals": ["clk_signal", "[0:0] pim_exec", "[0:0] bit_error", "[0:0] pim_ready"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(pim_exec) |-> ##1 (!bit_error) until $fell(pim_ready)", "sva_name": "p_PimExec_Fell_NoBitError_Until_PimReady_Fell", "full_property": "property p_Fell_Pim_Exec_Check;\n@(posedge clk_signal)     $fell(pim_exec) |-> ##1 (!bit_error) until $fell(pim_ready)\nendproperty\nassert_p_Fell_Pim_Exec_Check:assert property (p_Fell_Pim_Exec_Check) else $error(\"\");", "task_id": "3_8460", "predict_sva": "@(posedge clk_signal)    $fell(pim_exec) |-> ##1 (!bit_error) until $fell(pim_ready)"}
{"id": "387_3_0729", "name": "data_stable_when_clock_stopped_3", "sva": "@(posedge clk)      $fell(clk_running) |-> $stable(data_out)[*1:$] until clk_running", "ori_sva": "property data_stable_when_clock_stopped_3;\n@(posedge clk)      $fell(clk_running) |-> $stable(data_out)[*1:$] until clk_running;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Data_After_Clk_Fall  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clk_running)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(data_out)[*1:$] until clk_running`  \n\n**Explanation of Consequent**:  \nThe consequent asserts that once `clk_running` falls (detected at the rising edge of `clk`), the value of `data_out` must remain stable (unchanged) for one or more clock cycles (`[*1:$]`) until `clk_running` becomes active again (`until clk_running`).  \n\n**Key Notes**:  \n1. `$fell(clk_running)` detects a high-to-low transition of `clk_running` at the clock edge.  \n2. `$stable(data_out)` checks that `data_out` does not change between consecutive clock cycles.  \n3. `[*1:$]` specifies the stability must hold for at least one cycle, potentially indefinitely.  \n4. `until clk_running` terminates the stability check when `clk_running` rises again.  \n\n---  \n(Output format adheres to the given template, with clear separation of components and additional context for the consequent's behavior.)", "sva_signals": ["clk", "rst_n", "[0:0] clk_running", "[0:0] data_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(clk_running) |-> $stable(data_out)[*1:$] until clk_running", "sva_name": "p_Stable_Data_When_Clk_Stopped", "full_property": "property p_Stable_Data_After_Clk_Fall;\n@(posedge clk)     $fell(clk_running) |-> $stable(data_out)[*1:$] until clk_running\nendproperty\nassert_p_Stable_Data_After_Clk_Fall:assert property (p_Stable_Data_After_Clk_Fall) else $error(\"\");", "task_id": "3_8182", "predict_sva": "@(posedge clk)     $fell(clk_running) |-> ##[0:$] $stable(data_out) throughout clk_running[->1]"}
{"sva": "@(negedge clk_space_medicine) disable iff(microgravity_physiological_adaptation_countermeasure_development_incomplete) astronaut_health_maintenance |-> ($past(bone_density_loss_prevention_strategy_effectiveness) && $past(cardiovascular_deconditioning_mitigation_success)) && ($past(space_flight_health_risk_management) < long_duration_space_mission_crew_health_assurance_standard)", "sva_description": "### Assertion description:  \n**Property Name**: p_Astronaut_Health_Maintenance  \n**Trigger Condition**: At every falling edge of the `clk_space_medicine`  \n**Disable Condition**: disable iff (`microgravity_physiological_adaptation_countermeasure_development_incomplete`)  \n**Antecedent (LHS of Implication)**: `astronaut_health_maintenance == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of:  \n  1. `$past(bone_density_loss_prevention_strategy_effectiveness)`  \n  2. `$past(cardiovascular_deconditioning_mitigation_success)`  \n- AND the comparison:  \n  `$past(space_flight_health_risk_management) < long_duration_space_mission_crew_health_assurance_standard`  ", "sva_signals": ["clk_space_medicine", "microgravity_physiological_adaptation_countermeasure_development_incomplete", "[0:0] astronaut_health_maintenance", "bone_density_loss_prevention_strategy_effectiveness", "cardiovascular_deconditioning_mitigation_success", "space_flight_health_risk_management", "long_duration_space_mission_crew_health_assurance_standard"], "clock": "clk_space_medicine", "attempts_left": 10, "sva_result": "@(negedge clk_space_medicine) disable iff (microgravity_physiological_adaptation_countermeasure_development_incomplete)     astronaut_health_maintenance == 1'b1 |->     ($past(bone_density_loss_prevention_strategy_effectiveness) &&       $past(cardiovascular_deconditioning_mitigation_success)) &&     ($past(space_flight_health_risk_management) < long_duration_space_mission_crew_health_assurance_standard)", "sva_name": "p_Astronaut_Health_Maintenance", "id": "4040", "full_property": "property p_Astronaut_Health_Maintenance;\n@(negedge clk_space_medicine) disable iff (microgravity_physiological_adaptation_countermeasure_development_incomplete)     astronaut_health_maintenance == 1'b1 |->     ($past(bone_density_loss_prevention_strategy_effectiveness) &&       $past(cardiovascular_deconditioning_mitigation_success)) &&     ($past(space_flight_health_risk_management) < long_duration_space_mission_crew_health_assurance_standard)\nendproperty\nassert_p_Astronaut_Health_Maintenance:assert property (p_Astronaut_Health_Maintenance) else $error(\"\");", "task_id": "3_7608", "predict_sva": "@(negedge clk_space_medicine) disable iff (microgravity_physiological_adaptation_countermeasure_development_incomplete)     astronaut_health_maintenance == 1'b1 |->      ($past(bone_density_loss_prevention_strategy_effectiveness) &&       $past(cardiovascular_deconditioning_mitigation_success)) &&     ($past(space_flight_health_risk_management) < long_duration_space_mission_crew_health_assurance_standard)"}
{"id": "612_4_0815", "name": "p_simd_vlen_set_stable", "sva": "@(negedge sys_clk)     $rose(simd_vlen_set) |-> $stable(vlen_cfg)", "ori_sva": "property p_simd_vlen_set_stable;\n@(negedge sys_clk)     $rose(simd_vlen_set) |-> $stable(vlen_cfg);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_vlen_set_stable  \n**Trigger Condition**: At every falling edge of the `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_vlen_set)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(vlen_cfg)`", "sva_signals": ["sys_clk", "simd_vlen_set", "vlen_cfg"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(negedge sys_clk)     $rose(simd_vlen_set) |-> $stable(vlen_cfg)", "sva_name": "p_simd_vlen_set_stable_after_rise", "full_property": "property p_simd_vlen_set_stable;\n@(negedge sys_clk)     $rose(simd_vlen_set) |-> $stable(vlen_cfg)\nendproperty\nassert_p_simd_vlen_set_stable:assert property (p_simd_vlen_set_stable) else $error(\"\");", "task_id": "3_8876", "predict_sva": "@(negedge sys_clk)     $rose(simd_vlen_set) |-> $stable(vlen_cfg)"}
{"id": "620_7_0890", "name": "simd_segment_write_overflow_protection_p7", "sva": "@(posedge clk)     $rose(simd_segment_write) |-> (segment_idx < NUM_SEGMENT) [*1]", "ori_sva": "property simd_segment_write_overflow_protection_p7;\n@(posedge clk)     $rose(simd_segment_write) |-> (segment_idx < NUM_SEGMENT) [*1];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_write_overflow_protection_p7  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_segment_write)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(segment_idx < NUM_SEGMENT) [*1]`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_segment_write", "[0:0] segment_idx", "[0:0] NUM_SEGMENT"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_segment_write) |-> (segment_idx < NUM_SEGMENT)", "sva_name": "simd_segment_write_overflow_protection_p6", "full_property": "property simd_segment_write_overflow_protection_p7;\n@(posedge clk)         $rose(simd_segment_write) |-> (segment_idx < NUM_SEGMENT)\nendproperty\nassert_simd_segment_write_overflow_protection_p7:assert property (simd_segment_write_overflow_protection_p7) else $error(\"\");", "task_id": "3_8923", "predict_sva": "@(posedge clk)     $rose(simd_segment_write) |-> (segment_idx < NUM_SEGMENT) throughout (1)"}
{"id": "651_2_1140", "name": "p_credit_stable_when_max", "sva": "@(posedge cxl_clk)     (credit_cnt == MAX_CREDIT) |-> $stable(credit_cnt)", "ori_sva": "property p_credit_stable_when_max;\n@(posedge cxl_clk)     (credit_cnt == MAX_CREDIT) |-> $stable(credit_cnt);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_credit_stable_when_max  \n**Trigger Condition**: At every rising edge of the `cxl_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `credit_cnt == MAX_CREDIT`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(credit_cnt)`  \n\n", "sva_signals": ["cxl_clk", "[0:0] credit_cnt", "[0:0] MAX_CREDIT"], "clock": "cxl_clk", "attempts_left": 10, "sva_result": "@(posedge cxl_clk)         credit_cnt == MAX_CREDIT |-> $stable(credit_cnt)", "sva_name": "p_credit_stable_after_max", "full_property": "property p_credit_stable_when_max;\n@(posedge cxl_clk)         credit_cnt == MAX_CREDIT |-> $stable(credit_cnt)\nendproperty\nassert_p_credit_stable_when_max:assert property (p_credit_stable_when_max) else $error(\"\");", "task_id": "3_9065", "predict_sva": "@(posedge cxl_clk)     credit_cnt == MAX_CREDIT |=> $stable(credit_cnt)"}
{"id": "649_5_1141", "name": "p_decoded_inst_onehot_valid", "sva": "@(posedge clk_core)     inst_valid_ && !stall_ |-> $onehot(decoded_inst_)", "ori_sva": "property p_decoded_inst_onehot_valid;\n@(posedge clk_core)     inst_valid_ && !stall_ |-> $onehot(decoded_inst_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_decoded_inst_onehot_valid  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `inst_valid_ && !stall_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(decoded_inst_)`", "sva_signals": ["clk_core", "stall_", "[0:0] inst_valid_", "decoded_inst_"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     (inst_valid_ && !stall_) |-> $onehot(decoded_inst_)", "sva_name": "p_decoded_inst_onehot_stall", "full_property": "property p_decoded_inst_onehot_valid;\n@(posedge clk_core)     (inst_valid_ && !stall_) |-> $onehot(decoded_inst_)\nendproperty\nassert_p_decoded_inst_onehot_valid:assert property (p_decoded_inst_onehot_valid) else $error(\"\");", "task_id": "3_9053", "predict_sva": "@(posedge clk_core)         (inst_valid_ && !stall_) |-> $onehot(decoded_inst_)"}
{"id": "490_4_1553", "name": "p_temp_normal_rise_after_stable", "sva": "@(posedge clk)     $stable(throttle_level) |-> ##[100:1000] $rose(temp_normal)", "ori_sva": "property p_temp_normal_rise_after_stable;\n@(posedge clk)     $stable(throttle_level) |-> ##[100:1000] $rose(temp_normal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Throttle_Stable_To_Temp_Normal  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(throttle_level)` (throttle_level remains unchanged from the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:1000] $rose(temp_normal)` (Within 100 to 1000 clock cycles after the antecedent holds, temp_normal must transition from low to high)", "sva_signals": ["clk", "rst_n", "[0:0] throttle_level", "[0:0] temp_normal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(throttle_level) |-> ##[100:1000] $rose(temp_normal)", "sva_name": "p_Stable_Throttle_To_Temp_Normal", "full_property": "property p_Throttle_Stable_To_Temp_Normal;\n@(posedge clk)     $stable(throttle_level) |-> ##[100:1000] $rose(temp_normal)\nendproperty\nassert_p_Throttle_Stable_To_Temp_Normal:assert property (p_Throttle_Stable_To_Temp_Normal) else $error(\"\");", "task_id": "3_8506", "predict_sva": "@(posedge clk)    $stable(throttle_level) |-> ##[100:1000] $rose(temp_normal)"}
{"id": "600_7_0721", "name": "p_simd_no_x_with_ack", "sva": "@(posedge clk_bus)     $rose(simd_req) ##1 simd_ack |-> !$isunknown(simd_bus_data)", "ori_sva": "property p_simd_no_x_with_ack;\n@(posedge clk_bus)     $rose(simd_req) ##1 simd_ack |-> !$isunknown(simd_bus_data);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_no_x_with_ack  \n**Trigger Condition**: At every rising edge of the `clk_bus`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_req) ##1 simd_ack`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(simd_bus_data)`  ", "sva_signals": ["clk_bus", "rst_n", "[0:0] simd_req", "[0:0] simd_ack", "[0:0] simd_bus_data"], "clock": "clk_bus", "attempts_left": 10, "sva_result": "@(posedge clk_bus)         $rose(simd_req) ##1 simd_ack |-> !$isunknown(simd_bus_data)", "sva_name": "p_simd_bus_no_x_after_ack", "full_property": "property p_simd_no_x_with_ack;\n@(posedge clk_bus)         $rose(simd_req) ##1 simd_ack |-> !$isunknown(simd_bus_data)\nendproperty\nassert_p_simd_no_x_with_ack:assert property (p_simd_no_x_with_ack) else $error(\"\");", "task_id": "3_8812", "predict_sva": "@(posedge clk_bus)    $rose(simd_req) ##1 simd_ack |-> !$isunknown(simd_bus_data)"}
{"id": "655_3_1194", "name": "p_link_width_stable_after_init", "sva": "@(posedge clk_link)     $rose(link_init_done) |=> $stable(link_width)", "ori_sva": "property p_link_width_stable_after_init;\n@(posedge clk_link)     $rose(link_init_done) |=> $stable(link_width);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_link_width_stable_after_init  \n**Trigger Condition**: At every rising edge of `clk_link`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(link_init_done)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(link_width)`  ", "sva_signals": ["clk_link", "link_init_done", "link_width"], "clock": "clk_link", "attempts_left": 10, "sva_result": "@(posedge clk_link)     $rose(link_init_done) |=> $stable(link_width)", "sva_name": "p_link_width_stable_after_negotiation", "full_property": "property p_link_width_stable_after_init;\n@(posedge clk_link)     $rose(link_init_done) |=> $stable(link_width)\nendproperty\nassert_p_link_width_stable_after_init:assert property (p_link_width_stable_after_init) else $error(\"\");", "task_id": "3_9090", "predict_sva": "@(posedge clk_link)     $rose(link_init_done) |-> $stable(link_width)"}
{"id": "653_10_1175", "name": "p_vc_sel_crc_match", "sva": "@(posedge clk)     crc_match |=> $onehot(vc_sel)", "ori_sva": "property p_vc_sel_crc_match;\n@(posedge clk)     crc_match |=> $onehot(vc_sel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_vc_sel_crc_match  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_match`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$onehot(vc_sel)`  ", "sva_signals": ["clk", "rst_n", "[0:0] crc_match", "[0:0] vc_sel"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     crc_match |=> $onehot(vc_sel)", "sva_name": "p_vc_sel_crc_match", "full_property": "property p_vc_sel_crc_match;\n@(posedge clk)     crc_match |=> $onehot(vc_sel)\nendproperty\nassert_p_vc_sel_crc_match:assert property (p_vc_sel_crc_match) else $error(\"\");", "task_id": "3_9080", "predict_sva": "@(posedge clk)         crc_match |-> $onehot(vc_sel)"}
{"id": "658_10_1198", "name": "ldpc_check_pass_p10", "sva": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct", "ori_sva": "property ldpc_check_pass_p10;\n@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ldpc_check_pass_p10  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `first_match(##[1:20] ldpc_check_finished)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ldpc_check_correct`  ", "sva_signals": ["clk_sys", "[0:0] ldpc_check_finished", "[0:0] ldpc_check_correct"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct", "sva_name": "ldpc_check_pass_p6", "full_property": "property ldpc_check_pass_p10;\n@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct\nendproperty\nassert_ldpc_check_pass_p10:assert property (ldpc_check_pass_p10) else $error(\"\");", "task_id": "3_9109", "predict_sva": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct"}
{"id": "658_8_1259", "name": "ldpc_check_pass_p8", "sva": "@(posedge clk_sys)     ldpc_check_in_progress |=> s_ldpc_check_done |-> r_ldpc_check_pass", "ori_sva": "property ldpc_check_pass_p8;\n@(posedge clk_sys)     ldpc_check_in_progress |=> s_ldpc_check_done |-> r_ldpc_check_pass;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ldpc_check_pass_p8  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ldpc_check_in_progress`  \n**Implication Operator**: `|=>`  \n**Intermediate Condition**: `s_ldpc_check_done`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `r_ldpc_check_pass`  ", "sva_signals": ["clk_sys", "[0:0] ldpc_check_in_progress", "[0:0] s_ldpc_check_done", "[0:0] r_ldpc_check_pass"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         ldpc_check_in_progress |=> s_ldpc_check_done |-> r_ldpc_check_pass", "sva_name": "ldpc_check_pass_p6", "full_property": "property ldpc_check_pass_p8;\n@(posedge clk_sys)         ldpc_check_in_progress |=> s_ldpc_check_done |-> r_ldpc_check_pass\nendproperty\nassert_ldpc_check_pass_p8:assert property (ldpc_check_pass_p8) else $error(\"\");", "task_id": "3_9116", "predict_sva": "@(posedge clk_sys)     ldpc_check_in_progress |-> (s_ldpc_check_done |-> r_ldpc_check_pass)"}
{"id": "696_4_1591", "name": "p_func_unit_sel_clear_before_decode", "sva": "@(posedge clk_core)     $rose(instr_valid) |=> func_unit_sel == 0 ##1 $onehot(func_unit_sel)", "ori_sva": "property p_func_unit_sel_clear_before_decode;\n@(posedge clk_core)     $rose(instr_valid) |=> func_unit_sel == 0 ##1 $onehot(func_unit_sel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_func_unit_sel_clear_before_decode  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(instr_valid)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `func_unit_sel == 0 ##1 $onehot(func_unit_sel)`  ", "sva_signals": ["clk_core", "[0:0] instr_valid", "[0:0] func_unit_sel"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(instr_valid) |=> (func_unit_sel == 0) ##1 $onehot(func_unit_sel)", "sva_name": "p_func_unit_sel_clear", "full_property": "property p_func_unit_sel_clear_before_decode;\n@(posedge clk_core)     $rose(instr_valid) |=> (func_unit_sel == 0) ##1 $onehot(func_unit_sel)\nendproperty\nassert_p_func_unit_sel_clear_before_decode:assert property (p_func_unit_sel_clear_before_decode) else $error(\"\");", "task_id": "3_9292", "predict_sva": "@(posedge clk_core)         $rose(instr_valid) |-> (func_unit_sel == 0) ##1 $onehot(func_unit_sel)"}
{"id": "717_7_1733", "name": "p_mac_result_no_x_transition", "sva": "@(posedge clk)     $changed(mac_result) |-> !$isunknown(mac_result)", "ori_sva": "property p_mac_result_no_x_transition;\n@(posedge clk)     $changed(mac_result) |-> !$isunknown(mac_result);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mac_result_no_x_transition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(mac_result)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(mac_result)`  ", "sva_signals": ["clk", "rst_n", "[0:0] mac_result"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $changed(mac_result) |-> !$isunknown(mac_result)", "sva_name": "p_mac_result_no_x_transition", "full_property": "property p_mac_result_no_x_transition;\n@(posedge clk)     $changed(mac_result) |-> !$isunknown(mac_result)\nendproperty\nassert_p_mac_result_no_x_transition:assert property (p_mac_result_no_x_transition) else $error(\"\");", "task_id": "3_9392", "predict_sva": "@(posedge clk)     $changed(mac_result) |-> !$isunknown(mac_result)"}
{"id": "463_6_1348", "name": "p_atomic_op_cache_miss_throughout", "sva": "@(posedge clk_signal)     $fell(amo_req) |-> ##1 (!cache_miss throughout ($rose(lock_ack) ##1 $fell(amo_resp)))", "ori_sva": "property p_atomic_op_cache_miss_throughout;\n@(posedge clk_signal)     $fell(amo_req) |-> ##1 (!cache_miss throughout ($rose(lock_ack) ##1 $fell(amo_resp)));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_amo_req_fell_to_lock_ack_resp  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(amo_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (!cache_miss throughout ($rose(lock_ack) ##1 $fell(amo_resp)))`  ", "sva_signals": ["clk_signal", "[0:0] amo_req", "[0:0] cache_miss", "[0:0] lock_ack", "[0:0] amo_resp"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(amo_req) |-> ##1 (!cache_miss throughout ($rose(lock_ack) ##1 $fell(amo_resp)))", "sva_name": "p_AmoReq_Fell_NoCacheMiss", "full_property": "property p_amo_req_fell_to_lock_ack_resp;\n@(posedge clk_signal)     $fell(amo_req) |-> ##1 (!cache_miss throughout ($rose(lock_ack) ##1 $fell(amo_resp)))\nendproperty\nassert_p_amo_req_fell_to_lock_ack_resp:assert property (p_amo_req_fell_to_lock_ack_resp) else $error(\"\");", "task_id": "3_8382", "predict_sva": "@(posedge clk_signal)     $fell(amo_req) |-> ##1 (!cache_miss throughout (##[0:$] $rose(lock_ack) ##[0:$] $fell(amo_resp)))"}
{"id": "707_8_1627", "name": "p_retrans_immediately_after_crc_fail", "sva": "@(posedge clk)     $fell(crc_fail) |-> ##1 !retrans_en", "ori_sva": "property p_retrans_immediately_after_crc_fail;\n@(posedge clk)     $fell(crc_fail) |-> ##1 !retrans_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_retrans_immediately_after_crc_fail  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(crc_fail)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !retrans_en`", "sva_signals": ["clk", "rst_n", "[0:0] crc_fail", "[0:0] retrans_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(crc_fail) |-> ##1 !retrans_en", "sva_name": "p_retrans_never_after_crc_fail_fall", "full_property": "property p_retrans_immediately_after_crc_fail;\n@(posedge clk)         $fell(crc_fail) |-> ##1 !retrans_en\nendproperty\nassert_p_retrans_immediately_after_crc_fail:assert property (p_retrans_immediately_after_crc_fail) else $error(\"\");", "task_id": "3_9353", "predict_sva": "@(posedge clk)     $fell(crc_fail) |-> ##1 !retrans_en"}
{"id": "665_3_1282", "name": "accum_target_valid", "sva": "@(posedge clk_sys)     accum_enable |-> $onehot(accum_target)", "ori_sva": "property accum_target_valid;\n@(posedge clk_sys)     accum_enable |-> $onehot(accum_target);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: accum_target_valid  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `accum_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(accum_target)`  ", "sva_signals": ["clk_sys", "[0:0] accum_enable", "[0:0] accum_target"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         accum_enable == 1'b1 |-> $onehot(accum_target)", "sva_name": "accum_target_onehot_p6", "full_property": "property accum_target_valid;\n@(posedge clk_sys)         accum_enable == 1'b1 |-> $onehot(accum_target)\nendproperty\nassert_accum_target_valid:assert property (accum_target_valid) else $error(\"\");", "task_id": "3_9150", "predict_sva": "@(posedge clk_sys)         accum_enable == 1'b1 |-> $onehot(accum_target)"}
{"id": "676_2_1406", "name": "p_activation_out_range_2", "sva": "@(posedge clk)     activation_enable |=> activation_out inside {[0:1]}", "ori_sva": "property p_activation_out_range_2;\n@(posedge clk)     activation_enable |=> activation_out inside {[0:1]};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_activation_out_range_2  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `activation_enable == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `activation_out` is inside the range `[0:1]` (i.e., `activation_out` equals 0 or 1)  ", "sva_signals": ["clk", "rst_n", "[0:0] activation_enable", "[1:0] activation_out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         activation_enable == 1'b1 |=> activation_out inside {1'b0, 1'b1}", "sva_name": "p_activation_out_range_8", "full_property": "property p_activation_out_range_2;\n@(posedge clk)         activation_enable == 1'b1 |=> activation_out inside {1'b0, 1'b1}\nendproperty\nassert_p_activation_out_range_2:assert property (p_activation_out_range_2) else $error(\"\");", "task_id": "3_9216", "predict_sva": "@(posedge clk)     activation_enable == 1'b1 |-> activation_out inside {[0:1]}"}
{"id": "636_4_1013", "name": "p_data_bus_no_x_stable", "sva": "@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)", "ori_sva": "property p_data_bus_no_x_stable;\n@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_bus_no_x_stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(data_bus)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(data_bus)`", "sva_signals": ["clk", "rst_n", "[0:0] data_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)", "sva_name": "p_Stable_Data_No_X", "full_property": "property p_data_bus_no_x_stable;\n@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)\nendproperty\nassert_p_data_bus_no_x_stable:assert property (p_data_bus_no_x_stable) else $error(\"\");", "task_id": "3_8995", "predict_sva": "@(posedge clk)    $stable(data_bus) |-> !$isunknown(data_bus)"}
{"id": "734_6_1894", "name": "ecc_error_assertion_6", "sva": "@(posedge clk_ecc)     ecc_error_detected |-> ecc_error_signal ##1 !ecc_error_signal", "ori_sva": "property ecc_error_assertion_6;\n@(posedge clk_ecc)     ecc_error_detected |-> ecc_error_signal ##1 !ecc_error_signal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_error_assertion_6  \n**Trigger Condition**: At every rising edge of the `clk_ecc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_error_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecc_error_signal` is asserted at the current clock cycle, and then `!ecc_error_signal` (deasserted) at the next clock cycle (`##1`).  ", "sva_signals": ["clk", "rst_n", "[0:0] ecc_error_detected", "[0:0] ecc_error_signal", "clk_ecc"], "clock": "clk_ecc", "attempts_left": 10, "sva_result": "@(posedge clk_ecc)     ecc_error_detected == 1'b1 |-> ecc_error_signal ##1 !ecc_error_signal", "sva_name": "ecc_error_assertion_7", "full_property": "property ecc_error_assertion_6;\n@(posedge clk_ecc)     ecc_error_detected == 1'b1 |-> ecc_error_signal ##1 !ecc_error_signal\nendproperty\nassert_ecc_error_assertion_6:assert property (ecc_error_assertion_6) else $error(\"\");", "task_id": "3_9475", "predict_sva": "@(posedge clk_ecc)     ecc_error_detected == 1'b1 |-> ecc_error_signal ##1 !ecc_error_signal"}
{"id": "718_2_1775", "name": "thermal_protect_implies_low_power_2", "sva": "@(posedge clk_sys)     thermal_protect_signal && !$past(thermal_protect_signal) |-> ##1 all_modules_low_power_state", "ori_sva": "property thermal_protect_implies_low_power_2;\n@(posedge clk_sys)     thermal_protect_signal && !$past(thermal_protect_signal) |-> ##1 all_modules_low_power_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_protect_implies_low_power_2  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_protect_signal && !$past(thermal_protect_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 all_modules_low_power_state`  ", "sva_signals": ["clk_sys", "[0:0] thermal_protect_signal", "[0:0] all_modules_low_power_state"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (thermal_protect_signal && !$past(thermal_protect_signal)) |-> ##1 all_modules_low_power_state", "sva_name": "thermal_protect_implies_low_power_6", "full_property": "property thermal_protect_implies_low_power_2;\n@(posedge clk_sys)     (thermal_protect_signal && !$past(thermal_protect_signal)) |-> ##1 all_modules_low_power_state\nendproperty\nassert_thermal_protect_implies_low_power_2:assert property (thermal_protect_implies_low_power_2) else $error(\"\");", "task_id": "3_9396", "predict_sva": "@(posedge clk_sys)         (thermal_protect_signal && $past(!thermal_protect_signal)) |-> ##1 all_modules_low_power_state"}
{"id": "653_2_1165", "name": "p_vc_sel_stable", "sva": "@(posedge clk)     $stable(vc_sel) |-> $onehot(vc_sel)", "ori_sva": "property p_vc_sel_stable;\n@(posedge clk)     $stable(vc_sel) |-> $onehot(vc_sel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_vc_sel_stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(vc_sel)` (the value of `vc_sel` remains unchanged from the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(vc_sel)` (the value of `vc_sel` must be one-hot encoded, meaning exactly one bit is set to 1)", "sva_signals": ["clk", "rst_n", "[2:0] vc_sel"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(vc_sel) |-> $onehot(vc_sel)", "sva_name": "p_vc_sel_stable_onehot", "full_property": "property p_vc_sel_stable;\n@(posedge clk)     $stable(vc_sel) |-> $onehot(vc_sel)\nendproperty\nassert_p_vc_sel_stable:assert property (p_vc_sel_stable) else $error(\"\");", "task_id": "3_9082", "predict_sva": "@(posedge clk)        $stable(vc_sel) |-> $onehot(vc_sel)"}
{"id": "738_3_1916", "name": "p_err_state_no_new_frame_3", "sva": "@(posedge can_clk)     can_error_state |-> ##[1:$] !can_tx_frame_active", "ori_sva": "property p_err_state_no_new_frame_3;\n@(posedge can_clk)     can_error_state |-> ##[1:$] !can_tx_frame_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_err_state_no_new_frame_3  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_state == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:$] !can_tx_frame_active`  ", "sva_signals": ["can_clk", "can_error_state", "[0:0] can_tx_frame_active"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     can_error_state == 1'b1 |-> ##[1:$] !can_tx_frame_active", "sva_name": "p_err_state_no_new_frame_5", "full_property": "property p_err_state_no_new_frame_3;\n@(posedge can_clk)     can_error_state == 1'b1 |-> ##[1:$] !can_tx_frame_active\nendproperty\nassert_p_err_state_no_new_frame_3:assert property (p_err_state_no_new_frame_3) else $error(\"\");", "task_id": "3_9490", "predict_sva": "@(posedge can_clk)     can_error_state == 1'b1 |-> ##[1:$] !can_tx_frame_active"}
{"id": "717_2_1720", "name": "p_mac_result_no_x_negedge", "sva": "@(negedge clk)     !$isunknown(mac_result)", "ori_sva": "property p_mac_result_no_x_negedge;\n@(negedge clk)     !$isunknown(mac_result);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mac_result_no_x_negedge  \n**Trigger Condition**: At every negedge of the `clk`  \n**Disable Condition**: None  \n**Check Condition**: `!$isunknown(mac_result)`  \n\n(Note: This assertion is not an implication-based property but a simple check that `mac_result` does not contain any unknown ('x' or 'z') values at every falling edge of the clock.)", "sva_signals": ["clk", "rst_n", "[0:0] mac_result"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) !$isunknown(mac_result)", "sva_name": "p_mac_result_no_x_negedge", "full_property": "property p_mac_result_no_x_negedge;\n@(negedge clk) !$isunknown(mac_result)\nendproperty\nassert_p_mac_result_no_x_negedge:assert property (p_mac_result_no_x_negedge) else $error(\"\");", "task_id": "3_9388", "predict_sva": "@(negedge clk)     !$isunknown(mac_result)"}
{"id": "685_4_1481", "name": "ecc_fail_causes_error_flag", "sva": "@(posedge clk)     ecc_fail |-> ##[0:1] ecc_error_flag", "ori_sva": "property ecc_fail_causes_error_flag;\n@(posedge clk)     ecc_fail |-> ##[0:1] ecc_error_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_fail_causes_error_flag  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_fail == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:1] ecc_error_flag == 1'b1`  \n\n(Note: `##[0:1]` means the consequent must hold either immediately (0 cycles) or after 1 clock cycle from the trigger.)", "sva_signals": ["clk", "rst_n", "[0:0] ecc_fail", "[0:0] ecc_error_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ecc_fail == 1'b1 |-> ##[0:1] ecc_error_flag == 1'b1", "sva_name": "ecc_fail_implies_error_next_cycle", "full_property": "property ecc_fail_causes_error_flag;\n@(posedge clk)         ecc_fail == 1'b1 |-> ##[0:1] ecc_error_flag == 1'b1\nendproperty\nassert_ecc_fail_causes_error_flag:assert property (ecc_fail_causes_error_flag) else $error(\"\");", "task_id": "3_9253", "predict_sva": "@(posedge clk)     ecc_fail == 1'b1 |-> ##[0:1] ecc_error_flag == 1'b1"}
{"id": "778_3_2302", "name": "recovery_completion", "sva": "@(posedge avb_clk)     recovery_activated |=> ##[1:10] $rose(stream_valid)", "ori_sva": "property recovery_completion;\n@(posedge avb_clk)     recovery_activated |=> ##[1:10] $rose(stream_valid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: recovery_completion  \n**Trigger Condition**: At every rising edge of the `avb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `recovery_activated`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##[1:10] $rose(stream_valid)` (within 1 to 10 clock cycles after the antecedent, `stream_valid` must rise)  ", "sva_signals": ["avb_clk", "[0:0] recovery_activated", "[0:0] stream_valid"], "clock": "avb_clk", "attempts_left": 10, "sva_result": "@(posedge avb_clk)         recovery_activated |=> ##[1:10] $rose(stream_valid)", "sva_name": "recovery_sequence_valid", "full_property": "property recovery_completion;\n@(posedge avb_clk)         recovery_activated |=> ##[1:10] $rose(stream_valid)\nendproperty\nassert_recovery_completion:assert property (recovery_completion) else $error(\"\");", "task_id": "3_9715", "predict_sva": "@(posedge avb_clk)     recovery_activated |-> ##[1:10] $rose(stream_valid)"}
{"id": "749_3_2029", "name": "p_switch_stable_until_grant", "sva": "@(posedge clk_sys)     thread_switch_req && !thread_switch_grant |=> $stable(thread_switch_req) until thread_switch_grant", "ori_sva": "property p_switch_stable_until_grant;\n@(posedge clk_sys)     thread_switch_req && !thread_switch_grant |=> $stable(thread_switch_req) until thread_switch_grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_switch_stable_until_grant  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thread_switch_req && !thread_switch_grant`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(thread_switch_req) until thread_switch_grant`  \n\n", "sva_signals": ["clk_sys", "thread_switch_req", "thread_switch_grant"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (thread_switch_req && !thread_switch_grant) |=> $stable(thread_switch_req) until thread_switch_grant", "sva_name": "p_thread_switch_stable_after_req", "full_property": "property p_switch_stable_until_grant;\n@(posedge clk_sys)     (thread_switch_req && !thread_switch_grant) |=> $stable(thread_switch_req) until thread_switch_grant\nendproperty\nassert_p_switch_stable_until_grant:assert property (p_switch_stable_until_grant) else $error(\"\");", "task_id": "3_9544", "predict_sva": "@(posedge clk_sys)     (thread_switch_req && !thread_switch_grant) |-> $stable(thread_switch_req) until thread_switch_grant"}
{"id": "773_10_2257", "name": "bitwidth_change_propagation", "sva": "@(posedge clk_quant)     disable iff (!rst_n)     $changed(quant_bits) |-> ##1 (quant_bits == dequant_bits)", "ori_sva": "property bitwidth_change_propagation;\n@(posedge clk_quant)     disable iff (!rst_n)     $changed(quant_bits) |-> ##1 (quant_bits == dequant_bits);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bitwidth_change_propagation  \n**Trigger Condition**: At every rising edge of the `clk_quant`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$changed(quant_bits)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (quant_bits == dequant_bits)`  ", "sva_signals": ["clk_quant", "rst_n", "[0:0] quant_bits", "[0:0] dequant_bits"], "clock": "clk_quant", "attempts_left": 10, "sva_result": "@(posedge clk_quant) disable iff (!rst_n)     $changed(quant_bits) |-> ##1 (quant_bits == dequant_bits)", "sva_name": "quant_dequant_consistency_p6", "full_property": "property bitwidth_change_propagation;\n@(posedge clk_quant) disable iff (!rst_n)     $changed(quant_bits) |-> ##1 (quant_bits == dequant_bits)\nendproperty\nassert_bitwidth_change_propagation:assert property (bitwidth_change_propagation) else $error(\"\");", "task_id": "3_9676", "predict_sva": "@(posedge clk_quant) disable iff (!rst_n)     $changed(quant_bits) |-> ##1 (dequant_bits == quant_bits)"}
{"id": "787_4_2407", "name": "packet_continuity", "sva": "@(posedge pcie_clk)     $fell(valid_pkt) ##1 $rose(valid_pkt) |-> $stable(pkt_id)", "ori_sva": "property packet_continuity;\n@(posedge pcie_clk)     $fell(valid_pkt) ##1 $rose(valid_pkt) |-> $stable(pkt_id);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: packet_continuity  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(valid_pkt) ##1 $rose(valid_pkt)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(pkt_id)`  ", "sva_signals": ["pcie_clk", "valid_pkt", "pkt_id"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)         $fell(valid_pkt) ##1 $rose(valid_pkt) |-> $stable(pkt_id)", "sva_name": "pcie_packet_continuity", "full_property": "property packet_continuity;\n@(posedge pcie_clk)         $fell(valid_pkt) ##1 $rose(valid_pkt) |-> $stable(pkt_id)\nendproperty\nassert_packet_continuity:assert property (packet_continuity) else $error(\"\");", "task_id": "3_9803", "predict_sva": "@(posedge pcie_clk)     $fell(valid_pkt) ##1 $rose(valid_pkt) |-> $stable(pkt_id)"}
{"id": "751_1_2039", "name": "pcie_train_state_no_skip_1", "sva": "@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_DETECT) |-> ##[1:2] (train_state_next == TRAIN_STATE_POLLING)", "ori_sva": "property pcie_train_state_no_skip_1;\n@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_DETECT) |-> ##[1:2] (train_state_next == TRAIN_STATE_POLLING);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_train_state_no_skip_1  \n**Trigger Condition**: At every rising edge of `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(train_state_curr == TRAIN_STATE_DETECT)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] (train_state_next == TRAIN_STATE_POLLING)`  ", "sva_signals": ["pcie_clk", "[0:0] train_state_curr", "[0:0] train_state_next", "[0:0] TRAIN_STATE_DETECT", "[0:0] TRAIN_STATE_POLLING"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)         $rose(train_state_curr == TRAIN_STATE_DETECT) |-> ##[1:2] (train_state_next == TRAIN_STATE_POLLING)", "sva_name": "pcie_train_state_no_skip_6", "full_property": "property pcie_train_state_no_skip_1;\n@(posedge pcie_clk)         $rose(train_state_curr == TRAIN_STATE_DETECT) |-> ##[1:2] (train_state_next == TRAIN_STATE_POLLING)\nendproperty\nassert_pcie_train_state_no_skip_1:assert property (pcie_train_state_no_skip_1) else $error(\"\");", "task_id": "3_9557", "predict_sva": "@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_DETECT) |-> ##[1:2] (train_state_next == TRAIN_STATE_POLLING)"}
{"id": "663_5_1287", "name": "p_write_voltage_window_after_reset", "sva": "@(posedge clk)     $rose(reset_n) |-> ##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX)", "ori_sva": "property p_write_voltage_window_after_reset;\n@(posedge clk)     $rose(reset_n) |-> ##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_write_voltage_window_after_reset  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX)`  ", "sva_signals": ["clk", "reset_n", "[0:0] write_voltage", "[0:0] V_SET_MIN", "[0:0] V_SET_MAX"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(reset_n) |-> ##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX)", "sva_name": "p_write_voltage_after_reset", "full_property": "property p_write_voltage_window_after_reset;\n@(posedge clk)     $rose(reset_n) |-> ##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX)\nendproperty\nassert_p_write_voltage_window_after_reset:assert property (p_write_voltage_window_after_reset) else $error(\"\");", "task_id": "3_9144", "predict_sva": "@(posedge clk)    $rose(reset_n) |-> ##[1:5] (write_voltage >= V_SET_MIN && write_voltage <= V_SET_MAX)"}
{"id": "768_8_2224", "name": "data_coherency_post_switch", "sva": "@(posedge clk_coherency)     $fell(primary_link_active) && $rose(backup_link_active) |->      $stable(cache_line_data)[*4]", "ori_sva": "property data_coherency_post_switch;\n@(posedge clk_coherency)     $fell(primary_link_active) && $rose(backup_link_active) |->      $stable(cache_line_data)[*4];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_coherency_post_switch  \n**Trigger Condition**: At every rising edge of the `clk_coherency`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(primary_link_active) && $rose(backup_link_active)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(cache_line_data)[*4]`  ", "sva_signals": ["clk_coherency", "primary_link_active", "backup_link_active", "cache_line_data", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "clk_coherency", "attempts_left": 10, "sva_result": "@(posedge clk_coherency)     ($fell(primary_link_active) && $rose(backup_link_active)) |-> $stable(cache_line_data)[*4]", "sva_name": "cache_coherency_across_failover", "full_property": "property data_coherency_post_switch;\n@(posedge clk_coherency)     ($fell(primary_link_active) && $rose(backup_link_active)) |-> $stable(cache_line_data)[*4]\nendproperty\nassert_data_coherency_post_switch:assert property (data_coherency_post_switch) else $error(\"\");", "task_id": "3_9653", "predict_sva": "@(posedge clk_coherency)     ($fell(primary_link_active) && $rose(backup_link_active)) |-> $stable(cache_line_data)[*4]"}
{"id": "802_8_2599", "name": "power_switch_completion_timeout", "sva": "@(posedge layer_clk)     $rose(power_switch_req) |-> ##[1:100] $rose(power_switch_ack)", "ori_sva": "property power_switch_completion_timeout;\n@(posedge layer_clk)     $rose(power_switch_req) |-> ##[1:100] $rose(power_switch_ack);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: power_switch_completion_timeout  \n**Trigger Condition**: At every rising edge of `layer_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(power_switch_req)` (power_switch_req transitions from low to high)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] $rose(power_switch_ack)` (Within 1 to 100 clock cycles after the antecedent, power_switch_ack must transition from low to high)", "sva_signals": ["layer_clk", "power_switch_req", "power_switch_ack"], "clock": "layer_clk", "attempts_left": 10, "sva_result": "@(posedge layer_clk)         $rose(power_switch_req) |-> ##[1:100] $rose(power_switch_ack)", "sva_name": "power_switch_sequence", "full_property": "property power_switch_completion_timeout;\n@(posedge layer_clk)         $rose(power_switch_req) |-> ##[1:100] $rose(power_switch_ack)\nendproperty\nassert_power_switch_completion_timeout:assert property (power_switch_completion_timeout) else $error(\"\");", "task_id": "3_9932", "predict_sva": "@(posedge layer_clk)     $rose(power_switch_req) |-> ##[1:100] $rose(power_switch_ack)"}
{"id": "798_8_2531", "name": "reset_behavior", "sva": "@(posedge clk_sparse)     $rose(sparsity_reset) |=> (zero_count == 0 && sparsity_ratio == 0.0)", "ori_sva": "property reset_behavior;\n@(posedge clk_sparse)     $rose(sparsity_reset) |=> (zero_count == 0 && sparsity_ratio == 0.0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: reset_behavior  \n**Trigger Condition**: At every rising edge of `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(sparsity_reset)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(zero_count == 0 && sparsity_ratio == 0.0)`  ", "sva_signals": ["clk", "rst_n", "[0:0] sparsity_reset", "[0:0] zero_count", "[0:0] sparsity_ratio", "clk_sparse"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)         $rose(sparsity_reset) |=> (zero_count == 0 && sparsity_ratio == 0.0)", "sva_name": "sparsity_reset_zero_count_ratio", "full_property": "property reset_behavior;\n@(posedge clk_sparse)         $rose(sparsity_reset) |=> (zero_count == 0 && sparsity_ratio == 0.0)\nendproperty\nassert_reset_behavior:assert property (reset_behavior) else $error(\"\");", "task_id": "3_9898", "predict_sva": "@(posedge clk_sparse)     $rose(sparsity_reset) |-> (zero_count == 0 && sparsity_ratio == 0.0)"}
{"id": "807_3_2633", "name": "noise_injection_recovery_p3", "sva": "@(posedge sys_clk)     $rose(noise_injection_flag) |-> ##[1:5] $fell(sensor3_weight)", "ori_sva": "property noise_injection_recovery_p3;\n@(posedge sys_clk)     $rose(noise_injection_flag) |-> ##[1:5] $fell(sensor3_weight);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: noise_injection_recovery_p3  \n**Trigger Condition**: At every rising edge of `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(noise_injection_flag)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $fell(sensor3_weight)`  \n\n", "sva_signals": ["sys_clk", "noise_injection_flag", "sensor3_weight"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)     $rose(noise_injection_flag) |-> ##[1:5] $fell(sensor3_weight)", "sva_name": "sensor_noise_detection_p6", "full_property": "property noise_injection_recovery_p3;\n@(posedge sys_clk)     $rose(noise_injection_flag) |-> ##[1:5] $fell(sensor3_weight)\nendproperty\nassert_noise_injection_recovery_p3:assert property (noise_injection_recovery_p3) else $error(\"\");", "task_id": "3_9967", "predict_sva": "@(posedge sys_clk)     $rose(noise_injection_flag) |-> ##[1:5] $fell(sensor3_weight)"}
{"id": "809_1_2662", "name": "exception_priority_check", "sva": "@(posedge clk_core)     ($rose(exception_req_high) && $rose(exception_req_low)) |-> ##1 exception_ack_high", "ori_sva": "property exception_priority_check;\n@(posedge clk_core)     ($rose(exception_req_high) && $rose(exception_req_low)) |-> ##1 exception_ack_high\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: exception_priority_check  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(exception_req_high) && $rose(exception_req_low)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 exception_ack_high`  ", "sva_signals": ["clk_core", "exception_req_high", "exception_req_low", "exception_ack_high"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         ($rose(exception_req_high) && $rose(exception_req_low)) |-> ##1 exception_ack_high", "sva_name": "nested_exception_priority", "full_property": "property exception_priority_check;\n@(posedge clk_core)         ($rose(exception_req_high) && $rose(exception_req_low)) |-> ##1 exception_ack_high\nendproperty\nassert_exception_priority_check:assert property (exception_priority_check) else $error(\"\");", "task_id": "3_9984", "predict_sva": "@(posedge clk_core)         ($rose(exception_req_high) && $rose(exception_req_low)) |-> ##1 exception_ack_high"}
{"id": "745_6_1989", "name": "p_no_muldiv_mem_conflict", "sva": "@(posedge clk_core)     !((mul_en_ || div_en_ || rem_en_) && mem_any_en_)", "ori_sva": "property p_no_muldiv_mem_conflict;\n@(posedge clk_core)     !((mul_en_ || div_en_ || rem_en_) && mem_any_en_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_muldiv_mem_conflict  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple assertion without implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `!((mul_en_ || div_en_ || rem_en_) && mem_any_en_)`  \n**Description**: The assertion checks that there is no conflict between multiplication/division/remainder operations (`mul_en_`, `div_en_`, or `rem_en_` being high) and any memory operation (`mem_any_en_` being high) at the same time. The assertion fails if both conditions are true simultaneously on a rising edge of `clk_core`.", "sva_signals": ["clk_core", "[0:0] mul_en_", "[0:0] div_en_", "[0:0] rem_en_", "[0:0] mem_any_en_"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         !((mul_en_ || div_en_ || rem_en_) && mem_any_en_)", "sva_name": "p_no_muldiv_rem_mem_conflict", "full_property": "property p_no_muldiv_mem_conflict;\n@(posedge clk_core)         !((mul_en_ || div_en_ || rem_en_) && mem_any_en_)\nendproperty\nassert_p_no_muldiv_mem_conflict:assert property (p_no_muldiv_mem_conflict) else $error(\"\");", "task_id": "3_9524", "predict_sva": "@(posedge clk_core)     !(mul_en_ || div_en_ || rem_en_) || !mem_any_en_"}
{"id": "793_10_2490", "name": "multi_carrier_lock_sync", "sva": "@(posedge clk_sys)     (num_active_carriers_i > 1) |-> (locked_o == &carrier_lock_status_i)", "ori_sva": "property multi_carrier_lock_sync;\n@(posedge clk_sys)     (num_active_carriers_i > 1) |-> (locked_o == &carrier_lock_status_i);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: multi_carrier_lock_sync  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `num_active_carriers_i > 1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `locked_o == &carrier_lock_status_i`  ", "sva_signals": ["clk_sys", "[0:0] locked_o", "[0:0] num_active_carriers_i", "[0:0] carrier_lock_status_i"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         num_active_carriers_i > 1 |-> locked_o == &carrier_lock_status_i", "sva_name": "multi_carrier_consistency", "full_property": "property multi_carrier_lock_sync;\n@(posedge clk_sys)         num_active_carriers_i > 1 |-> locked_o == &carrier_lock_status_i\nendproperty\nassert_multi_carrier_lock_sync:assert property (multi_carrier_lock_sync) else $error(\"\");", "task_id": "3_9852", "predict_sva": "@(posedge clk_sys)     num_active_carriers_i > 1 |-> locked_o == &carrier_lock_status_i"}
{"id": "815_2_2715", "name": "index_compression_integrity", "sva": "@(posedge clk_sparse)     $rose(compression_valid) |-> (compressed_idx == $past(uncompressed_idx, 1))", "ori_sva": "property index_compression_integrity;\n@(posedge clk_sparse)     $rose(compression_valid) |-> (compressed_idx == $past(uncompressed_idx, 1));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: index_compression_integrity  \n**Trigger Condition**: At every rising edge of `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(compression_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `compressed_idx == $past(uncompressed_idx, 1)`", "sva_signals": ["clk_sparse", "compression_valid", "compressed_idx", "uncompressed_idx"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)         $rose(compression_valid) |-> compressed_idx == $past(uncompressed_idx, 1)", "sva_name": "p_compression_idx_match", "full_property": "property index_compression_integrity;\n@(posedge clk_sparse)         $rose(compression_valid) |-> compressed_idx == $past(uncompressed_idx, 1)\nendproperty\nassert_index_compression_integrity:assert property (index_compression_integrity) else $error(\"\");", "task_id": "3_10040", "predict_sva": "@(posedge clk_sparse)         $rose(compression_valid) |-> compressed_idx == $past(uncompressed_idx, 1)"}
{"id": "801_12_2585", "name": "p_unique_channel_allocation", "sva": "@(posedge clk_control)     channel_alloc_req |-> ##[1:3] $onehot(allocated_channel)", "ori_sva": "property p_unique_channel_allocation;\n@(posedge clk_control)     channel_alloc_req |-> ##[1:3] $onehot(allocated_channel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_unique_channel_allocation  \n**Trigger Condition**: At every rising edge of the `clk_control`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `channel_alloc_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 3 clock cycles (`##[1:3]`), the `allocated_channel` signal must be one-hot (`$onehot(allocated_channel)`)", "sva_signals": ["clk", "rst_n", "[0:0] channel_alloc_req", "[0:0] allocated_channel", "clk_control"], "clock": "clk_control", "attempts_left": 10, "sva_result": "@(posedge clk_control)     channel_alloc_req == 1'b1 |-> ##[1:3] $onehot(allocated_channel)", "sva_name": "channel_allocation_unique", "full_property": "property p_unique_channel_allocation;\n@(posedge clk_control)     channel_alloc_req == 1'b1 |-> ##[1:3] $onehot(allocated_channel)\nendproperty\nassert_p_unique_channel_allocation:assert property (p_unique_channel_allocation) else $error(\"\");", "task_id": "3_9919", "predict_sva": "@(posedge clk_control)     channel_alloc_req == 1'b1 |-> ##[1:3] $onehot(allocated_channel)"}
{"id": "786_4_2395", "name": "pcie_recovery_to_training_allowed", "sva": "@(posedge pcie_clk_i)     $fell(link_state_recovery_i) |=> ##[1:3] link_state_train_i", "ori_sva": "property pcie_recovery_to_training_allowed;\n@(posedge pcie_clk_i)     $fell(link_state_recovery_i) |=> ##[1:3] link_state_train_i\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_recovery_to_training_allowed  \n**Trigger Condition**: At every rising edge of `pcie_clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(link_state_recovery_i)` (a falling edge is detected on `link_state_recovery_i`)  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##[1:3] link_state_train_i` (within 1 to 3 clock cycles after the antecedent, `link_state_train_i` must be asserted)", "sva_signals": ["pcie_clk_i", "link_state_recovery_i", "link_state_train_i"], "clock": "pcie_clk_i", "attempts_left": 10, "sva_result": "@(posedge pcie_clk_i)     $fell(link_state_recovery_i) |=> ##[1:3] link_state_train_i", "sva_name": "pcie_link_state_transition_valid", "full_property": "property pcie_recovery_to_training_allowed;\n@(posedge pcie_clk_i)     $fell(link_state_recovery_i) |=> ##[1:3] link_state_train_i\nendproperty\nassert_pcie_recovery_to_training_allowed:assert property (pcie_recovery_to_training_allowed) else $error(\"\");", "task_id": "3_9791", "predict_sva": "@(posedge pcie_clk_i)     $fell(link_state_recovery_i) |-> ##[1:3] link_state_train_i"}
{"id": "821_3_2796", "name": "priority_adjustment_response", "sva": "@(posedge clk_sys)     $rose(priority_change_req) |-> ##[1:2] priority_update_done", "ori_sva": "property priority_adjustment_response;\n@(posedge clk_sys)     $rose(priority_change_req) |-> ##[1:2] priority_update_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: priority_adjustment_response  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(priority_change_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] priority_update_done`  ", "sva_signals": ["clk_sys", "priority_change_req", "priority_update_done"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(priority_change_req) |-> ##[1:2] priority_update_done", "sva_name": "priority_change_prop_7", "full_property": "property priority_adjustment_response;\n@(posedge clk_sys)         $rose(priority_change_req) |-> ##[1:2] priority_update_done\nendproperty\nassert_priority_adjustment_response:assert property (priority_adjustment_response) else $error(\"\");", "task_id": "3_10096", "predict_sva": "@(posedge clk_sys)         $rose(priority_change_req) |-> ##[1:2] priority_update_done"}
{"id": "812_10_2711", "name": "p_no_backpressure_during_switch", "sva": "@(posedge clk_axi)     dec_mode_switch_active |-> ##[0:2] !data_fifo_backpressure", "ori_sva": "property p_no_backpressure_during_switch;\n@(posedge clk_axi)     dec_mode_switch_active |-> ##[0:2] !data_fifo_backpressure\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_backpressure_during_switch  \n**Trigger Condition**: At every rising edge of the `clk_axi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dec_mode_switch_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] !data_fifo_backpressure`  ", "sva_signals": ["clk_axi", "dec_mode_switch_active", "data_fifo_backpressure"], "clock": "clk_axi", "attempts_left": 10, "sva_result": "@(posedge clk_axi)         dec_mode_switch_active == 1'b1 |-> ##[0:2] !data_fifo_backpressure", "sva_name": "data_path_no_backpressure_during_switch", "full_property": "property p_no_backpressure_during_switch;\n@(posedge clk_axi)         dec_mode_switch_active == 1'b1 |-> ##[0:2] !data_fifo_backpressure\nendproperty\nassert_p_no_backpressure_during_switch:assert property (p_no_backpressure_during_switch) else $error(\"\");", "task_id": "3_10014", "predict_sva": "@(posedge clk_axi)     dec_mode_switch_active == 1'b1 |-> ##[0:2] !data_fifo_backpressure"}
{"id": "816_15_2786", "name": "address_bus_stable_during_switch", "sva": "@(posedge ddr_clk)     rank_switch_ack_ |-> $stable(address_bus_)", "ori_sva": "property address_bus_stable_during_switch;\n@(posedge ddr_clk)     rank_switch_ack_ |-> $stable(address_bus_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: address_bus_stable_during_switch  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rank_switch_ack_` is true (1'b1)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `address_bus_` remains stable (i.e., does not change from its previous value)", "sva_signals": ["ddr_clk", "[0:0] rank_switch_ack_", "[0:0] address_bus_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> $stable(address_bus_)", "sva_name": "address_stable_during_switch", "full_property": "property address_bus_stable_during_switch;\n@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> $stable(address_bus_)\nendproperty\nassert_address_bus_stable_during_switch:assert property (address_bus_stable_during_switch) else $error(\"\");", "task_id": "3_10049", "predict_sva": "@(posedge ddr_clk)         rank_switch_ack_ == 1'b1 |-> $stable(address_bus_)"}
{"id": "819_10_2810", "name": "p_mixed_op_complete", "sva": "@(posedge clk_core)     $rose(calc_active) |-> ##[1:100] $fell(calc_active)", "ori_sva": "property p_mixed_op_complete;\n@(posedge clk_core)     $rose(calc_active) |-> ##[1:100] $fell(calc_active);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mixed_op_complete  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(calc_active)` (a rising edge occurs on `calc_active`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] $fell(calc_active)` (within 1 to 100 clock cycles after the antecedent, a falling edge occurs on `calc_active`)", "sva_signals": ["clk", "rst_n", "[0:0] calc_active", "clk_core"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(calc_active) |-> ##[1:100] $fell(calc_active)", "sva_name": "p_calc_active_fall_after_rise", "full_property": "property p_mixed_op_complete;\n@(posedge clk_core)         $rose(calc_active) |-> ##[1:100] $fell(calc_active)\nendproperty\nassert_p_mixed_op_complete:assert property (p_mixed_op_complete) else $error(\"\");", "task_id": "3_10077", "predict_sva": "@(posedge clk_core)     $rose(calc_active) |-> ##[1:100] $fell(calc_active)"}
{"id": "462_1_1332", "name": "p_sync_fall_to_stable_gmtime", "sva": "@(posedge clk_sys)     $fell(sync_request) |-> ##1 !clock_adjust throughout      (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset))", "ori_sva": "property p_sync_fall_to_stable_gmtime;\n@(posedge clk_sys)     $fell(sync_request) |-> ##1 !clock_adjust throughout      (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_request_fall  \n**Trigger Condition**: At every posedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(sync_request)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`##1 !clock_adjust throughout (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset))`  \n\n**Explanation of Consequent**:  \n1. **Initial Delay**: After the antecedent is true (`$fell(sync_request)`), the consequent starts **1 clock cycle later (`##1`)** with the condition `!clock_adjust` (clock adjustment must be disabled).  \n2. **Temporal Sequence**:  \n   - **Stable GM Time**: Within **1 to 5 clock cycles** (`##[1:5]`), the global time (`gm_time[63:0]`) must remain stable (`$stable`).  \n   - **Sync Acknowledge**: After the stable GM time, within **10 to 100 clock cycles** (`##[10:100]`), a rising edge on `sync_ack` must occur (`$rose(sync_ack)`).  \n   - **Stable Clock Offset**: **Immediately** after `sync_ack` rises (`##0`), the `clock_offset` must remain stable (`$stable`).  \n3. **Throughout Constraint**: The condition `!clock_adjust` must hold **continuously** from **1 cycle after the antecedent** until the **entire temporal sequence completes**.  \n\n**Key Notes**:  \n- The assertion ensures that when `sync_request` falls, clock adjustment is disabled, followed by a specific sequence of events (stable time, acknowledgment, and stable offset).  \n- The `throughout` operator enforces that `!clock_adjust` remains true during the entire sequence.", "sva_signals": ["clk_sys", "sync_request", "clock_adjust", "gm_time[63:0]", "sync_ack", "clock_offset"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(sync_request) |->      ##1 (!clock_adjust) throughout (         ##[1:5] $stable(gm_time[63:0])          ##[10:100] $rose(sync_ack)          ##0 $stable(clock_offset)     )", "sva_name": "p_Sync_Request_Fell_Check", "full_property": "property p_sync_request_fall;\n@(posedge clk_sys)     $fell(sync_request) |->      ##1 (!clock_adjust) throughout (         ##[1:5] $stable(gm_time[63:0])          ##[10:100] $rose(sync_ack)          ##0 $stable(clock_offset)     )\nendproperty\nassert_p_sync_request_fall:assert property (p_sync_request_fall) else $error(\"\");", "task_id": "3_8373", "predict_sva": "@(posedge clk_sys)     $fell(sync_request) |->      ##1 (!clock_adjust throughout (         ##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##1 $stable(clock_offset)     ))"}
{"id": "829_5_2897", "name": "spi_slave_data_hold_after_error", "sva": "@(posedge spi_clk)     ($rose(spi_crc_error) && spi_cs_active) |-> spi_miso_data_stable[*4]", "ori_sva": "property spi_slave_data_hold_after_error;\n@(posedge spi_clk)     ($rose(spi_crc_error) && spi_cs_active) |-> spi_miso_data_stable[*4];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: spi_slave_data_hold_after_error  \n**Trigger Condition**: At every rising edge of the `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(spi_crc_error) && spi_cs_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `spi_miso_data_stable[*4]` (spi_miso_data_stable must hold true for 4 consecutive clock cycles)", "sva_signals": ["spi_clk", "spi_cs_active", "[0:0] spi_crc_error", "spi_miso_data_stable"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     ($rose(spi_crc_error) && spi_cs_active) |-> spi_miso_data_stable[*4]", "sva_name": "spi_slave_error_handling", "full_property": "property spi_slave_data_hold_after_error;\n@(posedge spi_clk)     ($rose(spi_crc_error) && spi_cs_active) |-> spi_miso_data_stable[*4]\nendproperty\nassert_spi_slave_data_hold_after_error:assert property (spi_slave_data_hold_after_error) else $error(\"\");", "task_id": "3_10174", "predict_sva": "@(posedge spi_clk)     ($rose(spi_crc_error) && spi_cs_active) |-> spi_miso_data_stable[*4]"}
{"id": "823_7_2832", "name": "stop_condition_reset", "sva": "@(posedge i2c_clk)     $rose(i2c_stop) |-> ##1 !i2c_busy", "ori_sva": "property stop_condition_reset;\n@(posedge i2c_clk)     $rose(i2c_stop) |-> ##1 !i2c_busy;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stop_condition_reset  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(i2c_stop)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !i2c_busy`", "sva_signals": ["i2c_clk", "i2c_stop", "[0:0] i2c_busy"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)         $rose(i2c_stop) |-> ##1 !i2c_busy", "sva_name": "p_i2c_stop_not_busy_next_cycle", "full_property": "property stop_condition_reset;\n@(posedge i2c_clk)         $rose(i2c_stop) |-> ##1 !i2c_busy\nendproperty\nassert_stop_condition_reset:assert property (stop_condition_reset) else $error(\"\");", "task_id": "3_10120", "predict_sva": "@(posedge i2c_clk)         $rose(i2c_stop) |-> ##1 !i2c_busy"}
{"id": "833_12_2956", "name": "ulps_exit_sequence", "sva": "@(posedge mipi_clk)     $fell(ulps_active) |-> ##8 !lp11_state && !hs_mode", "ori_sva": "property ulps_exit_sequence;\n@(posedge mipi_clk)     $fell(ulps_active) |-> ##8 !lp11_state && !hs_mode;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ulps_exit_sequence  \n**Trigger Condition**: At every rising edge of `mipi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(ulps_active)` (a falling edge on `ulps_active`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 !lp11_state && !hs_mode` (after 8 clock cycles, `lp11_state` is low and `hs_mode` is low)", "sva_signals": ["mipi_clk", "ulps_active", "lp11_state", "hs_mode"], "clock": "mipi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_clk)     $fell(ulps_active) |-> ##8 (!lp11_state && !hs_mode)", "sva_name": "ulps_exit_protocol", "full_property": "property ulps_exit_sequence;\n@(posedge mipi_clk)     $fell(ulps_active) |-> ##8 (!lp11_state && !hs_mode)\nendproperty\nassert_ulps_exit_sequence:assert property (ulps_exit_sequence) else $error(\"\");", "task_id": "3_10207", "predict_sva": "@(posedge mipi_clk)     $fell(ulps_active) |-> ##8 (!lp11_state && !hs_mode)"}
{"id": "830_8_2944", "name": "slave_mosi_safe_after_reset", "sva": "@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:4] slave_mosi == 1'b0", "ori_sva": "property slave_mosi_safe_after_reset;\n@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:4] slave_mosi == 1'b0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: slave_mosi_safe_after_reset  \n**Trigger Condition**: At every rising edge of the `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(master_reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] slave_mosi == 1'b0`  ", "sva_signals": ["spi_clk", "master_reset_n", "[0:0] slave_mosi"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:4] slave_mosi == 1'b0", "sva_name": "slave_no_response_during_master_reset", "full_property": "property slave_mosi_safe_after_reset;\n@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:4] slave_mosi == 1'b0\nendproperty\nassert_slave_mosi_safe_after_reset:assert property (slave_mosi_safe_after_reset) else $error(\"\");", "task_id": "3_10187", "predict_sva": "@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:4] (slave_mosi == 1'b0)"}
{"id": "836_11_3000", "name": "bank_precharge_completion", "sva": "@(posedge ddr_clk)     $rose(precharge_cmd_) |-> ##[1:8] $fell(bank_active_)", "ori_sva": "property bank_precharge_completion;\n@(posedge ddr_clk)     $rose(precharge_cmd_) |-> ##[1:8] $fell(bank_active_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bank_precharge_completion  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(precharge_cmd_)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] $fell(bank_active_)`  ", "sva_signals": ["ddr_clk", "precharge_cmd_", "bank_active_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         $rose(precharge_cmd_) |-> ##[1:8] $fell(bank_active_)", "sva_name": "precharge_timing_constraint", "full_property": "property bank_precharge_completion;\n@(posedge ddr_clk)         $rose(precharge_cmd_) |-> ##[1:8] $fell(bank_active_)\nendproperty\nassert_bank_precharge_completion:assert property (bank_precharge_completion) else $error(\"\");", "task_id": "3_10238", "predict_sva": "@(posedge ddr_clk)         $rose(precharge_cmd_) |-> ##[1:8] $fell(bank_active_)"}
{"id": "741_2_1959", "name": "no_frame_end_without_sync", "sva": "@(posedge clk_signal)     frame_end |=> !sync_pulse until sync_pulse", "ori_sva": "property no_frame_end_without_sync;\n@(posedge clk_signal)     frame_end |=> !sync_pulse until sync_pulse;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_frame_end_without_sync  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_end`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!sync_pulse until sync_pulse`  ", "sva_signals": ["clk_signal", "[0:0] frame_end", "[0:0] sync_pulse"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     frame_end |=> !sync_pulse until sync_pulse", "sva_name": "p_Frame_End_Sync_Pulse", "full_property": "property no_frame_end_without_sync;\n@(posedge clk_signal)     frame_end |=> !sync_pulse until sync_pulse\nendproperty\nassert_no_frame_end_without_sync:assert property (no_frame_end_without_sync) else $error(\"\");", "task_id": "3_9501", "predict_sva": "@(posedge clk_signal)    frame_end |-> !sync_pulse until_with !sync_pulse[->1]"}
{"id": "823_3_2859", "name": "stretch_recovery", "sva": "@(posedge i2c_clk)     $rose(i2c_scl_stretch) ##[1:16] $fell(i2c_scl_stretch) |-> ##1 i2c_scl_normal", "ori_sva": "property stretch_recovery;\n@(posedge i2c_clk)     $rose(i2c_scl_stretch) ##[1:16] $fell(i2c_scl_stretch) |-> ##1 i2c_scl_normal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stretch_recovery  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(i2c_scl_stretch) ##[1:16] $fell(i2c_scl_stretch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 i2c_scl_normal`  ", "sva_signals": ["i2c_clk", "i2c_scl_stretch", "i2c_scl_normal"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     $rose(i2c_scl_stretch) ##[1:16] $fell(i2c_scl_stretch) |-> ##1 i2c_scl_normal", "sva_name": "clock_stretch_limit", "full_property": "property stretch_recovery;\n@(posedge i2c_clk)     $rose(i2c_scl_stretch) ##[1:16] $fell(i2c_scl_stretch) |-> ##1 i2c_scl_normal\nendproperty\nassert_stretch_recovery:assert property (stretch_recovery) else $error(\"\");", "task_id": "3_10116", "predict_sva": "@(posedge i2c_clk)     $rose(i2c_scl_stretch) |-> ##[1:16] $fell(i2c_scl_stretch) ##1 i2c_scl_normal"}
{"id": "836_14_2989", "name": "read_modify_write_sequence", "sva": "@(posedge ddr_clk)     (rmw_cmd_ && rd_data_valid_) |=> ##[1:4] wr_cmd_valid_", "ori_sva": "property read_modify_write_sequence;\n@(posedge ddr_clk)     (rmw_cmd_ && rd_data_valid_) |=> ##[1:4] wr_cmd_valid_;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: read_modify_write_sequence  \n**Trigger Condition**: At every rising edge of `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rmw_cmd_ && rd_data_valid_`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:4] wr_cmd_valid_`  ", "sva_signals": ["ddr_clk", "[0:0] rmw_cmd_", "[0:0] rd_data_valid_", "[0:0] wr_cmd_valid_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         (rmw_cmd_ && rd_data_valid_) |=> ##[1:4] wr_cmd_valid_", "sva_name": "read_modify_write_sequence", "full_property": "property read_modify_write_sequence;\n@(posedge ddr_clk)         (rmw_cmd_ && rd_data_valid_) |=> ##[1:4] wr_cmd_valid_\nendproperty\nassert_read_modify_write_sequence:assert property (read_modify_write_sequence) else $error(\"\");", "task_id": "3_10240", "predict_sva": "@(posedge ddr_clk)         (rmw_cmd_ && rd_data_valid_) |-> ##[1:4] wr_cmd_valid_"}
{"id": "838_10_3015", "name": "ecc_error_counter_increments", "sva": "@(posedge ecc_clk)     $rose(ecc_error_detected) |-> ecc_error_count == $past(ecc_error_count) + 1", "ori_sva": "property ecc_error_counter_increments;\n@(posedge ecc_clk)     $rose(ecc_error_detected) |-> ecc_error_count == $past(ecc_error_count) + 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_error_counter_increments  \n**Trigger Condition**: At every rising edge of the `ecc_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ecc_error_detected)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecc_error_count == $past(ecc_error_count) + 1`", "sva_signals": ["ecc_clk", "ecc_error_detected", "[0:0] ecc_error_count"], "clock": "ecc_clk", "attempts_left": 10, "sva_result": "@(posedge ecc_clk)         $rose(ecc_error_detected) |-> ecc_error_count == ($past(ecc_error_count) + 1)", "sva_name": "ecc_error_counter_increment", "full_property": "property ecc_error_counter_increments;\n@(posedge ecc_clk)         $rose(ecc_error_detected) |-> ecc_error_count == ($past(ecc_error_count) + 1)\nendproperty\nassert_ecc_error_counter_increments:assert property (ecc_error_counter_increments) else $error(\"\");", "task_id": "3_10264", "predict_sva": "@(posedge ecc_clk)         $rose(ecc_error_detected) |-> (ecc_error_count == $past(ecc_error_count) + 1)"}
{"id": "456_4_1292", "name": "pwr_gating_seq_4", "sva": "@(posedge clk_signal)     $fell(power_down_req) |-> ##1 (!isolation_en) throughout (clk_gate[->2] ##[3:10] $stable(retention_regs) ##1 $rose(power_ok))", "ori_sva": "property pwr_gating_seq_4;\n@(posedge clk_signal)     $fell(power_down_req) |-> ##1 (!isolation_en) throughout (clk_gate[->2] ##[3:10] $stable(retention_regs) ##1 $rose(power_ok));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Down_Req_Fell  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(power_down_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 1 clock cycle (`##1`), the following sequence must hold:  \n  1. `!isolation_en` must remain true **throughout** the entire subsequent sequence.  \n  2. `clk_gate` must go high twice (`clk_gate[->2]`), with any number of cycles between the two occurrences.  \n  3. After the second occurrence of `clk_gate`, within 3 to 10 clock cycles (`##[3:10]`), `retention_regs` must remain stable (`$stable(retention_regs)`).  \n  4. Finally, after the stability of `retention_regs`, `power_ok` must rise (`$rose(power_ok)`) in the next clock cycle (`##1`).  \n\n### Notes:  \n- The `throughout` operator ensures `!isolation_en` holds continuously from the cycle after `$fell(power_down_req)` until the end of the sequence.  \n- The `[->2]` goto repetition specifies that `clk_gate` must be high twice, with arbitrary delays between occurrences.  \n- The `##[3:10]` range allows flexibility in the timing between `clk_gate[->2]` and `$stable(retention_regs)`.  \n- The sequence concludes with `$rose(power_ok)` one cycle after `retention_regs` stability.", "sva_signals": ["clk_signal", "power_down_req", "isolation_en", "clk_gate", "retention_regs", "power_ok"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(power_down_req) |->      (##1 (!isolation_en throughout          (clk_gate[->2] ##[3:10] $stable(retention_regs) ##1 $rose(power_ok))))", "sva_name": "p_power_down_sequence", "full_property": "property p_Power_Down_Req_Fell;\n@(posedge clk_signal)     $fell(power_down_req) |->      (##1 (!isolation_en throughout          (clk_gate[->2] ##[3:10] $stable(retention_regs) ##1 $rose(power_ok))))\nendproperty\nassert_p_Power_Down_Req_Fell:assert property (p_Power_Down_Req_Fell) else $error(\"\");", "task_id": "3_8348", "predict_sva": "@(posedge clk_signal)    $fell(power_down_req) |->     (##1 !isolation_en throughout (clk_gate[->2] ##[3:10] $stable(retention_regs)))     ##1 $rose(power_ok)"}
{"id": "855_10_3232", "name": "proper_disconnect_sequence", "sva": "@(posedge wifi_clk)     $fell(wifi_connected) |-> ##[1:5] $fell(wifi_link_status)", "ori_sva": "property proper_disconnect_sequence;\n@(posedge wifi_clk)     $fell(wifi_connected) |-> ##[1:5] $fell(wifi_link_status);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: proper_disconnect_sequence  \n**Trigger Condition**: At every rising edge of the `wifi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(wifi_connected)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $fell(wifi_link_status)`  ", "sva_signals": ["wifi_clk", "wifi_connected", "[0:0] wifi_link_status"], "clock": "wifi_clk", "attempts_left": 10, "sva_result": "@(posedge wifi_clk)     $fell(wifi_connected) |-> ##[1:5] $fell(wifi_link_status)", "sva_name": "link_down_propagate", "full_property": "property proper_disconnect_sequence;\n@(posedge wifi_clk)     $fell(wifi_connected) |-> ##[1:5] $fell(wifi_link_status)\nendproperty\nassert_proper_disconnect_sequence:assert property (proper_disconnect_sequence) else $error(\"\");", "task_id": "3_10434", "predict_sva": "@(posedge wifi_clk)     $fell(wifi_connected) |-> ##[1:5] $fell(wifi_link_status)"}
{"id": "841_13_3076", "name": "no_write_channel_deadlock", "sva": "@(posedge axi_clk)     aw_valid_i && !aw_ready_i |-> ##[1:$] aw_ready_i or !aw_valid_i", "ori_sva": "property no_write_channel_deadlock;\n@(posedge axi_clk)     aw_valid_i && !aw_ready_i |-> ##[1:$] aw_ready_i or !aw_valid_i;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: no_write_channel_deadlock  \n**Trigger Condition**: At every rising edge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `aw_valid_i && !aw_ready_i`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:$] aw_ready_i or !aw_valid_i`  ", "sva_signals": ["axi_clk", "aw_valid_i", "aw_ready_i"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |-> ##[1:$] (aw_ready_i || !aw_valid_i)", "sva_name": "p_no_write_channel_deadlock", "full_property": "property no_write_channel_deadlock;\n@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |-> ##[1:$] (aw_ready_i || !aw_valid_i)\nendproperty\nassert_no_write_channel_deadlock:assert property (no_write_channel_deadlock) else $error(\"\");", "task_id": "3_10299", "predict_sva": "@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |-> ##[0:$] (aw_ready_i || !aw_valid_i)"}
{"id": "852_7_3229", "name": "lane_skew_compensation", "sva": "@(posedge serdes_clk)     $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)", "ori_sva": "property lane_skew_compensation;\n@(posedge serdes_clk)     $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: lane_skew_compensation  \n**Trigger Condition**: At every posedge of the `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(lane_sync_done)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:10] (lane_skew < max_skew_threshold)`  ", "sva_signals": ["serdes_clk", "lane_sync_done", "[0:0] lane_skew", "[0:0] max_skew_threshold"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)         $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)", "sva_name": "lane_skew_check", "full_property": "property lane_skew_compensation;\n@(posedge serdes_clk)         $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)\nendproperty\nassert_lane_skew_compensation:assert property (lane_skew_compensation) else $error(\"\");", "task_id": "3_10413", "predict_sva": "@(posedge serdes_clk)     $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)"}
{"id": "840_6_3060", "name": "data_valid_after_pwr_up", "sva": "@(posedge ddr_clk)     $fell(ddr_pwr_down) |-> ##[10:100] ddr_data_valid", "ori_sva": "property data_valid_after_pwr_up;\n@(posedge ddr_clk)     $fell(ddr_pwr_down) |-> ##[10:100] ddr_data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_valid_after_pwr_up  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(ddr_pwr_down)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:100] ddr_data_valid`  ", "sva_signals": ["ddr_clk", "ddr_pwr_down", "[0:0] ddr_data_valid"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)     $fell(ddr_pwr_down) |-> ##[10:100] ddr_data_valid", "sva_name": "data_valid_after_power_up", "full_property": "property data_valid_after_pwr_up;\n@(posedge ddr_clk)     $fell(ddr_pwr_down) |-> ##[10:100] ddr_data_valid\nendproperty\nassert_data_valid_after_pwr_up:assert property (data_valid_after_pwr_up) else $error(\"\");", "task_id": "3_10292", "predict_sva": "@(posedge ddr_clk)     $fell(ddr_pwr_down) |-> ##[10:100] ddr_data_valid"}
{"id": "850_15_3177", "name": "rx_termination_adjustment", "sva": "@(posedge serdes_clk)     $rose(impedance_mismatch) |-> ##[1:10] $rose(rx_term_adjust)", "ori_sva": "property rx_termination_adjustment;\n@(posedge serdes_clk)     $rose(impedance_mismatch) |-> ##[1:10] $rose(rx_term_adjust);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: rx_termination_adjustment  \n**Trigger Condition**: At every rising edge of the `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(impedance_mismatch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] $rose(rx_term_adjust)`  ", "sva_signals": ["serdes_clk", "impedance_mismatch", "rx_term_adjust"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)         $rose(impedance_mismatch) |-> ##[1:10] $rose(rx_term_adjust)", "sva_name": "p_rx_term_adjust_after_impedance_mismatch", "full_property": "property rx_termination_adjustment;\n@(posedge serdes_clk)         $rose(impedance_mismatch) |-> ##[1:10] $rose(rx_term_adjust)\nendproperty\nassert_rx_termination_adjustment:assert property (rx_termination_adjustment) else $error(\"\");", "task_id": "3_10386", "predict_sva": "@(posedge serdes_clk)     $rose(impedance_mismatch) |-> ##[1:10] $rose(rx_term_adjust)"}
{"id": "865_7_3378", "name": "usb_pid_sequence_valid", "sva": "@(posedge usb_clk)     (usb_pid_valid) |-> (usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL})", "ori_sva": "property usb_pid_sequence_valid;\n@(posedge usb_clk)     (usb_pid_valid) |-> (usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_pid_sequence_valid  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_pid_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}`", "sva_signals": ["usb_clk", "usb_pid_valid", "[3:0] usb_pid_type", "DATA0", "DATA1", "ACK", "NAK", "STALL"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_pid_valid == 1'b1 |-> usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}", "sva_name": "usb_packet_id_check", "full_property": "property usb_pid_sequence_valid;\n@(posedge usb_clk)     usb_pid_valid == 1'b1 |-> usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}\nendproperty\nassert_usb_pid_sequence_valid:assert property (usb_pid_sequence_valid) else $error(\"\");", "task_id": "3_10544", "predict_sva": "@(posedge usb_clk)     usb_pid_valid == 1'b1 |-> usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}"}
{"id": "872_7_3466", "name": "multicast_filtering", "sva": "@(posedge eth_clk)     (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop", "ori_sva": "property multicast_filtering;\n@(posedge eth_clk)     (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: multicast_filtering  \n**Trigger Condition**: At every rising edge of the `eth_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `pkt_drop`  ", "sva_signals": ["eth_clk", "eth_pkt_valid", "eth_pkt_multicast", "multicast_group_enabled", "[0:0] pkt_drop"], "clock": "eth_clk", "attempts_left": 10, "sva_result": "@(posedge eth_clk)         (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop", "sva_name": "multicast_filtering", "full_property": "property multicast_filtering;\n@(posedge eth_clk)         (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop\nendproperty\nassert_multicast_filtering:assert property (multicast_filtering) else $error(\"\");", "task_id": "3_10615", "predict_sva": "@(posedge eth_clk)         (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |-> eth_pkt_drop"}
{"id": "867_20_3407", "name": "error_frame_length", "sva": "@(posedge can_clk)     $rose(can_error_flag_detected) |-> ##[6:12] $fell(can_error_flag_detected)", "ori_sva": "property error_frame_length;\n@(posedge can_clk)     $rose(can_error_flag_detected) |-> ##[6:12] $fell(can_error_flag_detected);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: error_frame_length  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(can_error_flag_detected)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[6:12] $fell(can_error_flag_detected)`  ", "sva_signals": ["can_clk", "can_error_flag_detected"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         $rose(can_error_flag_detected) |-> ##[6:12] $fell(can_error_flag_detected)", "sva_name": "error_flag_clearance_time", "full_property": "property error_frame_length;\n@(posedge can_clk)         $rose(can_error_flag_detected) |-> ##[6:12] $fell(can_error_flag_detected)\nendproperty\nassert_error_frame_length:assert property (error_frame_length) else $error(\"\");", "task_id": "3_10568", "predict_sva": "@(posedge can_clk)     $rose(can_error_flag_detected) |-> ##[6:12] $fell(can_error_flag_detected)"}
{"id": "860_12_3294", "name": "spi_data_phase_alignment", "sva": "@(posedge mcu_clk)     spi_cs_o && $changed(spi_mosi_o) |-> ##[0:1] !$changed(spi_sck_o)", "ori_sva": "property spi_data_phase_alignment;\n@(posedge mcu_clk)     spi_cs_o && $changed(spi_mosi_o) |-> ##[0:1] !$changed(spi_sck_o);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: spi_data_phase_alignment  \n**Trigger Condition**: At every rising edge of `mcu_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `spi_cs_o && $changed(spi_mosi_o)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:1] !$changed(spi_sck_o)`  ", "sva_signals": ["mcu_clk", "[0:0] spi_cs_o", "[0:0] spi_mosi_o", "[0:0] spi_sck_o"], "clock": "mcu_clk", "attempts_left": 10, "sva_result": "@(posedge mcu_clk)     (spi_cs_o && $changed(spi_mosi_o)) |-> ##[0:1] !$changed(spi_sck_o)", "sva_name": "p_spi_no_glitch_during_transfer", "full_property": "property spi_data_phase_alignment;\n@(posedge mcu_clk)     (spi_cs_o && $changed(spi_mosi_o)) |-> ##[0:1] !$changed(spi_sck_o)\nendproperty\nassert_spi_data_phase_alignment:assert property (spi_data_phase_alignment) else $error(\"\");", "task_id": "3_10484", "predict_sva": "@(posedge mcu_clk)     (spi_cs_o && $changed(spi_mosi_o)) |-> ##[0:1] !$changed(spi_sck_o)"}
{"id": "876_10_3504", "name": "metadata_integrity", "sva": "@(posedge flash_clk)     $rose(power_good) |-> $stable(metadata_area) throughout (initialization_done == 1)", "ori_sva": "property metadata_integrity;\n@(posedge flash_clk)     $rose(power_good) |-> $stable(metadata_area) throughout (initialization_done == 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: metadata_integrity  \n**Trigger Condition**: At every rising edge of `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(power_good)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(metadata_area) throughout (initialization_done == 1)`  \n\n", "sva_signals": ["flash_clk", "power_good", "metadata_area", "[0:0] initialization_done"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         $rose(power_good) |-> $stable(metadata_area) throughout (initialization_done == 1)", "sva_name": "pwr_recovery_initialization", "full_property": "property metadata_integrity;\n@(posedge flash_clk)         $rose(power_good) |-> $stable(metadata_area) throughout (initialization_done == 1)\nendproperty\nassert_metadata_integrity:assert property (metadata_integrity) else $error(\"\");", "task_id": "3_10647", "predict_sva": "@(posedge flash_clk)     $rose(power_good) |-> $stable(metadata_area) throughout initialization_done[->1]"}
{"id": "820_4_2813", "name": "pwr_stable_after_on", "sva": "@(posedge clk_pwr)     $rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_) |-> ##[10:100] $stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_)", "ori_sva": "property pwr_stable_after_on;\n@(posedge clk_pwr)     $rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_) |-> ##[10:100] $stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pwr_stable_after_on  \n**Trigger Condition**: At every rising edge of the `clk_pwr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:100] $stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_)`  ", "sva_signals": ["clk_pwr", "[0:0] pwr_on_ack_layer1_", "[0:0] pwr_on_ack_layer2_", "[0:0] pwr_on_ack_layer3_", "[0:0] pwr_good_layer1_", "[0:0] pwr_good_layer2_", "[0:0] pwr_good_layer3_"], "clock": "clk_pwr", "attempts_left": 10, "sva_result": "@(posedge clk_pwr)     ($rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_))      |->     ##[10:100] ($stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_))", "sva_name": "p_power_sequence_36", "full_property": "property pwr_stable_after_on;\n@(posedge clk_pwr)     ($rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_))      |->     ##[10:100] ($stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_))\nendproperty\nassert_pwr_stable_after_on:assert property (pwr_stable_after_on) else $error(\"\");", "task_id": "3_10087", "predict_sva": "@(posedge clk_pwr)     ($rose(pwr_on_ack_layer1_) && $rose(pwr_on_ack_layer2_) && $rose(pwr_on_ack_layer3_))      |-> ##[10:100] ($stable(pwr_good_layer1_) && $stable(pwr_good_layer2_) && $stable(pwr_good_layer3_))"}
{"id": "859_10_3292", "name": "p_io_pad_retention", "sva": "@(posedge mcu_clk)     (io_pad_sleep_en && $fell(io_pad_sleep_en)) |-> (io_pad_state == $past(io_pad_state, 2))", "ori_sva": "property p_io_pad_retention;\n@(posedge mcu_clk)     (io_pad_sleep_en && $fell(io_pad_sleep_en)) |-> (io_pad_state == $past(io_pad_state, 2));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_io_pad_retention  \n**Trigger Condition**: At every rising edge of the `mcu_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `io_pad_sleep_en && $fell(io_pad_sleep_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `io_pad_state == $past(io_pad_state, 2)`  ", "sva_signals": ["mcu_clk", "io_pad_sleep_en", "io_pad_state"], "clock": "mcu_clk", "attempts_left": 10, "sva_result": "@(posedge mcu_clk)     (io_pad_sleep_en && $fell(io_pad_sleep_en)) |-> (io_pad_state == $past(io_pad_state, 2))", "sva_name": "p_io_pad_sleep_wakeup", "full_property": "property p_io_pad_retention;\n@(posedge mcu_clk)     (io_pad_sleep_en && $fell(io_pad_sleep_en)) |-> (io_pad_state == $past(io_pad_state, 2))\nendproperty\nassert_p_io_pad_retention:assert property (p_io_pad_retention) else $error(\"\");", "task_id": "3_10474", "predict_sva": "@(posedge mcu_clk)     ($past(io_pad_sleep_en) && !$past(io_pad_sleep_en, 1)) |-> ##2 ($past(io_pad_state, 2) == io_pad_state)"}
{"id": "834_4_2978", "name": "p_mipi_power_down_recovery", "sva": "@(posedge mipi_clk)     $rose(power_good) |-> ##[1:10] controller_ready", "ori_sva": "property p_mipi_power_down_recovery;\n@(posedge mipi_clk)     $rose(power_good) |-> ##[1:10] controller_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mipi_power_down_recovery  \n**Trigger Condition**: At every posedge of the `mipi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(power_good)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] controller_ready`  \n\nExplanation:  \nThis assertion checks that whenever there is a rising edge on the `power_good` signal (indicating power has become good), then within 1 to 10 clock cycles of the `mipi_clk`, the `controller_ready` signal must become high. The check occurs at every positive edge of `mipi_clk`.", "sva_signals": ["mipi_clk", "[0:0] power_good", "[0:0] controller_ready"], "clock": "mipi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_clk)     $rose(power_good) |-> ##[1:10] controller_ready", "sva_name": "p_power_good_to_controller_ready", "full_property": "property p_mipi_power_down_recovery;\n@(posedge mipi_clk)     $rose(power_good) |-> ##[1:10] controller_ready\nendproperty\nassert_p_mipi_power_down_recovery:assert property (p_mipi_power_down_recovery) else $error(\"\");", "task_id": "3_10221", "predict_sva": "@(posedge mipi_clk)    $rose(power_good) |-> ##[1:10] controller_ready"}
{"id": "877_1_3509", "name": "multi_plane_op_sync", "sva": "@(posedge nand_clk)     $rose(plane0_cmd_valid) |-> ##[1:4] $rose(plane1_cmd_valid)", "ori_sva": "property multi_plane_op_sync;\n@(posedge nand_clk)     $rose(plane0_cmd_valid) |-> ##[1:4] $rose(plane1_cmd_valid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: multi_plane_op_sync  \n**Trigger Condition**: At every rising edge of the `nand_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(plane0_cmd_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] $rose(plane1_cmd_valid)`  ", "sva_signals": ["nand_clk", "plane0_cmd_valid", "plane1_cmd_valid"], "clock": "nand_clk", "attempts_left": 10, "sva_result": "@(posedge nand_clk)     $rose(plane0_cmd_valid) |-> ##[1:4] $rose(plane1_cmd_valid)", "sva_name": "multi_plane_sync", "full_property": "property multi_plane_op_sync;\n@(posedge nand_clk)     $rose(plane0_cmd_valid) |-> ##[1:4] $rose(plane1_cmd_valid)\nendproperty\nassert_multi_plane_op_sync:assert property (multi_plane_op_sync) else $error(\"\");", "task_id": "3_10662", "predict_sva": "@(posedge nand_clk)     $rose(plane0_cmd_valid) |-> ##[1:4] $rose(plane1_cmd_valid)"}
{"id": "866_2_3383", "name": "handshake_timeout_recovery", "sva": "@(posedge usb_clk)     (usb_handshake_timeout && $past(usb_tx_active, 2)) |=> ##[1:8] usb_handshake_retry", "ori_sva": "property handshake_timeout_recovery;\n@(posedge usb_clk)     (usb_handshake_timeout && $past(usb_tx_active, 2)) |=> ##[1:8] usb_handshake_retry;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: handshake_timeout_recovery  \n**Trigger Condition**: At every rising edge of `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_handshake_timeout && $past(usb_tx_active, 2)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:8] usb_handshake_retry`  ", "sva_signals": ["usb_clk", "usb_handshake_timeout", "usb_tx_active", "usb_handshake_retry"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)         (usb_handshake_timeout && $past(usb_tx_active, 2)) |=> ##[1:8] usb_handshake_retry", "sva_name": "usb_handshake_retry_mechanism", "full_property": "property handshake_timeout_recovery;\n@(posedge usb_clk)         (usb_handshake_timeout && $past(usb_tx_active, 2)) |=> ##[1:8] usb_handshake_retry\nendproperty\nassert_handshake_timeout_recovery:assert property (handshake_timeout_recovery) else $error(\"\");", "task_id": "3_10550", "predict_sva": "@(posedge usb_clk)     (usb_handshake_timeout && $past(usb_tx_active, 2)) |-> ##[1:8] usb_handshake_retry"}
{"id": "877_12_3513", "name": "address_cycle_count", "sva": "@(posedge nand_clk)     $rose(addr_latch_en) |-> ##[4:6] $fell(addr_latch_en)", "ori_sva": "property address_cycle_count;\n@(posedge nand_clk)     $rose(addr_latch_en) |-> ##[4:6] $fell(addr_latch_en);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: address_cycle_count  \n**Trigger Condition**: At every rising edge of the `nand_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(addr_latch_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:6] $fell(addr_latch_en)`  ", "sva_signals": ["nand_clk", "addr_latch_en"], "clock": "nand_clk", "attempts_left": 10, "sva_result": "@(posedge nand_clk)         $rose(addr_latch_en) |-> ##[4:6] $fell(addr_latch_en)", "sva_name": "p_addr_latch_pulse_width", "full_property": "property address_cycle_count;\n@(posedge nand_clk)         $rose(addr_latch_en) |-> ##[4:6] $fell(addr_latch_en)\nendproperty\nassert_address_cycle_count:assert property (address_cycle_count) else $error(\"\");", "task_id": "3_10658", "predict_sva": "@(posedge nand_clk)     $rose(addr_latch_en) |-> ##[4:6] $fell(addr_latch_en)"}
{"id": "883_8_3606", "name": "p_cable_flip_cc_change", "sva": "@(posedge pd_clk)     $rose(cable_flipped) |-> ##[1:5] (cc1_state != cc2_state)", "ori_sva": "property p_cable_flip_cc_change;\n@(posedge pd_clk)     $rose(cable_flipped) |-> ##[1:5] (cc1_state != cc2_state);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cable_flip_cc_change  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cable_flipped)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] (cc1_state != cc2_state)`  ", "sva_signals": ["pd_clk", "cable_flipped", "cc1_state", "cc2_state"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)         $rose(cable_flipped) |-> ##[1:5] (cc1_state != cc2_state)", "sva_name": "cc_line_flip_detect", "full_property": "property p_cable_flip_cc_change;\n@(posedge pd_clk)         $rose(cable_flipped) |-> ##[1:5] (cc1_state != cc2_state)\nendproperty\nassert_p_cable_flip_cc_change:assert property (p_cable_flip_cc_change) else $error(\"\");", "task_id": "3_10740", "predict_sva": "@(posedge pd_clk)     $rose(cable_flipped) |-> ##[1:5] (cc1_state != cc2_state)"}
{"id": "884_4_3632", "name": "overcurrent_recovery", "sva": "@(posedge pd_clk)     $fell(overcurrent_detected) |=> ##[1:5] $rose(normal_current_mode)", "ori_sva": "property overcurrent_recovery;\n@(posedge pd_clk)     $fell(overcurrent_detected) |=> ##[1:5] $rose(normal_current_mode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: overcurrent_recovery  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(overcurrent_detected)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:5] $rose(normal_current_mode)`  ", "sva_signals": ["pd_clk", "overcurrent_detected", "normal_current_mode"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     $fell(overcurrent_detected) |=> ##[1:5] $rose(normal_current_mode)", "sva_name": "overcurrent_recovery", "full_property": "property overcurrent_recovery;\n@(posedge pd_clk)     $fell(overcurrent_detected) |=> ##[1:5] $rose(normal_current_mode)\nendproperty\nassert_overcurrent_recovery:assert property (overcurrent_recovery) else $error(\"\");", "task_id": "3_10748", "predict_sva": "@(posedge pd_clk)     $fell(overcurrent_detected) |-> ##[1:5] $rose(normal_current_mode)"}
{"id": "841_2_3065", "name": "aw_stable_until_handshake", "sva": "@(posedge axi_clk)     aw_valid_i && !aw_ready_i |=> $stable(aw_addr_i) && $stable(aw_id_i) && $stable(aw_len_i)", "ori_sva": "property aw_stable_until_handshake;\n@(posedge axi_clk)     aw_valid_i && !aw_ready_i |=> $stable(aw_addr_i) && $stable(aw_id_i) && $stable(aw_len_i);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: aw_stable_until_handshake  \n**Trigger Condition**: At every rising edge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `aw_valid_i && !aw_ready_i`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(aw_addr_i) && $stable(aw_id_i) && $stable(aw_len_i)`  ", "sva_signals": ["axi_clk", "aw_valid_i", "aw_ready_i", "aw_addr_i", "aw_id_i", "aw_len_i"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |=> ($stable(aw_addr_i) && $stable(aw_id_i) && $stable(aw_len_i))", "sva_name": "aw_channel_stable_before_handshake", "full_property": "property aw_stable_until_handshake;\n@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |=> ($stable(aw_addr_i) && $stable(aw_id_i) && $stable(aw_len_i))\nendproperty\nassert_aw_stable_until_handshake:assert property (aw_stable_until_handshake) else $error(\"\");", "task_id": "3_10308", "predict_sva": "@(posedge axi_clk)     (aw_valid_i && !aw_ready_i) |-> $stable({aw_addr_i, aw_id_i, aw_len_i})"}
{"id": "885_14_3630", "name": "mode_switch_interrupt", "sva": "@(posedge pd_clk)     $changed(alt_mode_active_) |-> ##[0:1] intr_alt_mode_change_", "ori_sva": "property mode_switch_interrupt;\n@(posedge pd_clk)     $changed(alt_mode_active_) |-> ##[0:1] intr_alt_mode_change_\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mode_switch_interrupt  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(alt_mode_active_)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:1] intr_alt_mode_change_`  ", "sva_signals": ["pd_clk", "alt_mode_active_", "[0:0] intr_alt_mode_change_"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)         $changed(alt_mode_active_) |-> ##[0:1] intr_alt_mode_change_", "sva_name": "p_alt_mode_change_intr", "full_property": "property mode_switch_interrupt;\n@(posedge pd_clk)         $changed(alt_mode_active_) |-> ##[0:1] intr_alt_mode_change_\nendproperty\nassert_mode_switch_interrupt:assert property (mode_switch_interrupt) else $error(\"\");", "task_id": "3_10756", "predict_sva": "@(posedge pd_clk)     $changed(alt_mode_active_) |-> ##[0:1] intr_alt_mode_change_"}
{"id": "898_1_3792", "name": "sim_hotplug_recovery", "sva": "@(posedge clk_core)     $rose(sim_inserted) |-> ##[1:10] sim_state == SIM_INIT", "ori_sva": "property sim_hotplug_recovery;\n@(posedge clk_core)     $rose(sim_inserted) |-> ##[1:10] sim_state == SIM_INIT\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sim_hotplug_recovery  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(sim_inserted)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] sim_state == SIM_INIT`  ", "sva_signals": ["clk_core", "[0:0] sim_inserted", "[0:0] sim_state", "[0:0] SIM_INIT"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(sim_inserted) |-> ##[1:10] sim_state == SIM_INIT", "sva_name": "sim_card_detection", "full_property": "property sim_hotplug_recovery;\n@(posedge clk_core)         $rose(sim_inserted) |-> ##[1:10] sim_state == SIM_INIT\nendproperty\nassert_sim_hotplug_recovery:assert property (sim_hotplug_recovery) else $error(\"\");", "task_id": "3_10900", "predict_sva": "@(posedge clk_core)     $rose(sim_inserted) |-> ##[1:10] (sim_state == SIM_INIT)"}
{"id": "883_10_3580", "name": "p_source_to_sink_transition", "sva": "@(posedge pd_clk)     (pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=>      ##[1:50] (pd_role == SINK_ROLE)", "ori_sva": "property p_source_to_sink_transition;\n@(posedge pd_clk)     (pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=>      ##[1:50] (pd_role == SINK_ROLE);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_source_to_sink_transition  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:50] (pd_role == SINK_ROLE)`  ", "sva_signals": ["pd_clk", "[0:0] pd_role", "[0:0] rx_packet", "[0:0] SOURCE_ROLE", "[0:0] SINK_ROLE", "[0:0] PD_CTRL_PR_SWAP"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     (pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=> ##[1:50] (pd_role == SINK_ROLE)", "sva_name": "power_role_swap_complete", "full_property": "property p_source_to_sink_transition;\n@(posedge pd_clk)     (pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=> ##[1:50] (pd_role == SINK_ROLE)\nendproperty\nassert_p_source_to_sink_transition:assert property (p_source_to_sink_transition) else $error(\"\");", "task_id": "3_10732", "predict_sva": "@(posedge pd_clk)     ((pd_role == SOURCE_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)) |-> ##[1:50] (pd_role == SINK_ROLE)"}
{"id": "890_4_3679", "name": "p_pixel_format_consistency", "sva": "@(posedge isp_clk)     (pixel_format_in_ == pixel_format_out_) throughout (isp_busy)", "ori_sva": "property p_pixel_format_consistency;\n@(posedge isp_clk)     (pixel_format_in_ == pixel_format_out_) throughout (isp_busy);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pixel_format_consistency  \n**Trigger Condition**: At every rising edge of `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `isp_busy` is active (true)  \n**Implication Operator**: `throughout`  \n**Consequent (RHS of Implication)**: `pixel_format_in_ == pixel_format_out_` must hold continuously while `isp_busy` is active  ", "sva_signals": ["isp_clk", "pixel_format_in_", "pixel_format_out_", "isp_busy"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     isp_busy throughout (pixel_format_in_ == pixel_format_out_)", "sva_name": "p_output_format_consistency", "full_property": "property p_pixel_format_consistency;\n@(posedge isp_clk)     isp_busy throughout (pixel_format_in_ == pixel_format_out_)\nendproperty\nassert_p_pixel_format_consistency:assert property (p_pixel_format_consistency) else $error(\"\");", "task_id": "3_10819", "predict_sva": "@(posedge isp_clk)     isp_busy throughout (pixel_format_out_ == pixel_format_in_)"}
{"id": "878_9_3515", "name": "spare_block_availability", "sva": "@(posedge flash_clk)     $fell(spare_block_count) |-> spare_block_count > 0", "ori_sva": "property spare_block_availability;\n@(posedge flash_clk)     $fell(spare_block_count) |-> spare_block_count > 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: spare_block_availability  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(spare_block_count)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `spare_block_count > 0`  ", "sva_signals": ["flash_clk", "[0:0] spare_block_count"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         $fell(spare_block_count) |-> spare_block_count > 0", "sva_name": "p_spare_block_count_never_zero", "full_property": "property spare_block_availability;\n@(posedge flash_clk)         $fell(spare_block_count) |-> spare_block_count > 0\nendproperty\nassert_spare_block_availability:assert property (spare_block_availability) else $error(\"\");", "task_id": "3_10682", "predict_sva": "@(posedge flash_clk)     $fell(spare_block_count) |-> (spare_block_count > 0)"}
{"id": "844_6_3109", "name": "axi_lowpwr_sleep_all_channels_idle", "sva": "@(posedge axi_clk)     $fell(axi_pwr_ok) |-> ##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid)", "ori_sva": "property axi_lowpwr_sleep_all_channels_idle;\n@(posedge axi_clk)     $fell(axi_pwr_ok) |-> ##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: axi_lowpwr_sleep_all_channels_idle  \n**Trigger Condition**: At every rising edge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(axi_pwr_ok)` (detects a falling edge on `axi_pwr_ok`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid)` (within 2 to 5 clock cycles after the antecedent, all AXI channels (`axi_awvalid`, `axi_wvalid`, `axi_arvalid`) must be inactive (low))", "sva_signals": ["axi_clk", "[0:0] axi_pwr_ok", "[0:0] axi_awvalid", "[0:0] axi_wvalid", "[0:0] axi_arvalid"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)     $fell(axi_pwr_ok) |-> ##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid)", "sva_name": "axi_lowpwr_sleep_awake_valid", "full_property": "property axi_lowpwr_sleep_all_channels_idle;\n@(posedge axi_clk)     $fell(axi_pwr_ok) |-> ##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid)\nendproperty\nassert_axi_lowpwr_sleep_all_channels_idle:assert property (axi_lowpwr_sleep_all_channels_idle) else $error(\"\");", "task_id": "3_10341", "predict_sva": "@(posedge axi_clk)     $fell(axi_pwr_ok) |-> ##[2:5] (!axi_awvalid && !axi_wvalid && !axi_arvalid)"}
{"id": "857_6_3268", "name": "sensitive_bus_unknown_after_reset", "sva": "@(posedge clk_core)     $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)", "ori_sva": "property sensitive_bus_unknown_after_reset;\n@(posedge clk_core)     $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sensitive_bus_unknown_after_reset  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] !$isunknown(secure_bus_internal)`  ", "sva_signals": ["clk", "reset_n", "[0:0] secure_bus_internal", "clk_core"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)", "sva_name": "p_secure_bus_after_reset", "full_property": "property sensitive_bus_unknown_after_reset;\n@(posedge clk_core)         $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)\nendproperty\nassert_sensitive_bus_unknown_after_reset:assert property (sensitive_bus_unknown_after_reset) else $error(\"\");", "task_id": "3_10456", "predict_sva": "@(posedge clk_core)    $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)"}
{"id": "842_9_3081", "name": "read_data_continuity", "sva": "@(posedge axi_clk)     (axi_rvalid && !axi_rlast) |=>      axi_rvalid[*1:16] ##0 axi_rlast", "ori_sva": "property read_data_continuity;\n@(posedge axi_clk)     (axi_rvalid && !axi_rlast) |=>      axi_rvalid[*1:16] ##0 axi_rlast;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: read_data_continuity  \n**Trigger Condition**: At every rising edge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `axi_rvalid && !axi_rlast`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `axi_rvalid[*1:16] ##0 axi_rlast`  ", "sva_signals": ["axi_clk", "[0:0] axi_rvalid", "[0:0] axi_rlast"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)         (axi_rvalid && !axi_rlast) |=> (axi_rvalid[*1:16] ##0 axi_rlast)", "sva_name": "p_axi_burst_transfer_check", "full_property": "property read_data_continuity;\n@(posedge axi_clk)         (axi_rvalid && !axi_rlast) |=> (axi_rvalid[*1:16] ##0 axi_rlast)\nendproperty\nassert_read_data_continuity:assert property (read_data_continuity) else $error(\"\");", "task_id": "3_10323", "predict_sva": "@(posedge axi_clk)    (axi_rvalid && !axi_rlast) |-> axi_rvalid[*1:16] ##1 axi_rlast"}
