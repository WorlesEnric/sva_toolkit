{"id": "119_10_0884", "name": "pvt_compensation_adapt_time_non_zero", "sva": "@(posedge clk_signal)     $changed(process_mon) |-> ($past(adapt_time) > 0)", "ori_sva": "property pvt_compensation_adapt_time_non_zero;\n@(posedge clk_signal)     $changed(process_mon) |-> ($past(adapt_time) > 0);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Process_Mon_Change_Adapt_Time  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(process_mon)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(adapt_time) > 0)`  \n\n**Explanation**:  \nThis assertion checks that whenever there is a change in the `process_mon` signal (detected by `$changed`), then in the same clock cycle, the past value of `adapt_time` (from the previous clock cycle) must be greater than 0. The check occurs at every rising edge of `clk_signal` and has no disable condition.", "sva_signals": ["clk_signal", "[0:0] process_mon", "[0:0] adapt_time"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $changed(process_mon) |-> ($past(adapt_time) > 0)", "sva_name": "p_Process_Mon_Change_Adapt_Time", "full_property": "property p_Process_Mon_Change_Adapt_Time;\n@(posedge clk_signal)    $changed(process_mon) |-> ($past(adapt_time) > 0)\nendproperty\nassert_p_Process_Mon_Change_Adapt_Time:assert property (p_Process_Mon_Change_Adapt_Time) else $error(\"\");", "task_id": "1_56", "predict_sva": "@(posedge clk_signal)     $changed(process_mon) |-> $past(adapt_time) > 0"}
{"id": "120_7_0893", "name": "hold_time_violation_check", "sva": "@(posedge phase2_clk)     $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))", "ori_sva": "property hold_time_violation_check;\n@(posedge phase2_clk)     $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Data_Valid_Hold_Time  \n**Trigger Condition**: At every posedge of the `phase2_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(data_valid, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (data_in >= ($past(hold_time) >> 1))`  \n\n**Explanation**:  \nThe property checks that if `data_valid` was high in the previous clock cycle (`$past(data_valid, 1)`), then in the next clock cycle (`##1`), the value of `data_in` must be greater than or equal to half the value of `hold_time` from the previous cycle (`$past(hold_time) >> 1`). The assertion is evaluated at every rising edge of `phase2_clk` and has no disable condition.", "sva_signals": ["phase2_clk", "[0:0] data_valid", "data_in", "hold_time"], "clock": "phase2_clk", "attempts_left": 10, "sva_result": "@(posedge phase2_clk)    $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))", "sva_name": "p_data_in_hold_time_half", "full_property": "property p_Data_Valid_Hold_Time;\n@(posedge phase2_clk)    $past(data_valid, 1) |-> ##1 (data_in >= ($past(hold_time) >> 1))\nendproperty\nassert_p_Data_Valid_Hold_Time:assert property (p_Data_Valid_Hold_Time) else $error(\"\");", "task_id": "1_71", "predict_sva": "@(posedge phase2_clk)         $past(data_valid, 1) == 1 |-> ##1 data_in >= ($past(hold_time) >> 1)"}
{"id": "12_2_0092", "name": "state_unknown_check", "sva": "@(posedge clk) $isunknown(state) |-> (err_flag == 1'b1)", "ori_sva": "property state_unknown_check;\n\n    @(posedge clk) $isunknown(state) |-> (err_flag == 1'b1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Err_Flag_On_Unknown_State  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$isunknown(state)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `err_flag == 1'b1`  \n\n**Explanation**:  \nThis property checks that whenever the `state` signal contains unknown values (X or Z) at a rising clock edge, the `err_flag` must be asserted (equal to 1) in the same cycle. The assertion triggers on every clock edge and has no reset/disabling condition. The implication ensures that the error flag is raised synchronously when an unknown state is detected.", "sva_signals": ["clk", "rst_n", "[2:0] state", "[0:0] err_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $isunknown(state) |-> err_flag == 1'b1", "sva_name": "p_err_flag_on_state_unknown", "full_property": "property p_Err_Flag_On_Unknown_State;\n@(posedge clk)    $isunknown(state) |-> err_flag == 1'b1\nendproperty\nassert_p_Err_Flag_On_Unknown_State:assert property (p_Err_Flag_On_Unknown_State) else $error(\"\");", "task_id": "1_84", "predict_sva": "@(posedge clk)         $isunknown(state) |-> err_flag == 1'b1"}
{"id": "155_12_1196", "name": "interrupt_handling", "sva": "@(posedge clk)     interrupt_request |-> ##2 interrupt_ack", "ori_sva": "property interrupt_handling;\n@(posedge clk)     interrupt_request |-> ##2 interrupt_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_interrupt_ack  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `interrupt_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 interrupt_ack == 1'b1`  \n\n### Explanation:  \nThe assertion checks that whenever an `interrupt_request` is detected (antecedent), the `interrupt_ack` signal must be asserted exactly two clock cycles later (consequent). The check is performed on every rising edge of `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_request", "[0:0] interrupt_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        interrupt_request == 1'b1 |-> ##2 interrupt_ack == 1'b1", "sva_name": "p_interrupt_ack_after_request", "full_property": "property p_interrupt_ack;\n@(posedge clk)        interrupt_request == 1'b1 |-> ##2 interrupt_ack == 1'b1\nendproperty\nassert_p_interrupt_ack:assert property (p_interrupt_ack) else $error(\"\");", "task_id": "1_185", "predict_sva": "@(posedge clk)         interrupt_request == 1'b1 |-> ##2 interrupt_ack == 1'b1"}
{"id": "157_2_1203", "name": "req_ack_handshake", "sva": "@(posedge clk_signal)     disable iff (test_mode)     req_signal |-> ##[1:4] ack_signal", "ori_sva": "property req_ack_handshake;\n@(posedge clk_signal)     disable iff (test_mode)     req_signal |-> ##[1:4] ack_signal;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_req_ack_handshake  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: disable iff (test_mode)  \n**Antecedent (LHS of Implication)**: `req_signal == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] ack_signal == 1'b1`  \n\n### Explanation:\n1. The property checks that whenever `req_signal` is high (antecedent), an `ack_signal` must arrive within 1 to 4 clock cycles (consequent).\n2. The check is performed at every rising edge of `clk_signal`.\n3. The assertion is disabled when `test_mode` is active (asynchronous reset condition).\n4. The `##[1:4]` operator specifies a range of acceptable delays (1-4 clock cycles) for the acknowledgment to arrive after the request.", "sva_signals": ["clk_signal", "test_mode", "[0:0] req_signal", "[0:0] ack_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal) disable iff (test_mode)    req_signal == 1'b1 |-> ##[1:4] ack_signal == 1'b1", "sva_name": "p_req_ack_within_4_cycles", "full_property": "property p_req_ack_handshake;\n@(posedge clk_signal) disable iff (test_mode)    req_signal == 1'b1 |-> ##[1:4] ack_signal == 1'b1\nendproperty\nassert_p_req_ack_handshake:assert property (p_req_ack_handshake) else $error(\"\");", "task_id": "1_206", "predict_sva": "@(posedge clk_signal) disable iff (test_mode)         (test_mode == 0 && req_signal == 1'b1) |-> ##[1:4] ack_signal == 1'b1"}
{"id": "159_7_1263", "name": "config_reg_write", "sva": "@(posedge clk)     reg_write_en |-> ##1 (reg_addr inside {[8'h00:8'h3F]} && reg_wdata != '0)", "ori_sva": "property config_reg_write;\n@(posedge clk)     reg_write_en |-> ##1 (reg_addr inside {[8'h00:8'h3F]} && reg_wdata != '0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Reg_Write_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reg_write_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (reg_addr inside {[8'h00:8'h3F]} && reg_wdata != '0)`  \n\n### Explanation:  \n1. The property checks that when `reg_write_en` is asserted (`1'b1`), in the next clock cycle (`##1`):  \n   - The `reg_addr` must be within the range `8'h00` to `8'h3F` (inclusive).  \n   - The `reg_wdata` must not be zero (`!= '0`).  \n2. The assertion triggers on every positive edge of `clk` and has no disable condition.  \n3. The implication (`|->`) ensures the consequent is evaluated only when the antecedent (`reg_write_en`) is true.", "sva_signals": ["clk", "rst_n", "[0:0] reg_write_en", "[7:0] reg_addr", "[7:0] reg_wdata"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        reg_write_en == 1'b1 |-> ##1 (reg_addr inside {[8'h00:8'h3F]} && reg_wdata != '0)", "sva_name": "p_reg_write_addr_wdata_valid", "full_property": "property p_Reg_Write_Check;\n@(posedge clk)        reg_write_en == 1'b1 |-> ##1 (reg_addr inside {[8'h00:8'h3F]} && reg_wdata != '0)\nendproperty\nassert_p_Reg_Write_Check:assert property (p_Reg_Write_Check) else $error(\"\");", "task_id": "1_224", "predict_sva": "@(posedge clk)         reg_write_en == 1'b1 |-> ##1 (reg_addr >= 8'h00 && reg_addr <= 8'h3F) && (reg_wdata != '0)"}
{"id": "160_5_1246", "name": "write_when_not_full", "sva": "@(posedge clk)     disable iff(async_rst)     wr_en |-> !fifo_full", "ori_sva": "property write_when_not_full;\n@(posedge clk)     disable iff(async_rst)     wr_en |-> !fifo_full;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wr_en_fifo_full_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (async_rst)`  \n**Antecedent (LHS of Implication)**: `wr_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!fifo_full`  \n\n### Explanation:  \n- The property checks that whenever a write enable (`wr_en`) is asserted (high), the FIFO should not be full (`!fifo_full`).  \n- The check is performed at every rising edge of the clock (`posedge clk`).  \n- The assertion is disabled if an asynchronous reset (`async_rst`) is active.  \n- The implication (`|->`) ensures that the consequent (`!fifo_full`) must hold true in the same cycle where the antecedent (`wr_en == 1'b1`) is true.  \n\n### Key Points:  \n1. **Trigger**: Synchronous to `posedge clk`.  \n2. **Disable Condition**: Asynchronous reset (`async_rst`) overrides the check.  \n3. **Assertion Logic**: If `wr_en` is high, `fifo_full` must be low in the same cycle.  \n\nThis ensures that the FIFO is never written to when it is full, preventing data corruption or overflow.", "sva_signals": ["clk", "async_rst", "[0:0] wr_en", "[0:0] fifo_full"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (async_rst)    wr_en == 1'b1 |-> !fifo_full", "sva_name": "p_no_write_when_fifo_full", "full_property": "property p_wr_en_fifo_full_check;\n@(posedge clk) disable iff (async_rst)    wr_en == 1'b1 |-> !fifo_full\nendproperty\nassert_p_wr_en_fifo_full_check:assert property (p_wr_en_fifo_full_check) else $error(\"\");", "task_id": "1_239", "predict_sva": "@(posedge clk) disable iff (async_rst)         (async_rst == 0 && wr_en == 1) |-> (fifo_full == 0)"}
{"id": "165_8_1288", "name": "data_integrity", "sva": "@(posedge data_clk)     disable iff (crc_reset)     data_valid |-> crc_match", "ori_sva": "property data_integrity;\n@(posedge data_clk)     disable iff (crc_reset)     data_valid |-> crc_match;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match_on_data_valid  \n**Trigger Condition**: At every rising edge of the `data_clk`  \n**Disable Condition**: `disable iff (crc_reset)`  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crc_match == 1'b1`  \n\n### Explanation:  \n1. The property checks that whenever `data_valid` is high (`1'b1`) at a rising edge of `data_clk`, the signal `crc_match` must also be high (`1'b1`) in the same clock cycle.  \n2. The assertion is disabled if `crc_reset` is active (asynchronous reset condition).  \n3. The implication (`|->`) ensures that the check is performed only when the antecedent (`data_valid`) is true.  \n4. No delay (`##1`) is specified, meaning the consequent (`crc_match`) is checked in the same cycle as the antecedent.", "sva_signals": ["data_clk", "crc_reset", "[0:0] data_valid", "[0:0] crc_match"], "clock": "data_clk", "attempts_left": 10, "sva_result": "@(posedge data_clk) disable iff (crc_reset)        data_valid == 1'b1 |-> crc_match == 1'b1", "sva_name": "p_crc_match_on_data_valid", "full_property": "property p_crc_match_on_data_valid;\n@(posedge data_clk) disable iff (crc_reset)        data_valid == 1'b1 |-> crc_match == 1'b1\nendproperty\nassert_p_crc_match_on_data_valid:assert property (p_crc_match_on_data_valid) else $error(\"\");", "task_id": "1_275", "predict_sva": "@(posedge data_clk) disable iff (crc_reset)         (crc_reset == 0 && data_valid == 1'b1) |-> (crc_match == 1'b1)"}
{"id": "166_6_1320", "name": "scrub_ecc_correct_implies_error", "sva": "@(posedge clk)     ecc_correct |-> prev_error_detected", "ori_sva": "property scrub_ecc_correct_implies_error;\n@(posedge clk)     ecc_correct |-> prev_error_detected;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ecc_correct_implies_prev_error  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_correct == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `prev_error_detected == 1'b1`  \n\n### Explanation:  \nThe assertion checks that whenever `ecc_correct` is high (`1'b1`) at a rising clock edge, the signal `prev_error_detected` must also be high in the same cycle. This implies that a correctable error (ECC correction) should only occur if an error was previously detected (`prev_error_detected`). The property has no reset/disabling condition.", "sva_signals": ["clk", "rst_n", "[0:0] ecc_correct", "[0:0] prev_error_detected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    ecc_correct == 1'b1 |-> prev_error_detected == 1'b1", "sva_name": "p_ecc_correct_prev_error_detected", "full_property": "property p_ecc_correct_implies_prev_error;\n@(posedge clk)    ecc_correct == 1'b1 |-> prev_error_detected == 1'b1\nendproperty\nassert_p_ecc_correct_implies_prev_error:assert property (p_ecc_correct_implies_prev_error) else $error(\"\");", "task_id": "1_279", "predict_sva": "@(posedge clk)         ecc_correct == 1'b1 |-> prev_error_detected == 1'b1"}
{"id": "167_9_1307", "name": "afifo_ptr_sync_delay", "sva": "@(posedge clk)     disable iff(soft_reset)     $changed(wr_ptr_gray) |-> ##[1:3] $changed(wr_ptr_sync)", "ori_sva": "property afifo_ptr_sync_delay;\n@(posedge clk)     disable iff(soft_reset)     $changed(wr_ptr_gray) |-> ##[1:3] $changed(wr_ptr_sync);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_WrPtrGrayToSync  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (soft_reset)`  \n**Antecedent (LHS of Implication)**: `$changed(wr_ptr_gray)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $changed(wr_ptr_sync)`  \n\n### Explanation:  \n- The property checks that whenever the `wr_ptr_gray` signal changes (`$changed(wr_ptr_gray)`), the `wr_ptr_sync` signal must change within 1 to 3 clock cycles (`##[1:3] $changed(wr_ptr_sync)`).  \n- The assertion is evaluated at every rising edge of `clk` but is disabled if `soft_reset` is active (`disable iff (soft_reset)`).  \n- The implication (`|->`) ensures the consequent is checked only when the antecedent is true.", "sva_signals": ["clk", "soft_reset", "wr_ptr_gray", "wr_ptr_sync"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (soft_reset)    $changed(wr_ptr_gray) |-> ##[1:3] $changed(wr_ptr_sync)", "sva_name": "p_wr_ptr_sync_change_after_gray_change", "full_property": "property p_WrPtrGrayToSync;\n@(posedge clk) disable iff (soft_reset)    $changed(wr_ptr_gray) |-> ##[1:3] $changed(wr_ptr_sync)\nendproperty\nassert_p_WrPtrGrayToSync:assert property (p_WrPtrGrayToSync) else $error(\"\");", "task_id": "1_291", "predict_sva": "@(posedge clk) disable iff (soft_reset)         (soft_reset == 0 && $changed(wr_ptr_gray)) |-> ##[1:3] $changed(wr_ptr_sync)"}
{"id": "198_9_1637", "name": "consecutive_attempts_prop", "sva": "@(posedge clk_signal)     auth_complete |-> ##[2:10] !auth_start_trigger", "ori_sva": "property consecutive_attempts_prop;\n@(posedge clk_signal)     auth_complete |-> ##[2:10] !auth_start_trigger;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_auth_complete_to_no_trigger  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `auth_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 2 to 10 clock cycles after the antecedent is true, `auth_start_trigger` must be low (`!auth_start_trigger`)  \n\n(Note: The property checks that after authentication completes, the auth_start_trigger signal must remain inactive for a period of 2 to 10 clock cycles)", "sva_signals": ["clk_signal", "[0:0] auth_complete", "[0:0] auth_start_trigger"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    auth_complete == 1'b1 |-> ##[2:10] !auth_start_trigger", "sva_name": "p_auth_complete_no_start_trigger", "full_property": "property p_auth_complete_to_no_trigger;\n@(posedge clk_signal)    auth_complete == 1'b1 |-> ##[2:10] !auth_start_trigger\nendproperty\nassert_p_auth_complete_to_no_trigger:assert property (p_auth_complete_to_no_trigger) else $error(\"\");", "task_id": "1_508", "predict_sva": "@(posedge clk_signal)     auth_complete == 1'b1 |-> ##[2:10] !auth_start_trigger"}
{"id": "168_3_1321", "name": "bist_no_done_without_run", "sva": "@(posedge clk_bist)     disable iff(manual_mode_en)     bist_done_ack |-> $past(bist_run_active, 1)", "ori_sva": "property bist_no_done_without_run;\n@(posedge clk_bist)     disable iff(manual_mode_en)     bist_done_ack |-> $past(bist_run_active, 1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bist_done_ack_after_run  \n**Trigger Condition**: At every rising edge of the `clk_bist`  \n**Disable Condition**: `disable iff (manual_mode_en)`  \n**Antecedent (LHS of Implication)**: `bist_done_ack == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(bist_run_active, 1) == 1'b1`  \n\n### Explanation:  \nThe property checks that whenever `bist_done_ack` is asserted (`1'b1`), it implies that `bist_run_active` was high (`1'b1`) in the previous clock cycle (`$past(bist_run_active, 1)`). The assertion is evaluated at every rising edge of `clk_bist` but is disabled if `manual_mode_en` is active.  \n\n### Key Points:  \n- The assertion ensures a causal relationship: `bist_done_ack` should only be asserted if `bist_run_active` was high in the preceding cycle.  \n- The `disable iff` condition ensures the property is ignored during `manual_mode_en`, likely to avoid false violations during manual testing or overrides.  \n- The `$past` function captures the value of `bist_run_active` one clock cycle before the assertion trigger.", "sva_signals": ["clk_bist", "manual_mode_en", "[0:0] bist_done_ack", "[0:0] bist_run_active"], "clock": "clk_bist", "attempts_left": 10, "sva_result": "@(posedge clk_bist) disable iff (manual_mode_en)    bist_done_ack == 1'b1 |-> $past(bist_run_active, 1) == 1'b1", "sva_name": "p_bist_done_ack_only_when_run_active", "full_property": "property p_bist_done_ack_after_run;\n@(posedge clk_bist) disable iff (manual_mode_en)    bist_done_ack == 1'b1 |-> $past(bist_run_active, 1) == 1'b1\nendproperty\nassert_p_bist_done_ack_after_run:assert property (p_bist_done_ack_after_run) else $error(\"\");", "task_id": "1_295", "predict_sva": "@(posedge clk_bist) disable iff (manual_mode_en)         (manual_mode_en == 0 && bist_done_ack == 1) |-> $past(bist_run_active) == 1"}
{"id": "207_9_1705", "name": "bus_timeout_check", "sva": "@(posedge clk_signal)     $rose(bus_req) && !bus_gnt |->      ##32 $fell(bus_req)", "ori_sva": "property bus_timeout_check;\n@(posedge clk_signal)     $rose(bus_req) && !bus_gnt |->      ##32 $fell(bus_req);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_bus_req_fall_after_no_grant  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(bus_req) && !bus_gnt`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##32 $fell(bus_req)`  \n\n**Explanation**:  \nThis property checks that if there is a rising edge on `bus_req` while `bus_gnt` is low (indicating a new bus request without immediate grant), then exactly 32 clock cycles later, the `bus_req` signal must fall. The assertion verifies that the bus request is deasserted after a specific delay when the request is not granted immediately.", "sva_signals": ["clk_signal", "bus_req", "bus_gnt"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    ($rose(bus_req) && !bus_gnt) |-> ##32 $fell(bus_req)", "sva_name": "p_bus_req_deassertion_after_32_cycles", "full_property": "property p_bus_req_fall_after_no_grant;\n@(posedge clk_signal)    ($rose(bus_req) && !bus_gnt) |-> ##32 $fell(bus_req)\nendproperty\nassert_p_bus_req_fall_after_no_grant:assert property (p_bus_req_fall_after_no_grant) else $error(\"\");", "task_id": "1_588", "predict_sva": "@(posedge clk_signal)         ($rose(bus_req) && bus_gnt == 0) |-> ##32 $fell(bus_req)"}
{"id": "208_7_1714", "name": "no_output_change_without_sel_change", "sva": "@(posedge clk)     $stable(sel) |-> $stable(out)", "ori_sva": "property no_output_change_without_sel_change;\n@(posedge clk)     $stable(sel) |-> $stable(out);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_out_after_stable_sel  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(sel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(out)`  \n\n### Explanation:  \nThe property checks that whenever the signal `sel` remains stable (i.e., does not change its value) at a rising clock edge, the signal `out` must also remain stable in the same cycle. The assertion does not have a disable condition and is evaluated on every rising edge of `clk`.", "sva_signals": ["clk", "rst_n", "[0:0] sel", "[0:0] out"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $stable(sel) |-> $stable(out)", "sva_name": "p_out_stable_when_sel_stable", "full_property": "property p_stable_out_after_stable_sel;\n@(posedge clk)    $stable(sel) |-> $stable(out)\nendproperty\nassert_p_stable_out_after_stable_sel:assert property (p_stable_out_after_stable_sel) else $error(\"\");", "task_id": "1_592", "predict_sva": "@(posedge clk)         $stable(sel) |-> $stable(out)"}
{"id": "21_4_0173", "name": "p_reg_b_onehot0_implies_known", "sva": "@(posedge clk) $onehot0(reg_b) |=> !$isunknown(reg_b)", "ori_sva": "property p_reg_b_onehot0_implies_known;\n\n    @(posedge clk) $onehot0(reg_b) |=> !$isunknown(reg_b);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_onehot0_reg_b  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$onehot0(reg_b)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!$isunknown(reg_b)`  \n\n### Explanation:  \n1. **Property Name**: The assertion checks that `reg_b` is one-hot0 (at most one bit is set) and, in the next cycle, none of its bits are unknown (`X` or `Z`).  \n2. **Trigger**: Evaluated at every positive clock edge of `clk`.  \n3. **Antecedent**: `$onehot0(reg_b)` ensures `reg_b` has zero or one bit set (one-hot0 encoding).  \n4. **Implication**: `|=>` (non-overlapping implication) means the consequent is checked **one clock cycle after** the antecedent holds.  \n5. **Consequent**: `!$isunknown(reg_b)` asserts that no bits of `reg_b` are in an unknown state (`X` or `Z`) in the next cycle.  \n\n### Key Notes:  \n- **Non-overlapping Check**: The consequent (`!$isunknown`) is verified in the **next cycle** (due to `|=>`).  \n- **Strict Validity**: Combines one-hot0 and unknown-state checks to ensure `reg_b` is both valid and deterministic.", "sva_signals": ["clk", "rst_n", "[7:0] reg_b"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $onehot0(reg_b) |=> !$isunknown(reg_b)", "sva_name": "p_reg_b_onehot0_implies_known", "full_property": "property p_onehot0_reg_b;\n@(posedge clk)    $onehot0(reg_b) |=> !$isunknown(reg_b)\nendproperty\nassert_p_onehot0_reg_b:assert property (p_onehot0_reg_b) else $error(\"\");", "task_id": "1_678", "predict_sva": "@(posedge clk)         $onehot0(reg_b) |=> !$isunknown(reg_b)"}
{"id": "222_8_1866", "name": "grant_after_request", "sva": "@(posedge clk)     req_grant_ |-> $past(req_,2)", "ori_sva": "property grant_after_request;\n@(posedge clk)     req_grant_ |-> $past(req_,2);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Req_Grant_Past_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req_grant_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(req_, 2)`  \n\n(Note: The consequent checks that the value of `req_` two clock cycles before the current clock edge is true when `req_grant_` is asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] req_grant_", "[0:0] req_"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    req_grant_ == 1'b1 |-> $past(req_, 2)", "sva_name": "p_req_grant_requires_prior_req", "full_property": "property p_Req_Grant_Past_Check;\n@(posedge clk)    req_grant_ == 1'b1 |-> $past(req_, 2)\nendproperty\nassert_p_Req_Grant_Past_Check:assert property (p_Req_Grant_Past_Check) else $error(\"\");", "task_id": "1_700", "predict_sva": "@(posedge clk)         req_grant_ == 1'b1 |-> $past(req_, 2) == 1'b1"}
{"id": "240_9_2066", "name": "clock_switch_glitch_free", "sva": "@(posedge clk_primary)     $rose(clk_switch_req) |-> ##1 $fell(clk_primary) ##0 $rose(clk_secondary)", "ori_sva": "property clock_switch_glitch_free;\n@(posedge clk_primary)     $rose(clk_switch_req) |-> ##1 $fell(clk_primary) ##0 $rose(clk_secondary);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_clock_switch_sequence  \n**Trigger Condition**: At every rising edge of `clk_primary`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(clk_switch_req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(clk_primary) ##0 $rose(clk_secondary)`  \n\n### Explanation:  \n- The property checks a clock switching sequence triggered by the rising edge of `clk_primary`.  \n- When a rising edge is detected on `clk_switch_req` (antecedent), the following must occur (consequent):  \n  - After 1 clock cycle (`##1`), `clk_primary` must fall (`$fell(clk_primary)`).  \n  - Simultaneously (`##0`), `clk_secondary` must rise (`$rose(clk_secondary)`).  \n- The assertion ensures proper handshaking between clock domains during a switch request.", "sva_signals": ["clk_primary", "clk_switch_req", "clk_secondary"], "clock": "clk_primary", "attempts_left": 10, "sva_result": "@(posedge clk_primary)    $rose(clk_switch_req) |-> ##1 $fell(clk_primary) ##0 $rose(clk_secondary)", "sva_name": "p_clk_switch_handshake", "full_property": "property p_clock_switch_sequence;\n@(posedge clk_primary)    $rose(clk_switch_req) |-> ##1 $fell(clk_primary) ##0 $rose(clk_secondary)\nendproperty\nassert_p_clock_switch_sequence:assert property (p_clock_switch_sequence) else $error(\"\");", "task_id": "1_822", "predict_sva": "@(posedge clk_primary)     $rose(clk_switch_req) |-> ##1 ($fell(clk_primary) && $rose(clk_secondary))"}
{"id": "24_4_0190", "name": "state_no_zero_transition", "sva": "@(posedge clk) $changed(state) && ($past(state) == 4'b0000) |-> !$onehot(state)", "ori_sva": "property state_no_zero_transition;\n\n    @(posedge clk) $changed(state) && ($past(state) == 4'b0000) |-> !$onehot(state);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_State_Transition_From_Zero  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(state) && ($past(state) == 4'b0000)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$onehot(state)`  \n\n### Explanation:  \n- The property checks that whenever the `state` signal changes (`$changed(state)`) **and** its previous value (`$past(state)`) was `4'b0000`, the new state must **not** be one-hot encoded (`!$onehot(state)`).  \n- This ensures that a transition from the all-zero state does not result in an invalid (one-hot) state encoding.", "sva_signals": ["clk", "rst_n", "[3:0] state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    ($changed(state) && ($past(state) == 4'b0000)) |-> !$onehot(state)", "sva_name": "p_state_transition_no_onehot", "full_property": "property p_State_Transition_From_Zero;\n@(posedge clk)    ($changed(state) && ($past(state) == 4'b0000)) |-> !$onehot(state)\nendproperty\nassert_p_State_Transition_From_Zero:assert property (p_State_Transition_From_Zero) else $error(\"\");", "task_id": "1_881", "predict_sva": "@(posedge clk)         ($changed(state) && $past(state) == 4'b0000) |-> !$onehot(state)"}
{"id": "281_1_2379", "name": "p_data_island_start", "sva": "@(posedge hdmi_clk)     $rose(video_blanking) |-> ##[1:4] $rose(data_island_period)", "ori_sva": "property p_data_island_start;\n@(posedge hdmi_clk)     $rose(video_blanking) |-> ##[1:4] $rose(data_island_period);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Video_Blanking_To_Data_Island  \n**Trigger Condition**: At every posedge of the `hdmi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(video_blanking)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] $rose(data_island_period)`  \n\n### Explanation:  \nThe property checks that whenever a rising edge is detected on `video_blanking` (indicating the start of a blanking period), a rising edge on `data_island_period` must occur within **1 to 4 clock cycles** after the trigger. This ensures proper timing between the blanking period and the subsequent data island period in HDMI signaling.", "sva_signals": ["hdmi_clk", "[0:0] video_blanking", "[0:0] data_island_period"], "clock": "hdmi_clk", "attempts_left": 10, "sva_result": "@(posedge hdmi_clk)    $rose(video_blanking) |-> ##[1:4] $rose(data_island_period)", "sva_name": "p_hdmi_blanking_to_data_island_timing", "full_property": "property p_Video_Blanking_To_Data_Island;\n@(posedge hdmi_clk)    $rose(video_blanking) |-> ##[1:4] $rose(data_island_period)\nendproperty\nassert_p_Video_Blanking_To_Data_Island:assert property (p_Video_Blanking_To_Data_Island) else $error(\"\");", "task_id": "1_1027", "predict_sva": "@(posedge hdmi_clk)         $rose(video_blanking) |-> ##[1:4] $rose(data_island_period)"}
{"id": "287_1_2447", "name": "p_csi2_checksum_match_immediate", "sva": "@(posedge csi2_clk)     csi2_valid_packet_start |-> ##[1:16] (csi2_checksum == csi2_header_payload_len)", "ori_sva": "property p_csi2_checksum_match_immediate;\n@(posedge csi2_clk)     csi2_valid_packet_start |-> ##[1:16] (csi2_checksum == csi2_header_payload_len);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_csi2_checksum_valid  \n**Trigger Condition**: At every rising edge of the `csi2_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `csi2_valid_packet_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:16] (csi2_checksum == csi2_header_payload_len)`  \n\n### Explanation:  \n- The property checks that whenever `csi2_valid_packet_start` is true at a rising edge of `csi2_clk`, then within **1 to 16 clock cycles** (`##[1:16]`), the `csi2_checksum` must match `csi2_header_payload_len`.  \n- The assertion does not have a disable condition (`disable iff`).  \n- The implication (`|->`) ensures that the consequent is checked only when the antecedent (`csi2_valid_packet_start`) is true.  \n- The time window `##[1:16]` allows flexibility in when the checksum validation occurs, as long as it happens within 1 to 16 clock cycles after the packet start signal.", "sva_signals": ["csi2_clk", "[0:0] csi2_valid_packet_start", "[0:0] csi2_checksum", "[0:0] csi2_header_payload_len"], "clock": "csi2_clk", "attempts_left": 10, "sva_result": "@(posedge csi2_clk)    csi2_valid_packet_start |-> ##[1:16] (csi2_checksum == csi2_header_payload_len)", "sva_name": "p_csi2_checksum_matches_header_payload_len", "full_property": "property p_csi2_checksum_valid;\n@(posedge csi2_clk)    csi2_valid_packet_start |-> ##[1:16] (csi2_checksum == csi2_header_payload_len)\nendproperty\nassert_p_csi2_checksum_valid:assert property (p_csi2_checksum_valid) else $error(\"\");", "task_id": "1_1061", "predict_sva": "@(posedge csi2_clk)         csi2_valid_packet_start == 1 |-> ##[1:16] (csi2_checksum == csi2_header_payload_len)"}
{"id": "287_5_2435", "name": "p_csi2_checksum_no_change_after_end", "sva": "@(posedge csi2_clk)     csi2_packet_end |=> $stable(csi2_checksum)", "ori_sva": "property p_csi2_checksum_no_change_after_end;\n@(posedge csi2_clk)     csi2_packet_end |=> $stable(csi2_checksum);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_csi2_checksum_stable_after_packet_end  \n**Trigger Condition**: At every posedge of the `csi2_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `csi2_packet_end`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(csi2_checksum)`  \n\nExplanation:  \nThis property checks that whenever a CSI-2 packet ends (`csi2_packet_end` is true), the checksum value (`csi2_checksum`) must remain stable (unchanged) in the next clock cycle. The check is performed at every rising edge of `csi2_clk` and there is no disable condition specified for this property.", "sva_signals": ["csi2_clk", "csi2_packet_end", "[0:0] csi2_checksum"], "clock": "csi2_clk", "attempts_left": 10, "sva_result": "@(posedge csi2_clk)        csi2_packet_end |=> $stable(csi2_checksum)", "sva_name": "p_csi2_checksum_stable_after_packet_end", "full_property": "property p_csi2_checksum_stable_after_packet_end;\n@(posedge csi2_clk)        csi2_packet_end |=> $stable(csi2_checksum)\nendproperty\nassert_p_csi2_checksum_stable_after_packet_end:assert property (p_csi2_checksum_stable_after_packet_end) else $error(\"\");", "task_id": "1_1069", "predict_sva": "@(posedge csi2_clk)         csi2_packet_end == 1 |-> ##1 csi2_checksum == $past(csi2_checksum)"}
{"id": "69_4_0487", "name": "pll_no_lock_during_bypass", "sva": "@(posedge pll_clk)     bypass_en |-> !lock_stable", "ori_sva": "property pll_no_lock_during_bypass;\n@(posedge pll_clk)\n    bypass_en |-> !lock_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bypass_en_lock_stable  \n**Trigger Condition**: At every rising edge of the `pll_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bypass_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!lock_stable`  \n\n### Explanation:  \nThe assertion checks that whenever `bypass_en` is high (`1'b1`) at a rising edge of `pll_clk`, the signal `lock_stable` must be low (`1'b0`) in the same clock cycle. There is no disable condition for this property.", "sva_signals": ["pll_clk", "[0:0] bypass_en", "[0:0] lock_stable"], "clock": "pll_clk", "attempts_left": 10, "sva_result": "@(posedge pll_clk)        bypass_en == 1'b1 |-> !lock_stable", "sva_name": "p_bypass_en_lock_stable_low", "full_property": "property p_bypass_en_lock_stable;\n@(posedge pll_clk)        bypass_en == 1'b1 |-> !lock_stable\nendproperty\nassert_p_bypass_en_lock_stable:assert property (p_bypass_en_lock_stable) else $error(\"\");", "task_id": "1_1337", "predict_sva": "@(posedge pll_clk)         bypass_en == 1'b1 |-> lock_stable == 1'b0"}
{"id": "7_5_0038", "name": "no_valid_without_burst", "sva": "@(posedge clk) disable iff (rst_n == 0)     data_valid |-> $past(burst_start,1) && !$past(burst_abort,1)", "ori_sva": "property no_valid_without_burst;\n\n    @(posedge clk) disable iff (rst_n == 0)\n    data_valid |-> $past(burst_start,1) && !$past(burst_abort,1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_valid_burst_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (rst_n == 0)`  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(burst_start, 1) && !$past(burst_abort, 1)`  \n\n### Explanation:  \n- The property checks that whenever `data_valid` is high (`1'b1`), the following must be true:  \n  - In the **previous clock cycle**, `burst_start` was asserted (`$past(burst_start, 1)`).  \n  - In the **previous clock cycle**, `burst_abort` was **not** asserted (`!$past(burst_abort, 1)`).  \n- The property is **disabled** if `rst_n` is low (`0`), indicating an active-low asynchronous reset.  \n- The check is evaluated on every rising edge of `clk`.  \n\n### Key Notes:  \n1. **Temporal Dependency**: The check relies on past values (`$past`) of `burst_start` and `burst_abort` from **one cycle before** `data_valid` is asserted.  \n2. **Reset Handling**: The assertion is ignored during reset (`rst_n == 0`).  \n3. **Implication Semantics**: If `data_valid` is high, the consequent **must** hold; otherwise, the property vacuously passes.  \n\nThis ensures that valid data transactions (`data_valid`) only occur after a properly initiated (`burst_start`) and non-aborted (`!burst_abort`) burst sequence.", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[0:0] burst_start", "[0:0] burst_abort"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst_n == 0)    data_valid == 1'b1 |-> $past(burst_start, 1) && !$past(burst_abort, 1)", "sva_name": "p_data_valid_after_burst_start", "full_property": "property p_data_valid_burst_check;\n@(posedge clk) disable iff (rst_n == 0)    data_valid == 1'b1 |-> $past(burst_start, 1) && !$past(burst_abort, 1)\nendproperty\nassert_p_data_valid_burst_check:assert property (p_data_valid_burst_check) else $error(\"\");", "task_id": "1_1391", "predict_sva": "@(posedge clk) disable iff (!rst_n)     data_valid == 1'b1 |-> $past(burst_start) && !$past(burst_abort)"}
{"id": "96_4_0720", "name": "return_after_pulse_only", "sva": "@(posedge clk_signal)     $rose(return_signal) |-> $past(pulse_signal)", "ori_sva": "property return_after_pulse_only;\n@(posedge clk_signal)\n    $rose(return_signal) |-> $past(pulse_signal)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Return_After_Pulse  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(return_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pulse_signal)`  \n\n**Explanation**:  \nThe property checks that whenever there is a rising edge on `return_signal` (antecedent), the value of `pulse_signal` from the previous clock cycle (`$past(pulse_signal)`) must hold true (consequent). The check is performed at every rising edge of `clk_signal` and has no disable condition.", "sva_signals": ["clk_signal", "return_signal", "pulse_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)        $rose(return_signal) |-> $past(pulse_signal)", "sva_name": "p_Return_Signal_Pulse_Check", "full_property": "property p_Return_After_Pulse;\n@(posedge clk_signal)        $rose(return_signal) |-> $past(pulse_signal)\nendproperty\nassert_p_Return_After_Pulse:assert property (p_Return_After_Pulse) else $error(\"\");", "task_id": "1_1447", "predict_sva": "@(posedge clk_signal)         $rose(return_signal) |-> $past(pulse_signal)"}
{"id": "10_17_0322", "name": "p17", "sva": "@(negedge clk)     disable iff (!reset_n) $stable(config_reg) |-> !config_update", "ori_sva": "property p17;\n@(negedge clk)     disable iff (!reset_n) $stable(config_reg) |-> !config_update\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_config_reg_stable  \n**Trigger Condition**: At every negedge of the `clk`  \n**Disable Condition**: disable iff (!reset_n)  \n**Antecedent (LHS of Implication)**: $stable(config_reg)  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: !config_update  ", "sva_signals": ["clk", "reset_n", "config_reg", "[0:0] config_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (!reset_n)     $stable(config_reg) |-> !config_update;", "sva_name": "p_config_update_not_asserted_when_config_reg_stable", "full_property": "property p_config_reg_stable;\n@(negedge clk) disable iff (!reset_n)     $stable(config_reg) |-> !config_update;\nendproperty\nassert_p_config_reg_stable:assert property (p_config_reg_stable) else $error(\"\");", "task_id": "1_1467", "predict_sva": "@(negedge clk) disable iff (!reset_n)         (reset_n == 1 && $stable(config_reg)) |-> config_update == 0"}
{"id": "10_9_0320", "name": "p9", "sva": "@(posedge clk)     disable iff (rst) first_phase & second_phase |-> ##1 third_phase", "ori_sva": "property p9;\n@(posedge clk)     disable iff (rst) first_phase & second_phase |-> ##1 third_phase\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FirstSecond_ThirdPhase  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (rst)`  \n**Antecedent (LHS of Implication)**: `first_phase & second_phase`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 third_phase`  ", "sva_signals": ["clk", "rst", "[0:0] first_phase", "[0:0] second_phase", "[0:0] third_phase"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst)     (first_phase & second_phase) |-> ##1 third_phase;", "sva_name": "p_third_phase_assertion_on_both_phases", "full_property": "property p_FirstSecond_ThirdPhase;\n@(posedge clk) disable iff (rst)     (first_phase & second_phase) |-> ##1 third_phase;\nendproperty\nassert_p_FirstSecond_ThirdPhase:assert property (p_FirstSecond_ThirdPhase) else $error(\"\");", "task_id": "1_1485", "predict_sva": "@(posedge clk) disable iff (rst)         (rst == 0 && first_phase == 1 && second_phase == 1) |-> ##1 (third_phase == 1)"}
{"id": "1_25_0025", "name": "p25", "sva": "@(posedge clk)     (watchdog_timeout && !debug_mode) |-> ##1 system_reset", "ori_sva": "property p25;\n@(posedge clk)     (watchdog_timeout && !debug_mode) |-> ##1 system_reset\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_watchdog_timeout_reset  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `watchdog_timeout && !debug_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 system_reset`  \n\n(Note: The assertion checks that if `watchdog_timeout` is active and `debug_mode` is inactive at a clock edge, then in the next cycle, `system_reset` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] watchdog_timeout", "[0:0] debug_mode", "[0:0] system_reset"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (watchdog_timeout && !debug_mode) |-> ##1 system_reset;", "sva_name": "p_system_reset_on_watchdog_timeout", "full_property": "property p_watchdog_timeout_reset;\n@(posedge clk)         (watchdog_timeout && !debug_mode) |-> ##1 system_reset;\nendproperty\nassert_p_watchdog_timeout_reset:assert property (p_watchdog_timeout_reset) else $error(\"\");", "task_id": "1_1501", "predict_sva": "@(posedge clk)         (watchdog_timeout == 1 && debug_mode == 0) |-> ##1 (system_reset == 1)"}
{"id": "2_19_0057", "name": "p_voltage_stable_after_change", "sva": "@(posedge clk)     voltage_change |-> ##[8:24] voltage_stable", "ori_sva": "property p_voltage_stable_after_change;\n@(posedge clk)     voltage_change |-> ##[8:24] voltage_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_stable_after_change  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_change == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:24] voltage_stable == 1'b1`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] voltage_change", "[0:0] voltage_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         voltage_change == 1'b1 |-> ##[8:24] voltage_stable == 1'b1;", "sva_name": "p_voltage_stable_after_change", "full_property": "property p_voltage_stable_after_change;\n@(posedge clk)         voltage_change == 1'b1 |-> ##[8:24] voltage_stable == 1'b1;\nendproperty\nassert_p_voltage_stable_after_change:assert property (p_voltage_stable_after_change) else $error(\"\");", "task_id": "1_1524", "predict_sva": "@(posedge clk)     voltage_change == 1'b1 |=> ##[8:24] voltage_stable == 1'b1"}
{"id": "3_30_0100", "name": "p_overlap_30", "sva": "@(posedge clk)     (sensor_calibration && reference_available) |-> ##15 calibration_complete", "ori_sva": "property p_overlap_30;\n@(posedge clk)     (sensor_calibration && reference_available) |-> ##15 calibration_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Calibration_Complete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_calibration && reference_available`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##15 calibration_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] sensor_calibration", "[0:0] reference_available", "[0:0] calibration_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sensor_calibration && reference_available) |-> ##15 calibration_complete;", "sva_name": "p_calibration_complete_after_15_cycles", "full_property": "property p_Calibration_Complete;\n@(posedge clk)         (sensor_calibration && reference_available) |-> ##15 calibration_complete;\nendproperty\nassert_p_Calibration_Complete:assert property (p_Calibration_Complete) else $error(\"\");", "task_id": "1_1567", "predict_sva": "@(posedge clk)         (sensor_calibration == 1 && reference_available == 1) |-> ##15 (calibration_complete == 1)"}
{"id": "5_23_0176", "name": "p23", "sva": "@(posedge clk)     (pipeline_flush && !stall_condition) |-> ##2 pipeline_clear", "ori_sva": "property p23;\n@(posedge clk)     (pipeline_flush && !stall_condition) |-> ##2 pipeline_clear\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pipeline_Flush_Clear  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_flush && !stall_condition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 pipeline_clear`  ", "sva_signals": ["clk", "rst_n", "[0:0] pipeline_flush", "[0:0] stall_condition", "[0:0] pipeline_clear"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pipeline_flush && !stall_condition) |-> ##2 pipeline_clear;", "sva_name": "p_pipeline_clear_after_flush", "full_property": "property p_Pipeline_Flush_Clear;\n@(posedge clk)         (pipeline_flush && !stall_condition) |-> ##2 pipeline_clear;\nendproperty\nassert_p_Pipeline_Flush_Clear:assert property (p_Pipeline_Flush_Clear) else $error(\"\");", "task_id": "1_1634", "predict_sva": "@(posedge clk)         (pipeline_flush == 1 && stall_condition == 0) |-> ##2 (pipeline_clear == 1)"}
{"id": "5_25_0199", "name": "p25", "sva": "@(posedge clk)     (data_match && pattern_enable) |-> ##1 match_interrupt", "ori_sva": "property p25;\n@(posedge clk)     (data_match && pattern_enable) |-> ##1 match_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_match_interrupt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_match && pattern_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 match_interrupt`  ", "sva_signals": ["clk", "rst_n", "[0:0] data_match", "[0:0] pattern_enable", "[0:0] match_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (data_match && pattern_enable) |-> ##1 match_interrupt;", "sva_name": "p_match_interrupt_on_data_match_and_pattern_enable", "full_property": "property p_data_match_interrupt;\n@(posedge clk)         (data_match && pattern_enable) |-> ##1 match_interrupt;\nendproperty\nassert_p_data_match_interrupt:assert property (p_data_match_interrupt) else $error(\"\");", "task_id": "1_1639", "predict_sva": "@(posedge clk)         (data_match == 1 && pattern_enable == 1) |-> ##1 (match_interrupt == 1)"}
{"id": "5_27_0165", "name": "p27", "sva": "@(posedge clk)     (encryption_start && key_loaded) |-> ##[1:8] encryption_done", "ori_sva": "property p27;\n@(posedge clk)     (encryption_start && key_loaded) |-> ##[1:8] encryption_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Encryption_Completion  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_start && key_loaded`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] encryption_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] encryption_start", "[0:0] key_loaded", "[0:0] encryption_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (encryption_start && key_loaded) |-> ##[1:8] encryption_done;", "sva_name": "p_encryption_done_within_8_cycles", "full_property": "property p_Encryption_Completion;\n@(posedge clk)         (encryption_start && key_loaded) |-> ##[1:8] encryption_done;\nendproperty\nassert_p_Encryption_Completion:assert property (p_Encryption_Completion) else $error(\"\");", "task_id": "1_1640", "predict_sva": "@(posedge clk)         (encryption_start == 1 && key_loaded == 1) |-> ##[1:8] encryption_done == 1"}
{"id": "8_18_0258", "name": "p_ddr_burst_term", "sva": "@(posedge clk)     $past(burst_term, 1) |-> $past(burst_cnt, 1) == 0", "ori_sva": "property p_ddr_burst_term;\n@(posedge clk)     $past(burst_term, 1) |-> $past(burst_cnt, 1) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Burst_Term_Zero_Cnt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(burst_term, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(burst_cnt, 1) == 0`  ", "sva_signals": ["clk", "rst_n", "[0:0] burst_term", "[0:0] burst_cnt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(burst_term, 1) |-> $past(burst_cnt, 1) == 0;", "sva_name": "p_burst_term_burst_cnt_zero", "full_property": "property p_Burst_Term_Zero_Cnt;\n@(posedge clk)         $past(burst_term, 1) |-> $past(burst_cnt, 1) == 0;\nendproperty\nassert_p_Burst_Term_Zero_Cnt:assert property (p_Burst_Term_Zero_Cnt) else $error(\"\");", "task_id": "1_1713", "predict_sva": "@(posedge clk)         $past(burst_term, 1) == 1 |-> $past(burst_cnt, 1) == 0"}
{"id": "8_21_0252", "name": "p_ram_rd_wr", "sva": "@(posedge clk)     $past(ram_we, 1) |-> $past(ram_addr, 2) != ram_addr", "ori_sva": "property p_ram_rd_wr;\n@(posedge clk)     $past(ram_we, 1) |-> $past(ram_addr, 2) != ram_addr;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PastRamWeToAddrConflict  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(ram_we, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ram_addr, 2) != ram_addr`  ", "sva_signals": ["clk", "rst_n", "[0:0] ram_we", "[0:0] ram_addr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(ram_we, 1) |-> $past(ram_addr, 2) != ram_addr;", "sva_name": "p_no_ram_addr_conflict_on_write_enable", "full_property": "property p_PastRamWeToAddrConflict;\n@(posedge clk)         $past(ram_we, 1) |-> $past(ram_addr, 2) != ram_addr;\nendproperty\nassert_p_PastRamWeToAddrConflict:assert property (p_PastRamWeToAddrConflict) else $error(\"\");", "task_id": "1_1717", "predict_sva": "@(posedge clk)         $past(ram_we, 1) |-> ($past(ram_addr, 2) != ram_addr)"}
{"id": "2_23_0001", "name": "p_not_repeated_pattern", "sva": "@(posedge clk)     not (pattern ##1 pattern ##1 pattern)", "ori_sva": "property p_not_repeated_pattern;\n@(posedge clk)     not (pattern ##1 pattern ##1 pattern);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_No_Consecutive_Pattern  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: Not applicable (this is a sequence property, not an implication)  \n**Implication Operator**: Not applicable  \n**Consequent (RHS of Implication)**: The sequence `pattern ##1 pattern ##1 pattern` must never occur. The assertion checks that three consecutive occurrences of `pattern` (each separated by one clock cycle) do not happen.  ", "sva_signals": ["clk", "rst_n", "[0:0] pattern"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     not (pattern ##1 pattern ##1 pattern);", "sva_name": "p_No_Three_Consecutive_Patterns", "full_property": "property p_No_Consecutive_Pattern;\n@(posedge clk)     not (pattern ##1 pattern ##1 pattern);\nendproperty\nassert_p_No_Consecutive_Pattern:assert property (p_No_Consecutive_Pattern) else $error(\"\");", "task_id": "1_1769", "predict_sva": "@(posedge clk)     not (pattern ##1 pattern ##1 pattern)"}
{"id": "2_21_0225", "name": "p21", "sva": "@(posedge clk)     (cache_miss && !cache_busy) |-> ##3 cache_fill", "ori_sva": "property p21;\n@(posedge clk)     (cache_miss && !cache_busy) |-> ##3 cache_fill;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Cache_Fill_After_Miss  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_miss && !cache_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 cache_fill`  \n\n(Note: The assertion checks that whenever there is a cache miss (`cache_miss`) and the cache is not busy (`!cache_busy`), the cache fill operation (`cache_fill`) must occur exactly 3 clock cycles later.)", "sva_signals": ["clk", "rst_n", "[0:0] cache_miss", "[0:0] cache_busy", "[0:0] cache_fill"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (cache_miss && !cache_busy) |-> ##3 cache_fill;", "sva_name": "p_cache_fill_after_miss", "full_property": "property p_Cache_Fill_After_Miss;\n@(posedge clk)         (cache_miss && !cache_busy) |-> ##3 cache_fill;\nendproperty\nassert_p_Cache_Fill_After_Miss:assert property (p_Cache_Fill_After_Miss) else $error(\"\");", "task_id": "1_1906", "predict_sva": "@(posedge clk)         (cache_miss == 1 && cache_busy == 0) |-> ##3 (cache_fill == 1)"}
{"id": "3_21_0257", "name": "p_handshake_protocol", "sva": "@(posedge clk)     $rose(req) |-> ##[1:8] $rose(ack) ##1 $fell(req)", "ori_sva": "property p_handshake_protocol;\n@(posedge clk)     $rose(req) |-> ##[1:8] $rose(ack) ##1 $fell(req);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_req_ack_handshake  \n**Trigger Condition**: At every positive edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] $rose(ack) ##1 $fell(req)`  ", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(req) |-> ##[1:8] $rose(ack) ##1 $fell(req);", "sva_name": "p_req_to_ack_and_req_fall", "full_property": "property p_req_ack_handshake;\n@(posedge clk)     $rose(req) |-> ##[1:8] $rose(ack) ##1 $fell(req);\nendproperty\nassert_p_req_ack_handshake:assert property (p_req_ack_handshake) else $error(\"\");", "task_id": "1_1958", "predict_sva": "@(posedge clk)    $rose(req) |-> ##[1:8] $rose(ack) ##1 $fell(req)"}
{"id": "5_10_0315", "name": "p_fixed_delay_10", "sva": "@(posedge clk)     (dma_request && !bus_busy) |-> ##7 dma_ack", "ori_sva": "property p_fixed_delay_10;\n@(posedge clk)     (dma_request && !bus_busy) |-> ##7 dma_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_DMA_Ack_After_Request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_request && !bus_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##7 dma_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] dma_request", "[0:0] bus_busy", "[0:0] dma_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (dma_request && !bus_busy) |-> ##7 dma_ack;", "sva_name": "p_dma_ack_after_7_cycles", "full_property": "property p_DMA_Ack_After_Request;\n@(posedge clk)     (dma_request && !bus_busy) |-> ##7 dma_ack;\nendproperty\nassert_p_DMA_Ack_After_Request:assert property (p_DMA_Ack_After_Request) else $error(\"\");", "task_id": "1_2020", "predict_sva": "@(posedge clk)         (dma_request == 1 && bus_busy == 0) |-> ##7 (dma_ack == 1)"}
{"id": "5_12_0310", "name": "p_fixed_delay_12", "sva": "@(posedge clk)     (sensor_trigger && calibration_done) |-> ##9 sensor_data_valid", "ori_sva": "property p_fixed_delay_12;\n@(posedge clk)     (sensor_trigger && calibration_done) |-> ##9 sensor_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_data_valid_after_trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_trigger && calibration_done`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##9 sensor_data_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] sensor_trigger", "[0:0] calibration_done", "[0:0] sensor_data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sensor_trigger && calibration_done) |-> ##9 sensor_data_valid;", "sva_name": "p_sensor_data_valid_after_trigger_and_calibration", "full_property": "property p_sensor_data_valid_after_trigger;\n@(posedge clk)         (sensor_trigger && calibration_done) |-> ##9 sensor_data_valid;\nendproperty\nassert_p_sensor_data_valid_after_trigger:assert property (p_sensor_data_valid_after_trigger) else $error(\"\");", "task_id": "1_2021", "predict_sva": "@(posedge clk)         (sensor_trigger == 1 && calibration_done == 1) |-> ##9 (sensor_data_valid == 1)"}
{"id": "5_30_0319", "name": "p_fixed_delay_30", "sva": "@(posedge clk)     (security_check && policy_loaded) |-> ##5 access_granted", "ori_sva": "property p_fixed_delay_30;\n@(posedge clk)     (security_check && policy_loaded) |-> ##5 access_granted\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Access_Grant_After_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `security_check && policy_loaded`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 access_granted`  ", "sva_signals": ["clk", "rst_n", "[0:0] security_check", "[0:0] policy_loaded", "[0:0] access_granted"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (security_check && policy_loaded) |-> ##5 access_granted;", "sva_name": "p_access_granted_after_security_and_policy", "full_property": "property p_Access_Grant_After_Check;\n@(posedge clk)         (security_check && policy_loaded) |-> ##5 access_granted;\nendproperty\nassert_p_Access_Grant_After_Check:assert property (p_Access_Grant_After_Check) else $error(\"\");", "task_id": "1_2041", "predict_sva": "@(posedge clk)         (security_check == 1 && policy_loaded == 1) |-> ##5 (access_granted == 1)"}
{"id": "5_9_0308", "name": "p_fixed_delay_9", "sva": "@(posedge clk)     (tx_start && baud_locked) |-> ##12 tx_done", "ori_sva": "property p_fixed_delay_9;\n@(posedge clk)     (tx_start && baud_locked) |-> ##12 tx_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_tx_done_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_start && baud_locked`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##12 tx_done`  ", "sva_signals": ["clk", "rst_n", "[0:0] tx_start", "[0:0] baud_locked", "[0:0] tx_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     tx_start && baud_locked |-> ##12 tx_done;", "sva_name": "p_tx_done_after_tx_start_and_baud_locked", "full_property": "property p_tx_done_after_start;\n@(posedge clk)     tx_start && baud_locked |-> ##12 tx_done;\nendproperty\nassert_p_tx_done_after_start:assert property (p_tx_done_after_start) else $error(\"\");", "task_id": "1_2047", "predict_sva": "@(posedge clk)         (tx_start == 1 && baud_locked == 1) |-> ##12 (tx_done == 1)"}
{"id": "6_24_0340", "name": "p_time_window_24", "sva": "@(posedge clk)     (voltage_threshold_crossed && monitoring_en) |-> ##[5:10] alert_triggered", "ori_sva": "property p_time_window_24;\n@(posedge clk)     (voltage_threshold_crossed && monitoring_en) |-> ##[5:10] alert_triggered;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_alert_triggered_after_threshold  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_threshold_crossed && monitoring_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] alert_triggered`  ", "sva_signals": ["clk", "rst_n", "[0:0] voltage_threshold_crossed", "[0:0] monitoring_en", "[0:0] alert_triggered"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (voltage_threshold_crossed && monitoring_en) |-> ##[5:10] alert_triggered;", "sva_name": "p_alert_triggered_within_5_to_10_cycles", "full_property": "property p_alert_triggered_after_threshold;\n@(posedge clk)         (voltage_threshold_crossed && monitoring_en) |-> ##[5:10] alert_triggered;\nendproperty\nassert_p_alert_triggered_after_threshold:assert property (p_alert_triggered_after_threshold) else $error(\"\");", "task_id": "1_2063", "predict_sva": "@(posedge clk)         (voltage_threshold_crossed == 1 && monitoring_en == 1) |-> ##[5:10] alert_triggered == 1"}
{"id": "6_5_0360", "name": "p_time_window_5", "sva": "@(posedge clk)     (power_up && !reset) |-> ##[5:10] initialization_complete", "ori_sva": "property p_time_window_5;\n@(posedge clk)     (power_up && !reset) |-> ##[5:10] initialization_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Initialization_Complete_After_Power_Up  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_up && !reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] initialization_complete`  \n\n", "sva_signals": ["clk", "reset", "[0:0] power_up", "[0:0] initialization_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (power_up && !reset) |-> ##[5:10] initialization_complete;", "sva_name": "p_initialization_complete_within_5_to_10_cycles_after_power_up", "full_property": "property p_Initialization_Complete_After_Power_Up;\n@(posedge clk)     (power_up && !reset) |-> ##[5:10] initialization_complete;\nendproperty\nassert_p_Initialization_Complete_After_Power_Up:assert property (p_Initialization_Complete_After_Power_Up) else $error(\"\");", "task_id": "1_2073", "predict_sva": "@(posedge clk)         (power_up == 1 && reset == 0) |-> ##[5:10] initialization_complete == 1"}
{"id": "7_26_0380", "name": "p_changed_bus_priority", "sva": "@(posedge clk) disable iff (!rst_n)     $changed(bus_priority) && !arb_active |-> ##1 arb_reset", "ori_sva": "property p_changed_bus_priority;\n@(posedge clk) disable iff (!rst_n)     $changed(bus_priority) && !arb_active |-> ##1 arb_reset;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_arb_reset_on_priority_change  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$changed(bus_priority) && !arb_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 arb_reset`  ", "sva_signals": ["clk", "rst_n", "[0:0] bus_priority", "[0:0] arb_active", "[0:0] arb_reset"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)         ($changed(bus_priority) && !arb_active) |-> ##1 arb_reset;", "sva_name": "p_arb_reset_on_bus_priority_change", "full_property": "property p_arb_reset_on_priority_change;\n@(posedge clk) disable iff (!rst_n)         ($changed(bus_priority) && !arb_active) |-> ##1 arb_reset;\nendproperty\nassert_p_arb_reset_on_priority_change:assert property (p_arb_reset_on_priority_change) else $error(\"\");", "task_id": "1_2094", "predict_sva": "@(posedge clk) disable iff (!rst_n)         ($changed(bus_priority) && arb_active == 0 && rst_n == 1) |-> ##1 arb_reset == 1"}
{"id": "9_10_0421", "name": "p_past_packet_start", "sva": "@(posedge clk)     pkt_start |-> ($past(pkt_sync, 3) == 1'b1) && ($past(pkt_sync, 2) == 1'b0)", "ori_sva": "property p_past_packet_start;\n@(posedge clk)     pkt_start |-> ($past(pkt_sync, 3) == 1'b1) && ($past(pkt_sync, 2) == 1'b0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pkt_Start_Sync_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pkt_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(pkt_sync, 3) == 1'b1) && ($past(pkt_sync, 2) == 1'b0)`  ", "sva_signals": ["clk", "rst_n", "[0:0] pkt_start", "[0:0] pkt_sync"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         pkt_start == 1'b1 |-> ($past(pkt_sync, 3) == 1'b1) && ($past(pkt_sync, 2) == 1'b0);", "sva_name": "p_pkt_sync_transition_prior_pkt_start", "full_property": "property p_Pkt_Start_Sync_Check;\n@(posedge clk)         pkt_start == 1'b1 |-> ($past(pkt_sync, 3) == 1'b1) && ($past(pkt_sync, 2) == 1'b0);\nendproperty\nassert_p_Pkt_Start_Sync_Check:assert property (p_Pkt_Start_Sync_Check) else $error(\"\");", "task_id": "1_2136", "predict_sva": "@(posedge clk)         pkt_start == 1'b1 |-> $past(pkt_sync, 3) == 1'b1 && $past(pkt_sync, 2) == 1'b0"}
{"id": "9_28_0437", "name": "p_past_ram_write", "sva": "@(posedge clk)     ram_wr_en |-> $past(ram_wr_pending, 1) == 1'b1", "ori_sva": "property p_past_ram_write;\n@(posedge clk)     ram_wr_en |-> $past(ram_wr_pending, 1) == 1'b1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ram_wr_en_pending  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ram_wr_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ram_wr_pending, 1) == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] ram_wr_en", "[0:0] ram_wr_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ram_wr_en == 1'b1 |-> $past(ram_wr_pending, 1) == 1'b1;", "sva_name": "p_ram_wr_en_requires_prev_ram_wr_pending", "full_property": "property p_ram_wr_en_pending;\n@(posedge clk)         ram_wr_en == 1'b1 |-> $past(ram_wr_pending, 1) == 1'b1;\nendproperty\nassert_p_ram_wr_en_pending:assert property (p_ram_wr_en_pending) else $error(\"\");", "task_id": "1_2151", "predict_sva": "@(posedge clk)         ram_wr_en == 1'b1 |-> $past(ram_wr_pending, 1) == 1'b1"}
{"id": "10_34_0802", "name": "p_onehot0_or_all_zero_34", "sva": "@(posedge clk) sensor_trigger |=> $onehot0(sensor_select);", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_trigger_onehot0  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_trigger == 1'b1`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$onehot0(sensor_select)`  \n\n### Explanation:  \n- The property checks that **one clock cycle after `sensor_trigger` is asserted**, the `sensor_select` signal must satisfy `$onehot0` (i.e., it must have **zero or exactly one bit set to 1**).  \n- The `|=>` operator ensures the consequent is evaluated **on the next clock cycle** after the antecedent holds.  \n- No reset condition is specified (`disable iff` is absent).  \n\n(Note: `$onehot0` returns true if the signal is all zeros or has exactly one bit high, distinguishing it from `$onehot`, which requires exactly one bit high.)", "sva_signals": ["clk", "rst_n", "[0:0] sensor_trigger", "[0:0] sensor_select"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sensor_trigger == 1'b1 |=> $onehot0(sensor_select)", "sva_name": "p_sensor_select_onehot0_after_trigger", "full_property": "property p_sensor_trigger_onehot0;\n@(posedge clk)         sensor_trigger == 1'b1 |=> $onehot0(sensor_select)\nendproperty\nassert_p_sensor_trigger_onehot0:assert property (p_sensor_trigger_onehot0) else $error(\"\");", "task_id": "1_2264", "predict_sva": "@(posedge clk)         sensor_trigger == 1'b1 |-> ##1 $onehot0(sensor_select)"}
{"id": "10_58_0818", "name": "p_onehot0_or_all_zero_58", "sva": "@(posedge clk) gps_fix |=> $onehot0(gps_satellites);", "sva_description": "### Assertion description:\n**Property Name**: p_gps_fix_onehot0  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gps_fix == 1'b1`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$onehot0(gps_satellites)`  \n\nExplanation:  \n- The property checks that in the clock cycle immediately following a GPS fix (`gps_fix` high), the `gps_satellites` signal must satisfy the `$onehot0` condition (either all bits are 0 or exactly one bit is 1).  \n- The `|=>` operator means the consequent is evaluated in the next clock cycle after the antecedent is true.  \n- There is no reset/disabling condition specified for this property.", "sva_signals": ["clk", "rst_n", "[0:0] gps_fix", "[0:0] gps_satellites"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         gps_fix == 1'b1 |=> $onehot0(gps_satellites)", "sva_name": "p_gps_satellites_onehot0_on_gps_fix", "full_property": "property p_gps_fix_onehot0;\n@(posedge clk)         gps_fix == 1'b1 |=> $onehot0(gps_satellites)\nendproperty\nassert_p_gps_fix_onehot0:assert property (p_gps_fix_onehot0) else $error(\"\");", "task_id": "1_2291", "predict_sva": "@(posedge clk)         gps_fix == 1'b1 |-> ##1 $onehot0(gps_satellites)"}
{"id": "10_68_0823", "name": "p_onehot0_or_all_zero_68", "sva": "@(posedge clk) ultrasonic_ping |=> $onehot0(ultrasonic_sensors);", "sva_description": "### Assertion description:\n**Property Name**: p_ultrasonic_sensors_onehot0  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ultrasonic_ping`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$onehot0(ultrasonic_sensors)`  \n\n**Explanation**:  \nThis property checks that whenever `ultrasonic_ping` is true at a positive clock edge, then in the next clock cycle (`|=>`), the `ultrasonic_sensors` signal must satisfy the `$onehot0` condition (meaning it should have at most one bit set to 1, or all bits 0). The assertion is always active and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] ultrasonic_ping", "[0:0] ultrasonic_sensors"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ultrasonic_ping |=> $onehot0(ultrasonic_sensors)", "sva_name": "p_ultrasonic_ping_onehot0_sensors", "full_property": "property p_ultrasonic_sensors_onehot0;\n@(posedge clk)     ultrasonic_ping |=> $onehot0(ultrasonic_sensors)\nendproperty\nassert_p_ultrasonic_sensors_onehot0:assert property (p_ultrasonic_sensors_onehot0) else $error(\"\");", "task_id": "1_2302", "predict_sva": "@(posedge clk)         ultrasonic_ping == 1 |-> ##1 $onehot0($past(ultrasonic_sensors))"}
{"id": "10_72_0841", "name": "p_onehot0_or_all_zero_72", "sva": "@(posedge clk) logic_analyzer |=> $onehot0(probe_points);", "sva_description": "### Assertion description:\n**Property Name**: p_logic_analyzer_probe_points  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `logic_analyzer`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$onehot0(probe_points)`  \n\n**Explanation**:  \nThis assertion checks that whenever `logic_analyzer` is true at a positive clock edge, then in the next clock cycle (`|=>`), the `probe_points` signal must satisfy the `$onehot0` condition (meaning it should have zero or one bit set to 1, i.e., no more than one bit can be active). The assertion is always active and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] logic_analyzer", "[0:0] probe_points"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     logic_analyzer |=> $onehot0(probe_points)", "sva_name": "p_logic_analyzer_onehot0_probe_points", "full_property": "property p_logic_analyzer_probe_points;\n@(posedge clk)     logic_analyzer |=> $onehot0(probe_points)\nendproperty\nassert_p_logic_analyzer_probe_points:assert property (p_logic_analyzer_probe_points) else $error(\"\");", "task_id": "1_2308", "predict_sva": "@(posedge clk)         logic_analyzer == 1 |-> ##1 $onehot0(probe_points)"}
{"id": "1_35_0129", "name": "p_fell_5", "sva": "@(posedge clk)      $fell(sig_a) |=> $fell(sig_b);", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_sig_b_after_sig_a  \n**Trigger Condition**: At every time step (implicit, no clock edge specified)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(sig_a)`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$fell(sig_b)`  \n\n**Explanation**:  \nThe property checks that whenever `sig_a` has a falling edge (`$fell(sig_a)`), then in the **next time step** (due to `|=>`), `sig_b` must also have a falling edge (`$fell(sig_b)`). The assertion does not specify a clock edge, so it evaluates at every simulation time step. There is no disable condition for this property.", "sva_signals": ["sig_a", "sig_b", "clk", "rst_n"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) $fell(sig_a) |=> $fell(sig_b)", "sva_name": "p_sig_a_fall_sigb_fall", "full_property": "property p_fell_sig_b_after_sig_a;\n@(posedge clk) $fell(sig_a) |=> $fell(sig_b)\nendproperty\nassert_p_fell_sig_b_after_sig_a:assert property (p_fell_sig_b_after_sig_a) else $error(\"\");", "task_id": "1_2725", "predict_sva": "@(posedge clk)     $fell(sig_a) |-> ##1 $fell(sig_b)"}
{"sva": "@(negedge rst) disable iff(!enable) counter_max |-> overflow_detect ? reset_counter : increment_counter", "sva_description": "### Assertion description:  \n**Property Name**: p_counter_overflow_handling  \n**Trigger Condition**: At every negedge of the `rst` signal  \n**Disable Condition**: `disable iff (!enable)`  \n**Antecedent (LHS of Implication)**: `counter_max`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `overflow_detect ? reset_counter : increment_counter`  \n\n### Explanation:  \n1. The property evaluates on the **falling edge** of the asynchronous reset signal (`rst`).  \n2. The assertion is **disabled** when `enable` is low (`!enable`).  \n3. If the antecedent (`counter_max` is true), the consequent checks whether:  \n   - If `overflow_detect` is true, the counter should be reset (`reset_counter`).  \n   - Otherwise, the counter should increment (`increment_counter`).  \n\n(Note: The exact behavior of `reset_counter`/`increment_counter` depends on their definitions in the design.)", "sva_signals": ["rst", "[0:0] enable", "[0:0] counter_max", "[0:0] overflow_detect", "[0:0] reset_counter", "[0:0] increment_counter"], "clock": "rst", "attempts_left": 10, "sva_result": "@(negedge rst) disable iff (!enable)    counter_max |-> (overflow_detect ? reset_counter : increment_counter)", "sva_name": "p_counter_overflow_behavior", "id": "0003", "full_property": "property p_counter_overflow_handling;\n@(negedge rst) disable iff (!enable)    counter_max |-> (overflow_detect ? reset_counter : increment_counter)\nendproperty\nassert_p_counter_overflow_handling:assert property (p_counter_overflow_handling) else $error(\"\");", "task_id": "1_2872", "predict_sva": "@(negedge rst) disable iff (!enable)         (enable == 1 && counter_max == 1) |->          (overflow_detect == 1 ? reset_counter == 1 : increment_counter == 1)"}
{"sva": "@(posedge clock) disable iff(power_down) flow_control |-> buffer_threshold ? pause_transmission : resume_flow", "sva_description": "### Assertion description:  \n**Property Name**: p_flow_control_assertion  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (power_down)`  \n**Antecedent (LHS of Implication)**: `flow_control`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `buffer_threshold ? pause_transmission : resume_flow`  \n\n### Explanation:  \n- The property checks the behavior of `flow_control` at every positive edge of `clock`.  \n- The assertion is disabled when `power_down` is active (high).  \n- If `flow_control` is true (antecedent), then (implication `|->`) the consequent evaluates:  \n  - If `buffer_threshold` is true, `pause_transmission` must hold.  \n  - Otherwise (`buffer_threshold` is false), `resume_flow` must hold.  \n\nThe assertion ensures that the system correctly pauses or resumes transmission based on the `buffer_threshold` condition whenever `flow_control` is active.", "sva_signals": ["clock", "power_down", "[0:0] flow_control", "[0:0] buffer_threshold", "[0:0] pause_transmission", "[0:0] resume_flow"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (power_down)    flow_control |-> (buffer_threshold ? pause_transmission : resume_flow)", "sva_name": "p_flow_control_buffer_threshold", "id": "0008", "full_property": "property p_flow_control_assertion;\n@(posedge clock) disable iff (power_down)    flow_control |-> (buffer_threshold ? pause_transmission : resume_flow)\nendproperty\nassert_p_flow_control_assertion:assert property (p_flow_control_assertion) else $error(\"\");", "task_id": "1_2876", "predict_sva": "@(posedge clock) disable iff (power_down)    flow_control |-> (buffer_threshold ? pause_transmission : resume_flow)"}
{"sva": "@(posedge clk) disable iff(reset) branch_predict |-> prediction_correct ? update_predictor : flush_pipeline", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_prediction  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (reset)`  \n**Antecedent (LHS of Implication)**: `branch_predict`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `prediction_correct ? update_predictor : flush_pipeline`  \n\n### Explanation:  \n- The property checks the behavior of branch prediction logic.  \n- When `branch_predict` is true (`1`), the implication is triggered.  \n- The consequent evaluates a conditional expression:  \n  - If `prediction_correct` is true, `update_predictor` must hold.  \n  - If `prediction_correct` is false, `flush_pipeline` must hold.  \n- The assertion is disabled during an active `reset`.", "sva_signals": ["clk", "reset", "[0:0] branch_predict", "[0:0] prediction_correct", "[0:0] update_predictor", "[0:0] flush_pipeline"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reset)    branch_predict |-> (prediction_correct ? update_predictor : flush_pipeline)", "sva_name": "p_branch_prediction_action", "id": "0024", "full_property": "property p_branch_prediction;\n@(posedge clk) disable iff (reset)    branch_predict |-> (prediction_correct ? update_predictor : flush_pipeline)\nendproperty\nassert_p_branch_prediction:assert property (p_branch_prediction) else $error(\"\");", "task_id": "1_2891", "predict_sva": "@(posedge clk) disable iff (reset)         (reset == 0 && branch_predict == 1) |->          (prediction_correct == 1 ? update_predictor == 1 : flush_pipeline == 1)"}
{"sva": "@(posedge clock) disable iff(!power_good) sensor_reading |-> threshold_exceeded ? alarm_active : normal_status", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_alarm_check  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (!power_good)`  \n**Antecedent (LHS of Implication)**: `sensor_reading`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `threshold_exceeded ? alarm_active : normal_status`  \n\n### Explanation:  \n- The property checks the relationship between `sensor_reading` and the alarm/status signals (`alarm_active` or `normal_status`) based on whether `threshold_exceeded` is true.  \n- If `sensor_reading` is high, the assertion evaluates whether `threshold_exceeded` is true (asserting `alarm_active`) or false (asserting `normal_status`).  \n- The check is disabled if `power_good` is low (`!power_good`).  \n- The evaluation occurs at every positive edge of `clock`.", "sva_signals": ["clock", "power_good", "[0:0] sensor_reading", "[0:0] threshold_exceeded", "[0:0] alarm_active", "[0:0] normal_status"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!power_good)    sensor_reading |-> (threshold_exceeded ? alarm_active : normal_status)", "sva_name": "p_sensor_reading_status_check", "id": "0037", "full_property": "property p_sensor_alarm_check;\n@(posedge clock) disable iff (!power_good)    sensor_reading |-> (threshold_exceeded ? alarm_active : normal_status)\nendproperty\nassert_p_sensor_alarm_check:assert property (p_sensor_alarm_check) else $error(\"\");", "task_id": "1_2903", "predict_sva": "@(posedge clock) disable iff (!power_good)         (power_good == 1 && sensor_reading == 1) |->          (threshold_exceeded == 1 ? alarm_active == 1 : normal_status == 1)"}
{"sva": "@(posedge clk) disable iff(reset) tx_ready |-> (tx_buf_empty ? send_data : wait_buf)", "sva_description": "### Assertion description:  \n**Property Name**: p_tx_ready_behavior  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (reset)`  \n**Antecedent (LHS of Implication)**: `tx_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(tx_buf_empty ? send_data : wait_buf)`  \n\n### Explanation:  \n- The property checks the behavior when `tx_ready` is asserted (`tx_ready == 1`).  \n- If `tx_buf_empty` is true, the expected action is `send_data`; otherwise, the expected action is `wait_buf`.  \n- The check is disabled if `reset` is asserted (`disable iff (reset)`).  \n- The evaluation occurs at every positive clock edge (`@(posedge clk)`).", "sva_signals": ["clk", "reset", "[0:0] tx_ready", "[0:0] tx_buf_empty", "[0:0] send_data", "[0:0] wait_buf"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reset)    tx_ready == 1'b1 |-> (tx_buf_empty ? send_data : wait_buf)", "sva_name": "p_tx_ready_action", "id": "0055", "full_property": "property p_tx_ready_behavior;\n@(posedge clk) disable iff (reset)    tx_ready == 1'b1 |-> (tx_buf_empty ? send_data : wait_buf)\nendproperty\nassert_p_tx_ready_behavior:assert property (p_tx_ready_behavior) else $error(\"\");", "task_id": "1_2921", "predict_sva": "@(posedge clk) disable iff (reset)    tx_ready == 1'b1 |->         if (tx_buf_empty == 1'b1)             send_data == 1'b1        else            wait_buf == 1'b1"}
{"sva": "@(negedge neural_clk) disable iff(!learning_enable) weight_update |-> (gradient_magnitude[15:0] > 16'h1000 ? large_step : small_step)", "sva_description": "### Assertion description:  \n**Property Name**: p_weight_update_step  \n**Trigger Condition**: At every negedge of the `neural_clk`  \n**Disable Condition**: disable iff (!learning_enable)  \n**Antecedent (LHS of Implication)**: `weight_update`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(gradient_magnitude[15:0] > 16'h1000 ? large_step : small_step)`  \n\n### Explanation:  \n1. The property checks the step size (`large_step` or `small_step`) for weight updates based on the gradient magnitude.  \n2. It triggers on the falling edge of `neural_clk` and is disabled if `learning_enable` is low.  \n3. If `weight_update` is true, the consequent evaluates whether the lower 16 bits of `gradient_magnitude` exceed `0x1000`:  \n   - If true, `large_step` is expected.  \n   - Otherwise, `small_step` is expected.", "sva_signals": ["neural_clk", "learning_enable", "[0:0] weight_update", "[15:0] gradient_magnitude", "[0:0] large_step", "[0:0] small_step"], "clock": "neural_clk", "attempts_left": 10, "sva_result": "@(negedge neural_clk) disable iff (!learning_enable)    weight_update |-> (gradient_magnitude[15:0] > 16'h1000 ? large_step : small_step)", "sva_name": "p_weight_update_step_size_selection", "id": "0152", "full_property": "property p_weight_update_step;\n@(negedge neural_clk) disable iff (!learning_enable)    weight_update |-> (gradient_magnitude[15:0] > 16'h1000 ? large_step : small_step)\nendproperty\nassert_p_weight_update_step:assert property (p_weight_update_step) else $error(\"\");", "task_id": "1_3017", "predict_sva": "@(negedge neural_clk) disable iff (!learning_enable)         (learning_enable == 1 && weight_update == 1) |->          (gradient_magnitude[15:0] > 16'h1000) ? large_step : small_step"}
{"sva": "@(negedge enzyme_clk) disable iff(!catalyst_present) biochemical_reactor |-> (substrate_level[7:0] ? enzymatic_reaction : inhibited_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_biochemical_reactor_check  \n**Trigger Condition**: At every negedge of the `enzyme_clk`  \n**Disable Condition**: disable iff (!catalyst_present)  \n**Antecedent (LHS of Implication)**: `biochemical_reactor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(substrate_level[7:0] ? enzymatic_reaction : inhibited_state)`  \n\n### Explanation:  \n1. The property checks the behavior of a biochemical reactor system triggered on the falling edge of `enzyme_clk`.  \n2. The assertion is disabled if `catalyst_present` is low (active-low disable condition).  \n3. If `biochemical_reactor` is true (antecedent), the consequent evaluates:  \n   - If `substrate_level[7:0]` is non-zero, `enzymatic_reaction` must hold.  \n   - If `substrate_level[7:0]` is zero, `inhibited_state` must hold.  \n4. The ternary operator (`? :`) acts as a conditional selector for the expected output.  \n\n### Notes:  \n- The property implicitly assumes `substrate_level[7:0]` is treated as a Boolean (non-zero = true, zero = false).  \n- The negedge trigger suggests this check relates to post-reaction stabilization or sampling phases.", "sva_signals": ["enzyme_clk", "catalyst_present", "[0:0] biochemical_reactor", "[7:0] substrate_level", "[0:0] enzymatic_reaction", "[0:0] inhibited_state"], "clock": "enzyme_clk", "attempts_left": 10, "sva_result": "@(negedge enzyme_clk) disable iff (!catalyst_present)    biochemical_reactor |-> (substrate_level[7:0] ? enzymatic_reaction : inhibited_state)", "sva_name": "p_biochemical_reactor_check", "id": "0197", "full_property": "property p_biochemical_reactor_check;\n@(negedge enzyme_clk) disable iff (!catalyst_present)    biochemical_reactor |-> (substrate_level[7:0] ? enzymatic_reaction : inhibited_state)\nendproperty\nassert_p_biochemical_reactor_check:assert property (p_biochemical_reactor_check) else $error(\"\");", "task_id": "1_3061", "predict_sva": "@(negedge enzyme_clk) disable iff (!catalyst_present)    biochemical_reactor |->         if (substrate_level[7:0] != 8'b0)             enzymatic_reaction        else            inhibited_state"}
{"sva": "@(posedge gesture_clk) disable iff(calibration_needed) motion_recognition |-> (confidence_score[7:0] > 8'd180 ? gesture_detected : false_positive)", "sva_description": "### Assertion description:  \n**Property Name**: p_Motion_Recognition_Confidence  \n**Trigger Condition**: At every rising edge of the `gesture_clk`  \n**Disable Condition**: disable iff (`calibration_needed`)  \n**Antecedent (LHS of Implication)**: `motion_recognition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`confidence_score[7:0] > 8'd180`) ? `gesture_detected` : `false_positive`  \n\n### Explanation:  \n1. The property evaluates on every positive edge of `gesture_clk`.  \n2. The assertion is disabled if `calibration_needed` is active (high).  \n3. If `motion_recognition` is true (antecedent), the consequent checks whether the lower 8 bits of `confidence_score` exceed 180:  \n   - If true (`> 180`), `gesture_detected` must hold.  \n   - Otherwise, `false_positive` must hold.  \n4. The ternary operator (`? :`) acts as a conditional check within the consequent.", "sva_signals": ["gesture_clk", "[0:0] calibration_needed", "[0:0] motion_recognition", "[7:0] confidence_score", "[0:0] gesture_detected", "[0:0] false_positive"], "clock": "gesture_clk", "attempts_left": 10, "sva_result": "@(posedge gesture_clk) disable iff (calibration_needed)    motion_recognition |-> (confidence_score[7:0] > 8'd180) ? gesture_detected : false_positive", "sva_name": "p_gesture_or_false_positive_on_motion_recognition", "id": "0166", "full_property": "property p_Motion_Recognition_Confidence;\n@(posedge gesture_clk) disable iff (calibration_needed)    motion_recognition |-> (confidence_score[7:0] > 8'd180) ? gesture_detected : false_positive\nendproperty\nassert_p_Motion_Recognition_Confidence:assert property (p_Motion_Recognition_Confidence) else $error(\"\");", "task_id": "1_3031", "predict_sva": "@(posedge gesture_clk) disable iff (calibration_needed)         (calibration_needed == 0 && motion_recognition == 1) |->          (confidence_score[7:0] > 8'd180) ? (gesture_detected == 1) : (false_positive == 1)"}
{"sva": "@(negedge optimization_clk) disable iff(!compiler_hints) code_transformer |-> (hot_path_detected ? inline_function : call_overhead)", "sva_description": "### Assertion description:  \n**Property Name**: p_code_transformer_optimization  \n**Trigger Condition**: At every negedge of the `optimization_clk`  \n**Disable Condition**: `disable iff (!compiler_hints)`  \n**Antecedent (LHS of Implication)**: `code_transformer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(hot_path_detected ? inline_function : call_overhead)`  \n\n### Explanation:  \nThe property checks that whenever `code_transformer` is active (evaluates to true) at the falling edge of `optimization_clk`, the system must either execute `inline_function` if `hot_path_detected` is true, or handle `call_overhead` otherwise. The assertion is disabled if `compiler_hints` is deasserted (low).", "sva_signals": ["optimization_clk", "[0:0] compiler_hints", "[0:0] code_transformer", "[0:0] hot_path_detected", "[0:0] inline_function", "[0:0] call_overhead"], "clock": "optimization_clk", "attempts_left": 10, "sva_result": "@(negedge optimization_clk) disable iff (!compiler_hints)    code_transformer |-> (hot_path_detected ? inline_function : call_overhead)", "sva_name": "p_code_transformer_check", "id": "0214", "full_property": "property p_code_transformer_optimization;\n@(negedge optimization_clk) disable iff (!compiler_hints)    code_transformer |-> (hot_path_detected ? inline_function : call_overhead)\nendproperty\nassert_p_code_transformer_optimization:assert property (p_code_transformer_optimization) else $error(\"\");", "task_id": "1_3078", "predict_sva": "@(negedge optimization_clk) disable iff (!compiler_hints)    code_transformer |->         if (hot_path_detected)             inline_function        else            call_overhead"}
{"sva": "@(posedge core_clock) disable iff(!system_rst_n) branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)", "sva_description": "### Assertion description:  \n**Property Name**: p_branch_predictor_mispredict  \n**Trigger Condition**: At every rising edge of the `core_clock`  \n**Disable Condition**: `disable iff (!system_rst_n)`  \n**Antecedent (LHS of Implication)**: `branch_predictor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)`  \n\n### Explanation:  \n- The property checks the behavior of the branch predictor when active (`branch_predictor` is true).  \n- If the `mispredict_rate[7:0]` exceeds `8'd15`, the system should `flush_frontend`; otherwise, it should `continue_fetch`.  \n- The assertion is disabled when `system_rst_n` is low (asynchronous reset condition).  \n- The check occurs at every positive edge of `core_clock`.", "sva_signals": ["core_clock", "system_rst_n", "[0:0] branch_predictor", "[7:0] mispredict_rate", "[0:0] flush_frontend", "[0:0] continue_fetch"], "clock": "core_clock", "attempts_left": 10, "sva_result": "@(posedge core_clock) disable iff (!system_rst_n)    branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)", "sva_name": "p_branch_predictor_flush_or_continue", "id": "0204", "full_property": "property p_branch_predictor_mispredict;\n@(posedge core_clock) disable iff (!system_rst_n)    branch_predictor |-> (mispredict_rate[7:0] > 8'd15 ? flush_frontend : continue_fetch)\nendproperty\nassert_p_branch_predictor_mispredict:assert property (p_branch_predictor_mispredict) else $error(\"\");", "task_id": "1_3068", "predict_sva": "@(posedge core_clock) disable iff (!system_rst_n)         (system_rst_n == 1 && branch_predictor == 1) |->          (mispredict_rate[7:0] > 8'd15) ? flush_frontend == 1 : continue_fetch == 1"}
{"sva": "@(posedge orchestration_clk) disable iff(service_degraded) microservice_mesh |-> (load_balancer[7:0] ? distribute_request : circuit_breaker)", "sva_description": "### Assertion description:  \n**Property Name**: p_microservice_mesh_behavior  \n**Trigger Condition**: At every rising edge of the `orchestration_clk`  \n**Disable Condition**: `disable iff (service_degraded)`  \n**Antecedent (LHS of Implication)**: `microservice_mesh`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(load_balancer[7:0] ? distribute_request : circuit_breaker)`  \n\n### Explanation:  \n- The property checks the behavior of `microservice_mesh` when enabled.  \n- If `microservice_mesh` is active (`1`), the implication requires that:  \n  - If `load_balancer[7:0]` is non-zero, `distribute_request` must be true.  \n  - If `load_balancer[7:0]` is zero, `circuit_breaker` must be true.  \n- The assertion is disabled if `service_degraded` is asserted (active-high).  \n- The check occurs at every positive edge of `orchestration_clk`.", "sva_signals": ["orchestration_clk", "service_degraded", "[0:0] microservice_mesh", "[7:0] load_balancer", "[0:0] distribute_request", "[0:0] circuit_breaker"], "clock": "orchestration_clk", "attempts_left": 10, "sva_result": "@(posedge orchestration_clk)    disable iff (service_degraded)    microservice_mesh |-> (load_balancer[7:0] != 8'b0 ? distribute_request : circuit_breaker)", "sva_name": "p_microservice_mesh_request_circuit_breaker", "id": "0234", "full_property": "property p_microservice_mesh_behavior;\n@(posedge orchestration_clk)    disable iff (service_degraded)    microservice_mesh |-> (load_balancer[7:0] != 8'b0 ? distribute_request : circuit_breaker)\nendproperty\nassert_p_microservice_mesh_behavior:assert property (p_microservice_mesh_behavior) else $error(\"\");", "task_id": "1_3098", "predict_sva": "@(posedge orchestration_clk) disable iff (service_degraded)         (service_degraded == 0 && microservice_mesh == 1) |->          (load_balancer[7:0] != 0 ? distribute_request == 1 : circuit_breaker == 1)"}
{"sva": "@(posedge oceanic_clk) disable iff(!pressure_hull_intact) submarine_control |-> (depth_limit[11:0] ? emergency_surface : continue_descent)", "sva_description": "### Assertion description:\n**Property Name**: p_Submarine_Control  \n**Trigger Condition**: At every rising edge of the `oceanic_clk`  \n**Disable Condition**: disable iff (!pressure_hull_intact)  \n**Antecedent (LHS of Implication)**: `submarine_control`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(depth_limit[11:0] ? emergency_surface : continue_descent)`  \n\n### Explanation:\n1. The property checks the behavior of submarine control logic.  \n2. The check is triggered at every positive edge of the `oceanic_clk`.  \n3. The assertion is disabled if the `pressure_hull_intact` signal is low (indicating hull damage).  \n4. When `submarine_control` is active (antecedent), the submarine must either:  \n   - Trigger `emergency_surface` if any bit in `depth_limit[11:0]` is set (true)  \n   - Continue normal operation (`continue_descent`) if `depth_limit[11:0]` is all zeros (false)", "sva_signals": ["oceanic_clk", "pressure_hull_intact", "[0:0] submarine_control", "[11:0] depth_limit", "[0:0] emergency_surface", "[0:0] continue_descent"], "clock": "oceanic_clk", "attempts_left": 10, "sva_result": "@(posedge oceanic_clk) disable iff (!pressure_hull_intact)    submarine_control |-> (|depth_limit[11:0] ? emergency_surface : continue_descent)", "sva_name": "p_submarine_control_depth_limit_response", "id": "0265", "full_property": "property p_Submarine_Control;\n@(posedge oceanic_clk) disable iff (!pressure_hull_intact)    submarine_control |-> (|depth_limit[11:0] ? emergency_surface : continue_descent)\nendproperty\nassert_p_Submarine_Control:assert property (p_Submarine_Control) else $error(\"\");", "task_id": "1_3129", "predict_sva": "@(posedge oceanic_clk) disable iff (!pressure_hull_intact)         (pressure_hull_intact == 1 && submarine_control == 1) |->          (|depth_limit[11:0] ? emergency_surface == 1 : continue_descent == 1)"}
{"sva": "@(posedge marine_clk) disable iff(!ballast_system_ready) vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)", "sva_description": "### Assertion description:  \n**Property Name**: p_vessel_stability_check  \n**Trigger Condition**: At every rising edge of the `marine_clk`  \n**Disable Condition**: `disable iff (!ballast_system_ready)`  \n**Antecedent (LHS of Implication)**: `vessel_stability`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)`  \n\n### Explanation:  \n- The property checks the vessel stability condition (`vessel_stability`) at every rising edge of `marine_clk`.  \n- If the ballast system is not ready (`!ballast_system_ready`), the property is disabled.  \n- When `vessel_stability` is true, the implication requires that:  \n  - If the `list_angle[7:0]` is greater than `8'd15`, the system should activate `counter_ballast`.  \n  - Otherwise, it should maintain the trim (`maintain_trim`).", "sva_signals": ["marine_clk", "ballast_system_ready", "[7:0] list_angle", "counter_ballast", "maintain_trim", "vessel_stability"], "clock": "marine_clk", "attempts_left": 10, "sva_result": "@(posedge marine_clk) disable iff (!ballast_system_ready)    vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)", "sva_name": "p_vessel_stability_ballast_response", "id": "0267", "full_property": "property p_vessel_stability_check;\n@(posedge marine_clk) disable iff (!ballast_system_ready)    vessel_stability |-> (list_angle[7:0] > 8'd15 ? counter_ballast : maintain_trim)\nendproperty\nassert_p_vessel_stability_check:assert property (p_vessel_stability_check) else $error(\"\");", "task_id": "1_3131", "predict_sva": "@(posedge marine_clk) disable iff (!ballast_system_ready)         (ballast_system_ready == 1 && vessel_stability == 1) |->          (list_angle[7:0] > 8'd15 ? counter_ballast == 1 : maintain_trim == 1)"}
{"sva": "@(negedge sonar_clk) disable iff(acoustic_interference) underwater_navigation |-> (echo_return[15:0] ? object_detected : clear_water)", "sva_description": "### Assertion description:  \n**Property Name**: p_Underwater_Navigation_Echo_Return  \n**Trigger Condition**: At every negedge of the `sonar_clk`  \n**Disable Condition**: `disable iff (acoustic_interference)`  \n**Antecedent (LHS of Implication)**: `underwater_navigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(echo_return[15:0] ? object_detected : clear_water)`  \n\n### Explanation:  \nThe property checks that whenever `underwater_navigation` is active (antecedent), the system must respond as follows (consequent):  \n- If any bit in `echo_return[15:0]` is high, `object_detected` must be true.  \n- If all bits in `echo_return[15:0]` are low, `clear_water` must be true.  \nThe check is triggered on the falling edge of `sonar_clk` and is disabled if `acoustic_interference` is asserted.", "sva_signals": ["sonar_clk", "[0:0] acoustic_interference", "[0:0] underwater_navigation", "[15:0] echo_return", "[0:0] object_detected", "[0:0] clear_water"], "clock": "sonar_clk", "attempts_left": 10, "sva_result": "@(negedge sonar_clk) disable iff (acoustic_interference)    underwater_navigation |-> (echo_return[15:0] ? object_detected : clear_water)", "sva_name": "p_underwater_navigation_echo_response", "id": "0271", "full_property": "property p_Underwater_Navigation_Echo_Return;\n@(negedge sonar_clk) disable iff (acoustic_interference)    underwater_navigation |-> (echo_return[15:0] ? object_detected : clear_water)\nendproperty\nassert_p_Underwater_Navigation_Echo_Return:assert property (p_Underwater_Navigation_Echo_Return) else $error(\"\");", "task_id": "1_3135", "predict_sva": "@(negedge sonar_clk) disable iff (acoustic_interference)         (acoustic_interference == 0 && underwater_navigation == 1) |->          (echo_return[15:0] != 16'b0) ? object_detected : clear_water"}
{"sva": "@(negedge pipeline_clk) disable iff(leak_detected) flow_monitor |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)", "sva_description": "### Assertion description:  \n**Property Name**: p_flow_monitor_check  \n**Trigger Condition**: At every negedge of the `pipeline_clk`  \n**Disable Condition**: disable iff (leak_detected)  \n**Antecedent (LHS of Implication)**: `flow_monitor == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(pressure_differential[11:0] ? isolation_valve : maintain_flow)`  \n\n### Explanation:  \n1. The property evaluates on every **falling edge** of `pipeline_clk`.  \n2. The check is **disabled** if `leak_detected` is asserted (active-high).  \n3. If `flow_monitor` is high (**antecedent**), the **consequent** must hold:  \n   - If `pressure_differential[11:0]` is non-zero, `isolation_valve` is the expected output.  \n   - Otherwise, `maintain_flow` is the expected output.  \n4. The ternary operator (`? :`) acts as a conditional selector in the consequent.  \n\n### Key Notes:  \n- The assertion ensures correct valve control (isolation/maintenance) based on pressure readings when flow monitoring is active.  \n- The **disable condition** prioritizes safety (disabling checks during leaks).  \n- The **negedge trigger** suggests this check aligns with a specific phase of the pipeline operation.", "sva_signals": ["pipeline_clk", "leak_detected", "[0:0] flow_monitor", "[11:0] pressure_differential", "isolation_valve", "maintain_flow"], "clock": "pipeline_clk", "attempts_left": 10, "sva_result": "@(negedge pipeline_clk) disable iff (leak_detected)    flow_monitor == 1'b1 |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)", "sva_name": "p_flow_monitor_valve_control", "id": "0272", "full_property": "property p_flow_monitor_check;\n@(negedge pipeline_clk) disable iff (leak_detected)    flow_monitor == 1'b1 |-> (pressure_differential[11:0] ? isolation_valve : maintain_flow)\nendproperty\nassert_p_flow_monitor_check:assert property (p_flow_monitor_check) else $error(\"\");", "task_id": "1_3136", "predict_sva": "@(negedge pipeline_clk) disable iff (leak_detected)         (leak_detected == 0 && flow_monitor == 1) |->          (pressure_differential[11:0] != 0 ? isolation_valve : maintain_flow)"}
{"sva": "@(negedge social_clk) disable iff(privacy_mode_on) friend_activity |-> (online_status ? show_presence : appear_offline)", "sva_description": "### Assertion description:  \n**Property Name**: p_Friend_Activity_Visibility  \n**Trigger Condition**: At every negedge of the `social_clk`  \n**Disable Condition**: disable iff (`privacy_mode_on`)  \n**Antecedent (LHS of Implication)**: `friend_activity`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`online_status ? show_presence : appear_offline`)  \n\n### Explanation:  \n1. The property checks the visibility behavior of a friend's activity based on their online status.  \n2. It triggers on the **falling edge** of `social_clk` (unlike typical rising-edge assertions).  \n3. The check is **disabled** if `privacy_mode_on` is active (high).  \n4. **Antecedent**: When `friend_activity` is detected (true), the consequent must hold.  \n5. **Consequent**:  \n   - If `online_status` is true, `show_presence` must be true (friend's presence is visible).  \n   - If `online_status` is false, `appear_offline` must be true (friend appears offline).  \n\nThis ensures the system correctly reflects friend visibility states during activity events while respecting privacy mode.", "sva_signals": ["social_clk", "[0:0] privacy_mode_on", "[0:0] friend_activity", "[0:0] online_status", "[0:0] show_presence", "[0:0] appear_offline"], "clock": "social_clk", "attempts_left": 10, "sva_result": "@(negedge social_clk) disable iff (privacy_mode_on)    friend_activity |-> (online_status ? show_presence : appear_offline)", "sva_name": "p_friend_activity_visibility_update", "id": "0295", "full_property": "property p_Friend_Activity_Visibility;\n@(negedge social_clk) disable iff (privacy_mode_on)    friend_activity |-> (online_status ? show_presence : appear_offline)\nendproperty\nassert_p_Friend_Activity_Visibility:assert property (p_Friend_Activity_Visibility) else $error(\"\");", "task_id": "1_3159", "predict_sva": "@(negedge social_clk) disable iff (privacy_mode_on)         (privacy_mode_on == 0 && friend_activity == 1) |->          (online_status == 1 ? show_presence == 1 : appear_offline == 1)"}
{"sva": "@(posedge streaming_clk) disable iff(!network_stable) video_encoder |-> (bandwidth_available[15:0] ? high_bitrate : adaptive_quality)", "sva_description": "### Assertion description:  \n**Property Name**: p_video_encoder_bandwidth_control  \n**Trigger Condition**: At every rising edge of the `streaming_clk`  \n**Disable Condition**: `disable iff (!network_stable)`  \n**Antecedent (LHS of Implication)**: `video_encoder`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(bandwidth_available[15:0] ? high_bitrate : adaptive_quality)`  \n\n### Explanation:  \nThe assertion checks that whenever `video_encoder` is active (antecedent), the system must select either `high_bitrate` if bandwidth is available (as indicated by `bandwidth_available[15:0]` being non-zero) or `adaptive_quality` otherwise (consequent). The check occurs at every rising edge of `streaming_clk` and is disabled if `network_stable` is low.", "sva_signals": ["streaming_clk", "network_stable", "[0:0] video_encoder", "[15:0] bandwidth_available", "[0:0] high_bitrate", "[0:0] adaptive_quality"], "clock": "streaming_clk", "attempts_left": 10, "sva_result": "@(posedge streaming_clk)    disable iff (!network_stable)    video_encoder |-> (bandwidth_available[15:0] ? high_bitrate : adaptive_quality)", "sva_name": "p_video_encoder_bitrate_selection", "id": "0296", "full_property": "property p_video_encoder_bandwidth_control;\n@(posedge streaming_clk)    disable iff (!network_stable)    video_encoder |-> (bandwidth_available[15:0] ? high_bitrate : adaptive_quality)\nendproperty\nassert_p_video_encoder_bandwidth_control:assert property (p_video_encoder_bandwidth_control) else $error(\"\");", "task_id": "1_3160", "predict_sva": "@(posedge streaming_clk) disable iff (!network_stable)         (network_stable == 1 && video_encoder == 1) |->          (bandwidth_available[15:0] != 0 ? high_bitrate == 1 : adaptive_quality == 1)"}
{"sva": "@(posedge sleep_clk) disable iff(!sleep_stage_detection) circadian_regulator |-> (rem_sleep_detected ? preserve_cycle : optimize_deep_sleep)", "sva_description": "### Assertion description:  \n**Property Name**: p_circadian_regulator_condition  \n**Trigger Condition**: At every rising edge of the `sleep_clk`  \n**Disable Condition**: `disable iff (!sleep_stage_detection)`  \n**Antecedent (LHS of Implication)**: `circadian_regulator`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(rem_sleep_detected ? preserve_cycle : optimize_deep_sleep)`  \n\n### Explanation:  \n- The property checks that whenever `circadian_regulator` is true at a rising edge of `sleep_clk`, the consequent evaluates to either `preserve_cycle` (if `rem_sleep_detected` is true) or `optimize_deep_sleep` (otherwise).  \n- The assertion is disabled if `sleep_stage_detection` is low (`!sleep_stage_detection`).  \n- The ternary operator (`? :`) in the consequent selects between two outcomes based on `rem_sleep_detected`.", "sva_signals": ["sleep_clk", "sleep_stage_detection", "[0:0] circadian_regulator", "[0:0] rem_sleep_detected", "[0:0] preserve_cycle", "[0:0] optimize_deep_sleep"], "clock": "sleep_clk", "attempts_left": 10, "sva_result": "@(posedge sleep_clk) disable iff (!sleep_stage_detection)    circadian_regulator |-> (rem_sleep_detected ? preserve_cycle : optimize_deep_sleep)", "sva_name": "p_circadian_regulator_sleep_output", "id": "0333", "full_property": "property p_circadian_regulator_condition;\n@(posedge sleep_clk) disable iff (!sleep_stage_detection)    circadian_regulator |-> (rem_sleep_detected ? preserve_cycle : optimize_deep_sleep)\nendproperty\nassert_p_circadian_regulator_condition:assert property (p_circadian_regulator_condition) else $error(\"\");", "task_id": "1_3197", "predict_sva": "@(posedge sleep_clk) disable iff (!sleep_stage_detection)         (sleep_stage_detection == 1 && circadian_regulator == 1) |->          (rem_sleep_detected == 1 ? preserve_cycle == 1 : optimize_deep_sleep == 1)"}
{"sva": "@(negedge privacy_clk) disable iff(gdpr_compliance_expired) data_processing |-> (user_consent_valid ? process_data : anonymize_records)", "sva_description": "### Assertion description:  \n**Property Name**: p_Data_Processing_Privacy  \n**Trigger Condition**: At every negedge of the `privacy_clk`  \n**Disable Condition**: disable iff (`gdpr_compliance_expired`)  \n**Antecedent (LHS of Implication)**: `data_processing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`user_consent_valid ? process_data : anonymize_records`)  \n\n### Explanation:  \n- The property checks the behavior of data processing on the falling edge of `privacy_clk`.  \n- The assertion is disabled if `gdpr_compliance_expired` is true.  \n- If `data_processing` is active (antecedent), the consequent evaluates whether `user_consent_valid` is true:  \n  - If true, `process_data` must occur.  \n  - If false, `anonymize_records` must occur.  \n- The ternary operator (`? :`) acts as a conditional selector in the consequent.", "sva_signals": ["privacy_clk", "gdpr_compliance_expired", "[0:0] data_processing", "[0:0] user_consent_valid", "[0:0] process_data", "[0:0] anonymize_records"], "clock": "privacy_clk", "attempts_left": 10, "sva_result": "@(negedge privacy_clk) disable iff (gdpr_compliance_expired)    data_processing |-> (user_consent_valid ? process_data : anonymize_records)", "sva_name": "p_privacy_data_processing_check", "id": "0339", "full_property": "property p_Data_Processing_Privacy;\n@(negedge privacy_clk) disable iff (gdpr_compliance_expired)    data_processing |-> (user_consent_valid ? process_data : anonymize_records)\nendproperty\nassert_p_Data_Processing_Privacy:assert property (p_Data_Processing_Privacy) else $error(\"\");", "task_id": "1_3202", "predict_sva": "@(negedge privacy_clk) disable iff (gdpr_compliance_expired)    data_processing |->         if (user_consent_valid)             process_data        else            anonymize_records"}
{"sva": "@(posedge fitness_clk) disable iff(!heart_rate_monitor_connected) exercise_tracker |-> (target_zone_reached ? maintain_intensity : increase_effort)", "sva_description": "### Assertion description:\n**Property Name**: p_Exercise_Tracker_Logic  \n**Trigger Condition**: At every rising edge of the `fitness_clk`  \n**Disable Condition**: disable iff (!heart_rate_monitor_connected)  \n**Antecedent (LHS of Implication)**: `exercise_tracker`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(target_zone_reached ? maintain_intensity : increase_effort)`  \n\n### Explanation:\n1. The property evaluates the exercise control logic based on heart rate monitoring.  \n2. When `exercise_tracker` is active (antecedent), the system must either:  \n   - Maintain current intensity (`maintain_intensity`) if `target_zone_reached` is true, or  \n   - Increase effort (`increase_effort`) if `target_zone_reached` is false.  \n3. The check is disabled if the heart rate monitor disconnects (`!heart_rate_monitor_connected`).  \n4. The ternary operator `? :` acts as a conditional selector in the consequent.", "sva_signals": ["fitness_clk", "heart_rate_monitor_connected", "[0:0] exercise_tracker", "[0:0] target_zone_reached", "[0:0] maintain_intensity", "[0:0] increase_effort"], "clock": "fitness_clk", "attempts_left": 10, "sva_result": "@(posedge fitness_clk) disable iff (!heart_rate_monitor_connected)    exercise_tracker |-> (target_zone_reached ? maintain_intensity : increase_effort)", "sva_name": "p_intensity_control_when_tracker_and_heart_rate_active", "id": "0334", "full_property": "property p_Exercise_Tracker_Logic;\n@(posedge fitness_clk) disable iff (!heart_rate_monitor_connected)    exercise_tracker |-> (target_zone_reached ? maintain_intensity : increase_effort)\nendproperty\nassert_p_Exercise_Tracker_Logic:assert property (p_Exercise_Tracker_Logic) else $error(\"\");", "task_id": "1_3198", "predict_sva": "@(posedge fitness_clk) disable iff (!heart_rate_monitor_connected)         (heart_rate_monitor_connected == 1 && exercise_tracker == 1) |->          (target_zone_reached == 1 ? maintain_intensity == 1 : increase_effort == 1)"}
{"sva": "@(negedge disaster_clk) disable iff(communication_down) crisis_management |-> (evacuation_needed ? emergency_broadcast : shelter_in_place)", "sva_description": "### Assertion description:  \n**Property Name**: p_Crisis_Management_Response  \n**Trigger Condition**: At every negedge of the `disaster_clk`  \n**Disable Condition**: disable iff (`communication_down`)  \n**Antecedent (LHS of Implication)**: `crisis_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`evacuation_needed ? emergency_broadcast : shelter_in_place`)  \n\n### Explanation:  \n1. The property evaluates on the **falling edge** of `disaster_clk`.  \n2. The assertion is **disabled** if `communication_down` is active (acts as an asynchronous reset).  \n3. If `crisis_management` is true (antecedent), the consequent checks:  \n   - If `evacuation_needed` is true, `emergency_broadcast` must be active.  \n   - Otherwise (`evacuation_needed` is false), `shelter_in_place` must be active.  \n4. The ternary operator (`? :`) dynamically selects the expected signal based on `evacuation_needed`.  \n\n### Key Notes:  \n- **Immediate Implication**: The check happens in the **same cycle** as `crisis_management` (no delay like `##1`).  \n- **Conditional Consequent**: The consequent is context-dependent, adapting to `evacuation_needed`.", "sva_signals": ["disaster_clk", "[0:0] communication_down", "[0:0] crisis_management", "[0:0] evacuation_needed", "[0:0] emergency_broadcast", "[0:0] shelter_in_place"], "clock": "disaster_clk", "attempts_left": 10, "sva_result": "@(negedge disaster_clk) disable iff (communication_down)    crisis_management |-> (evacuation_needed ? emergency_broadcast : shelter_in_place)", "sva_name": "p_crisis_management_response", "id": "0341", "full_property": "property p_Crisis_Management_Response;\n@(negedge disaster_clk) disable iff (communication_down)    crisis_management |-> (evacuation_needed ? emergency_broadcast : shelter_in_place)\nendproperty\nassert_p_Crisis_Management_Response:assert property (p_Crisis_Management_Response) else $error(\"\");", "task_id": "1_3204", "predict_sva": "@(negedge disaster_clk) disable iff (communication_down)         (communication_down == 0 && crisis_management == 1) |->          (evacuation_needed == 1 ? emergency_broadcast == 1 : shelter_in_place == 1)"}
{"sva": "@(posedge midi_clk) disable iff(!instrument_connected) musical_interface |-> (system_exclusive ? (manufacturer_id_valid ? device_specific_message : (universal_sysex ? global_parameter : ignore_message)) : channel_message)", "sva_description": "### Assertion description:  \n**Property Name**: p_musical_interface_response  \n**Trigger Condition**: At every rising edge of the `midi_clk`  \n**Disable Condition**: disable iff (`!instrument_connected`)  \n**Antecedent (LHS of Implication)**: `musical_interface`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(system_exclusive ? (manufacturer_id_valid ? device_specific_message : (universal_sysex ? global_parameter : ignore_message)) : channel_message)`  \n\n**Explanation of Consequent**:  \nThe consequent is a nested conditional expression that checks:  \n1. If `system_exclusive` is true:  \n   - If `manufacturer_id_valid` is true, then `device_specific_message` must hold.  \n   - Else, if `universal_sysex` is true, then `global_parameter` must hold; otherwise, `ignore_message` must hold.  \n2. If `system_exclusive` is false, then `channel_message` must hold.  \n\nThis property ensures that the MIDI interface responds correctly based on the system configuration and message type.", "sva_signals": ["midi_clk", "instrument_connected", "[0:0] musical_interface", "[0:0] system_exclusive", "[0:0] manufacturer_id_valid", "[0:0] device_specific_message", "[0:0] universal_sysex", "[0:0] global_parameter", "[0:0] ignore_message", "[0:0] channel_message"], "clock": "midi_clk", "attempts_left": 10, "sva_result": "@(posedge midi_clk) disable iff (!instrument_connected)    musical_interface |->         (system_exclusive ?             (manufacturer_id_valid ? device_specific_message :                 (universal_sysex ? global_parameter : ignore_message))         : channel_message)", "sva_name": "p_musical_interface_check", "id": "0436", "full_property": "property p_musical_interface_response;\n@(posedge midi_clk) disable iff (!instrument_connected)    musical_interface |->         (system_exclusive ?             (manufacturer_id_valid ? device_specific_message :                 (universal_sysex ? global_parameter : ignore_message))         : channel_message)\nendproperty\nassert_p_musical_interface_response:assert property (p_musical_interface_response) else $error(\"\");", "task_id": "1_3298", "predict_sva": "@(posedge midi_clk) disable iff (!instrument_connected)    musical_interface == 1 |->     if (system_exclusive == 1)         if (manufacturer_id_valid == 1)             device_specific_message == 1        else if (universal_sysex == 1)             global_parameter == 1        else            ignore_message == 1    else        channel_message == 1"}
{"sva": "@(negedge cellular_clk) disable iff(tower_maintenance) basestation_controller |-> (handover_required ? (target_cell_available ? execute_handover : call_drop) : continue_service)", "sva_description": "### Assertion description:  \n**Property Name**: p_basestation_controller_behavior  \n**Trigger Condition**: At every negedge of the `cellular_clk`  \n**Disable Condition**: disable iff (`tower_maintenance`)  \n**Antecedent (LHS of Implication)**: `basestation_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(handover_required ? (target_cell_available ? execute_handover : call_drop) : continue_service)`  \n\n### Explanation:  \nThe property checks the behavior of the `basestation_controller` on every falling edge of `cellular_clk`. If the controller is active (`basestation_controller` is true), it implies a conditional outcome based on:  \n1. If `handover_required` is true:  \n   - If `target_cell_available` is true, `execute_handover` must occur.  \n   - Else, `call_drop` must occur.  \n2. If `handover_required` is false, `continue_service` must occur.  \nThe assertion is disabled during `tower_maintenance`.", "sva_signals": ["cellular_clk", "tower_maintenance", "[0:0] basestation_controller", "[0:0] handover_required", "[0:0] target_cell_available", "[0:0] execute_handover", "[0:0] call_drop", "[0:0] continue_service"], "clock": "cellular_clk", "attempts_left": 10, "sva_result": "@(negedge cellular_clk) disable iff (tower_maintenance)    basestation_controller |->         (handover_required ? (target_cell_available ? execute_handover : call_drop) : continue_service)", "sva_name": "p_basestation_controller_handover_behavior", "id": "0410", "full_property": "property p_basestation_controller_behavior;\n@(negedge cellular_clk) disable iff (tower_maintenance)    basestation_controller |->         (handover_required ? (target_cell_available ? execute_handover : call_drop) : continue_service)\nendproperty\nassert_p_basestation_controller_behavior:assert property (p_basestation_controller_behavior) else $error(\"\");", "task_id": "1_3273", "predict_sva": "@(negedge cellular_clk) disable iff (tower_maintenance)         (tower_maintenance == 0 && basestation_controller == 1) |->          (handover_required == 1 && target_cell_available == 1) ? execute_handover == 1 :          (handover_required == 1 && target_cell_available == 0) ? call_drop == 1 :          (handover_required == 0) ? continue_service == 1 :          1"}
{"sva": "@(negedge codec_clk) disable iff(buffer_underrun) audio_encoder |-> (quality_priority ? (bitrate_sufficient ? lossless_encoding : high_quality_lossy) : low_bitrate_compression)", "sva_description": "### Assertion description:  \n**Property Name**: p_audio_encoder_quality  \n**Trigger Condition**: At every negedge of the `codec_clk`  \n**Disable Condition**: `disable iff (buffer_underrun)`  \n**Antecedent (LHS of Implication)**: `audio_encoder`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(quality_priority ? (bitrate_sufficient ? lossless_encoding : high_quality_lossy) : low_bitrate_compression)`  \n\n### Explanation:  \nThe property checks the encoding mode of the audio encoder based on the conditions `quality_priority` and `bitrate_sufficient` whenever `audio_encoder` is active. The evaluation occurs at every falling edge of `codec_clk`, and the assertion is disabled if `buffer_underrun` is true.  \n\n- If `quality_priority` is true:  \n  - If `bitrate_sufficient` is true, `lossless_encoding` is expected.  \n  - Otherwise, `high_quality_lossy` is expected.  \n- If `quality_priority` is false, `low_bitrate_compression` is expected.", "sva_signals": ["codec_clk", "[0:0] buffer_underrun", "[0:0] audio_encoder", "[0:0] quality_priority", "[0:0] bitrate_sufficient", "[0:0] lossless_encoding", "[0:0] high_quality_lossy", "[0:0] low_bitrate_compression"], "clock": "codec_clk", "attempts_left": 10, "sva_result": "@(negedge codec_clk) disable iff (buffer_underrun)    audio_encoder |-> (quality_priority ? (bitrate_sufficient ? lossless_encoding : high_quality_lossy) : low_bitrate_compression)", "sva_name": "p_audio_encoder_encoding_mode_selection", "id": "0467", "full_property": "property p_audio_encoder_quality;\n@(negedge codec_clk) disable iff (buffer_underrun)    audio_encoder |-> (quality_priority ? (bitrate_sufficient ? lossless_encoding : high_quality_lossy) : low_bitrate_compression)\nendproperty\nassert_p_audio_encoder_quality:assert property (p_audio_encoder_quality) else $error(\"\");", "task_id": "1_3328", "predict_sva": "@(negedge codec_clk) disable iff (buffer_underrun)         (buffer_underrun == 0 && audio_encoder == 1) |->          (quality_priority == 1) ?              (bitrate_sufficient == 1) ? lossless_encoding == 1 : high_quality_lossy == 1          : low_bitrate_compression == 1"}
{"sva": "@(posedge inventory_clk) disable iff(!scanner_functional) stock_tracker |-> (item_count[15:0] ? (reorder_point_reached ? generate_purchase_order : update_database) : count_discrepancy)", "sva_description": "### Assertion description:  \n**Property Name**: p_stock_tracker  \n**Trigger Condition**: At every rising edge of the `inventory_clk`  \n**Disable Condition**: `disable iff (!scanner_functional)`  \n**Antecedent (LHS of Implication)**: `stock_tracker`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(item_count[15:0] ? (reorder_point_reached ? generate_purchase_order : update_database) : count_discrepancy)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional expression:  \n1. If `item_count[15:0]` is non-zero:  \n   - If `reorder_point_reached` is true, the action is `generate_purchase_order`.  \n   - Else, the action is `update_database`.  \n2. If `item_count[15:0]` is zero, the action is `count_discrepancy`.  \n\nThis property ensures that when `stock_tracker` is active, the system performs the appropriate action based on the current item count and reorder status. The assertion is disabled if the scanner is non-functional (`!scanner_functional`).", "sva_signals": ["inventory_clk", "scanner_functional", "[0:0] stock_tracker", "[15:0] item_count", "[0:0] reorder_point_reached", "[0:0] generate_purchase_order", "[0:0] update_database", "[0:0] count_discrepancy"], "clock": "inventory_clk", "attempts_left": 10, "sva_result": "@(posedge inventory_clk) disable iff (!scanner_functional)    stock_tracker |-> (        item_count[15:0] ? (            reorder_point_reached ? generate_purchase_order : update_database        ) : count_discrepancy    )", "sva_name": "p_stock_tracker_behavior", "id": "0521", "full_property": "property p_stock_tracker;\n@(posedge inventory_clk) disable iff (!scanner_functional)    stock_tracker |-> (        item_count[15:0] ? (            reorder_point_reached ? generate_purchase_order : update_database        ) : count_discrepancy    )\nendproperty\nassert_p_stock_tracker:assert property (p_stock_tracker) else $error(\"\");", "task_id": "1_3381", "predict_sva": "@(posedge inventory_clk) disable iff (!scanner_functional)    stock_tracker |->         if (item_count[15:0] != 16'b0)             if (reorder_point_reached)                 generate_purchase_order            else                update_database        else            count_discrepancy"}
{"sva": "@(posedge regression_clk) disable iff(!training_samples_adequate) function_approximation |-> (linear_relationship ? (least_squares_stable ? analytical_solution : regularized_regression) : polynomial_features)", "sva_description": "### Assertion description:  \n**Property Name**: p_function_approximation_condition  \n**Trigger Condition**: At every rising edge of the `regression_clk`  \n**Disable Condition**: `disable iff (!training_samples_adequate)`  \n**Antecedent (LHS of Implication)**: `function_approximation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(linear_relationship ? (least_squares_stable ? analytical_solution : regularized_regression) : polynomial_features)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested conditional expression:  \n1. If `linear_relationship` is true:  \n   - If `least_squares_stable` is true, the result is `analytical_solution`.  \n   - Else, the result is `regularized_regression`.  \n2. If `linear_relationship` is false, the result is `polynomial_features`.  \n\nThis property asserts that whenever `function_approximation` is true (and `training_samples_adequate` is not false), the output must follow the specified conditional logic.", "sva_signals": ["regression_clk", "[0:0] training_samples_adequate", "[0:0] function_approximation", "[0:0] linear_relationship", "[0:0] least_squares_stable", "[0:0] analytical_solution", "[0:0] regularized_regression", "[0:0] polynomial_features"], "clock": "regression_clk", "attempts_left": 10, "sva_result": "@(posedge regression_clk) disable iff (!training_samples_adequate)    function_approximation |->         (linear_relationship ? (least_squares_stable ? analytical_solution : regularized_regression) : polynomial_features)", "sva_name": "p_function_approximation_output_logic", "id": "0505", "full_property": "property p_function_approximation_condition;\n@(posedge regression_clk) disable iff (!training_samples_adequate)    function_approximation |->         (linear_relationship ? (least_squares_stable ? analytical_solution : regularized_regression) : polynomial_features)\nendproperty\nassert_p_function_approximation_condition:assert property (p_function_approximation_condition) else $error(\"\");", "task_id": "1_3365", "predict_sva": "@(posedge regression_clk) disable iff (!training_samples_adequate)         (training_samples_adequate == 1 && function_approximation == 1) |->          (linear_relationship == 1 && least_squares_stable == 1) ? analytical_solution :          (linear_relationship == 1 && least_squares_stable == 0) ? regularized_regression :          (linear_relationship == 0) ? polynomial_features :          1"}
{"sva": "@(posedge dairy_clk) disable iff(!milk_quality_tested) cheese_maker |-> (acidity_level[7:0] ? (curd_formation_proper ? aging_process : adjust_culture) : add_starter)", "sva_description": "### Assertion description:  \n**Property Name**: p_cheese_making_process  \n**Trigger Condition**: At every rising edge of the `dairy_clk`  \n**Disable Condition**: `disable iff (!milk_quality_tested)`  \n**Antecedent (LHS of Implication)**: `cheese_maker`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(acidity_level[7:0] ? (curd_formation_proper ? aging_process : adjust_culture) : add_starter)`  \n\n### Explanation:  \nThe property checks the cheese-making process when `cheese_maker` is active.  \n- If `acidity_level[7:0]` is non-zero:  \n  - If `curd_formation_proper` is true, proceed with `aging_process`.  \n  - Else, `adjust_culture`.  \n- If `acidity_level[7:0]` is zero, `add_starter` must be triggered.  \nThe assertion is disabled if `milk_quality_tested` is false.", "sva_signals": ["dairy_clk", "[0:0] milk_quality_tested", "[0:0] cheese_maker", "[7:0] acidity_level", "[0:0] curd_formation_proper", "[0:0] aging_process", "[0:0] adjust_culture", "[0:0] add_starter"], "clock": "dairy_clk", "attempts_left": 10, "sva_result": "@(posedge dairy_clk) disable iff (!milk_quality_tested)    cheese_maker |-> (        acidity_level[7:0] != 0 ? (            curd_formation_proper ? aging_process : adjust_culture        ) : add_starter    )", "sva_name": "p_cheese_maker_check", "id": "0551", "full_property": "property p_cheese_making_process;\n@(posedge dairy_clk) disable iff (!milk_quality_tested)    cheese_maker |-> (        acidity_level[7:0] != 0 ? (            curd_formation_proper ? aging_process : adjust_culture        ) : add_starter    )\nendproperty\nassert_p_cheese_making_process:assert property (p_cheese_making_process) else $error(\"\");", "task_id": "1_3410", "predict_sva": "@(posedge dairy_clk) disable iff (!milk_quality_tested)    cheese_maker |->         if (acidity_level[7:0] != 8'b0)             if (curd_formation_proper)                 aging_process            else                adjust_culture        else            add_starter"}
{"sva": "@(negedge archive_clk) disable iff(preservation_environment_unstable) historical_storage |-> (digitization_priority[7:0] ? (fragile_condition ? immediate_scanning : scheduled_digitization) : physical_preservation)", "sva_description": "### Assertion description:  \n**Property Name**: p_Historical_Storage_Condition  \n**Trigger Condition**: At every negedge of the `archive_clk`  \n**Disable Condition**: `disable iff (preservation_environment_unstable)`  \n**Antecedent (LHS of Implication)**: `historical_storage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(digitization_priority[7:0] ? (fragile_condition ? immediate_scanning : scheduled_digitization) : physical_preservation)`  \n\n### Explanation of the Consequent:  \nThe consequent is a conditional (ternary) expression that evaluates as follows:  \n1. If `digitization_priority[7:0]` is non-zero (true), then:  \n   - If `fragile_condition` is true, the result is `immediate_scanning`.  \n   - Else, the result is `scheduled_digitization`.  \n2. If `digitization_priority[7:0]` is zero (false), the result is `physical_preservation`.  \n\n### Summary:  \nThe property asserts that whenever `historical_storage` is true at the falling edge of `archive_clk` (and the preservation environment is stable), the system must adhere to the digitization or preservation policy defined by `digitization_priority` and `fragile_condition`. If the environment is unstable (`preservation_environment_unstable` is true), the assertion is disabled.", "sva_signals": ["archive_clk", "[0:0] preservation_environment_unstable", "[0:0] historical_storage", "[7:0] digitization_priority", "[0:0] fragile_condition", "[0:0] immediate_scanning", "[0:0] scheduled_digitization", "[0:0] physical_preservation"], "clock": "archive_clk", "attempts_left": 10, "sva_result": "@(negedge archive_clk) disable iff (preservation_environment_unstable)    historical_storage |-> (        digitization_priority[7:0] ?             (fragile_condition ? immediate_scanning : scheduled_digitization) :             physical_preservation    )", "sva_name": "p_historical_storage_check", "id": "0579", "full_property": "property p_Historical_Storage_Condition;\n@(negedge archive_clk) disable iff (preservation_environment_unstable)    historical_storage |-> (        digitization_priority[7:0] ?             (fragile_condition ? immediate_scanning : scheduled_digitization) :             physical_preservation    )\nendproperty\nassert_p_Historical_Storage_Condition:assert property (p_Historical_Storage_Condition) else $error(\"\");", "task_id": "1_3438", "predict_sva": "@(negedge archive_clk) disable iff (preservation_environment_unstable)    historical_storage == 1'b1 |->     if (digitization_priority[7:0] != 8'b0)         if (fragile_condition == 1'b1)             immediate_scanning == 1'b1        else            scheduled_digitization == 1'b1    else        physical_preservation == 1'b1"}
{"sva": "@(negedge boundary_clk) disable iff(jtag_disabled) ieee1149_controller |-> (instruction_register[3:0] == 4'b0001 ? (bypass_mode ? single_bit_path : full_scan_chain) : normal_operation)", "sva_description": "### Assertion description:  \n**Property Name**: p_ieee1149_controller_check  \n**Trigger Condition**: At every negedge of the `boundary_clk`  \n**Disable Condition**: disable iff (jtag_disabled)  \n**Antecedent (LHS of Implication)**: `ieee1149_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(instruction_register[3:0] == 4'b0001 ? (bypass_mode ? single_bit_path : full_scan_chain) : normal_operation)`  \n\n### Explanation of Consequent:  \nThe consequent is a conditional (ternary) expression that checks:  \n1. If `instruction_register[3:0] == 4'b0001`, then:  \n   - If `bypass_mode` is true, the output should be `single_bit_path`.  \n   - Else, the output should be `full_scan_chain`.  \n2. If `instruction_register[3:0]` is not `4'b0001`, the output should be `normal_operation`.  \n\nThis assertion ensures the correct behavior of the IEEE 1149.1 (JTAG) controller based on the instruction register value and bypass mode.", "sva_signals": ["boundary_clk", "[0:0] jtag_disabled", "[0:0] ieee1149_controller", "[3:0] instruction_register", "[0:0] bypass_mode", "[0:0] single_bit_path", "[0:0] full_scan_chain", "[0:0] normal_operation"], "clock": "boundary_clk", "attempts_left": 10, "sva_result": "@(negedge boundary_clk) disable iff (jtag_disabled)    ieee1149_controller |->         (instruction_register[3:0] == 4'b0001 ?             (bypass_mode ? single_bit_path : full_scan_chain) :             normal_operation)", "sva_name": "p_jtag_controller_output_mode_selection", "id": "0603", "full_property": "property p_ieee1149_controller_check;\n@(negedge boundary_clk) disable iff (jtag_disabled)    ieee1149_controller |->         (instruction_register[3:0] == 4'b0001 ?             (bypass_mode ? single_bit_path : full_scan_chain) :             normal_operation)\nendproperty\nassert_p_ieee1149_controller_check:assert property (p_ieee1149_controller_check) else $error(\"\");", "task_id": "1_3461", "predict_sva": "@(negedge boundary_clk) disable iff (jtag_disabled)         (jtag_disabled == 0 && ieee1149_controller == 1) |->          (instruction_register[3:0] == 4'b0001) ?              (bypass_mode == 1 ? single_bit_path : full_scan_chain) :              normal_operation"}
{"sva": "@(posedge signal_clk) disable iff(!adc_powered) analog_to_digital |-> (reference_voltage[11:0] == 12'hFFF ? (overrange_condition ? clamp_output : saturated_conversion) : linear_conversion)", "sva_description": "### Assertion description:  \n**Property Name**: p_analog_to_digital_conversion  \n**Trigger Condition**: At every rising edge of `signal_clk`  \n**Disable Condition**: `disable iff (!adc_powered)`  \n**Antecedent (LHS of Implication)**: `analog_to_digital`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(reference_voltage[11:0] == 12'hFFF ? (overrange_condition ? clamp_output : saturated_conversion) : linear_conversion)`  \n\n### Explanation of Consequent:  \nThe consequent is a ternary conditional expression with the following logic:  \n1. If `reference_voltage[11:0]` equals `12'hFFF`, then:  \n   - If `overrange_condition` is true, the output is `clamp_output`.  \n   - Else, the output is `saturated_conversion`.  \n2. If `reference_voltage[11:0]` does not equal `12'hFFF`, the output is `linear_conversion`.  \n\nThis property ensures that when the ADC is powered (`adc_powered` is high) and the `analog_to_digital` signal is asserted, the output follows the specified conversion rules based on the reference voltage and overrange conditions.", "sva_signals": ["signal_clk", "adc_powered", "[11:0] reference_voltage", "[0:0] overrange_condition", "[0:0] clamp_output", "[0:0] saturated_conversion", "[0:0] linear_conversion", "[0:0] analog_to_digital"], "clock": "signal_clk", "attempts_left": 10, "sva_result": "@(posedge signal_clk) disable iff (!adc_powered)    analog_to_digital |->         (reference_voltage[11:0] == 12'hFFF ?             (overrange_condition ? clamp_output : saturated_conversion) :             linear_conversion)", "sva_name": "p_adc_output_conversion_logic", "id": "0664", "full_property": "property p_analog_to_digital_conversion;\n@(posedge signal_clk) disable iff (!adc_powered)    analog_to_digital |->         (reference_voltage[11:0] == 12'hFFF ?             (overrange_condition ? clamp_output : saturated_conversion) :             linear_conversion)\nendproperty\nassert_p_analog_to_digital_conversion:assert property (p_analog_to_digital_conversion) else $error(\"\");", "task_id": "1_3522", "predict_sva": "@(posedge signal_clk) disable iff (!adc_powered)         (adc_powered == 1 && analog_to_digital == 1) |->          (reference_voltage[11:0] == 12'hFFF) ?              (overrange_condition ? clamp_output : saturated_conversion) :              linear_conversion"}
{"sva": "@(posedge consciousness_clock) disable iff(!global_workspace_active) cognitive_architecture |-> (attention_focus[9:0] ? (working_memory_active ? conscious_processing : (implicit_processing ? unconscious_computation : dormant_state)) : distributed_processing)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cognitive_Architecture_Processing  \n**Trigger Condition**: At every rising edge of the `consciousness_clock`  \n**Disable Condition**: `disable iff (!global_workspace_active)`  \n**Antecedent (LHS of Implication)**: `cognitive_architecture`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(attention_focus[9:0] ? (working_memory_active ? conscious_processing : (implicit_processing ? unconscious_computation : dormant_state)) : distributed_processing)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional expression that evaluates as follows:  \n1. If `attention_focus[9:0]` is non-zero:  \n   - If `working_memory_active` is true, the result is `conscious_processing`.  \n   - Else, if `implicit_processing` is true, the result is `unconscious_computation`.  \n   - Otherwise, the result is `dormant_state`.  \n2. If `attention_focus[9:0]` is zero, the result is `distributed_processing`.  \n\nThis property asserts that whenever `cognitive_architecture` is active, the system's processing state must align with the hierarchical conditions defined by `attention_focus`, `working_memory_active`, and `implicit_processing`. The check is disabled if `global_workspace_active` is low.", "sva_signals": ["consciousness_clock", "global_workspace_active", "[0:0] cognitive_architecture", "[9:0] attention_focus", "[0:0] working_memory_active", "[0:0] conscious_processing", "[0:0] implicit_processing", "[0:0] unconscious_computation", "[0:0] dormant_state", "[0:0] distributed_processing"], "clock": "consciousness_clock", "attempts_left": 10, "sva_result": "@(posedge consciousness_clock) disable iff (!global_workspace_active)    cognitive_architecture |->         (attention_focus[9:0] ?             (working_memory_active ? conscious_processing :                 (implicit_processing ? unconscious_computation : dormant_state))         : distributed_processing)", "sva_name": "p_Cognitive_Architecture_Processing", "id": "0731", "full_property": "property p_Cognitive_Architecture_Processing;\n@(posedge consciousness_clock) disable iff (!global_workspace_active)    cognitive_architecture |->         (attention_focus[9:0] ?             (working_memory_active ? conscious_processing :                 (implicit_processing ? unconscious_computation : dormant_state))         : distributed_processing)\nendproperty\nassert_p_Cognitive_Architecture_Processing:assert property (p_Cognitive_Architecture_Processing) else $error(\"\");", "task_id": "1_3586", "predict_sva": "@(posedge consciousness_clock) disable iff (!global_workspace_active)    cognitive_architecture |->         if (attention_focus[9:0] != 10'b0)             if (working_memory_active)                 conscious_processing            else if (implicit_processing)                 unconscious_computation            else                dormant_state        else            distributed_processing"}
{"sva": "@(negedge emergence_clock) disable iff(complexity_threshold_not_met) complex_system |-> (phase_transition_indicator[11:0] ? (critical_point_reached ? emergent_behavior : (self_organization ? pattern_formation : random_dynamics)) : simple_behavior)", "sva_description": "### Assertion description:  \n**Property Name**: p_Emergent_Behavior_Check  \n**Trigger Condition**: At every negedge of the `emergence_clock`  \n**Disable Condition**: `disable iff (complexity_threshold_not_met)`  \n**Antecedent (LHS of Implication)**: `complex_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(phase_transition_indicator[11:0] ? (critical_point_reached ? emergent_behavior : (self_organization ? pattern_formation : random_dynamics)) : simple_behavior)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary expression that evaluates as follows:  \n1. If `phase_transition_indicator[11:0]` is non-zero:  \n   - If `critical_point_reached` is true, the expected outcome is `emergent_behavior`.  \n   - Else, if `self_organization` is true, the expected outcome is `pattern_formation`.  \n   - Otherwise, the outcome is `random_dynamics`.  \n2. If `phase_transition_indicator[11:0]` is zero, the expected outcome is `simple_behavior`.  \n\nThis property asserts that when `complex_system` is active (antecedent), the system's behavior (consequent) must follow the described logic based on the state of `phase_transition_indicator`, `critical_point_reached`, and `self_organization`. The check is disabled if `complexity_threshold_not_met` is true.", "sva_signals": ["emergence_clock", "complexity_threshold_not_met", "[0:0] complex_system", "[11:0] phase_transition_indicator", "[0:0] critical_point_reached", "[0:0] emergent_behavior", "[0:0] self_organization", "[0:0] pattern_formation", "[0:0] random_dynamics", "[0:0] simple_behavior"], "clock": "emergence_clock", "attempts_left": 10, "sva_result": "disable iff (complexity_threshold_not_met)    @(negedge emergence_clock)    complex_system |->         (phase_transition_indicator[11:0] ?             (critical_point_reached ? emergent_behavior :                 (self_organization ? pattern_formation : random_dynamics))             : simple_behavior)", "sva_name": "p_complex_system_behavior", "id": "0732", "full_property": "property p_Emergent_Behavior_Check;\ndisable iff (complexity_threshold_not_met)    @(negedge emergence_clock)    complex_system |->         (phase_transition_indicator[11:0] ?             (critical_point_reached ? emergent_behavior :                 (self_organization ? pattern_formation : random_dynamics))             : simple_behavior)\nendproperty\nassert_p_Emergent_Behavior_Check:assert property (p_Emergent_Behavior_Check) else $error(\"\");", "task_id": "1_3587", "predict_sva": "@(negedge emergence_clock) disable iff (complexity_threshold_not_met)    complex_system |->         if (phase_transition_indicator[11:0] != 0)             if (critical_point_reached)                 emergent_behavior            else if (self_organization)                 pattern_formation            else                random_dynamics        else            simple_behavior"}
{"sva": "@(posedge voltage_clk) disable iff(!regulator_stable) voltage_monitor |-> (measurement_complete ? (within_tolerance ? voltage_ok : voltage_fault) : measuring)", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_monitor_check  \n**Trigger Condition**: At every rising edge of the `voltage_clk`  \n**Disable Condition**: `disable iff (!regulator_stable)`  \n**Antecedent (LHS of Implication)**: `voltage_monitor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(measurement_complete ? (within_tolerance ? voltage_ok : voltage_fault) : measuring)`  \n\n### Explanation:  \nThe property checks that whenever `voltage_monitor` is active (antecedent), the consequent condition must hold. The consequent is a ternary expression:  \n- If `measurement_complete` is true, the output depends on `within_tolerance`:  \n  - If `within_tolerance` is true, `voltage_ok` must be asserted.  \n  - If `within_tolerance` is false, `voltage_fault` must be asserted.  \n- If `measurement_complete` is false, `measuring` must be asserted.  \nThe property is disabled if `regulator_stable` is not asserted (i.e., when the regulator is unstable).", "sva_signals": ["voltage_clk", "[0:0] regulator_stable", "[0:0] voltage_monitor", "[0:0] measurement_complete", "[0:0] within_tolerance", "[0:0] voltage_ok", "[0:0] voltage_fault", "[0:0] measuring"], "clock": "voltage_clk", "attempts_left": 10, "sva_result": "@(posedge voltage_clk) disable iff (!regulator_stable)    voltage_monitor |-> (measurement_complete ? (within_tolerance ? voltage_ok : voltage_fault) : measuring)", "sva_name": "p_voltage_monitor_output_behavior", "id": "0894", "full_property": "property p_voltage_monitor_check;\n@(posedge voltage_clk) disable iff (!regulator_stable)    voltage_monitor |-> (measurement_complete ? (within_tolerance ? voltage_ok : voltage_fault) : measuring)\nendproperty\nassert_p_voltage_monitor_check:assert property (p_voltage_monitor_check) else $error(\"\");", "task_id": "1_3733", "predict_sva": "@(posedge voltage_clk) disable iff (!regulator_stable)         (regulator_stable == 1 && voltage_monitor == 1) |->          (measurement_complete == 1 ? (within_tolerance == 1 ? voltage_ok == 1 : voltage_fault == 1) : measuring == 1)"}
{"sva": "@(posedge swarm_clk) disable iff(communication_lost) particle_swarm |-> (velocity_update[15:0] && position_bounds ? (global_best_found ? exploitation_phase : exploration_phase) : swarm_convergence)", "sva_description": "### Assertion description:  \n**Property Name**: p_Particle_Swarm_Behavior  \n**Trigger Condition**: At every rising edge of the `swarm_clk`  \n**Disable Condition**: `disable iff (communication_lost)`  \n**Antecedent (LHS of Implication)**: `particle_swarm`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(velocity_update[15:0] && position_bounds) ? (global_best_found ? exploitation_phase : exploration_phase) : swarm_convergence`  \n\n### Explanation:  \n1. The property evaluates the behavior of a particle swarm optimization algorithm on each rising edge of `swarm_clk`.  \n2. The assertion is **disabled** if `communication_lost` is active (high).  \n3. The **antecedent** (`particle_swarm`) triggers the implication when true.  \n4. The **consequent** is a **conditional expression**:  \n   - If `velocity_update[15:0]` and `position_bounds` are both true:  \n     - Further checks if `global_best_found` is true:  \n       - If true, expects `exploitation_phase` to be active.  \n       - If false, expects `exploration_phase` to be active.  \n   - If either `velocity_update[15:0]` or `position_bounds` is false:  \n     - Expects `swarm_convergence` to be active.  \n\nThis assertion ensures the swarm follows the expected state transitions based on velocity updates, position bounds, and whether the global best solution is found.", "sva_signals": ["swarm_clk", "[0:0] communication_lost", "[0:0] particle_swarm", "[15:0] velocity_update", "[0:0] position_bounds", "[0:0] global_best_found", "[0:0] exploitation_phase", "[0:0] exploration_phase", "[0:0] swarm_convergence"], "clock": "swarm_clk", "attempts_left": 10, "sva_result": "@(posedge swarm_clk) disable iff (communication_lost)    particle_swarm |->         (velocity_update[15:0] && position_bounds) ?             (global_best_found ? exploitation_phase : exploration_phase) :             swarm_convergence", "sva_name": "p_particle_swarm_phase_transition", "id": "0953", "full_property": "property p_Particle_Swarm_Behavior;\n@(posedge swarm_clk) disable iff (communication_lost)    particle_swarm |->         (velocity_update[15:0] && position_bounds) ?             (global_best_found ? exploitation_phase : exploration_phase) :             swarm_convergence\nendproperty\nassert_p_Particle_Swarm_Behavior:assert property (p_Particle_Swarm_Behavior) else $error(\"\");", "task_id": "1_3786", "predict_sva": "@(posedge swarm_clk) disable iff (communication_lost)         (communication_lost == 0 && particle_swarm == 1) |->          (velocity_update[15:0] != 0 && position_bounds == 1) ?              (global_best_found ? exploitation_phase : exploration_phase) :              swarm_convergence"}
{"sva": "@(posedge clk) disable iff(!rst) timer_expired |-> $past(counter_enable) && ($past(reload_value) > 0)", "sva_description": "### Assertion description:  \n**Property Name**: p_Timer_Expired_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`!rst`)  \n**Antecedent (LHS of Implication)**: `timer_expired == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(counter_enable) && ($past(reload_value) > 0)`  ", "sva_signals": ["clk", "rst", "[0:0] timer_expired", "[0:0] counter_enable", "[15:0] reload_value"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst)     timer_expired == 1'b1 |-> $past(counter_enable) && ($past(reload_value) > 0)", "sva_name": "p_timer_expired_prev_counter_enable_reload_value", "id": "0012", "full_property": "property p_Timer_Expired_Check;\n@(posedge clk) disable iff (!rst)     timer_expired == 1'b1 |-> $past(counter_enable) && ($past(reload_value) > 0)\nendproperty\nassert_p_Timer_Expired_Check:assert property (p_Timer_Expired_Check) else $error(\"\");", "task_id": "1_3845", "predict_sva": "@(posedge clk) disable iff (!rst)         (rst == 1 && timer_expired == 1'b1) |-> ($past(counter_enable) == 1 && $past(reload_value) > 0)"}
{"sva": "@(negedge pump_clk) disable iff(dry_run_protection) pump_controller |-> (flow_request ? (pressure_ok ? maintain_flow : pressure_fault) : pump_standby)", "sva_description": "### Assertion description:  \n**Property Name**: p_pump_controller_behavior  \n**Trigger Condition**: At every negedge of the `pump_clk`  \n**Disable Condition**: `disable iff (dry_run_protection)`  \n**Antecedent (LHS of Implication)**: `pump_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(flow_request ? (pressure_ok ? maintain_flow : pressure_fault) : pump_standby)`  \n\n### Explanation:  \n1. The property evaluates the behavior of `pump_controller` on the falling edge of `pump_clk`.  \n2. If `dry_run_protection` is active, the assertion is disabled.  \n3. When `pump_controller` is asserted (antecedent), the consequent checks a conditional expression:  \n   - If `flow_request` is true, it further checks:  \n     - If `pressure_ok` is true, `maintain_flow` must hold.  \n     - Else, `pressure_fault` must hold.  \n   - If `flow_request` is false, `pump_standby` must hold.  \n\nThis ensures the pump controller responds correctly to flow and pressure conditions.", "sva_signals": ["pump_clk", "dry_run_protection", "[0:0] pump_controller", "[0:0] flow_request", "[0:0] pressure_ok", "[0:0] maintain_flow", "[0:0] pressure_fault", "[0:0] pump_standby"], "clock": "pump_clk", "attempts_left": 10, "sva_result": "@(negedge pump_clk) disable iff (dry_run_protection)    pump_controller |->         (flow_request ? (pressure_ok ? maintain_flow : pressure_fault) : pump_standby)", "sva_name": "p_pump_controller_flow_pressure_response", "id": "0906", "full_property": "property p_pump_controller_behavior;\n@(negedge pump_clk) disable iff (dry_run_protection)    pump_controller |->         (flow_request ? (pressure_ok ? maintain_flow : pressure_fault) : pump_standby)\nendproperty\nassert_p_pump_controller_behavior:assert property (p_pump_controller_behavior) else $error(\"\");", "task_id": "1_3745", "predict_sva": "@(negedge pump_clk) disable iff (dry_run_protection)         (dry_run_protection == 0 && pump_controller == 1) |->          (flow_request == 1 && pressure_ok == 1) ? maintain_flow == 1 :          (flow_request == 1 && pressure_ok == 0) ? pressure_fault == 1 :          (flow_request == 0) ? pump_standby == 1 :          1"}
{"sva": "@(posedge clk) disable iff(!chip_enable) spi_transaction |-> ($past(cs_active) && $past(clock_ready, 1)) |=> $past(data_setup)", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_transaction_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!chip_enable)`  \n**Antecedent (LHS of Implication)**: `spi_transaction`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(cs_active) && $past(clock_ready, 1)) |=> $past(data_setup)`  ", "sva_signals": ["clk", "[0:0] chip_enable", "[0:0] spi_transaction", "[0:0] cs_active", "[0:0] clock_ready", "[0:0] data_setup"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!chip_enable)     spi_transaction |-> ($past(cs_active) && $past(clock_ready, 1)) |=> $past(data_setup)", "sva_name": "p_spi_transaction_data_setup_check", "id": "0061", "full_property": "property p_spi_transaction_check;\n@(posedge clk) disable iff (!chip_enable)     spi_transaction |-> ($past(cs_active) && $past(clock_ready, 1)) |=> $past(data_setup)\nendproperty\nassert_p_spi_transaction_check:assert property (p_spi_transaction_check) else $error(\"\");", "task_id": "1_3891", "predict_sva": "@(posedge clk) disable iff (!chip_enable)         (chip_enable == 1 && spi_transaction == 1 && $past(cs_active) == 1 && $past(clock_ready) == 1) |-> ##1 $past(data_setup) == 1"}
{"sva": "@(posedge clk_sys) request_active |-> $past(acknowledge_pending) && ($past(state_reg) == 4'h5)", "sva_description": "### Assertion description:\n**Property Name**: p_Request_Active_Ack_Pending  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `request_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(acknowledge_pending) && ($past(state_reg) == 4'h5)`  \n\n(Note: The property checks that whenever `request_active` is high, in the previous cycle, `acknowledge_pending` was high and `state_reg` was equal to 4'h5.)", "sva_signals": ["clk_sys", "request_active", "[0:0] acknowledge_pending", "[3:0] state_reg"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     request_active == 1'b1 |-> $past(acknowledge_pending) && ($past(state_reg) == 4'h5)", "sva_name": "p_request_active_prev_acknowledge_pending_state_reg", "id": "0104", "full_property": "property p_Request_Active_Ack_Pending;\n@(posedge clk_sys)     request_active == 1'b1 |-> $past(acknowledge_pending) && ($past(state_reg) == 4'h5)\nendproperty\nassert_p_Request_Active_Ack_Pending:assert property (p_Request_Active_Ack_Pending) else $error(\"\");", "task_id": "1_3930", "predict_sva": "@(posedge clk_sys)         request_active == 1'b1 |-> $past(acknowledge_pending) == 1'b1 && $past(state_reg) == 4'h5"}
{"sva": "@(posedge clk_can) disable iff(can_error) can_message_tx |-> ($past(arbitration_won) && $past(bus_idle, 1)) && !$past(error_passive_mode, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_Can_Message_Tx_After_Arbitration  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: `disable iff (can_error)`  \n**Antecedent (LHS of Implication)**: `can_message_tx == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(arbitration_won) && $past(bus_idle, 1)) && !$past(error_passive_mode, 2)`  ", "sva_signals": ["clk_can", "can_error", "can_message_tx", "arbitration_won", "bus_idle", "error_passive_mode"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can) disable iff (can_error)     can_message_tx == 1'b1 |->      ($past(arbitration_won) && $past(bus_idle, 1)) && !$past(error_passive_mode, 2)", "sva_name": "p_can_message_tx_arbitration_and_bus_idle_check", "id": "0095", "full_property": "property p_Can_Message_Tx_After_Arbitration;\n@(posedge clk_can) disable iff (can_error)     can_message_tx == 1'b1 |->      ($past(arbitration_won) && $past(bus_idle, 1)) && !$past(error_passive_mode, 2)\nendproperty\nassert_p_Can_Message_Tx_After_Arbitration:assert property (p_Can_Message_Tx_After_Arbitration) else $error(\"\");", "task_id": "1_3923", "predict_sva": "@(posedge clk_can) disable iff (can_error)         (can_error == 0 && can_message_tx == 1'b1) |->          ($past(arbitration_won, 1) == 1'b1 && $past(bus_idle, 1) == 1'b1 && $past(error_passive_mode, 2) == 1'b0)"}
{"sva": "@(posedge clk_can) disable iff(can_bus_off) message_send |-> ($past(bus_arbitration) && $past(dominant_bit, 1)) && !$past(error_passive, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_Message_Send_After_Arbitration  \n**Trigger Condition**: At every rising edge of `clk_can`  \n**Disable Condition**: `disable iff (can_bus_off)`  \n**Antecedent (LHS of Implication)**: `message_send == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(bus_arbitration) && $past(dominant_bit, 1)) && !$past(error_passive, 2)`  ", "sva_signals": ["clk_can", "can_bus_off", "[0:0] message_send", "[0:0] bus_arbitration", "[0:0] dominant_bit", "[0:0] error_passive"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can) disable iff (can_bus_off)     message_send == 1'b1 |-> ($past(bus_arbitration) && $past(dominant_bit, 1)) && !$past(error_passive, 2)", "sva_name": "p_message_send_arbitration_dominant_errorpassive", "id": "0183", "full_property": "property p_Message_Send_After_Arbitration;\n@(posedge clk_can) disable iff (can_bus_off)     message_send == 1'b1 |-> ($past(bus_arbitration) && $past(dominant_bit, 1)) && !$past(error_passive, 2)\nendproperty\nassert_p_Message_Send_After_Arbitration:assert property (p_Message_Send_After_Arbitration) else $error(\"\");", "task_id": "1_4004", "predict_sva": "@(posedge clk_can) disable iff (can_bus_off)         (can_bus_off == 0 && message_send == 1'b1) |->          ($past(bus_arbitration, 1) == 1 && $past(dominant_bit, 1) == 1 && $past(error_passive, 2) == 0)"}
{"sva": "@(negedge clk_phy) disable iff(phy_fault) link_establishment |-> $past(signal_detect, 2) && ($past(training_complete) && !$past(symbol_error))", "sva_description": "### Assertion description:  \n**Property Name**: p_Link_Establishment  \n**Trigger Condition**: At every falling edge of `clk_phy`  \n**Disable Condition**: `disable iff (phy_fault)`  \n**Antecedent (LHS of Implication)**: `link_establishment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(signal_detect, 2) && ($past(training_complete) && !$past(symbol_error))`  ", "sva_signals": ["clk_phy", "phy_fault", "[0:0] link_establishment", "[0:0] signal_detect", "[0:0] training_complete", "[0:0] symbol_error"], "clock": "clk_phy", "attempts_left": 10, "sva_result": "@(negedge clk_phy) disable iff (phy_fault)     link_establishment |-> ($past(signal_detect, 2) && ($past(training_complete) && !$past(symbol_error)))", "sva_name": "p_link_establishment_sequence_check", "id": "0184", "full_property": "property p_Link_Establishment;\n@(negedge clk_phy) disable iff (phy_fault)     link_establishment |-> ($past(signal_detect, 2) && ($past(training_complete) && !$past(symbol_error)))\nendproperty\nassert_p_Link_Establishment:assert property (p_Link_Establishment) else $error(\"\");", "task_id": "1_4005", "predict_sva": "@(negedge clk_phy) disable iff (phy_fault)         (phy_fault == 0 && link_establishment == 1) |->          ($past(signal_detect, 2) == 1) &&          ($past(training_complete, 1) == 1) &&          ($past(symbol_error, 1) == 0)"}
{"sva": "@(posedge clk) disable iff(watchdog_rst) cpu_pipeline |-> $past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush))", "sva_description": "### Assertion description:  \n**Property Name**: p_cpu_pipeline_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (watchdog_rst)`  \n**Antecedent (LHS of Implication)**: `cpu_pipeline == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush))`  ", "sva_signals": ["clk", "watchdog_rst", "cpu_pipeline", "[0:0] pc_increment", "[0:0] pipeline_stall", "[0:0] exception_flush"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (watchdog_rst)     cpu_pipeline == 1'b1 |-> ($past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush)))", "sva_name": "p_cpu_pipeline_pc_increment_dependency", "id": "0217", "full_property": "property p_cpu_pipeline_check;\n@(posedge clk) disable iff (watchdog_rst)     cpu_pipeline == 1'b1 |-> ($past(pc_increment) && (!$past(pipeline_stall, 2) || $past(exception_flush)))\nendproperty\nassert_p_cpu_pipeline_check:assert property (p_cpu_pipeline_check) else $error(\"\");", "task_id": "1_4036", "predict_sva": "@(posedge clk) disable iff (watchdog_rst)         (watchdog_rst == 0 && cpu_pipeline == 1) |-> ($past(pc_increment) == 1 && ($past(pipeline_stall, 2) == 0 || $past(exception_flush) == 1))"}
{"sva": "@(negedge sampling_clk) disable iff(!rst_async) adc_sample |-> $past(input_stable) && ($past(reference_voltage, 2) && $past(converter_ready))", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_sample_condition  \n**Trigger Condition**: At every falling edge of the `sampling_clk`  \n**Disable Condition**: disable iff (!rst_async)  \n**Antecedent (LHS of Implication)**: `adc_sample == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(input_stable)` must be true (i.e., `input_stable` was true in the previous cycle), AND  \n- `$past(reference_voltage, 2)` must be true (i.e., `reference_voltage` was true two cycles ago), AND  \n- `$past(converter_ready)` must be true (i.e., `converter_ready` was true in the previous cycle).  \n\n### Notes:  \n1. The assertion checks that when `adc_sample` is active (1), the conditions `input_stable`, `reference_voltage` (delayed by 2 cycles), and `converter_ready` (delayed by 1 cycle) must have been met in the past.  \n2. The assertion is asynchronously disabled if `rst_async` is low (`!rst_async`).  \n3. The evaluation occurs at the **negedge** of `sampling_clk`.", "sva_signals": ["sampling_clk", "rst_async", "[0:0] adc_sample", "[0:0] input_stable", "[0:0] reference_voltage", "[0:0] converter_ready"], "clock": "sampling_clk", "attempts_left": 10, "sva_result": "@(negedge sampling_clk) disable iff (!rst_async)     adc_sample == 1'b1 |->          $past(input_stable) &&          $past(reference_voltage, 2) &&          $past(converter_ready)", "sva_name": "p_adc_sample_past_conditions", "id": "0218", "full_property": "property p_adc_sample_condition;\n@(negedge sampling_clk) disable iff (!rst_async)     adc_sample == 1'b1 |->          $past(input_stable) &&          $past(reference_voltage, 2) &&          $past(converter_ready)\nendproperty\nassert_p_adc_sample_condition:assert property (p_adc_sample_condition) else $error(\"\");", "task_id": "1_4037", "predict_sva": "@(negedge sampling_clk) disable iff (!rst_async)         (rst_async == 1 && adc_sample == 1) |->          ($past(input_stable, 1) == 1) &&          ($past(reference_voltage, 2) == 1) &&          ($past(converter_ready, 1) == 1)"}
{"sva": "@(posedge clk_mem) disable iff(mem_power_down) bank_precharge |-> ($past(row_active_time, 1) > $past(minimum_ras)) && $past(no_pending_access)", "sva_description": "### Assertion description:  \n**Property Name**: p_bank_precharge_check  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: disable iff (mem_power_down)  \n**Antecedent (LHS of Implication)**: `bank_precharge == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(row_active_time, 1) > $past(minimum_ras))`  \n- `&& $past(no_pending_access)`  \n\nThe assertion checks that when `bank_precharge` is high, the following two conditions must hold:  \n1. The past value of `row_active_time` (1 clock cycle ago) must be greater than the past value of `minimum_ras`.  \n2. The past value of `no_pending_access` must be true (indicating no pending memory accesses).  \n\nThe assertion is disabled during `mem_power_down`.", "sva_signals": ["clk_mem", "mem_power_down", "[0:0] bank_precharge", "[0:0] row_active_time", "[0:0] minimum_ras", "[0:0] no_pending_access"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem) disable iff (mem_power_down)     bank_precharge == 1'b1 |->          ($past(row_active_time, 1) > $past(minimum_ras, 1)) &&          $past(no_pending_access, 1)", "sva_name": "p_bank_precharge_precondition_check", "id": "0259", "full_property": "property p_bank_precharge_check;\n@(posedge clk_mem) disable iff (mem_power_down)     bank_precharge == 1'b1 |->          ($past(row_active_time, 1) > $past(minimum_ras, 1)) &&          $past(no_pending_access, 1)\nendproperty\nassert_p_bank_precharge_check:assert property (p_bank_precharge_check) else $error(\"\");", "task_id": "1_4077", "predict_sva": "@(posedge clk_mem) disable iff (mem_power_down)         (mem_power_down == 0 && bank_precharge == 1'b1) |->          ($past(row_active_time) > $past(minimum_ras) && $past(no_pending_access) == 1'b1)"}
{"sva": "@(posedge clk_dma) disable iff(dma_abort) transfer_engine |-> $past(descriptor_valid, 1) |=> ($past(source_ready) && $past(destination_ready) && !$past(bus_error))", "sva_description": "### Assertion description:  \n**Property Name**: p_transfer_engine_check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: `disable iff (dma_abort)`  \n**Antecedent (LHS of Implication)**: `transfer_engine == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(descriptor_valid, 1) |=> ($past(source_ready) && $past(destination_ready) && !$past(bus_error))`  ", "sva_signals": ["clk_dma", "dma_abort", "[0:0] transfer_engine", "[0:0] descriptor_valid", "[0:0] source_ready", "[0:0] destination_ready", "[0:0] bus_error"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma) disable iff (dma_abort)     transfer_engine == 1'b1 |->      $past(descriptor_valid, 1) |=>      ($past(source_ready) && $past(destination_ready) && !$past(bus_error))", "sva_name": "p_transfer_engine_check", "id": "0284", "full_property": "property p_transfer_engine_check;\n@(posedge clk_dma) disable iff (dma_abort)     transfer_engine == 1'b1 |->      $past(descriptor_valid, 1) |=>      ($past(source_ready) && $past(destination_ready) && !$past(bus_error))\nendproperty\nassert_p_transfer_engine_check:assert property (p_transfer_engine_check) else $error(\"\");", "task_id": "1_4101", "predict_sva": "@(posedge clk_dma) disable iff (dma_abort)     transfer_engine == 1'b1 |->      $past(descriptor_valid) |=> ($past(source_ready) && $past(destination_ready) && !$past(bus_error))"}
{"sva": "@(posedge clk_network) disable iff(!network_reset_n) routing_table |-> $past(topology_update, 1) && ($past(convergence_timer) && !$past(loop_detection, 3))", "sva_description": "### Assertion description:  \n**Property Name**: p_routing_table_update  \n**Trigger Condition**: At every rising edge of the `clk_network`  \n**Disable Condition**: disable iff (!network_reset_n)  \n**Antecedent (LHS of Implication)**: `routing_table`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(topology_update, 1) && ($past(convergence_timer) && !$past(loop_detection, 3))`  ", "sva_signals": ["clk", "network_reset_n", "[0:0] routing_table", "[0:0] topology_update", "[0:0] convergence_timer", "[0:0] loop_detection", "clk_network"], "clock": "clk_network", "attempts_left": 10, "sva_result": "@(posedge clk_network) disable iff (!network_reset_n)     routing_table |-> $past(topology_update, 1) && ($past(convergence_timer) && !$past(loop_detection, 3))", "sva_name": "p_routing_table_precedence_check", "id": "0263", "full_property": "property p_routing_table_update;\n@(posedge clk_network) disable iff (!network_reset_n)     routing_table |-> $past(topology_update, 1) && ($past(convergence_timer) && !$past(loop_detection, 3))\nendproperty\nassert_p_routing_table_update:assert property (p_routing_table_update) else $error(\"\");", "task_id": "1_4081", "predict_sva": "@(posedge clk_network) disable iff (!network_reset_n)         (network_reset_n == 1 && routing_table == 1) |->          ($past(topology_update, 1) == 1 && $past(convergence_timer, 1) == 1 && $past(loop_detection, 3) == 0)"}
{"sva": "@(negedge clk_comp) disable iff(!comparator_on) threshold_detection |-> $past(input_signal, 1) && ($past(hysteresis_band) && !$past(noise_filter_active, 3))", "sva_description": "### Assertion description:  \n**Property Name**: p_threshold_detection  \n**Trigger Condition**: At every falling edge of the `clk_comp`  \n**Disable Condition**: disable iff (`!comparator_on`)  \n**Antecedent (LHS of Implication)**: `threshold_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(input_signal, 1) && ($past(hysteresis_band) && !$past(noise_filter_active, 3))`  \n\n", "sva_signals": ["clk", "comparator_on", "threshold_detection", "[0:0] input_signal", "[0:0] hysteresis_band", "[0:0] noise_filter_active", "clk_comp"], "clock": "clk_comp", "attempts_left": 10, "sva_result": "@(negedge clk_comp) disable iff (!comparator_on)     threshold_detection |->          $past(input_signal, 1) &&          ($past(hysteresis_band, 1) && !$past(noise_filter_active, 3))", "sva_name": "p_threshold_detection_input_hysteresis_noise_filter", "id": "0285", "full_property": "property p_threshold_detection;\n@(negedge clk_comp) disable iff (!comparator_on)     threshold_detection |->          $past(input_signal, 1) &&          ($past(hysteresis_band, 1) && !$past(noise_filter_active, 3))\nendproperty\nassert_p_threshold_detection:assert property (p_threshold_detection) else $error(\"\");", "task_id": "1_4102", "predict_sva": "@(negedge clk_comp) disable iff (!comparator_on)         (comparator_on == 1 && threshold_detection == 1) |->          ($past(input_signal, 1) == 1 && $past(hysteresis_band, 1) == 1 && $past(noise_filter_active, 3) == 0)"}
{"sva": "@(posedge clk_turbo) disable iff(turbo_disable) iterative_decode |-> ($past(extrinsic_information, 1) && $past(interleaver, 3)) && $past(stopping_criterion)", "sva_description": "### Assertion description:  \n**Property Name**: p_iterative_decode_check  \n**Trigger Condition**: At every rising edge of the `clk_turbo`  \n**Disable Condition**: `disable iff (turbo_disable)`  \n**Antecedent (LHS of Implication)**: `iterative_decode == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(extrinsic_information, 1) && $past(interleaver, 3)) && $past(stopping_criterion)`  ", "sva_signals": ["clk_turbo", "turbo_disable", "[0:0] iterative_decode", "[0:0] extrinsic_information", "[0:0] interleaver", "[0:0] stopping_criterion"], "clock": "clk_turbo", "attempts_left": 10, "sva_result": "@(posedge clk_turbo) disable iff (turbo_disable)     iterative_decode == 1'b1 |-> ($past(extrinsic_information, 1) && $past(interleaver, 3)) && $past(stopping_criterion)", "sva_name": "p_iterative_decode_sequence_check", "id": "0318", "full_property": "property p_iterative_decode_check;\n@(posedge clk_turbo) disable iff (turbo_disable)     iterative_decode == 1'b1 |-> ($past(extrinsic_information, 1) && $past(interleaver, 3)) && $past(stopping_criterion)\nendproperty\nassert_p_iterative_decode_check:assert property (p_iterative_decode_check) else $error(\"\");", "task_id": "1_4134", "predict_sva": "@(posedge clk_turbo) disable iff (turbo_disable)         (turbo_disable == 0 && iterative_decode == 1'b1) |->          ($past(extrinsic_information, 1) == 1'b1) &&          ($past(interleaver, 3) == 1'b1) &&          ($past(stopping_criterion, 1) == 1'b1)"}
{"sva": "@(posedge clk_equalizer) disable iff(eq_bypass) adaptive_filter |-> ($past(error_signal, 2) && $past(tap_weight_update)) |=> !$past(filter_instability)", "sva_description": "### Assertion description:  \n**Property Name**: p_adaptive_filter_check  \n**Trigger Condition**: At every rising edge of the `clk_equalizer`  \n**Disable Condition**: `disable iff (eq_bypass)`  \n**Antecedent (LHS of Implication)**: `adaptive_filter == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(error_signal, 2) && $past(tap_weight_update)) |=> !$past(filter_instability)`  \n\n**Explanation of Consequent**:  \n- The consequent checks that if the conditions `$past(error_signal, 2)` (error signal two cycles ago) **and** `$past(tap_weight_update)` (tap weight update signal one cycle ago) are both true, then in the **next cycle** (`|=>`), `$past(filter_instability)` (filter instability signal one cycle ago) must be **false**.  \n\n**Key Notes**:  \n1. The assertion is **disabled** when `eq_bypass` is active.  \n2. The check is triggered only when `adaptive_filter` is high.  \n3. The consequent involves **past values** of signals (`error_signal`, `tap_weight_update`, `filter_instability`) and a **delayed implication** (`|=>`).  \n4. The `|=>` operator ensures the check occurs **one cycle after** the antecedent conditions are met.  \n\n---  \nLet me know if you need further clarification!", "sva_signals": ["clk_equalizer", "eq_bypass", "[0:0] adaptive_filter", "[0:0] error_signal", "[0:0] tap_weight_update", "[0:0] filter_instability"], "clock": "clk_equalizer", "attempts_left": 10, "sva_result": "@(posedge clk_equalizer) disable iff (eq_bypass)     adaptive_filter == 1'b1 |->      ($past(error_signal, 2) && $past(tap_weight_update)) |=> !$past(filter_instability)", "sva_name": "p_filter_instability_prevented_on_adaptive_filter", "id": "0328", "full_property": "property p_adaptive_filter_check;\n@(posedge clk_equalizer) disable iff (eq_bypass)     adaptive_filter == 1'b1 |->      ($past(error_signal, 2) && $past(tap_weight_update)) |=> !$past(filter_instability)\nendproperty\nassert_p_adaptive_filter_check:assert property (p_adaptive_filter_check) else $error(\"\");", "task_id": "1_4142", "predict_sva": "@(posedge clk_equalizer) disable iff (eq_bypass)         (eq_bypass == 0 && adaptive_filter == 1'b1 && $past(error_signal, 2) == 1'b1 && $past(tap_weight_update, 1) == 1'b1) |-> ##1 $past(filter_instability, 1) == 1'b0"}
{"sva": "@(posedge clk) disable iff(thermal_fluctuation) brownian_motor |-> $past(ratchet_potential, 2) && ($past(thermal_noise) && $past(directional_motion, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_brownian_motor_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (thermal_fluctuation)  \n**Antecedent (LHS of Implication)**: `brownian_motor == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ratchet_potential, 2) && ($past(thermal_noise) && $past(directional_motion, 1))`  \n\n(Note: The consequent checks that:  \n1. The value of `ratchet_potential` from **two clock cycles ago** is true (`$past(ratchet_potential, 2)`),  \n2. The value of `thermal_noise` from **one clock cycle ago** is true (`$past(thermal_noise)`), and  \n3. The value of `directional_motion` from **one clock cycle ago** is true (`$past(directional_motion, 1)`).  \nAll three conditions must hold simultaneously when `brownian_motor` is active.)", "sva_signals": ["clk", "rst_n", "[0:0] thermal_fluctuation", "[0:0] brownian_motor", "[0:0] ratchet_potential", "[0:0] thermal_noise", "[0:0] directional_motion"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (thermal_fluctuation)     brownian_motor == 1'b1 |->          $past(ratchet_potential, 2) &&          $past(thermal_noise) &&          $past(directional_motion, 1)", "sva_name": "p_brownian_motor_past_conditions", "id": "0422", "full_property": "property p_brownian_motor_check;\n@(posedge clk) disable iff (thermal_fluctuation)     brownian_motor == 1'b1 |->          $past(ratchet_potential, 2) &&          $past(thermal_noise) &&          $past(directional_motion, 1)\nendproperty\nassert_p_brownian_motor_check:assert property (p_brownian_motor_check) else $error(\"\");", "task_id": "1_4233", "predict_sva": "@(posedge clk) disable iff (thermal_fluctuation)         (thermal_fluctuation == 0 && brownian_motor == 1) |->          ($past(ratchet_potential, 2) == 1) &&          ($past(thermal_noise, 1) == 1) &&          ($past(directional_motion, 1) == 1)"}
{"sva": "@(negedge clk_ferroelectric) disable iff(!ferroelectric_switching) memory_storage |-> $past(polarization_reversal, 3) |=> ($past(retention_time) && $past(endurance_cycles))", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_storage_condition  \n**Trigger Condition**: At every falling edge of the `clk_ferroelectric`  \n**Disable Condition**: `disable iff (!ferroelectric_switching)`  \n**Antecedent (LHS of Implication)**: `memory_storage`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(polarization_reversal, 3) |=> ($past(retention_time) && $past(endurance_cycles))`  ", "sva_signals": ["clk_ferroelectric", "ferroelectric_switching", "[0:0] memory_storage", "[0:0] polarization_reversal", "[0:0] retention_time", "[0:0] endurance_cycles"], "clock": "clk_ferroelectric", "attempts_left": 10, "sva_result": "@(negedge clk_ferroelectric) disable iff (!ferroelectric_switching)     memory_storage |-> $past(polarization_reversal, 3) |=> ($past(retention_time) && $past(endurance_cycles))", "sva_name": "p_memory_storage_retention_endurance_check", "id": "0435", "full_property": "property p_memory_storage_condition;\n@(negedge clk_ferroelectric) disable iff (!ferroelectric_switching)     memory_storage |-> $past(polarization_reversal, 3) |=> ($past(retention_time) && $past(endurance_cycles))\nendproperty\nassert_p_memory_storage_condition:assert property (p_memory_storage_condition) else $error(\"\");", "task_id": "1_4246", "predict_sva": "@(negedge clk_ferroelectric) disable iff (!ferroelectric_switching)         (ferroelectric_switching == 1 && memory_storage == 1 && $past(polarization_reversal, 3)) |-> ##1 ($past(retention_time, 1) == 1 && $past(endurance_cycles, 1) == 1)"}
{"sva": "@(posedge clk_gesture) disable iff(gesture_sensor_fault) human_robot_interaction |-> ($past(hand_tracking, 1) && $past(gesture_vocabulary, 2)) && $past(intent_recognition, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Human_Robot_Interaction  \n**Trigger Condition**: At every rising edge of the `clk_gesture`  \n**Disable Condition**: `disable iff (gesture_sensor_fault)`  \n**Antecedent (LHS of Implication)**: `human_robot_interaction == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(hand_tracking, 1)` must be true (1 clock cycle ago)  \n- `$past(gesture_vocabulary, 2)` must be true (2 clock cycles ago)  \n- `$past(intent_recognition, 3)` must be true (3 clock cycles ago)  \nThe consequent requires all three past conditions to be simultaneously true.", "sva_signals": ["clk_gesture", "gesture_sensor_fault", "[0:0] human_robot_interaction", "[0:0] hand_tracking", "[0:0] gesture_vocabulary", "[0:0] intent_recognition"], "clock": "clk_gesture", "attempts_left": 10, "sva_result": "@(posedge clk_gesture) disable iff (gesture_sensor_fault)     human_robot_interaction == 1'b1 |->     $past(hand_tracking, 1) &&      $past(gesture_vocabulary, 2) &&      $past(intent_recognition, 3)", "sva_name": "p_human_robot_interaction_past_dependencies", "id": "0468", "full_property": "property p_Human_Robot_Interaction;\n@(posedge clk_gesture) disable iff (gesture_sensor_fault)     human_robot_interaction == 1'b1 |->     $past(hand_tracking, 1) &&      $past(gesture_vocabulary, 2) &&      $past(intent_recognition, 3)\nendproperty\nassert_p_Human_Robot_Interaction:assert property (p_Human_Robot_Interaction) else $error(\"\");", "task_id": "1_4277", "predict_sva": "@(posedge clk_gesture) disable iff (gesture_sensor_fault)         (gesture_sensor_fault == 0 && human_robot_interaction == 1'b1) |->          ($past(hand_tracking, 1) == 1'b1) &&          ($past(gesture_vocabulary, 2) == 1'b1) &&          ($past(intent_recognition, 3) == 1'b1)"}
{"sva": "@(posedge clk_biocomputing) disable iff(enzyme_inhibition) dna_computing |-> ($past(hybridization_reaction, 1) && $past(strand_displacement, 2)) && !$past(cross_hybridization, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_dna_computing_check  \n**Trigger Condition**: At every rising edge of the `clk_biocomputing`  \n**Disable Condition**: disable iff (`enzyme_inhibition`)  \n**Antecedent (LHS of Implication)**: `dna_computing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`$past(hybridization_reaction, 1)` && `$past(strand_displacement, 2)`) && !`$past(cross_hybridization, 3)`", "sva_signals": ["clk_biocomputing", "enzyme_inhibition", "[0:0] dna_computing", "[0:0] hybridization_reaction", "[0:0] strand_displacement", "[0:0] cross_hybridization"], "clock": "clk_biocomputing", "attempts_left": 10, "sva_result": "@(posedge clk_biocomputing) disable iff (enzyme_inhibition)     dna_computing |-> ($past(hybridization_reaction, 1) && $past(strand_displacement, 2)) && !$past(cross_hybridization, 3)", "sva_name": "p_dna_computing_sequence_check", "id": "0469", "full_property": "property p_dna_computing_check;\n@(posedge clk_biocomputing) disable iff (enzyme_inhibition)     dna_computing |-> ($past(hybridization_reaction, 1) && $past(strand_displacement, 2)) && !$past(cross_hybridization, 3)\nendproperty\nassert_p_dna_computing_check:assert property (p_dna_computing_check) else $error(\"\");", "task_id": "1_4278", "predict_sva": "@(posedge clk_biocomputing) disable iff (enzyme_inhibition)         (enzyme_inhibition == 0 && dna_computing == 1) |->          ($past(hybridization_reaction, 1) == 1) &&          ($past(strand_displacement, 2) == 1) &&          ($past(cross_hybridization, 3) == 0)"}
{"sva": "@(posedge clk_brain_interface) disable iff(neural_noise_high) thought_controlled_computing |-> ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Thought_Controlled_Computing  \n**Trigger Condition**: At every rising edge of the `clk_brain_interface`  \n**Disable Condition**: `disable iff (neural_noise_high)`  \n**Antecedent (LHS of Implication)**: `thought_controlled_computing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)`  ", "sva_signals": ["clk_brain_interface", "neural_noise_high", "thought_controlled_computing", "[0:0] eeg_signal_processing", "[0:0] motor_imagery", "[0:0] classification_accuracy"], "clock": "clk_brain_interface", "attempts_left": 10, "sva_result": "@(posedge clk_brain_interface) disable iff (neural_noise_high)     thought_controlled_computing |->          ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)", "sva_name": "p_thought_controlled_computing_sequence_check", "id": "0538", "full_property": "property p_Thought_Controlled_Computing;\n@(posedge clk_brain_interface) disable iff (neural_noise_high)     thought_controlled_computing |->          ($past(eeg_signal_processing, 1) && $past(motor_imagery, 3)) && $past(classification_accuracy)\nendproperty\nassert_p_Thought_Controlled_Computing:assert property (p_Thought_Controlled_Computing) else $error(\"\");", "task_id": "1_4342", "predict_sva": "@(posedge clk_brain_interface) disable iff (neural_noise_high)         (neural_noise_high == 0 && thought_controlled_computing == 1) |->          ($past(eeg_signal_processing, 1) == 1) &&          ($past(motor_imagery, 3) == 1) &&          ($past(classification_accuracy, 1) == 1)"}
{"sva": "@(posedge clk_galaxy_formation) disable iff(dark_energy_dominance) cosmological_structure |-> ($past(dark_matter_halo, 2) && $past(baryonic_matter_accretion)) |=> !$past(galaxy_collision)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cosmological_Structure_Check  \n**Trigger Condition**: At every rising edge of the `clk_galaxy_formation`  \n**Disable Condition**: `disable iff (dark_energy_dominance)`  \n**Antecedent (LHS of Implication)**: `cosmological_structure`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(dark_matter_halo, 2) && $past(baryonic_matter_accretion)) |=> !$past(galaxy_collision)`  ", "sva_signals": ["clk_galaxy_formation", "dark_energy_dominance", "[0:0] cosmological_structure", "[0:0] dark_matter_halo", "[0:0] baryonic_matter_accretion", "[0:0] galaxy_collision"], "clock": "clk_galaxy_formation", "attempts_left": 10, "sva_result": "@(posedge clk_galaxy_formation) disable iff (dark_energy_dominance)     cosmological_structure |->      ($past(dark_matter_halo, 2) && $past(baryonic_matter_accretion)) |=> !$past(galaxy_collision)", "sva_name": "p_no_galaxy_collision_on_cosmological_structure", "id": "0584", "full_property": "property p_Cosmological_Structure_Check;\n@(posedge clk_galaxy_formation) disable iff (dark_energy_dominance)     cosmological_structure |->      ($past(dark_matter_halo, 2) && $past(baryonic_matter_accretion)) |=> !$past(galaxy_collision)\nendproperty\nassert_p_Cosmological_Structure_Check:assert property (p_Cosmological_Structure_Check) else $error(\"\");", "task_id": "1_4386", "predict_sva": "@(posedge clk_galaxy_formation) disable iff (dark_energy_dominance)         (dark_energy_dominance == 0 && cosmological_structure == 1 && $past(baryonic_matter_accretion, 1) == 1 && $past(dark_matter_halo, 2) == 1) |-> ##1 $past(galaxy_collision, 1) == 0"}
{"sva": "@(posedge clk_vehicle_access) disable iff(vehicle_theft_attempt) automotive_biometrics |-> ($past(driver_face_recognition, 1) && $past(steering_wheel_grip, 2)) && !$past(unauthorized_access, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Automotive_Biometrics_Check  \n**Trigger Condition**: At every rising edge of the `clk_vehicle_access`  \n**Disable Condition**: disable iff (`vehicle_theft_attempt`)  \n**Antecedent (LHS of Implication)**: `automotive_biometrics == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe following conditions must hold true:  \n1. `$past(driver_face_recognition, 1)` (driver face recognition was valid 1 clock cycle ago)  \n2. `$past(steering_wheel_grip, 2)` (steering wheel grip was detected 2 clock cycles ago)  \n3. `!$past(unauthorized_access, 3)` (no unauthorized access occurred 3 clock cycles ago)  \n\nThe consequent requires all three past conditions to be simultaneously true when `automotive_biometrics` is asserted.", "sva_signals": ["clk_vehicle_access", "vehicle_theft_attempt", "[0:0] automotive_biometrics", "[0:0] driver_face_recognition", "[0:0] steering_wheel_grip", "[0:0] unauthorized_access"], "clock": "clk_vehicle_access", "attempts_left": 10, "sva_result": "@(posedge clk_vehicle_access) disable iff (vehicle_theft_attempt)     automotive_biometrics == 1'b1 |->     $past(driver_face_recognition, 1) &&     $past(steering_wheel_grip, 2) &&     !$past(unauthorized_access, 3)", "sva_name": "p_automotive_biometrics_sequence_check", "id": "0642", "full_property": "property p_Automotive_Biometrics_Check;\n@(posedge clk_vehicle_access) disable iff (vehicle_theft_attempt)     automotive_biometrics == 1'b1 |->     $past(driver_face_recognition, 1) &&     $past(steering_wheel_grip, 2) &&     !$past(unauthorized_access, 3)\nendproperty\nassert_p_Automotive_Biometrics_Check:assert property (p_Automotive_Biometrics_Check) else $error(\"\");", "task_id": "1_4439", "predict_sva": "@(posedge clk_vehicle_access) disable iff (vehicle_theft_attempt)         (vehicle_theft_attempt == 0 && automotive_biometrics == 1) |->          ($past(driver_face_recognition, 1) == 1) &&          ($past(steering_wheel_grip, 2) == 1) &&          ($past(unauthorized_access, 3) == 0)"}
{"sva": "@(posedge clk_insurance) disable iff(insurance_fraud_detected) claim_verification |-> ($past(claimant_identity_verification, 1) && $past(injury_assessment, 2)) && !$past(fraudulent_claim, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_claim_verification  \n**Trigger Condition**: At every rising edge of the `clk_insurance`  \n**Disable Condition**: disable iff (`insurance_fraud_detected`)  \n**Antecedent (LHS of Implication)**: `claim_verification == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n(`$past(claimant_identity_verification, 1)` && `$past(injury_assessment, 2)`) && !`$past(fraudulent_claim, 3)`  ", "sva_signals": ["clk_insurance", "insurance_fraud_detected", "[0:0] claim_verification", "[0:0] claimant_identity_verification", "[0:0] injury_assessment", "[0:0] fraudulent_claim"], "clock": "clk_insurance", "attempts_left": 10, "sva_result": "@(posedge clk_insurance) disable iff (insurance_fraud_detected)     claim_verification == 1'b1 |->     ($past(claimant_identity_verification, 1) && $past(injury_assessment, 2)) &&      !$past(fraudulent_claim, 3)", "sva_name": "p_claim_verification_sequence_check", "id": "0663", "full_property": "property p_claim_verification;\n@(posedge clk_insurance) disable iff (insurance_fraud_detected)     claim_verification == 1'b1 |->     ($past(claimant_identity_verification, 1) && $past(injury_assessment, 2)) &&      !$past(fraudulent_claim, 3)\nendproperty\nassert_p_claim_verification:assert property (p_claim_verification) else $error(\"\");", "task_id": "1_4457", "predict_sva": "@(posedge clk_insurance) disable iff (insurance_fraud_detected)         (insurance_fraud_detected == 0 && claim_verification == 1) |->          ($past(claimant_identity_verification, 1) == 1) &&          ($past(injury_assessment, 2) == 1) &&          ($past(fraudulent_claim, 3) == 0)"}
{"sva": "@(posedge clk_casino_surveillance) disable iff(gambling_regulation_breach) gaming_security |-> ($past(card_counter_identification, 2) && $past(collusion_detection)) |=> !$past(cheating_activity)", "sva_description": "### Assertion description:  \n**Property Name**: p_Gaming_Security_Check  \n**Trigger Condition**: At every rising edge of the `clk_casino_surveillance`  \n**Disable Condition**: disable iff (`gambling_regulation_breach`)  \n**Antecedent (LHS of Implication)**: `gaming_security == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- **First Condition**: `($past(card_counter_identification, 2) && $past(collusion_detection))`  \n  - Checks if `card_counter_identification` was true **two cycles ago** and `collusion_detection` was true **one cycle ago**.  \n- **Immediate Follow-up (|=>)**: `!$past(cheating_activity)`  \n  - Ensures that in the **next cycle**, `cheating_activity` was **not true in the previous cycle**.  \n\n### Key Notes:  \n1. **Temporal Dependencies**:  \n   - `$past(card_counter_identification, 2)` looks back **two clock cycles**.  \n   - `$past(collusion_detection)` (no depth specified) defaults to **one cycle**.  \n   - `|=>` enforces the consequent (`!$past(cheating_activity)`) in the **next cycle** after the antecedent evaluates true.  \n\n2. **Safety Check**:  \n   - The assertion ensures that when `gaming_security` is active, historical checks (`card_counter_identification` and `collusion_detection`) must have passed, and no `cheating_activity` occurred in the immediately preceding cycle.  \n\n3. **Reset Behavior**:  \n   - Disabled entirely if `gambling_regulation_breach` is asserted (active-high reset condition).  \n\n---  \nThis description captures the temporal logic, reset behavior, and combinatorial conditions of the original SVA while maintaining clarity for verification or documentation purposes.", "sva_signals": ["clk_casino_surveillance", "gambling_regulation_breach", "[0:0] gaming_security", "[0:0] card_counter_identification", "[0:0] collusion_detection", "[0:0] cheating_activity"], "clock": "clk_casino_surveillance", "attempts_left": 10, "sva_result": "@(posedge clk_casino_surveillance) disable iff (gambling_regulation_breach)     gaming_security == 1'b1 |->      ($past(card_counter_identification, 2) && $past(collusion_detection)) |=>      !$past(cheating_activity)", "sva_name": "p_Gaming_Security_Check", "id": "0676", "full_property": "property p_Gaming_Security_Check;\n@(posedge clk_casino_surveillance) disable iff (gambling_regulation_breach)     gaming_security == 1'b1 |->      ($past(card_counter_identification, 2) && $past(collusion_detection)) |=>      !$past(cheating_activity)\nendproperty\nassert_p_Gaming_Security_Check:assert property (p_Gaming_Security_Check) else $error(\"\");", "task_id": "1_4470", "predict_sva": "@(posedge clk_casino_surveillance) disable iff (gambling_regulation_breach)     gaming_security |->          ($past(card_counter_identification, 2) &&           $past(collusion_detection)) |=> !$past(cheating_activity)"}
{"sva": "@(posedge clk_water_cycle) disable iff(hydrological_disruption) freshwater_management |-> ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=> !$past(water_scarcity_crisis)", "sva_description": "### Assertion description:  \n**Property Name**: p_Freshwater_Management_Impact  \n**Trigger Condition**: At every rising edge of the `clk_water_cycle`  \n**Disable Condition**: `disable iff (hydrological_disruption)`  \n**Antecedent (LHS of Implication)**: `freshwater_management == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=> !$past(water_scarcity_crisis)`  \n\n**Explanation of Consequent**:  \n- The consequent checks that **if** the logical AND of:  \n  1. Value of `precipitation_pattern` **two cycles ago** (`$past(precipitation_pattern, 2)`)  \n  2. Value of `groundwater_depletion` **one cycle ago** (`$past(groundwater_depletion)`)  \n  **is true**, then **in the next cycle** (`|=>`), the value of `water_scarcity_crisis` **one cycle ago** (`$past(water_scarcity_crisis)`) must be **false** (`!`).  \n\n**Key Notes**:  \n- The `|=>` operator enforces a **next-cycle** relationship between the past conditions and the expected outcome.  \n- Temporal checks rely on historical values (`$past`) to evaluate the impact of `freshwater_management`.  \n- Assertion is **disabled** during `hydrological_disruption` to ignore invalid states.", "sva_signals": ["clk_water_cycle", "hydrological_disruption", "[0:0] freshwater_management", "[0:0] precipitation_pattern", "[0:0] groundwater_depletion", "[0:0] water_scarcity_crisis"], "clock": "clk_water_cycle", "attempts_left": 10, "sva_result": "@(posedge clk_water_cycle) disable iff (hydrological_disruption)     freshwater_management == 1'b1 |->      ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=>      !$past(water_scarcity_crisis)", "sva_name": "p_water_scarcity_crisis_prevented_on_freshwater_management", "id": "0674", "full_property": "property p_Freshwater_Management_Impact;\n@(posedge clk_water_cycle) disable iff (hydrological_disruption)     freshwater_management == 1'b1 |->      ($past(precipitation_pattern, 2) && $past(groundwater_depletion)) |=>      !$past(water_scarcity_crisis)\nendproperty\nassert_p_Freshwater_Management_Impact:assert property (p_Freshwater_Management_Impact) else $error(\"\");", "task_id": "1_4468", "predict_sva": "@(posedge clk_water_cycle) disable iff (hydrological_disruption)         (hydrological_disruption == 0 && freshwater_management == 1 && $past(precipitation_pattern, 2) == 1 && $past(groundwater_depletion, 1) == 1) |-> ##1 $past(water_scarcity_crisis, 1) == 0"}
{"sva": "@(posedge clk) disable iff(!sustainable_development_goals_tracking) global_sustainability_index |-> $past(poverty_reduction_rate, 1) && ($past(education_access_improvement, 3) && $past(gender_equality_progress))", "sva_description": "### Assertion description:  \n**Property Name**: p_Global_Sustainability_Index_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!sustainable_development_goals_tracking)`  \n**Antecedent (LHS of Implication)**: `global_sustainability_index == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(poverty_reduction_rate, 1) && ($past(education_access_improvement, 3) && $past(gender_equality_progress))`  ", "sva_signals": ["clk", "[0:0] sustainable_development_goals_tracking", "[0:0] global_sustainability_index", "[0:0] poverty_reduction_rate", "[0:0] education_access_improvement", "[0:0] gender_equality_progress"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!sustainable_development_goals_tracking)     global_sustainability_index == 1'b1 |->      $past(poverty_reduction_rate, 1) &&      ($past(education_access_improvement, 3) && $past(gender_equality_progress))", "sva_name": "p_global_sustainability_index_dependency", "id": "0688", "full_property": "property p_Global_Sustainability_Index_Check;\n@(posedge clk) disable iff (!sustainable_development_goals_tracking)     global_sustainability_index == 1'b1 |->      $past(poverty_reduction_rate, 1) &&      ($past(education_access_improvement, 3) && $past(gender_equality_progress))\nendproperty\nassert_p_Global_Sustainability_Index_Check:assert property (p_Global_Sustainability_Index_Check) else $error(\"\");", "task_id": "1_4481", "predict_sva": "@(posedge clk) disable iff (!sustainable_development_goals_tracking)         (sustainable_development_goals_tracking == 1 && global_sustainability_index == 1) |->          ($past(poverty_reduction_rate, 1) == 1) &&          ($past(education_access_improvement, 3) == 1) &&          ($past(gender_equality_progress, 1) == 1)"}
{"sva": "@(posedge clk) disable iff(!one_health_approach_implemented) zoonotic_disease_prevention |-> $past(animal_human_interface_surveillance, 2) && ($past(environmental_reservoir_monitoring) && $past(cross_species_transmission_risk, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Zoonotic_Disease_Prevention  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!one_health_approach_implemented)`  \n**Antecedent (LHS of Implication)**: `zoonotic_disease_prevention == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(animal_human_interface_surveillance, 2) && ($past(environmental_reservoir_monitoring) && $past(cross_species_transmission_risk, 1))`  ", "sva_signals": ["clk", "one_health_approach_implemented", "zoonotic_disease_prevention", "animal_human_interface_surveillance", "environmental_reservoir_monitoring", "cross_species_transmission_risk"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!one_health_approach_implemented)     zoonotic_disease_prevention == 1'b1 |->      $past(animal_human_interface_surveillance, 2) &&      ($past(environmental_reservoir_monitoring) && $past(cross_species_transmission_risk, 1))", "sva_name": "p_zoonotic_disease_prevention_sequence_check", "id": "0731", "full_property": "property p_Zoonotic_Disease_Prevention;\n@(posedge clk) disable iff (!one_health_approach_implemented)     zoonotic_disease_prevention == 1'b1 |->      $past(animal_human_interface_surveillance, 2) &&      ($past(environmental_reservoir_monitoring) && $past(cross_species_transmission_risk, 1))\nendproperty\nassert_p_Zoonotic_Disease_Prevention:assert property (p_Zoonotic_Disease_Prevention) else $error(\"\");", "task_id": "1_4522", "predict_sva": "@(posedge clk) disable iff (!one_health_approach_implemented)         (one_health_approach_implemented == 1 && zoonotic_disease_prevention == 1) |->          ($past(animal_human_interface_surveillance, 2) == 1) &&          ($past(environmental_reservoir_monitoring, 1) == 1 && $past(cross_species_transmission_risk, 1) == 1)"}
{"sva": "@(posedge clk_gaming) disable iff(game_economy_imbalance) blockchain_gaming |-> ($past(in_game_asset_ownership, 1) && $past(play_to_earn_mechanism, 3)) && $past(economic_sustainability)", "sva_description": "### Assertion description:  \n**Property Name**: p_blockchain_gaming_validation  \n**Trigger Condition**: At every rising edge of the `clk_gaming`  \n**Disable Condition**: disable iff (`game_economy_imbalance`)  \n**Antecedent (LHS of Implication)**: `blockchain_gaming`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The current value of `in_game_asset_ownership` from 1 clock cycle ago (`$past(in_game_asset_ownership, 1)`) must be true,  \n- The current value of `play_to_earn_mechanism` from 3 clock cycles ago (`$past(play_to_earn_mechanism, 3)`) must be true,  \n- The current value of `economic_sustainability` from 1 clock cycle ago (`$past(economic_sustainability)`) must be true.  \n\nThe consequent requires all three past conditions to be simultaneously true when the antecedent (`blockchain_gaming`) is active.", "sva_signals": ["clk_gaming", "game_economy_imbalance", "blockchain_gaming", "in_game_asset_ownership", "play_to_earn_mechanism", "economic_sustainability"], "clock": "clk_gaming", "attempts_left": 10, "sva_result": "@(posedge clk_gaming) disable iff (game_economy_imbalance)     blockchain_gaming |-> (         $past(in_game_asset_ownership, 1) &&         $past(play_to_earn_mechanism, 3) &&         $past(economic_sustainability, 1)     )", "sva_name": "p_blockchain_gaming_conditions", "id": "0782", "full_property": "property p_blockchain_gaming_validation;\n@(posedge clk_gaming) disable iff (game_economy_imbalance)     blockchain_gaming |-> (         $past(in_game_asset_ownership, 1) &&         $past(play_to_earn_mechanism, 3) &&         $past(economic_sustainability, 1)     )\nendproperty\nassert_p_blockchain_gaming_validation:assert property (p_blockchain_gaming_validation) else $error(\"\");", "task_id": "1_4573", "predict_sva": "@(posedge clk_gaming) disable iff (game_economy_imbalance)         (game_economy_imbalance == 0 && blockchain_gaming == 1) |->          ($past(in_game_asset_ownership, 1) == 1) &&          ($past(play_to_earn_mechanism, 3) == 1) &&          ($past(economic_sustainability, 1) == 1)"}
{"sva": "@(posedge clk_dao_treasury) disable iff(treasury_governance_attack) decentralized_treasury |-> ($past(spending_proposal_evaluation, 1) && $past(multi_sig_approval, 2)) && !$past(fund_misappropriation, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Decentralized_Treasury_Check  \n**Trigger Condition**: At every rising edge of the `clk_dao_treasury`  \n**Disable Condition**: `disable iff (treasury_governance_attack)`  \n**Antecedent (LHS of Implication)**: `decentralized_treasury`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(spending_proposal_evaluation, 1) && $past(multi_sig_approval, 2)) && !$past(fund_misappropriation, 3)`  ", "sva_signals": ["clk_dao_treasury", "treasury_governance_attack", "[0:0] decentralized_treasury", "[0:0] spending_proposal_evaluation", "[0:0] multi_sig_approval", "[0:0] fund_misappropriation"], "clock": "clk_dao_treasury", "attempts_left": 10, "sva_result": "@(posedge clk_dao_treasury) disable iff (treasury_governance_attack)     decentralized_treasury |-> ($past(spending_proposal_evaluation, 1) && $past(multi_sig_approval, 2)) && !$past(fund_misappropriation, 3)", "sva_name": "p_decentralized_treasury_proposal_evaluation", "id": "0831", "full_property": "property p_Decentralized_Treasury_Check;\n@(posedge clk_dao_treasury) disable iff (treasury_governance_attack)     decentralized_treasury |-> ($past(spending_proposal_evaluation, 1) && $past(multi_sig_approval, 2)) && !$past(fund_misappropriation, 3)\nendproperty\nassert_p_Decentralized_Treasury_Check:assert property (p_Decentralized_Treasury_Check) else $error(\"\");", "task_id": "1_4618", "predict_sva": "@(posedge clk_dao_treasury) disable iff (treasury_governance_attack)         (treasury_governance_attack == 0 && decentralized_treasury == 1) |->          ($past(spending_proposal_evaluation, 1) == 1) &&          ($past(multi_sig_approval, 2) == 1) &&          ($past(fund_misappropriation, 3) == 0)"}
{"sva": "@(negedge clk_distillation) disable iff(alcohol_concentration_deviation) spirit_production |-> $past(vapor_temperature_monitoring, 2) |=> ($past(congener_separation_efficiency) && $past(product_purity_achievement))", "sva_description": "### Assertion description:  \n**Property Name**: p_Spirit_Production_Safety  \n**Trigger Condition**: At every falling edge of the `clk_distillation`  \n**Disable Condition**: `disable iff (alcohol_concentration_deviation)`  \n**Antecedent (LHS of Implication)**: `spirit_production == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(vapor_temperature_monitoring, 2) |=> ($past(congener_separation_efficiency) && $past(product_purity_achievement))`  ", "sva_signals": ["clk_distillation", "alcohol_concentration_deviation", "spirit_production", "vapor_temperature_monitoring", "congener_separation_efficiency", "product_purity_achievement"], "clock": "clk_distillation", "attempts_left": 10, "sva_result": "@(negedge clk_distillation) disable iff (alcohol_concentration_deviation)     spirit_production == 1'b1 |->     $past(vapor_temperature_monitoring, 2) |=>      ($past(congener_separation_efficiency) && $past(product_purity_achievement))", "sva_name": "p_spirit_production_check", "id": "0924", "full_property": "property p_Spirit_Production_Safety;\n@(negedge clk_distillation) disable iff (alcohol_concentration_deviation)     spirit_production == 1'b1 |->     $past(vapor_temperature_monitoring, 2) |=>      ($past(congener_separation_efficiency) && $past(product_purity_achievement))\nendproperty\nassert_p_Spirit_Production_Safety:assert property (p_Spirit_Production_Safety) else $error(\"\");", "task_id": "1_4703", "predict_sva": "@(negedge clk_distillation) disable iff (alcohol_concentration_deviation == 1'b1)     spirit_production == 1'b1 |->      $past(vapor_temperature_monitoring, 2) |=>      ($past(congener_separation_efficiency) && $past(product_purity_achievement))"}
{"sva": "@(negedge clk_sonic_branding) disable iff(brand_identity_inconsistency) audio_logo_recognition |-> $past(acoustic_signature_extraction, 3) && ($past(brand_association_strength) || $past(memorability_index, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_audio_logo_recognition  \n**Trigger Condition**: At every negedge of the `clk_sonic_branding`  \n**Disable Condition**: disable iff (`brand_identity_inconsistency`)  \n**Antecedent (LHS of Implication)**: `audio_logo_recognition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(acoustic_signature_extraction, 3) && ($past(brand_association_strength) || $past(memorability_index, 1))`  ", "sva_signals": ["clk_sonic_branding", "brand_identity_inconsistency", "[0:0] audio_logo_recognition", "[0:0] acoustic_signature_extraction", "[0:0] brand_association_strength", "[0:0] memorability_index"], "clock": "clk_sonic_branding", "attempts_left": 10, "sva_result": "@(negedge clk_sonic_branding) disable iff (brand_identity_inconsistency)     audio_logo_recognition |->      $past(acoustic_signature_extraction, 3) &&      ($past(brand_association_strength) || $past(memorability_index, 1))", "sva_name": "p_audio_logo_recognition_validity", "id": "0855", "full_property": "property p_audio_logo_recognition;\n@(negedge clk_sonic_branding) disable iff (brand_identity_inconsistency)     audio_logo_recognition |->      $past(acoustic_signature_extraction, 3) &&      ($past(brand_association_strength) || $past(memorability_index, 1))\nendproperty\nassert_p_audio_logo_recognition:assert property (p_audio_logo_recognition) else $error(\"\");", "task_id": "1_4640", "predict_sva": "@(negedge clk_sonic_branding) disable iff (brand_identity_inconsistency)         (brand_identity_inconsistency == 0 && audio_logo_recognition == 1) |->          ($past(acoustic_signature_extraction, 3) == 1) &&          ($past(brand_association_strength, 1) == 1 || $past(memorability_index, 1) == 1)"}
{"sva": "@(posedge clk) branch_taken && $past(condition_met) |-> $past(branch_predict) == prediction", "sva_description": "### Assertion description:  \n**Property Name**: p_Branch_Prediction  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `branch_taken && $past(condition_met)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(branch_predict) == prediction`", "sva_signals": ["clk", "rst_n", "[0:0] branch_taken", "[0:0] condition_met", "[0:0] branch_predict", "[0:0] prediction"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (branch_taken && $past(condition_met)) |-> ($past(branch_predict) == prediction)", "sva_name": "p_branch_prediction_match", "id": "1045", "full_property": "property p_Branch_Prediction;\n@(posedge clk)         (branch_taken && $past(condition_met)) |-> ($past(branch_predict) == prediction)\nendproperty\nassert_p_Branch_Prediction:assert property (p_Branch_Prediction) else $error(\"\");", "task_id": "1_4812", "predict_sva": "@(posedge clk)         (branch_taken == 1 && $past(condition_met) == 1) |-> (prediction == $past(branch_predict))"}
{"sva": "@(posedge clk) disable iff(rst == 1'b1) mem_access |-> $past(addr_valid) && $past(data_setup)", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_access_after_valid_setup  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (rst == 1'b1)`  \n**Antecedent (LHS of Implication)**: `mem_access == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(addr_valid) && $past(data_setup)`  ", "sva_signals": ["clk", "rst", "[0:0] mem_access", "[0:0] addr_valid", "[0:0] data_setup"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst == 1'b1)     mem_access == 1'b1 |-> $past(addr_valid) && $past(data_setup)", "sva_name": "p_mem_access_requires_prev_addr_valid_and_data_setup", "id": "0994", "full_property": "property p_mem_access_after_valid_setup;\n@(posedge clk) disable iff (rst == 1'b1)     mem_access == 1'b1 |-> $past(addr_valid) && $past(data_setup)\nendproperty\nassert_p_mem_access_after_valid_setup:assert property (p_mem_access_after_valid_setup) else $error(\"\");", "task_id": "1_4766", "predict_sva": "@(posedge clk) disable iff (rst)         (rst == 0 && mem_access == 1) |-> ($past(addr_valid) == 1 && $past(data_setup) == 1)"}
{"sva": "@(posedge clk) disable iff(!rst) arbitration_grant |-> $past(request_priority) == highest_priority", "sva_description": "### Assertion description:  \n**Property Name**: p_arbitration_grant_priority  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff `(!rst)`  \n**Antecedent (LHS of Implication)**: `arbitration_grant == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(request_priority) == highest_priority`  ", "sva_signals": ["clk", "rst", "[0:0] arbitration_grant", "[0:0] request_priority", "[0:0] highest_priority"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst)     arbitration_grant == 1'b1 |-> $past(request_priority) == highest_priority", "sva_name": "p_arbitration_grant_priority_check", "id": "1059", "full_property": "property p_arbitration_grant_priority;\n@(posedge clk) disable iff (!rst)     arbitration_grant == 1'b1 |-> $past(request_priority) == highest_priority\nendproperty\nassert_p_arbitration_grant_priority:assert property (p_arbitration_grant_priority) else $error(\"\");", "task_id": "1_4825", "predict_sva": "@(posedge clk) disable iff (rst == 0)         (arbitration_grant == 1'b1 && rst == 1) |-> ($past(request_priority) == highest_priority)"}
{"sva": "@(posedge clk) motor_control && $past(feedback_stable) && $past(pid_compute) |-> pwm_output_update", "sva_description": "### Assertion description:  \n**Property Name**: p_MotorControl_PWMUpdate  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `motor_control && $past(feedback_stable) && $past(pid_compute)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pwm_output_update`  ", "sva_signals": ["clk", "rst_n", "[0:0] motor_control", "[0:0] feedback_stable", "[0:0] pid_compute", "[0:0] pwm_output_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (motor_control && $past(feedback_stable) && $past(pid_compute)) |-> pwm_output_update", "sva_name": "p_pwm_output_update_on_motor_control_and_prev_feedback_pid", "id": "1070", "full_property": "property p_MotorControl_PWMUpdate;\n@(posedge clk)         (motor_control && $past(feedback_stable) && $past(pid_compute)) |-> pwm_output_update\nendproperty\nassert_p_MotorControl_PWMUpdate:assert property (p_MotorControl_PWMUpdate) else $error(\"\");", "task_id": "1_4836", "predict_sva": "@(posedge clk)         (motor_control == 1 && $past(feedback_stable) == 1 && $past(pid_compute) == 1) |-> (pwm_output_update == 1)"}
{"sva": "@(posedge clock) disable iff(calibration_mode) lidar_point_cloud_gen && $past(laser_pulse_timing) |-> distance_calculation", "sva_description": "### Assertion description:  \n**Property Name**: p_lidar_point_cloud_gen_distance  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (calibration_mode)`  \n**Antecedent (LHS of Implication)**: `lidar_point_cloud_gen && $past(laser_pulse_timing)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `distance_calculation`", "sva_signals": ["clock", "[0:0] calibration_mode", "[0:0] lidar_point_cloud_gen", "laser_pulse_timing", "distance_calculation"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (calibration_mode)     lidar_point_cloud_gen && $past(laser_pulse_timing) |-> distance_calculation", "sva_name": "p_distance_calculation_on_lidar_and_laser_timing", "id": "1097", "full_property": "property p_lidar_point_cloud_gen_distance;\n@(posedge clock) disable iff (calibration_mode)     lidar_point_cloud_gen && $past(laser_pulse_timing) |-> distance_calculation\nendproperty\nassert_p_lidar_point_cloud_gen_distance:assert property (p_lidar_point_cloud_gen_distance) else $error(\"\");", "task_id": "1_4863", "predict_sva": "@(posedge clock) disable iff (calibration_mode)         (calibration_mode == 0 && lidar_point_cloud_gen == 1 && $past(laser_pulse_timing) == 1) |-> distance_calculation == 1"}
{"sva": "@(posedge clk) disable iff(rst == 1'b1) automotive_ecu_diagnostic && $past(obd_request_received) |-> dtc_code_retrieval", "sva_description": "### Assertion description:\n**Property Name**: p_Automotive_ECU_Diagnostic  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (rst == 1'b1)  \n**Antecedent (LHS of Implication)**: automotive_ecu_diagnostic && $past(obd_request_received)  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: dtc_code_retrieval", "sva_signals": ["clk", "rst", "[0:0] automotive_ecu_diagnostic", "[0:0] obd_request_received", "[0:0] dtc_code_retrieval"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst == 1'b1)         (automotive_ecu_diagnostic && $past(obd_request_received)) |-> dtc_code_retrieval", "sva_name": "p_dtc_code_retrieval_on_diagnostic_and_obd_received", "id": "1102", "full_property": "property p_Automotive_ECU_Diagnostic;\n@(posedge clk) disable iff (rst == 1'b1)         (automotive_ecu_diagnostic && $past(obd_request_received)) |-> dtc_code_retrieval\nendproperty\nassert_p_Automotive_ECU_Diagnostic:assert property (p_Automotive_ECU_Diagnostic) else $error(\"\");", "task_id": "1_4868", "predict_sva": "@(posedge clk) disable iff (rst)         (rst == 0 && automotive_ecu_diagnostic == 1'b1 && $past(obd_request_received) == 1'b1) |-> dtc_code_retrieval == 1'b1"}
{"sva": "@(posedge clock) disable iff(!reset_n) neural_network_backprop && $past(forward_pass_complete) |-> gradient_computation", "sva_description": "### Assertion description:  \n**Property Name**: p_Gradient_Computation_After_Backprop  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: disable iff (!reset_n)  \n**Antecedent (LHS of Implication)**: `neural_network_backprop && $past(forward_pass_complete)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gradient_computation`", "sva_signals": ["clock", "reset_n", "[0:0] neural_network_backprop", "[0:0] forward_pass_complete", "[0:0] gradient_computation"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!reset_n)     (neural_network_backprop && $past(forward_pass_complete)) |-> gradient_computation", "sva_name": "p_gradient_computation_on_backprop_and_forward_complete", "id": "1107", "full_property": "property p_Gradient_Computation_After_Backprop;\n@(posedge clock) disable iff (!reset_n)     (neural_network_backprop && $past(forward_pass_complete)) |-> gradient_computation\nendproperty\nassert_p_Gradient_Computation_After_Backprop:assert property (p_Gradient_Computation_After_Backprop) else $error(\"\");", "task_id": "1_4873", "predict_sva": "@(posedge clock) disable iff (!reset_n)         (reset_n == 1 && neural_network_backprop == 1 && $past(forward_pass_complete) == 1) |-> gradient_computation == 1"}
{"sva": "@(negedge sys_clock) voice_codec_encode && $past(audio_sample_ready, 4) && $past(bit_rate_config) |-> compression_algorithm_start", "sva_description": "### Assertion description:  \n**Property Name**: p_Voice_Codec_Encode_Trigger  \n**Trigger Condition**: At every falling edge of the `sys_clock`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voice_codec_encode && $past(audio_sample_ready, 4) && $past(bit_rate_config)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `compression_algorithm_start`", "sva_signals": ["sys_clock", "[0:0] voice_codec_encode", "[0:0] audio_sample_ready", "[0:0] bit_rate_config", "[0:0] compression_algorithm_start"], "clock": "sys_clock", "attempts_left": 10, "sva_result": "@(negedge sys_clock)     (voice_codec_encode && $past(audio_sample_ready, 4) && $past(bit_rate_config)) |-> compression_algorithm_start", "sva_name": "p_compression_algorithm_start_on_voice_codec_encode", "id": "1108", "full_property": "property p_Voice_Codec_Encode_Trigger;\n@(negedge sys_clock)     (voice_codec_encode && $past(audio_sample_ready, 4) && $past(bit_rate_config)) |-> compression_algorithm_start\nendproperty\nassert_p_Voice_Codec_Encode_Trigger:assert property (p_Voice_Codec_Encode_Trigger) else $error(\"\");", "task_id": "1_4874", "predict_sva": "@(negedge sys_clock)         (voice_codec_encode == 1 && $past(audio_sample_ready, 4) == 1 && $past(bit_rate_config, 1) == 1) |-> compression_algorithm_start == 1"}
{"sva": "@(negedge clock) disable iff(!hw_rst) magnetic_stripe_reader && $past(card_swipe_detect) |-> track_data_extraction", "sva_description": "### Assertion description:  \n**Property Name**: p_magnetic_stripe_track_data  \n**Trigger Condition**: At every falling edge of the `clock`  \n**Disable Condition**: disable iff (!hw_rst)  \n**Antecedent (LHS of Implication)**: `magnetic_stripe_reader && $past(card_swipe_detect)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `track_data_extraction`", "sva_signals": ["clock", "hw_rst", "[0:0] magnetic_stripe_reader", "[0:0] card_swipe_detect", "[0:0] track_data_extraction"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (!hw_rst)     (magnetic_stripe_reader && $past(card_swipe_detect)) |-> track_data_extraction", "sva_name": "p_track_data_extraction_on_magnetic_stripe_and_card_swipe", "id": "1122", "full_property": "property p_magnetic_stripe_track_data;\n@(negedge clock) disable iff (!hw_rst)     (magnetic_stripe_reader && $past(card_swipe_detect)) |-> track_data_extraction\nendproperty\nassert_p_magnetic_stripe_track_data:assert property (p_magnetic_stripe_track_data) else $error(\"\");", "task_id": "1_4888", "predict_sva": "@(negedge clock) disable iff (hw_rst == 0)         (hw_rst == 1 && magnetic_stripe_reader == 1 && $past(card_swipe_detect) == 1) |-> track_data_extraction == 1"}
{"sva": "@(posedge clk) disable iff(rst == 1'b1) underwater_sonar_ping && $past(transducer_calibration) |-> acoustic_beam_formation", "sva_description": "### Assertion description:  \n**Property Name**: p_Underwater_Sonar_Ping_Beam_Formation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (rst == 1'b1)`  \n**Antecedent (LHS of Implication)**: `underwater_sonar_ping && $past(transducer_calibration)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `acoustic_beam_formation`", "sva_signals": ["clk", "rst", "[0:0] underwater_sonar_ping", "[0:0] transducer_calibration", "[0:0] acoustic_beam_formation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst == 1'b1)         underwater_sonar_ping && $past(transducer_calibration) |-> acoustic_beam_formation", "sva_name": "p_acoustic_beam_formation_on_ping_and_calibration", "id": "1124", "full_property": "property p_Underwater_Sonar_Ping_Beam_Formation;\n@(posedge clk) disable iff (rst == 1'b1)         underwater_sonar_ping && $past(transducer_calibration) |-> acoustic_beam_formation\nendproperty\nassert_p_Underwater_Sonar_Ping_Beam_Formation:assert property (p_Underwater_Sonar_Ping_Beam_Formation) else $error(\"\");", "task_id": "1_4890", "predict_sva": "@(posedge clk) disable iff (rst)         (rst == 0 && underwater_sonar_ping == 1 && $past(transducer_calibration) == 1) |-> acoustic_beam_formation == 1"}
{"sva": "@(posedge clock) disable iff(!hw_reset) ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete", "sva_description": "### Assertion description:  \n**Property Name**: p_Range_Calculation_Complete  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: `disable iff (!hw_reset)`  \n**Antecedent (LHS of Implication)**: `ultrasonic_distance_measure && $past(echo_time_capture)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `range_calculation_complete`", "sva_signals": ["clock", "hw_reset", "[0:0] ultrasonic_distance_measure", "[0:0] echo_time_capture", "[0:0] range_calculation_complete"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!hw_reset)         ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete", "sva_name": "p_range_calculation_complete_on_ultrasonic_and_echo", "id": "1134", "full_property": "property p_Range_Calculation_Complete;\n@(posedge clock) disable iff (!hw_reset)         ultrasonic_distance_measure && $past(echo_time_capture) |-> range_calculation_complete\nendproperty\nassert_p_Range_Calculation_Complete:assert property (p_Range_Calculation_Complete) else $error(\"\");", "task_id": "1_4898", "predict_sva": "@(posedge clock) disable iff (!hw_reset)         (hw_reset == 1 && ultrasonic_distance_measure == 1 && $past(echo_time_capture) == 1) |-> range_calculation_complete == 1"}
{"sva": "@(negedge clock) disable iff(!reset_enable) quantum_error_correction && $past(syndrome_measurement_complete, 8) |-> logical_qubit_recovery", "sva_description": "### Assertion description:  \n**Property Name**: p_Quantum_Error_Correction  \n**Trigger Condition**: At every falling edge of the `clock`  \n**Disable Condition**: disable iff (`!reset_enable`)  \n**Antecedent (LHS of Implication)**: `quantum_error_correction && $past(syndrome_measurement_complete, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `logical_qubit_recovery`  ", "sva_signals": ["clock", "reset_enable", "[0:0] quantum_error_correction", "[0:0] syndrome_measurement_complete", "[0:0] logical_qubit_recovery"], "clock": "clock", "attempts_left": 10, "sva_result": "@(negedge clock) disable iff (!reset_enable)     quantum_error_correction && $past(syndrome_measurement_complete, 8) |-> logical_qubit_recovery", "sva_name": "p_logical_qubit_recovery_on_qec_and_syndrome_8ago", "id": "1149", "full_property": "property p_Quantum_Error_Correction;\n@(negedge clock) disable iff (!reset_enable)     quantum_error_correction && $past(syndrome_measurement_complete, 8) |-> logical_qubit_recovery\nendproperty\nassert_p_Quantum_Error_Correction:assert property (p_Quantum_Error_Correction) else $error(\"\");", "task_id": "1_4913", "predict_sva": "@(negedge clock) disable iff (reset_enable == 0)         (reset_enable == 1 && quantum_error_correction == 1 && $past(syndrome_measurement_complete, 8) == 1) |-> logical_qubit_recovery == 1"}
{"sva": "@(posedge system_clock) disable iff(!power_on_reset) matrix_vector_multiply && $past(weight_buffer_loaded, 6) |-> dot_product_computation", "sva_description": "### Assertion description:  \n**Property Name**: p_matrix_vector_dot_product  \n**Trigger Condition**: At every rising edge of the `system_clock`  \n**Disable Condition**: `disable iff (!power_on_reset)`  \n**Antecedent (LHS of Implication)**: `matrix_vector_multiply && $past(weight_buffer_loaded, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dot_product_computation`  ", "sva_signals": ["system_clock", "power_on_reset", "[0:0] matrix_vector_multiply", "[0:0] weight_buffer_loaded", "[0:0] dot_product_computation"], "clock": "system_clock", "attempts_left": 10, "sva_result": "@(posedge system_clock) disable iff (!power_on_reset)     (matrix_vector_multiply && $past(weight_buffer_loaded, 6)) |-> dot_product_computation", "sva_name": "p_dot_product_computation_on_matrix_vector_multiply_and_weight_buffer_loaded", "id": "1173", "full_property": "property p_matrix_vector_dot_product;\n@(posedge system_clock) disable iff (!power_on_reset)     (matrix_vector_multiply && $past(weight_buffer_loaded, 6)) |-> dot_product_computation\nendproperty\nassert_p_matrix_vector_dot_product:assert property (p_matrix_vector_dot_product) else $error(\"\");", "task_id": "1_4937", "predict_sva": "@(posedge system_clock) disable iff (!power_on_reset)         (power_on_reset == 1 && matrix_vector_multiply == 1 && $past(weight_buffer_loaded, 6) == 1) |-> dot_product_computation == 1"}
{"sva": "@(posedge clock) disable iff(!rst_control) biosensor_immunoassay && $past(antigen_binding_kinetics, 15) |-> concentration_measurement_output", "sva_description": "### Assertion description:  \n**Property Name**: p_Biosensor_Immunoassay_Concentration  \n**Trigger Condition**: At every rising edge of the `clock`  \n**Disable Condition**: disable iff `(!rst_control)`  \n**Antecedent (LHS of Implication)**: `biosensor_immunoassay && $past(antigen_binding_kinetics, 15)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `concentration_measurement_output`", "sva_signals": ["clock", "[0:0] rst_control", "[0:0] biosensor_immunoassay", "[0:0] antigen_binding_kinetics", "[0:0] concentration_measurement_output"], "clock": "clock", "attempts_left": 10, "sva_result": "@(posedge clock) disable iff (!rst_control)         biosensor_immunoassay && $past(antigen_binding_kinetics, 15) |-> concentration_measurement_output", "sva_name": "p_concentration_measurement_output_on_immunoassay_and_kinetics", "id": "1178", "full_property": "property p_Biosensor_Immunoassay_Concentration;\n@(posedge clock) disable iff (!rst_control)         biosensor_immunoassay && $past(antigen_binding_kinetics, 15) |-> concentration_measurement_output\nendproperty\nassert_p_Biosensor_Immunoassay_Concentration:assert property (p_Biosensor_Immunoassay_Concentration) else $error(\"\");", "task_id": "1_4941", "predict_sva": "@(posedge clock) disable iff (rst_control == 0)         (rst_control == 1 && biosensor_immunoassay == 1 && $past(antigen_binding_kinetics, 15) == 1) |-> concentration_measurement_output == 1"}
{"sva": "@(posedge audio_clk) disable iff(rst_audio) digital_signal_processing && $past(sample_rate_conversion, 8) |-> filter_bank_computation", "sva_description": "### Assertion description:  \n**Property Name**: p_Digital_Signal_Processing_Trigger  \n**Trigger Condition**: At every rising edge of the `audio_clk`  \n**Disable Condition**: `disable iff (rst_audio)`  \n**Antecedent (LHS of Implication)**: `digital_signal_processing && $past(sample_rate_conversion, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `filter_bank_computation`  ", "sva_signals": ["audio_clk", "rst_audio", "[0:0] digital_signal_processing", "[0:0] sample_rate_conversion", "[0:0] filter_bank_computation"], "clock": "audio_clk", "attempts_left": 10, "sva_result": "@(posedge audio_clk) disable iff (rst_audio)     digital_signal_processing && $past(sample_rate_conversion, 8) |-> filter_bank_computation", "sva_name": "p_filter_bank_computation_on_dsp_and_srate_conv_8ago", "id": "1187", "full_property": "property p_Digital_Signal_Processing_Trigger;\n@(posedge audio_clk) disable iff (rst_audio)     digital_signal_processing && $past(sample_rate_conversion, 8) |-> filter_bank_computation\nendproperty\nassert_p_Digital_Signal_Processing_Trigger:assert property (p_Digital_Signal_Processing_Trigger) else $error(\"\");", "task_id": "1_4949", "predict_sva": "@(posedge audio_clk) disable iff (rst_audio)         (rst_audio == 0 && digital_signal_processing == 1 && $past(sample_rate_conversion, 8) == 1) |-> filter_bank_computation == 1"}
{"sva": "@(negedge clk_thermal) disable iff(!thermal_sensor_valid) dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition", "sva_description": "### Assertion description:  \n**Property Name**: p_dynamic_voltage_frequency_scaling_check  \n**Trigger Condition**: At every falling edge of the `clk_thermal`  \n**Disable Condition**: disable iff (`!thermal_sensor_valid`)  \n**Antecedent (LHS of Implication)**: `dynamic_voltage_frequency_scaling`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(workload_prediction_model, 9) && power_state_transition`  \n\n(Note: The property checks that whenever `dynamic_voltage_frequency_scaling` is active, the value of `workload_prediction_model` from 9 cycles ago must be true, and `power_state_transition` must also be true at the current cycle.)", "sva_signals": ["clk_thermal", "thermal_sensor_valid", "[0:0] dynamic_voltage_frequency_scaling", "[0:0] workload_prediction_model", "[0:0] power_state_transition"], "clock": "clk_thermal", "attempts_left": 10, "sva_result": "@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition", "sva_name": "p_dynamic_voltage_frequency_scaling", "id": "1202", "full_property": "property p_dynamic_voltage_frequency_scaling_check;\n@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |-> $past(workload_prediction_model, 9) && power_state_transition\nendproperty\nassert_p_dynamic_voltage_frequency_scaling_check:assert property (p_dynamic_voltage_frequency_scaling_check) else $error(\"\");", "task_id": "1_4964", "predict_sva": "@(negedge clk_thermal) disable iff (!thermal_sensor_valid)     dynamic_voltage_frequency_scaling |->          ($past(workload_prediction_model, 9) && power_state_transition)"}
{"sva": "@(negedge dsp_clock) disable iff(rst_domain) fir_filter_coefficient_update && $past(tap_weight_calculation, 7) |-> filter_response_reconfigure", "sva_description": "### Assertion description:  \n**Property Name**: p_Filter_Coefficient_Update  \n**Trigger Condition**: At every falling edge of the `dsp_clock`  \n**Disable Condition**: `disable iff (rst_domain)`  \n**Antecedent (LHS of Implication)**: `fir_filter_coefficient_update && $past(tap_weight_calculation, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `filter_response_reconfigure`  ", "sva_signals": ["dsp_clock", "rst_domain", "[0:0] fir_filter_coefficient_update", "[0:0] tap_weight_calculation", "[0:0] filter_response_reconfigure"], "clock": "dsp_clock", "attempts_left": 10, "sva_result": "@(negedge dsp_clock) disable iff (rst_domain)         fir_filter_coefficient_update && $past(tap_weight_calculation, 7) |-> filter_response_reconfigure", "sva_name": "p_filter_response_reconfigure_on_coeff_update_and_tap_calc", "id": "1201", "full_property": "property p_Filter_Coefficient_Update;\n@(negedge dsp_clock) disable iff (rst_domain)         fir_filter_coefficient_update && $past(tap_weight_calculation, 7) |-> filter_response_reconfigure\nendproperty\nassert_p_Filter_Coefficient_Update:assert property (p_Filter_Coefficient_Update) else $error(\"\");", "task_id": "1_4963", "predict_sva": "@(negedge dsp_clock) disable iff (rst_domain)         (rst_domain == 0 && fir_filter_coefficient_update == 1 && $past(tap_weight_calculation, 7) == 1) |-> filter_response_reconfigure == 1"}
{"sva": "@(posedge clk_satellite) disable iff(!ground_station_lock) telemetry_data_compression && $past(error_resilient_encoding, 18) |-> downlink_transmission_start", "sva_description": "### Assertion description:  \n**Property Name**: p_Telemetry_Data_Compression_Trigger  \n**Trigger Condition**: At every rising edge of `clk_satellite`  \n**Disable Condition**: `disable iff (!ground_station_lock)`  \n**Antecedent (LHS of Implication)**: `telemetry_data_compression && $past(error_resilient_encoding, 18)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `downlink_transmission_start`  ", "sva_signals": ["clk_satellite", "ground_station_lock", "[0:0] telemetry_data_compression", "[0:0] error_resilient_encoding", "[0:0] downlink_transmission_start"], "clock": "clk_satellite", "attempts_left": 10, "sva_result": "@(posedge clk_satellite) disable iff (!ground_station_lock)     telemetry_data_compression && $past(error_resilient_encoding, 18) |-> downlink_transmission_start", "sva_name": "p_downlink_transmission_start_on_compressed_telemetry", "id": "1203", "full_property": "property p_Telemetry_Data_Compression_Trigger;\n@(posedge clk_satellite) disable iff (!ground_station_lock)     telemetry_data_compression && $past(error_resilient_encoding, 18) |-> downlink_transmission_start\nendproperty\nassert_p_Telemetry_Data_Compression_Trigger:assert property (p_Telemetry_Data_Compression_Trigger) else $error(\"\");", "task_id": "1_4965", "predict_sva": "@(posedge clk_satellite) disable iff (!ground_station_lock)         (ground_station_lock == 1 && telemetry_data_compression == 1 && $past(error_resilient_encoding, 18) == 1) |-> downlink_transmission_start == 1"}
{"sva": "@(posedge clk_industrial) disable iff(rst_emergency == 1'b1) predictive_maintenance_analysis && $past(vibration_signature_learning, 14) |-> fault_prediction_output", "sva_description": "### Assertion description:  \n**Property Name**: p_fault_prediction  \n**Trigger Condition**: At every rising edge of the `clk_industrial`  \n**Disable Condition**: `disable iff (rst_emergency == 1'b1)`  \n**Antecedent (LHS of Implication)**: `predictive_maintenance_analysis && $past(vibration_signature_learning, 14)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fault_prediction_output`", "sva_signals": ["clk_industrial", "rst_emergency", "[0:0] predictive_maintenance_analysis", "[0:0] vibration_signature_learning", "[0:0] fault_prediction_output"], "clock": "clk_industrial", "attempts_left": 10, "sva_result": "@(posedge clk_industrial) disable iff (rst_emergency == 1'b1)     predictive_maintenance_analysis && $past(vibration_signature_learning, 14) |-> fault_prediction_output", "sva_name": "p_fault_prediction_on_learning_and_maintenance", "id": "1226", "full_property": "property p_fault_prediction;\n@(posedge clk_industrial) disable iff (rst_emergency == 1'b1)     predictive_maintenance_analysis && $past(vibration_signature_learning, 14) |-> fault_prediction_output\nendproperty\nassert_p_fault_prediction:assert property (p_fault_prediction) else $error(\"\");", "task_id": "1_4986", "predict_sva": "@(posedge clk_industrial) disable iff (rst_emergency)         (rst_emergency == 0 && predictive_maintenance_analysis == 1 && $past(vibration_signature_learning, 14) == 1) |-> fault_prediction_output == 1"}
{"sva": "@(negedge clk_optical) disable iff(rst_photonic == 1'b1) wavelength_division_multiplexing |-> $past(channel_spacing_optimization, 12) && optical_switch_control", "sva_description": "### Assertion description:  \n**Property Name**: p_wavelength_division_multiplexing_check  \n**Trigger Condition**: At every falling edge of `clk_optical`  \n**Disable Condition**: `disable iff (rst_photonic == 1'b1)`  \n**Antecedent (LHS of Implication)**: `wavelength_division_multiplexing == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(channel_spacing_optimization, 12) && optical_switch_control`  ", "sva_signals": ["clk_optical", "rst_photonic", "[0:0] wavelength_division_multiplexing", "[0:0] channel_spacing_optimization", "[0:0] optical_switch_control"], "clock": "clk_optical", "attempts_left": 10, "sva_result": "@(negedge clk_optical) disable iff (rst_photonic == 1'b1)     wavelength_division_multiplexing == 1'b1 |->      $past(channel_spacing_optimization, 12) && optical_switch_control", "sva_name": "p_wavelength_division_multiplexing_channel_spacing_optical_switch", "id": "1217", "full_property": "property p_wavelength_division_multiplexing_check;\n@(negedge clk_optical) disable iff (rst_photonic == 1'b1)     wavelength_division_multiplexing == 1'b1 |->      $past(channel_spacing_optimization, 12) && optical_switch_control\nendproperty\nassert_p_wavelength_division_multiplexing_check:assert property (p_wavelength_division_multiplexing_check) else $error(\"\");", "task_id": "1_4978", "predict_sva": "@(negedge clk_optical) disable iff (rst_photonic)         (rst_photonic == 0 && wavelength_division_multiplexing == 1'b1) |->          ($past(channel_spacing_optimization, 12) == 1'b1) && optical_switch_control == 1'b1"}
{"sva": "@(posedge clk_video_decoder) disable iff(rst_codec) motion_compensation_unit && $past(reference_frame_available, 4) |-> interpolation_filter_apply", "sva_description": "### Assertion description:  \n**Property Name**: p_motion_compensation_with_reference  \n**Trigger Condition**: At every rising edge of the `clk_video_decoder`  \n**Disable Condition**: `disable iff (rst_codec)`  \n**Antecedent (LHS of Implication)**: `motion_compensation_unit && $past(reference_frame_available, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interpolation_filter_apply`", "sva_signals": ["clk_video_decoder", "rst_codec", "[0:0] motion_compensation_unit", "[0:0] reference_frame_available", "[0:0] interpolation_filter_apply"], "clock": "clk_video_decoder", "attempts_left": 10, "sva_result": "@(posedge clk_video_decoder) disable iff (rst_codec)         (motion_compensation_unit && $past(reference_frame_available, 4)) |-> interpolation_filter_apply", "sva_name": "p_interpolation_filter_apply_on_mcu_and_reference_frame", "id": "1244", "full_property": "property p_motion_compensation_with_reference;\n@(posedge clk_video_decoder) disable iff (rst_codec)         (motion_compensation_unit && $past(reference_frame_available, 4)) |-> interpolation_filter_apply\nendproperty\nassert_p_motion_compensation_with_reference:assert property (p_motion_compensation_with_reference) else $error(\"\");", "task_id": "1_5004", "predict_sva": "@(posedge clk_video_decoder) disable iff (rst_codec)         (rst_codec == 0 && motion_compensation_unit == 1 && $past(reference_frame_available, 4) == 1) |-> interpolation_filter_apply == 1"}
{"sva": "@(posedge clk_audio_dsp) disable iff(!codec_reset) noise_reduction_adaptive && $past(spectral_subtraction_coefficients, 6) |-> enhanced_signal_reconstruction", "sva_description": "### Assertion description:  \n**Property Name**: p_NoiseReductionAdaptive_EnhancedSignal  \n**Trigger Condition**: At every rising edge of `clk_audio_dsp`  \n**Disable Condition**: `disable iff (!codec_reset)`  \n**Antecedent (LHS of Implication)**: `noise_reduction_adaptive && $past(spectral_subtraction_coefficients, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `enhanced_signal_reconstruction`", "sva_signals": ["clk_audio_dsp", "codec_reset", "[0:0] noise_reduction_adaptive", "[0:0] enhanced_signal_reconstruction", "[0:0] spectral_subtraction_coefficients"], "clock": "clk_audio_dsp", "attempts_left": 10, "sva_result": "@(posedge clk_audio_dsp) disable iff (!codec_reset)     noise_reduction_adaptive && $past(spectral_subtraction_coefficients, 6) |-> enhanced_signal_reconstruction", "sva_name": "p_enhanced_signal_reconstruction_on_adaptive_and_spectral_coefficients", "id": "1247", "full_property": "property p_NoiseReductionAdaptive_EnhancedSignal;\n@(posedge clk_audio_dsp) disable iff (!codec_reset)     noise_reduction_adaptive && $past(spectral_subtraction_coefficients, 6) |-> enhanced_signal_reconstruction\nendproperty\nassert_p_NoiseReductionAdaptive_EnhancedSignal:assert property (p_NoiseReductionAdaptive_EnhancedSignal) else $error(\"\");", "task_id": "1_5007", "predict_sva": "@(posedge clk_audio_dsp) disable iff (!codec_reset)         (codec_reset == 1 && noise_reduction_adaptive == 1 && $past(spectral_subtraction_coefficients, 6) == 1) |-> enhanced_signal_reconstruction == 1"}
{"sva": "@(negedge clk_superconducting_qubit) disable iff(rst_cryogenic) josephson_junction_control && $past(microwave_pulse_calibration, 6) |-> quantum_gate_fidelity_measurement", "sva_description": "### Assertion description:  \n**Property Name**: p_josephson_junction_control_quantum_gate_fidelity  \n**Trigger Condition**: At every falling edge of `clk_superconducting_qubit`  \n**Disable Condition**: `disable iff (rst_cryogenic)`  \n**Antecedent (LHS of Implication)**: `josephson_junction_control && $past(microwave_pulse_calibration, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `quantum_gate_fidelity_measurement`", "sva_signals": ["clk_superconducting_qubit", "rst_cryogenic", "[0:0] josephson_junction_control", "[0:0] microwave_pulse_calibration", "[0:0] quantum_gate_fidelity_measurement"], "clock": "clk_superconducting_qubit", "attempts_left": 10, "sva_result": "@(negedge clk_superconducting_qubit) disable iff (rst_cryogenic)         (josephson_junction_control && $past(microwave_pulse_calibration, 6)) |-> quantum_gate_fidelity_measurement", "sva_name": "p_quantum_gate_fidelity_measurement_on_josephson_and_calibration", "id": "1253", "full_property": "property p_josephson_junction_control_quantum_gate_fidelity;\n@(negedge clk_superconducting_qubit) disable iff (rst_cryogenic)         (josephson_junction_control && $past(microwave_pulse_calibration, 6)) |-> quantum_gate_fidelity_measurement\nendproperty\nassert_p_josephson_junction_control_quantum_gate_fidelity:assert property (p_josephson_junction_control_quantum_gate_fidelity) else $error(\"\");", "task_id": "1_5013", "predict_sva": "@(negedge clk_superconducting_qubit) disable iff (rst_cryogenic)         (rst_cryogenic == 0 && josephson_junction_control == 1 && $past(microwave_pulse_calibration, 6) == 1) |-> quantum_gate_fidelity_measurement == 1"}
{"sva": "@(posedge clk_register_file_banking) disable iff(rst_multi_port_register == 1'b1) port_conflict_arbitration |-> $past(read_write_port_scheduling, 8) && register_file_bandwidth_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_port_conflict_arbitration_check  \n**Trigger Condition**: At every rising edge of the `clk_register_file_banking`  \n**Disable Condition**: `disable iff (rst_multi_port_register == 1'b1)`  \n**Antecedent (LHS of Implication)**: `port_conflict_arbitration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(read_write_port_scheduling, 8) && register_file_bandwidth_optimization`  ", "sva_signals": ["clk_register_file_banking", "rst_multi_port_register", "[0:0] port_conflict_arbitration", "[0:0] read_write_port_scheduling", "[0:0] register_file_bandwidth_optimization"], "clock": "clk_register_file_banking", "attempts_left": 10, "sva_result": "@(posedge clk_register_file_banking) disable iff (rst_multi_port_register == 1'b1)     port_conflict_arbitration |-> $past(read_write_port_scheduling, 8) && register_file_bandwidth_optimization", "sva_name": "p_port_conflict_arbitration_dependency", "id": "1318", "full_property": "property p_port_conflict_arbitration_check;\n@(posedge clk_register_file_banking) disable iff (rst_multi_port_register == 1'b1)     port_conflict_arbitration |-> $past(read_write_port_scheduling, 8) && register_file_bandwidth_optimization\nendproperty\nassert_p_port_conflict_arbitration_check:assert property (p_port_conflict_arbitration_check) else $error(\"\");", "task_id": "1_5078", "predict_sva": "@(posedge clk_register_file_banking) disable iff (rst_multi_port_register)         (rst_multi_port_register == 0 && port_conflict_arbitration == 1) |->          ($past(read_write_port_scheduling, 8) == 1 && register_file_bandwidth_optimization == 1)"}
{"sva": "@(posedge clk_mimo_processing) disable iff(!multiple_antenna_reset) spatial_multiplexing_detection && $past(channel_matrix_decomposition, 6) |-> interference_cancellation_algorithm", "sva_description": "### Assertion description:  \n**Property Name**: p_Spatial_Multiplexing_Detection  \n**Trigger Condition**: At every rising edge of the `clk_mimo_processing`  \n**Disable Condition**: disable iff `(!multiple_antenna_reset)`  \n**Antecedent (LHS of Implication)**: `spatial_multiplexing_detection && $past(channel_matrix_decomposition, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interference_cancellation_algorithm`", "sva_signals": ["clk_mimo_processing", "multiple_antenna_reset", "[0:0] spatial_multiplexing_detection", "[0:0] channel_matrix_decomposition", "[0:0] interference_cancellation_algorithm"], "clock": "clk_mimo_processing", "attempts_left": 10, "sva_result": "@(posedge clk_mimo_processing) disable iff (!multiple_antenna_reset)     spatial_multiplexing_detection && $past(channel_matrix_decomposition, 6) |-> interference_cancellation_algorithm", "sva_name": "p_interference_cancellation_on_spatial_multiplexing_and_channel_decomposition", "id": "1336", "full_property": "property p_Spatial_Multiplexing_Detection;\n@(posedge clk_mimo_processing) disable iff (!multiple_antenna_reset)     spatial_multiplexing_detection && $past(channel_matrix_decomposition, 6) |-> interference_cancellation_algorithm\nendproperty\nassert_p_Spatial_Multiplexing_Detection:assert property (p_Spatial_Multiplexing_Detection) else $error(\"\");", "task_id": "1_5095", "predict_sva": "@(posedge clk_mimo_processing) disable iff (!multiple_antenna_reset)         (multiple_antenna_reset == 1 && spatial_multiplexing_detection == 1 && $past(channel_matrix_decomposition, 6) == 1) |-> interference_cancellation_algorithm == 1"}
{"sva": "@(posedge clk_channel_coding) disable iff(!forward_error_correction_reset) low_density_parity_check_decoder && $past(belief_propagation_iteration, 6) |-> bit_error_rate_improvement", "sva_description": "### Assertion description:  \n**Property Name**: p_Bit_Error_Rate_Improvement  \n**Trigger Condition**: At every rising edge of the `clk_channel_coding`  \n**Disable Condition**: `disable iff (!forward_error_correction_reset)`  \n**Antecedent (LHS of Implication)**: `low_density_parity_check_decoder && $past(belief_propagation_iteration, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bit_error_rate_improvement`  ", "sva_signals": ["clk_channel_coding", "forward_error_correction_reset", "[0:0] low_density_parity_check_decoder", "[0:0] belief_propagation_iteration", "[0:0] bit_error_rate_improvement"], "clock": "clk_channel_coding", "attempts_left": 10, "sva_result": "@(posedge clk_channel_coding) disable iff (!forward_error_correction_reset)     (low_density_parity_check_decoder && $past(belief_propagation_iteration, 6)) |-> bit_error_rate_improvement", "sva_name": "p_bit_error_rate_improvement_on_lpc_and_belief_propagation", "id": "1344", "full_property": "property p_Bit_Error_Rate_Improvement;\n@(posedge clk_channel_coding) disable iff (!forward_error_correction_reset)     (low_density_parity_check_decoder && $past(belief_propagation_iteration, 6)) |-> bit_error_rate_improvement\nendproperty\nassert_p_Bit_Error_Rate_Improvement:assert property (p_Bit_Error_Rate_Improvement) else $error(\"\");", "task_id": "1_5103", "predict_sva": "@(posedge clk_channel_coding) disable iff (!forward_error_correction_reset)         (forward_error_correction_reset == 1 && low_density_parity_check_decoder == 1 && $past(belief_propagation_iteration, 6) == 1) |-> bit_error_rate_improvement == 1"}
{"sva": "@(posedge clk_channel_estimation) disable iff(rst_pilot_extraction) least_squares_channel_estimation && $past(pilot_symbol_interpolation, 6) |-> frequency_domain_equalization", "sva_description": "### Assertion description:  \n**Property Name**: p_LeastSquares_Channel_Estimation  \n**Trigger Condition**: At every rising edge of the `clk_channel_estimation`  \n**Disable Condition**: `disable iff (rst_pilot_extraction)`  \n**Antecedent (LHS of Implication)**: `least_squares_channel_estimation && $past(pilot_symbol_interpolation, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `frequency_domain_equalization`  ", "sva_signals": ["clk_channel_estimation", "rst_pilot_extraction", "[0:0] least_squares_channel_estimation", "[0:0] pilot_symbol_interpolation", "[0:0] frequency_domain_equalization"], "clock": "clk_channel_estimation", "attempts_left": 10, "sva_result": "@(posedge clk_channel_estimation) disable iff (rst_pilot_extraction)         least_squares_channel_estimation && $past(pilot_symbol_interpolation, 6) |-> frequency_domain_equalization", "sva_name": "p_frequency_domain_equalization_on_channel_estimation_and_pilot_interpolation", "id": "1348", "full_property": "property p_LeastSquares_Channel_Estimation;\n@(posedge clk_channel_estimation) disable iff (rst_pilot_extraction)         least_squares_channel_estimation && $past(pilot_symbol_interpolation, 6) |-> frequency_domain_equalization\nendproperty\nassert_p_LeastSquares_Channel_Estimation:assert property (p_LeastSquares_Channel_Estimation) else $error(\"\");", "task_id": "1_5107", "predict_sva": "@(posedge clk_channel_estimation) disable iff (rst_pilot_extraction)         (rst_pilot_extraction == 0 && least_squares_channel_estimation == 1 && $past(pilot_symbol_interpolation, 6) == 1) |-> frequency_domain_equalization == 1"}
{"sva": "@(posedge clk_underwater_acoustic) disable iff(!marine_communication_reset) doppler_shift_compensation && $past(multipath_propagation_modeling, 11) |-> underwater_network_connectivity", "sva_description": "### Assertion description:  \n**Property Name**: p_Underwater_Network_Connectivity  \n**Trigger Condition**: At every rising edge of the `clk_underwater_acoustic`  \n**Disable Condition**: `disable iff (!marine_communication_reset)`  \n**Antecedent (LHS of Implication)**: `doppler_shift_compensation && $past(multipath_propagation_modeling, 11)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `underwater_network_connectivity`", "sva_signals": ["clk_underwater_acoustic", "marine_communication_reset", "[0:0] doppler_shift_compensation", "[0:0] multipath_propagation_modeling", "[0:0] underwater_network_connectivity"], "clock": "clk_underwater_acoustic", "attempts_left": 10, "sva_result": "@(posedge clk_underwater_acoustic) disable iff (!marine_communication_reset)     doppler_shift_compensation && $past(multipath_propagation_modeling, 11) |-> underwater_network_connectivity", "sva_name": "p_underwater_network_connectivity_on_doppler_and_multipath", "id": "1357", "full_property": "property p_Underwater_Network_Connectivity;\n@(posedge clk_underwater_acoustic) disable iff (!marine_communication_reset)     doppler_shift_compensation && $past(multipath_propagation_modeling, 11) |-> underwater_network_connectivity\nendproperty\nassert_p_Underwater_Network_Connectivity:assert property (p_Underwater_Network_Connectivity) else $error(\"\");", "task_id": "1_5115", "predict_sva": "@(posedge clk_underwater_acoustic) disable iff (marine_communication_reset == 0)         (marine_communication_reset == 1 && doppler_shift_compensation == 1 && $past(multipath_propagation_modeling, 11) == 1) |-> underwater_network_connectivity == 1"}
{"sva": "@(negedge clk_tactile_internet) disable iff(rst_haptic_communication) ultra_low_latency_feedback && $past(force_feedback_encoding, 3) |-> immersive_remote_interaction", "sva_description": "### Assertion description:  \n**Property Name**: p_ultra_low_latency_feedback  \n**Trigger Condition**: At every falling edge of the `clk_tactile_internet`  \n**Disable Condition**: `disable iff (rst_haptic_communication)`  \n**Antecedent (LHS of Implication)**: `ultra_low_latency_feedback && $past(force_feedback_encoding, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `immersive_remote_interaction`  ", "sva_signals": ["clk_tactile_internet", "rst_haptic_communication", "[0:0] ultra_low_latency_feedback", "[0:0] force_feedback_encoding", "[0:0] immersive_remote_interaction"], "clock": "clk_tactile_internet", "attempts_left": 10, "sva_result": "@(negedge clk_tactile_internet) disable iff (rst_haptic_communication)         (ultra_low_latency_feedback && $past(force_feedback_encoding, 3)) |-> immersive_remote_interaction", "sva_name": "p_immersive_remote_interaction_on_ultra_low_latency_and_force_feedback", "id": "1359", "full_property": "property p_ultra_low_latency_feedback;\n@(negedge clk_tactile_internet) disable iff (rst_haptic_communication)         (ultra_low_latency_feedback && $past(force_feedback_encoding, 3)) |-> immersive_remote_interaction\nendproperty\nassert_p_ultra_low_latency_feedback:assert property (p_ultra_low_latency_feedback) else $error(\"\");", "task_id": "1_5117", "predict_sva": "@(negedge clk_tactile_internet) disable iff (rst_haptic_communication)         (rst_haptic_communication == 0 && ultra_low_latency_feedback == 1 && $past(force_feedback_encoding, 3) == 1) |-> immersive_remote_interaction == 1"}
{"sva": "@(posedge clk_artificial_intelligence) disable iff(rst_machine_learning == 1'b1) intelligent_resource_management |-> $past(neural_network_inference_complete, 7) && autonomous_network_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_intelligent_resource_management  \n**Trigger Condition**: At every rising edge of the `clk_artificial_intelligence`  \n**Disable Condition**: `disable iff (rst_machine_learning == 1'b1)`  \n**Antecedent (LHS of Implication)**: `intelligent_resource_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(neural_network_inference_complete, 7) && autonomous_network_optimization`  ", "sva_signals": ["clk_artificial_intelligence", "rst_machine_learning", "[0:0] intelligent_resource_management", "[0:0] neural_network_inference_complete", "[0:0] autonomous_network_optimization"], "clock": "clk_artificial_intelligence", "attempts_left": 10, "sva_result": "@(posedge clk_artificial_intelligence) disable iff (rst_machine_learning == 1'b1)     intelligent_resource_management |-> $past(neural_network_inference_complete, 7) && autonomous_network_optimization", "sva_name": "p_intelligent_resource_management_dependency", "id": "1378", "full_property": "property p_intelligent_resource_management;\n@(posedge clk_artificial_intelligence) disable iff (rst_machine_learning == 1'b1)     intelligent_resource_management |-> $past(neural_network_inference_complete, 7) && autonomous_network_optimization\nendproperty\nassert_p_intelligent_resource_management:assert property (p_intelligent_resource_management) else $error(\"\");", "task_id": "1_5136", "predict_sva": "@(posedge clk_artificial_intelligence) disable iff (rst_machine_learning)         (rst_machine_learning == 0 && intelligent_resource_management == 1) |->          ($past(neural_network_inference_complete, 7) == 1) &&          (autonomous_network_optimization == 1)"}
{"sva": "@(posedge clk_electrochemical) disable iff(rst_biosensor == 1'b1) glucose_concentration_detection |-> $past(enzyme_reaction_kinetics, 9) && current_signal_amplification", "sva_description": "### Assertion description:  \n**Property Name**: p_glucose_detection_after_reaction  \n**Trigger Condition**: At every rising edge of the `clk_electrochemical`  \n**Disable Condition**: `disable iff (rst_biosensor == 1'b1)`  \n**Antecedent (LHS of Implication)**: `glucose_concentration_detection == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(enzyme_reaction_kinetics, 9) && current_signal_amplification`  ", "sva_signals": ["clk_electrochemical", "rst_biosensor", "[0:0] glucose_concentration_detection", "[0:0] enzyme_reaction_kinetics", "[0:0] current_signal_amplification"], "clock": "clk_electrochemical", "attempts_left": 10, "sva_result": "@(posedge clk_electrochemical) disable iff (rst_biosensor == 1'b1)     glucose_concentration_detection == 1'b1 |->      $past(enzyme_reaction_kinetics, 9) && current_signal_amplification", "sva_name": "p_glucose_concentration_detection_requires_kinetics_and_amplification", "id": "1394", "full_property": "property p_glucose_detection_after_reaction;\n@(posedge clk_electrochemical) disable iff (rst_biosensor == 1'b1)     glucose_concentration_detection == 1'b1 |->      $past(enzyme_reaction_kinetics, 9) && current_signal_amplification\nendproperty\nassert_p_glucose_detection_after_reaction:assert property (p_glucose_detection_after_reaction) else $error(\"\");", "task_id": "1_5152", "predict_sva": "@(posedge clk_electrochemical) disable iff (rst_biosensor)         (rst_biosensor == 0 && glucose_concentration_detection == 1'b1) |->          (current_signal_amplification == 1'b1 && $past(enzyme_reaction_kinetics, 9) == 1'b1)"}
{"sva": "@(posedge clk_strain_gauge) disable iff(!load_cell_reset) wheatstone_bridge_measurement && $past(temperature_compensation_applied, 7) |-> mechanical_stress_quantification", "sva_description": "### Assertion description:  \n**Property Name**: p_Mechanical_Stress_Quantification  \n**Trigger Condition**: At every rising edge of the `clk_strain_gauge`  \n**Disable Condition**: `disable iff (!load_cell_reset)`  \n**Antecedent (LHS of Implication)**: `wheatstone_bridge_measurement && $past(temperature_compensation_applied, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mechanical_stress_quantification`  ", "sva_signals": ["clk_strain_gauge", "load_cell_reset", "[0:0] wheatstone_bridge_measurement", "[0:0] temperature_compensation_applied", "[0:0] mechanical_stress_quantification"], "clock": "clk_strain_gauge", "attempts_left": 10, "sva_result": "@(posedge clk_strain_gauge) disable iff (!load_cell_reset)         wheatstone_bridge_measurement && $past(temperature_compensation_applied, 7)          |-> mechanical_stress_quantification", "sva_name": "p_mechanical_stress_quantification_on_wheatstone_and_temp_comp", "id": "1398", "full_property": "property p_Mechanical_Stress_Quantification;\n@(posedge clk_strain_gauge) disable iff (!load_cell_reset)         wheatstone_bridge_measurement && $past(temperature_compensation_applied, 7)          |-> mechanical_stress_quantification\nendproperty\nassert_p_Mechanical_Stress_Quantification:assert property (p_Mechanical_Stress_Quantification) else $error(\"\");", "task_id": "1_5156", "predict_sva": "@(posedge clk_strain_gauge) disable iff (!load_cell_reset)         (load_cell_reset == 1 && wheatstone_bridge_measurement == 1 && $past(temperature_compensation_applied, 7) == 1) |-> mechanical_stress_quantification == 1"}
{"sva": "@(posedge clk_electroretinograph) disable iff(rst_retinal_function == 1'b1) photoreceptor_response_measurement |-> $past(light_stimulus_standardization, 10) && visual_pathway_assessment", "sva_description": "### Assertion description:  \n**Property Name**: p_photoreceptor_response_measurement  \n**Trigger Condition**: At every rising edge of the `clk_electroretinograph`  \n**Disable Condition**: `disable iff (rst_retinal_function == 1'b1)`  \n**Antecedent (LHS of Implication)**: `photoreceptor_response_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(light_stimulus_standardization, 10) && visual_pathway_assessment`  ", "sva_signals": ["clk_electroretinograph", "rst_retinal_function", "[0:0] photoreceptor_response_measurement", "[0:0] light_stimulus_standardization", "[0:0] visual_pathway_assessment"], "clock": "clk_electroretinograph", "attempts_left": 10, "sva_result": "@(posedge clk_electroretinograph) disable iff (rst_retinal_function == 1'b1)         photoreceptor_response_measurement |-> $past(light_stimulus_standardization, 10) && visual_pathway_assessment", "sva_name": "p_photoreceptor_response_measurement_dependency", "id": "1426", "full_property": "property p_photoreceptor_response_measurement;\n@(posedge clk_electroretinograph) disable iff (rst_retinal_function == 1'b1)         photoreceptor_response_measurement |-> $past(light_stimulus_standardization, 10) && visual_pathway_assessment\nendproperty\nassert_p_photoreceptor_response_measurement:assert property (p_photoreceptor_response_measurement) else $error(\"\");", "task_id": "1_5184", "predict_sva": "@(posedge clk_electroretinograph) disable iff (rst_retinal_function)         (rst_retinal_function == 0 && photoreceptor_response_measurement == 1) |->          (visual_pathway_assessment == 1 && $past(light_stimulus_standardization, 10) == 1)"}
{"sva": "@(posedge clk_space_time_coding) disable iff(!diversity_coding_reset) alamouti_space_time_block_code && $past(orthogonal_design_matrix, 8) |-> transmit_diversity_gain_achievement", "sva_description": "### Assertion description:  \n**Property Name**: p_Transmit_Diversity_Gain  \n**Trigger Condition**: At every rising edge of `clk_space_time_coding`  \n**Disable Condition**: `disable iff (!diversity_coding_reset)`  \n**Antecedent (LHS of Implication)**: `alamouti_space_time_block_code && $past(orthogonal_design_matrix, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `transmit_diversity_gain_achievement`  ", "sva_signals": ["clk", "diversity_coding_reset", "[0:0] alamouti_space_time_block_code", "[0:0] orthogonal_design_matrix", "[0:0] transmit_diversity_gain_achievement", "clk_space_time_coding"], "clock": "clk_space_time_coding", "attempts_left": 10, "sva_result": "@(posedge clk_space_time_coding) disable iff (!diversity_coding_reset)         alamouti_space_time_block_code && $past(orthogonal_design_matrix, 8) |-> transmit_diversity_gain_achievement", "sva_name": "p_transmit_diversity_gain_achievement_on_alamouti_and_orthogonal", "id": "1403", "full_property": "property p_Transmit_Diversity_Gain;\n@(posedge clk_space_time_coding) disable iff (!diversity_coding_reset)         alamouti_space_time_block_code && $past(orthogonal_design_matrix, 8) |-> transmit_diversity_gain_achievement\nendproperty\nassert_p_Transmit_Diversity_Gain:assert property (p_Transmit_Diversity_Gain) else $error(\"\");", "task_id": "1_5161", "predict_sva": "@(posedge clk_space_time_coding) disable iff (!diversity_coding_reset)         (diversity_coding_reset == 1 && alamouti_space_time_block_code == 1 && $past(orthogonal_design_matrix, 8) == 1) |-> transmit_diversity_gain_achievement == 1"}
{"sva": "@(negedge clk_industrial_safety) disable iff(!process_safety_reset) pressure_relief_valve_testing && $past(overpressure_scenario_simulation, 10) |-> process_hazard_mitigation", "sva_description": "### Assertion description:  \n**Property Name**: p_Pressure_Relief_Valve_Test  \n**Trigger Condition**: At every falling edge of the `clk_industrial_safety`  \n**Disable Condition**: `disable iff (!process_safety_reset)`  \n**Antecedent (LHS of Implication)**: `pressure_relief_valve_testing && $past(overpressure_scenario_simulation, 10)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `process_hazard_mitigation`", "sva_signals": ["clk_industrial_safety", "process_safety_reset", "[0:0] pressure_relief_valve_testing", "overpressure_scenario_simulation", "[0:0] process_hazard_mitigation"], "clock": "clk_industrial_safety", "attempts_left": 10, "sva_result": "@(negedge clk_industrial_safety) disable iff (!process_safety_reset)         (pressure_relief_valve_testing && $past(overpressure_scenario_simulation, 10)) |-> process_hazard_mitigation", "sva_name": "p_pressure_relief_valve_hazard_mitigation", "id": "1490", "full_property": "property p_Pressure_Relief_Valve_Test;\n@(negedge clk_industrial_safety) disable iff (!process_safety_reset)         (pressure_relief_valve_testing && $past(overpressure_scenario_simulation, 10)) |-> process_hazard_mitigation\nendproperty\nassert_p_Pressure_Relief_Valve_Test:assert property (p_Pressure_Relief_Valve_Test) else $error(\"\");", "task_id": "1_5248", "predict_sva": "@(negedge clk_industrial_safety) disable iff (!process_safety_reset)         (process_safety_reset == 1 && pressure_relief_valve_testing == 1 && $past(overpressure_scenario_simulation, 10) == 1) |-> process_hazard_mitigation == 1"}
{"sva": "@(negedge clk_chemical_plant) disable iff(rst_process_control) reaction_temperature_control && $past(catalyst_activity_degradation, 9) |-> process_optimization_adjustment", "sva_description": "### Assertion description:  \n**Property Name**: p_reaction_temp_control_to_optimization  \n**Trigger Condition**: At every falling edge of the `clk_chemical_plant`  \n**Disable Condition**: disable iff (rst_process_control)  \n**Antecedent (LHS of Implication)**: `reaction_temperature_control && $past(catalyst_activity_degradation, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `process_optimization_adjustment`  ", "sva_signals": ["clk_chemical_plant", "rst_process_control", "[0:0] reaction_temperature_control", "[0:0] catalyst_activity_degradation", "[0:0] process_optimization_adjustment"], "clock": "clk_chemical_plant", "attempts_left": 10, "sva_result": "@(negedge clk_chemical_plant) disable iff (rst_process_control)     (reaction_temperature_control && $past(catalyst_activity_degradation, 9)) |-> process_optimization_adjustment", "sva_name": "p_process_optimization_adjustment_on_temp_and_catalyst_history", "id": "1494", "full_property": "property p_reaction_temp_control_to_optimization;\n@(negedge clk_chemical_plant) disable iff (rst_process_control)     (reaction_temperature_control && $past(catalyst_activity_degradation, 9)) |-> process_optimization_adjustment\nendproperty\nassert_p_reaction_temp_control_to_optimization:assert property (p_reaction_temp_control_to_optimization) else $error(\"\");", "task_id": "1_5252", "predict_sva": "@(negedge clk_chemical_plant) disable iff (rst_process_control)         (rst_process_control == 0 && reaction_temperature_control == 1 && $past(catalyst_activity_degradation, 9) == 1) |-> process_optimization_adjustment == 1"}
{"sva": "@(negedge clk_livestock_management) disable iff(rst_animal_welfare) biometric_health_monitoring && $past(feed_conversion_efficiency, 3) |-> precision_livestock_farming", "sva_description": "### Assertion description:  \n**Property Name**: p_biometric_health_monitoring_trigger  \n**Trigger Condition**: At every falling edge of `clk_livestock_management`  \n**Disable Condition**: `disable iff (rst_animal_welfare)`  \n**Antecedent (LHS of Implication)**: `biometric_health_monitoring && $past(feed_conversion_efficiency, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `precision_livestock_farming`", "sva_signals": ["clk_livestock_management", "rst_animal_welfare", "[0:0] biometric_health_monitoring", "[0:0] feed_conversion_efficiency", "[0:0] precision_livestock_farming"], "clock": "clk_livestock_management", "attempts_left": 10, "sva_result": "@(negedge clk_livestock_management) disable iff (rst_animal_welfare)         biometric_health_monitoring && $past(feed_conversion_efficiency, 3) |-> precision_livestock_farming", "sva_name": "p_precision_livestock_farming_biometric_feed_conversion", "id": "1507", "full_property": "property p_biometric_health_monitoring_trigger;\n@(negedge clk_livestock_management) disable iff (rst_animal_welfare)         biometric_health_monitoring && $past(feed_conversion_efficiency, 3) |-> precision_livestock_farming\nendproperty\nassert_p_biometric_health_monitoring_trigger:assert property (p_biometric_health_monitoring_trigger) else $error(\"\");", "task_id": "1_5265", "predict_sva": "@(negedge clk_livestock_management) disable iff (rst_animal_welfare)         (rst_animal_welfare == 0 && biometric_health_monitoring == 1 && $past(feed_conversion_efficiency, 3) == 1) |-> precision_livestock_farming == 1"}
{"sva": "@(posedge clk_dam_safety) disable iff(rst_hydroelectric_structure) concrete_deformation_measurement && $past(seepage_flow_monitoring, 5) |-> structural_stability_assessment", "sva_description": "### Assertion description:  \n**Property Name**: p_structural_stability_assessment  \n**Trigger Condition**: At every rising edge of the `clk_dam_safety`  \n**Disable Condition**: `disable iff (rst_hydroelectric_structure)`  \n**Antecedent (LHS of Implication)**: `concrete_deformation_measurement && $past(seepage_flow_monitoring, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `structural_stability_assessment`", "sva_signals": ["clk_dam_safety", "rst_hydroelectric_structure", "[0:0] concrete_deformation_measurement", "[0:0] seepage_flow_monitoring", "[0:0] structural_stability_assessment"], "clock": "clk_dam_safety", "attempts_left": 10, "sva_result": "@(posedge clk_dam_safety) disable iff (rst_hydroelectric_structure)     (concrete_deformation_measurement && $past(seepage_flow_monitoring, 5)) |-> structural_stability_assessment", "sva_name": "p_structural_stability_assessment_on_concrete_and_seepage", "id": "1517", "full_property": "property p_structural_stability_assessment;\n@(posedge clk_dam_safety) disable iff (rst_hydroelectric_structure)     (concrete_deformation_measurement && $past(seepage_flow_monitoring, 5)) |-> structural_stability_assessment\nendproperty\nassert_p_structural_stability_assessment:assert property (p_structural_stability_assessment) else $error(\"\");", "task_id": "1_5275", "predict_sva": "@(posedge clk_dam_safety) disable iff (rst_hydroelectric_structure)         (rst_hydroelectric_structure == 0 && concrete_deformation_measurement == 1 && $past(seepage_flow_monitoring, 5) == 1) |-> structural_stability_assessment == 1"}
{"sva": "@(posedge clk_marine_conservation) disable iff(rst_ocean_monitoring) coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy", "sva_description": "### Assertion description:  \n**Property Name**: p_coral_reef_restoration  \n**Trigger Condition**: At every rising edge of the `clk_marine_conservation`  \n**Disable Condition**: `disable iff (rst_ocean_monitoring)`  \n**Antecedent (LHS of Implication)**: `coral_reef_health_assessment && $past(water_chemistry_analysis, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecosystem_restoration_strategy`  ", "sva_signals": ["clk_marine_conservation", "rst_ocean_monitoring", "[0:0] coral_reef_health_assessment", "[0:0] water_chemistry_analysis", "[0:0] ecosystem_restoration_strategy"], "clock": "clk_marine_conservation", "attempts_left": 10, "sva_result": "@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy", "sva_name": "p_ecosystem_restoration_strategy_on_coral_and_water_chemistry", "id": "1520", "full_property": "property p_coral_reef_restoration;\n@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         coral_reef_health_assessment && $past(water_chemistry_analysis, 7) |-> ecosystem_restoration_strategy\nendproperty\nassert_p_coral_reef_restoration:assert property (p_coral_reef_restoration) else $error(\"\");", "task_id": "1_5278", "predict_sva": "@(posedge clk_marine_conservation) disable iff (rst_ocean_monitoring)         (rst_ocean_monitoring == 0 && coral_reef_health_assessment == 1 && $past(water_chemistry_analysis, 7) == 1) |-> ecosystem_restoration_strategy == 1"}
{"sva": "@(negedge clk_companion_robot) disable iff(!social_interaction_reset) emotional_state_recognition && $past(facial_expression_analysis, 12) |-> empathetic_response_generation", "sva_description": "### Assertion description:  \n**Property Name**: p_Emotional_State_Recognition_Response  \n**Trigger Condition**: At every falling edge of `clk_companion_robot`  \n**Disable Condition**: `disable iff (!social_interaction_reset)`  \n**Antecedent (LHS of Implication)**: `emotional_state_recognition && $past(facial_expression_analysis, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `empathetic_response_generation`", "sva_signals": ["clk_companion_robot", "social_interaction_reset", "[0:0] emotional_state_recognition", "[0:0] facial_expression_analysis", "[0:0] empathetic_response_generation"], "clock": "clk_companion_robot", "attempts_left": 10, "sva_result": "@(negedge clk_companion_robot) disable iff (!social_interaction_reset)     emotional_state_recognition && $past(facial_expression_analysis, 12) |-> empathetic_response_generation", "sva_name": "p_empathetic_response_on_emotion_and_past_facial_analysis", "id": "1536", "full_property": "property p_Emotional_State_Recognition_Response;\n@(negedge clk_companion_robot) disable iff (!social_interaction_reset)     emotional_state_recognition && $past(facial_expression_analysis, 12) |-> empathetic_response_generation\nendproperty\nassert_p_Emotional_State_Recognition_Response:assert property (p_Emotional_State_Recognition_Response) else $error(\"\");", "task_id": "1_5294", "predict_sva": "@(negedge clk_companion_robot) disable iff (!social_interaction_reset)         (social_interaction_reset == 1 && emotional_state_recognition == 1 && $past(facial_expression_analysis, 12) == 1) |-> empathetic_response_generation == 1"}
{"sva": "@(posedge clk_snake_robot) disable iff(rst_serpentine_locomotion) undulatory_motion_control && $past(body_wave_propagation, 5) |-> confined_space_navigation", "sva_description": "### Assertion description:  \n**Property Name**: p_undulatory_motion_control_to_navigation  \n**Trigger Condition**: At every rising edge of `clk_snake_robot`  \n**Disable Condition**: `disable iff (rst_serpentine_locomotion)`  \n**Antecedent (LHS of Implication)**: `undulatory_motion_control && $past(body_wave_propagation, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `confined_space_navigation`  ", "sva_signals": ["clk_snake_robot", "rst_serpentine_locomotion", "[0:0] undulatory_motion_control", "[0:0] body_wave_propagation", "[0:0] confined_space_navigation"], "clock": "clk_snake_robot", "attempts_left": 10, "sva_result": "@(posedge clk_snake_robot) disable iff (rst_serpentine_locomotion)     (undulatory_motion_control && $past(body_wave_propagation, 5)) |-> confined_space_navigation", "sva_name": "p_confined_space_navigation_on_undulatory_and_past_body_wave", "id": "1546", "full_property": "property p_undulatory_motion_control_to_navigation;\n@(posedge clk_snake_robot) disable iff (rst_serpentine_locomotion)     (undulatory_motion_control && $past(body_wave_propagation, 5)) |-> confined_space_navigation\nendproperty\nassert_p_undulatory_motion_control_to_navigation:assert property (p_undulatory_motion_control_to_navigation) else $error(\"\");", "task_id": "1_5304", "predict_sva": "@(posedge clk_snake_robot) disable iff (rst_serpentine_locomotion)         (rst_serpentine_locomotion == 0 && undulatory_motion_control == 1 && $past(body_wave_propagation, 5) == 1) |-> confined_space_navigation == 1"}
{"sva": "@(posedge clk_agricultural_robot) disable iff(!crop_harvesting_reset) selective_harvesting_algorithm && $past(fruit_ripeness_detection, 6) |-> yield_optimization_strategy", "sva_description": "### Assertion description:  \n**Property Name**: p_selective_harvesting_yield_optimization  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_robot`  \n**Disable Condition**: disable iff (`!crop_harvesting_reset`)  \n**Antecedent (LHS of Implication)**: `selective_harvesting_algorithm && $past(fruit_ripeness_detection, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `yield_optimization_strategy`  ", "sva_signals": ["clk_agricultural_robot", "crop_harvesting_reset", "[0:0] selective_harvesting_algorithm", "[0:0] fruit_ripeness_detection", "[0:0] yield_optimization_strategy"], "clock": "clk_agricultural_robot", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_robot) disable iff (!crop_harvesting_reset)         (selective_harvesting_algorithm && $past(fruit_ripeness_detection, 6)) |-> yield_optimization_strategy", "sva_name": "p_yield_optimization_strategy_on_selective_harvesting_and_fruit_ripeness", "id": "1548", "full_property": "property p_selective_harvesting_yield_optimization;\n@(posedge clk_agricultural_robot) disable iff (!crop_harvesting_reset)         (selective_harvesting_algorithm && $past(fruit_ripeness_detection, 6)) |-> yield_optimization_strategy\nendproperty\nassert_p_selective_harvesting_yield_optimization:assert property (p_selective_harvesting_yield_optimization) else $error(\"\");", "task_id": "1_5306", "predict_sva": "@(posedge clk_agricultural_robot) disable iff (!crop_harvesting_reset)         (crop_harvesting_reset == 1 && selective_harvesting_algorithm == 1 && $past(fruit_ripeness_detection, 6) == 1) |-> yield_optimization_strategy == 1"}
{"sva": "@(posedge clk_climbing_robot) disable iff(!wall_crawling_reset) adhesion_mechanism_control && $past(surface_texture_adaptation, 3) |-> vertical_mobility_capability", "sva_description": "### Assertion description:  \n**Property Name**: p_Adhesion_Control_Meets_Vertical_Mobility  \n**Trigger Condition**: At every rising edge of `clk_climbing_robot`  \n**Disable Condition**: `disable iff (!wall_crawling_reset)`  \n**Antecedent (LHS of Implication)**: `adhesion_mechanism_control && $past(surface_texture_adaptation, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `vertical_mobility_capability`  ", "sva_signals": ["clk_climbing_robot", "wall_crawling_reset", "[0:0] adhesion_mechanism_control", "[0:0] surface_texture_adaptation", "[0:0] vertical_mobility_capability"], "clock": "clk_climbing_robot", "attempts_left": 10, "sva_result": "@(posedge clk_climbing_robot) disable iff (!wall_crawling_reset)     (adhesion_mechanism_control && $past(surface_texture_adaptation, 3)) |-> vertical_mobility_capability", "sva_name": "p_vertical_mobility_capability_on_adhesion_and_texture_adaptation", "id": "1553", "full_property": "property p_Adhesion_Control_Meets_Vertical_Mobility;\n@(posedge clk_climbing_robot) disable iff (!wall_crawling_reset)     (adhesion_mechanism_control && $past(surface_texture_adaptation, 3)) |-> vertical_mobility_capability\nendproperty\nassert_p_Adhesion_Control_Meets_Vertical_Mobility:assert property (p_Adhesion_Control_Meets_Vertical_Mobility) else $error(\"\");", "task_id": "1_5311", "predict_sva": "@(posedge clk_climbing_robot) disable iff (!wall_crawling_reset)         (wall_crawling_reset == 1 && adhesion_mechanism_control == 1 && $past(surface_texture_adaptation, 3) == 1) |-> vertical_mobility_capability == 1"}
{"sva": "@(negedge clk_painting_robot) disable iff(rst_surface_coating) spray_pattern_optimization && $past(paint_viscosity_compensation, 7) |-> uniform_coating_application", "sva_description": "### Assertion description:  \n**Property Name**: p_spray_pattern_optimization  \n**Trigger Condition**: At every falling edge of the `clk_painting_robot`  \n**Disable Condition**: `disable iff (rst_surface_coating)`  \n**Antecedent (LHS of Implication)**: `spray_pattern_optimization && $past(paint_viscosity_compensation, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `uniform_coating_application`", "sva_signals": ["clk_painting_robot", "rst_surface_coating", "[0:0] spray_pattern_optimization", "[0:0] paint_viscosity_compensation", "[0:0] uniform_coating_application"], "clock": "clk_painting_robot", "attempts_left": 10, "sva_result": "@(negedge clk_painting_robot) disable iff (rst_surface_coating)         (spray_pattern_optimization && $past(paint_viscosity_compensation, 7)) |-> uniform_coating_application", "sva_name": "p_uniform_coating_application_on_optimization_and_viscosity", "id": "1567", "full_property": "property p_spray_pattern_optimization;\n@(negedge clk_painting_robot) disable iff (rst_surface_coating)         (spray_pattern_optimization && $past(paint_viscosity_compensation, 7)) |-> uniform_coating_application\nendproperty\nassert_p_spray_pattern_optimization:assert property (p_spray_pattern_optimization) else $error(\"\");", "task_id": "1_5325", "predict_sva": "@(negedge clk_painting_robot) disable iff (rst_surface_coating)         (rst_surface_coating == 0 && spray_pattern_optimization == 1 && $past(paint_viscosity_compensation, 7) == 1) |-> uniform_coating_application == 1"}
{"sva": "@(posedge clk_transforming_robot) disable iff(rst_morphological_change) structural_reconfiguration_sequence && $past(mechanical_constraint_verification, 9) |-> multi_modal_functionality", "sva_description": "### Assertion description:  \n**Property Name**: p_structural_reconfiguration_sequence  \n**Trigger Condition**: At every rising edge of `clk_transforming_robot`  \n**Disable Condition**: `disable iff (rst_morphological_change)`  \n**Antecedent (LHS of Implication)**: `structural_reconfiguration_sequence && $past(mechanical_constraint_verification, 9)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `multi_modal_functionality`", "sva_signals": ["clk_transforming_robot", "rst_morphological_change", "[0:0] structural_reconfiguration_sequence", "[0:0] mechanical_constraint_verification", "[0:0] multi_modal_functionality"], "clock": "clk_transforming_robot", "attempts_left": 10, "sva_result": "@(posedge clk_transforming_robot) disable iff (rst_morphological_change)     structural_reconfiguration_sequence && $past(mechanical_constraint_verification, 9) |-> multi_modal_functionality", "sva_name": "p_multi_modal_functionality_on_reconfig_and_mechanical_constraint", "id": "1579", "full_property": "property p_structural_reconfiguration_sequence;\n@(posedge clk_transforming_robot) disable iff (rst_morphological_change)     structural_reconfiguration_sequence && $past(mechanical_constraint_verification, 9) |-> multi_modal_functionality\nendproperty\nassert_p_structural_reconfiguration_sequence:assert property (p_structural_reconfiguration_sequence) else $error(\"\");", "task_id": "1_5337", "predict_sva": "@(posedge clk_transforming_robot) disable iff (rst_morphological_change)         (rst_morphological_change == 0 && structural_reconfiguration_sequence == 1 && $past(mechanical_constraint_verification, 9) == 1) |-> multi_modal_functionality == 1"}
{"sva": "@(posedge clk_welding_robot) disable iff(rst_arc_welding_control == 1'b1) seam_tracking_algorithm |-> $past(weld_pool_monitoring, 5) && joint_quality_assurance", "sva_description": "### Assertion description:  \n**Property Name**: p_seam_tracking_algorithm_check  \n**Trigger Condition**: At every rising edge of the `clk_welding_robot`  \n**Disable Condition**: disable iff (`rst_arc_welding_control == 1'b1`)  \n**Antecedent (LHS of Implication)**: `seam_tracking_algorithm`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(weld_pool_monitoring, 5) && joint_quality_assurance`  ", "sva_signals": ["clk_welding_robot", "rst_arc_welding_control", "[0:0] seam_tracking_algorithm", "[0:0] weld_pool_monitoring", "[0:0] joint_quality_assurance"], "clock": "clk_welding_robot", "attempts_left": 10, "sva_result": "@(posedge clk_welding_robot) disable iff (rst_arc_welding_control == 1'b1)         seam_tracking_algorithm |-> $past(weld_pool_monitoring, 5) && joint_quality_assurance", "sva_name": "p_seam_tracking_requires_joint_quality_and_weld_pool_monitoring", "id": "1586", "full_property": "property p_seam_tracking_algorithm_check;\n@(posedge clk_welding_robot) disable iff (rst_arc_welding_control == 1'b1)         seam_tracking_algorithm |-> $past(weld_pool_monitoring, 5) && joint_quality_assurance\nendproperty\nassert_p_seam_tracking_algorithm_check:assert property (p_seam_tracking_algorithm_check) else $error(\"\");", "task_id": "1_5343", "predict_sva": "@(posedge clk_welding_robot) disable iff (rst_arc_welding_control)         (rst_arc_welding_control == 0 && seam_tracking_algorithm == 1) |->          (joint_quality_assurance == 1 && $past(weld_pool_monitoring, 5) == 1)"}
{"sva": "@(posedge clk_architecture_exploration) disable iff(rst_system_architecture) performance_power_area_analysis && $past(architectural_template_evaluation, 8) |-> design_methodology_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_performance_power_area_analysis  \n**Trigger Condition**: At every rising edge of the `clk_architecture_exploration`  \n**Disable Condition**: `disable iff (rst_system_architecture)`  \n**Antecedent (LHS of Implication)**: `performance_power_area_analysis && $past(architectural_template_evaluation, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `design_methodology_optimization`", "sva_signals": ["clk", "rst_system_architecture", "[0:0] performance_power_area_analysis", "[0:0] architectural_template_evaluation", "[0:0] design_methodology_optimization", "clk_architecture_exploration"], "clock": "clk_architecture_exploration", "attempts_left": 10, "sva_result": "@(posedge clk_architecture_exploration) disable iff (rst_system_architecture)     performance_power_area_analysis && $past(architectural_template_evaluation, 8) |-> design_methodology_optimization", "sva_name": "p_design_methodology_optimization_on_performance_and_architectural_history", "id": "1593", "full_property": "property p_performance_power_area_analysis;\n@(posedge clk_architecture_exploration) disable iff (rst_system_architecture)     performance_power_area_analysis && $past(architectural_template_evaluation, 8) |-> design_methodology_optimization\nendproperty\nassert_p_performance_power_area_analysis:assert property (p_performance_power_area_analysis) else $error(\"\");", "task_id": "1_5349", "predict_sva": "@(posedge clk_architecture_exploration) disable iff (rst_system_architecture)         (rst_system_architecture == 0 && performance_power_area_analysis == 1 && $past(architectural_template_evaluation, 8) == 1) |-> design_methodology_optimization == 1"}
{"sva": "@(posedge clk_analog_synthesis) disable iff(rst_analog_automation == 1'b1) operational_amplifier_sizing |-> $past(performance_specification_mapping, 9) && analog_circuit_optimization", "sva_description": "### Assertion description:  \n**Property Name**: operational_amplifier_sizing_check  \n**Trigger Condition**: At every rising edge of the `clk_analog_synthesis`  \n**Disable Condition**: `disable iff (rst_analog_automation == 1'b1)`  \n**Antecedent (LHS of Implication)**: `operational_amplifier_sizing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(performance_specification_mapping, 9) && analog_circuit_optimization`  ", "sva_signals": ["clk_analog_synthesis", "rst_analog_automation", "[0:0] operational_amplifier_sizing", "[0:0] performance_specification_mapping", "[0:0] analog_circuit_optimization"], "clock": "clk_analog_synthesis", "attempts_left": 10, "sva_result": "@(posedge clk_analog_synthesis) disable iff (rst_analog_automation == 1'b1)     operational_amplifier_sizing |-> $past(performance_specification_mapping, 9) && analog_circuit_optimization", "sva_name": "p_operational_amplifier_sizing_dependency", "id": "1633", "full_property": "property operational_amplifier_sizing_check;\n@(posedge clk_analog_synthesis) disable iff (rst_analog_automation == 1'b1)     operational_amplifier_sizing |-> $past(performance_specification_mapping, 9) && analog_circuit_optimization\nendproperty\nassert_operational_amplifier_sizing_check:assert property (operational_amplifier_sizing_check) else $error(\"\");", "task_id": "1_5389", "predict_sva": "@(posedge clk_analog_synthesis) disable iff (rst_analog_automation)         (rst_analog_automation == 0 && operational_amplifier_sizing == 1) |->          ($past(performance_specification_mapping, 9) == 1) && analog_circuit_optimization == 1"}
{"sva": "@(posedge clk_life_support) disable iff(rst_environmental_control) carbon_dioxide_scrubbing && $past(atmospheric_composition_monitoring, 3) |-> crew_safety_assurance", "sva_description": "### Assertion description:  \n**Property Name**: p_Crew_Safety_After_Scrubbing  \n**Trigger Condition**: At every rising edge of the `clk_life_support`  \n**Disable Condition**: `disable iff (rst_environmental_control)`  \n**Antecedent (LHS of Implication)**: `carbon_dioxide_scrubbing && $past(atmospheric_composition_monitoring, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crew_safety_assurance`  ", "sva_signals": ["clk_life_support", "rst_environmental_control", "[0:0] carbon_dioxide_scrubbing", "[0:0] atmospheric_composition_monitoring", "[0:0] crew_safety_assurance"], "clock": "clk_life_support", "attempts_left": 10, "sva_result": "@(posedge clk_life_support) disable iff (rst_environmental_control)     (carbon_dioxide_scrubbing && $past(atmospheric_composition_monitoring, 3)) |-> crew_safety_assurance", "sva_name": "p_crew_safety_assurance_on_scrubbing_and_past_monitoring", "id": "1638", "full_property": "property p_Crew_Safety_After_Scrubbing;\n@(posedge clk_life_support) disable iff (rst_environmental_control)     (carbon_dioxide_scrubbing && $past(atmospheric_composition_monitoring, 3)) |-> crew_safety_assurance\nendproperty\nassert_p_Crew_Safety_After_Scrubbing:assert property (p_Crew_Safety_After_Scrubbing) else $error(\"\");", "task_id": "1_5394", "predict_sva": "@(posedge clk_life_support) disable iff (rst_environmental_control)         (rst_environmental_control == 0 && carbon_dioxide_scrubbing == 1 && $past(atmospheric_composition_monitoring, 3) == 1) |-> crew_safety_assurance == 1"}
{"sva": "@(posedge clk_spacecraft) disable iff(!attitude_control_rst_n) reaction_wheel_momentum && $past(gyroscope_drift_compensation, 6) |-> three_axis_stabilization", "sva_description": "### Assertion description:  \n**Property Name**: p_reaction_wheel_stabilization  \n**Trigger Condition**: At every rising edge of the `clk_spacecraft`  \n**Disable Condition**: `disable iff (!attitude_control_rst_n)`  \n**Antecedent (LHS of Implication)**: `reaction_wheel_momentum && $past(gyroscope_drift_compensation, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `three_axis_stabilization`", "sva_signals": ["clk_spacecraft", "attitude_control_rst_n", "[0:0] reaction_wheel_momentum", "[0:0] gyroscope_drift_compensation", "[0:0] three_axis_stabilization"], "clock": "clk_spacecraft", "attempts_left": 10, "sva_result": "@(posedge clk_spacecraft) disable iff (!attitude_control_rst_n)         reaction_wheel_momentum && $past(gyroscope_drift_compensation, 6) |-> three_axis_stabilization", "sva_name": "p_three_axis_stabilization_on_momentum_and_past_drift_compensation", "id": "1649", "full_property": "property p_reaction_wheel_stabilization;\n@(posedge clk_spacecraft) disable iff (!attitude_control_rst_n)         reaction_wheel_momentum && $past(gyroscope_drift_compensation, 6) |-> three_axis_stabilization\nendproperty\nassert_p_reaction_wheel_stabilization:assert property (p_reaction_wheel_stabilization) else $error(\"\");", "task_id": "1_5405", "predict_sva": "@(posedge clk_spacecraft) disable iff (!attitude_control_rst_n)         (attitude_control_rst_n == 1 && reaction_wheel_momentum == 1 && $past(gyroscope_drift_compensation, 6) == 1) |-> three_axis_stabilization == 1"}
{"sva": "@(negedge clk_atomic_clock) disable iff(!frequency_standard_reset) cesium_hyperfine_transition && $past(magnetic_field_shielding_effectiveness, 3) |-> precision_timekeeping_reference", "sva_description": "### Assertion description:  \n**Property Name**: p_Cesium_Hyperfine_Transition_Precision  \n**Trigger Condition**: At every falling edge of the `clk_atomic_clock`  \n**Disable Condition**: disable iff `(!frequency_standard_reset)`  \n**Antecedent (LHS of Implication)**: `cesium_hyperfine_transition && $past(magnetic_field_shielding_effectiveness, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `precision_timekeeping_reference`  ", "sva_signals": ["clk_atomic_clock", "frequency_standard_reset", "[0:0] cesium_hyperfine_transition", "[0:0] magnetic_field_shielding_effectiveness", "[0:0] precision_timekeeping_reference"], "clock": "clk_atomic_clock", "attempts_left": 10, "sva_result": "@(negedge clk_atomic_clock) disable iff (!frequency_standard_reset)         cesium_hyperfine_transition && $past(magnetic_field_shielding_effectiveness, 3) |-> precision_timekeeping_reference", "sva_name": "p_precision_timekeeping_reference_on_hyperfine_transition_and_shielding_effectiveness", "id": "1652", "full_property": "property p_Cesium_Hyperfine_Transition_Precision;\n@(negedge clk_atomic_clock) disable iff (!frequency_standard_reset)         cesium_hyperfine_transition && $past(magnetic_field_shielding_effectiveness, 3) |-> precision_timekeeping_reference\nendproperty\nassert_p_Cesium_Hyperfine_Transition_Precision:assert property (p_Cesium_Hyperfine_Transition_Precision) else $error(\"\");", "task_id": "1_5408", "predict_sva": "@(negedge clk_atomic_clock) disable iff (!frequency_standard_reset)         (frequency_standard_reset == 1 && cesium_hyperfine_transition == 1 && $past(magnetic_field_shielding_effectiveness, 3) == 1) |-> precision_timekeeping_reference == 1"}
{"sva": "@(negedge clk_vehicle_dynamics) disable iff(rst_stability_control == 1'b1) electronic_stability_program |-> $past(yaw_rate_sensor_validation, 3) && traction_control_intervention", "sva_description": "### Assertion description:  \n**Property Name**: p_electronic_stability_program_check  \n**Trigger Condition**: At every falling edge of `clk_vehicle_dynamics`  \n**Disable Condition**: `disable iff (rst_stability_control == 1'b1)`  \n**Antecedent (LHS of Implication)**: `electronic_stability_program == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(yaw_rate_sensor_validation, 3) && traction_control_intervention`  \n\n(Note: The consequent checks that both the following conditions are true:  \n1. The value of `yaw_rate_sensor_validation` from **3 clock cycles ago** is true.  \n2. The current value of `traction_control_intervention` is true.)", "sva_signals": ["clk_vehicle_dynamics", "rst_stability_control", "[0:0] electronic_stability_program", "[0:0] yaw_rate_sensor_validation", "[0:0] traction_control_intervention"], "clock": "clk_vehicle_dynamics", "attempts_left": 10, "sva_result": "@(negedge clk_vehicle_dynamics) disable iff (rst_stability_control == 1'b1)     electronic_stability_program == 1'b1 |-> $past(yaw_rate_sensor_validation, 3) && traction_control_intervention", "sva_name": "p_stability_program_yawrate_tci_asserted", "id": "1728", "full_property": "property p_electronic_stability_program_check;\n@(negedge clk_vehicle_dynamics) disable iff (rst_stability_control == 1'b1)     electronic_stability_program == 1'b1 |-> $past(yaw_rate_sensor_validation, 3) && traction_control_intervention\nendproperty\nassert_p_electronic_stability_program_check:assert property (p_electronic_stability_program_check) else $error(\"\");", "task_id": "1_5481", "predict_sva": "@(negedge clk_vehicle_dynamics) disable iff (rst_stability_control)         (rst_stability_control == 0 && electronic_stability_program == 1) |->          ($past(yaw_rate_sensor_validation, 3) == 1 && traction_control_intervention == 1)"}
{"sva": "@(posedge clk_powertrain_control) disable iff(rst_engine_management) fuel_injection_timing && $past(knock_sensor_threshold_adaptation, 7) |-> combustion_efficiency_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_Fuel_Injection_Timing_Combustion_Efficiency  \n**Trigger Condition**: At every rising edge of the `clk_powertrain_control`  \n**Disable Condition**: `disable iff (rst_engine_management)`  \n**Antecedent (LHS of Implication)**: `fuel_injection_timing && $past(knock_sensor_threshold_adaptation, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `combustion_efficiency_optimization`  ", "sva_signals": ["clk_powertrain_control", "rst_engine_management", "[0:0] fuel_injection_timing", "[0:0] knock_sensor_threshold_adaptation", "[0:0] combustion_efficiency_optimization"], "clock": "clk_powertrain_control", "attempts_left": 10, "sva_result": "@(posedge clk_powertrain_control) disable iff (rst_engine_management)     fuel_injection_timing && $past(knock_sensor_threshold_adaptation, 7) |-> combustion_efficiency_optimization", "sva_name": "p_combustion_efficiency_optimization_on_timing_and_knock_history", "id": "1730", "full_property": "property p_Fuel_Injection_Timing_Combustion_Efficiency;\n@(posedge clk_powertrain_control) disable iff (rst_engine_management)     fuel_injection_timing && $past(knock_sensor_threshold_adaptation, 7) |-> combustion_efficiency_optimization\nendproperty\nassert_p_Fuel_Injection_Timing_Combustion_Efficiency:assert property (p_Fuel_Injection_Timing_Combustion_Efficiency) else $error(\"\");", "task_id": "1_5483", "predict_sva": "@(posedge clk_powertrain_control) disable iff (rst_engine_management)         (rst_engine_management == 0 && fuel_injection_timing == 1 && $past(knock_sensor_threshold_adaptation, 7) == 1) |-> combustion_efficiency_optimization == 1"}
{"sva": "@(posedge clk_equity_research) disable iff(rst_fundamental_analysis) discounted_cash_flow_model && $past(earnings_forecast_revision, 7) |-> fair_value_estimation", "sva_description": "### Assertion description:  \n**Property Name**: p_fair_value_estimation  \n**Trigger Condition**: At every rising edge of the `clk_equity_research`  \n**Disable Condition**: disable iff (`rst_fundamental_analysis`)  \n**Antecedent (LHS of Implication)**: `discounted_cash_flow_model && $past(earnings_forecast_revision, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fair_value_estimation`", "sva_signals": ["clk_equity_research", "rst_fundamental_analysis", "[0:0] discounted_cash_flow_model", "[0:0] earnings_forecast_revision", "[0:0] fair_value_estimation"], "clock": "clk_equity_research", "attempts_left": 10, "sva_result": "@(posedge clk_equity_research) disable iff (rst_fundamental_analysis)     discounted_cash_flow_model && $past(earnings_forecast_revision, 7) |-> fair_value_estimation", "sva_name": "p_fair_value_estimation_on_dcf_and_earnings_revision", "id": "1740", "full_property": "property p_fair_value_estimation;\n@(posedge clk_equity_research) disable iff (rst_fundamental_analysis)     discounted_cash_flow_model && $past(earnings_forecast_revision, 7) |-> fair_value_estimation\nendproperty\nassert_p_fair_value_estimation:assert property (p_fair_value_estimation) else $error(\"\");", "task_id": "1_5493", "predict_sva": "@(posedge clk_equity_research) disable iff (rst_fundamental_analysis)         (rst_fundamental_analysis == 0 && discounted_cash_flow_model == 1 && $past(earnings_forecast_revision, 7) == 1) |-> fair_value_estimation == 1"}
{"sva": "@(posedge clk_collision_mitigation) disable iff(rst_pre_crash_system) airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_airbag_deployment_timing  \n**Trigger Condition**: At every rising edge of the `clk_collision_mitigation`  \n**Disable Condition**: `disable iff (rst_pre_crash_system)`  \n**Antecedent (LHS of Implication)**: `airbag_deployment_timing && $past(crash_severity_assessment, 12)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `occupant_protection_optimization`", "sva_signals": ["clk_collision_mitigation", "rst_pre_crash_system", "[0:0] airbag_deployment_timing", "[0:0] crash_severity_assessment", "[0:0] occupant_protection_optimization"], "clock": "clk_collision_mitigation", "attempts_left": 10, "sva_result": "@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)     airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization", "sva_name": "p_occupant_protection_optimization_on_airbag_and_crash_history", "id": "1780", "full_property": "property p_airbag_deployment_timing;\n@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)     airbag_deployment_timing && $past(crash_severity_assessment, 12) |-> occupant_protection_optimization\nendproperty\nassert_p_airbag_deployment_timing:assert property (p_airbag_deployment_timing) else $error(\"\");", "task_id": "1_5533", "predict_sva": "@(posedge clk_collision_mitigation) disable iff (rst_pre_crash_system)         (rst_pre_crash_system == 0 && airbag_deployment_timing == 1 && $past(crash_severity_assessment, 12) == 1) |-> occupant_protection_optimization == 1"}
{"sva": "@(posedge clk_hybrid_powertrain) disable iff(rst_energy_management == 1'b1) power_split_device_control |-> $past(battery_state_of_charge_prediction, 6) && fuel_economy_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Split_Device_Control  \n**Trigger Condition**: At every rising edge of the `clk_hybrid_powertrain`  \n**Disable Condition**: `disable iff (rst_energy_management == 1'b1)`  \n**Antecedent (LHS of Implication)**: `power_split_device_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(battery_state_of_charge_prediction, 6) && fuel_economy_optimization`  \n\n(Note: The assertion checks that whenever `power_split_device_control` is active, the past value of `battery_state_of_charge_prediction` from 6 clock cycles ago must be true, and `fuel_economy_optimization` must also be true at the current cycle.)", "sva_signals": ["clk_hybrid_powertrain", "rst_energy_management", "[0:0] power_split_device_control", "[0:0] battery_state_of_charge_prediction", "[0:0] fuel_economy_optimization"], "clock": "clk_hybrid_powertrain", "attempts_left": 10, "sva_result": "@(posedge clk_hybrid_powertrain) disable iff (rst_energy_management == 1'b1)     power_split_device_control == 1'b1 |->      $past(battery_state_of_charge_prediction, 6) && fuel_economy_optimization", "sva_name": "p_power_split_device_control_soc_prediction_fuel_optimization", "id": "1810", "full_property": "property p_Power_Split_Device_Control;\n@(posedge clk_hybrid_powertrain) disable iff (rst_energy_management == 1'b1)     power_split_device_control == 1'b1 |->      $past(battery_state_of_charge_prediction, 6) && fuel_economy_optimization\nendproperty\nassert_p_Power_Split_Device_Control:assert property (p_Power_Split_Device_Control) else $error(\"\");", "task_id": "1_5563", "predict_sva": "@(posedge clk_hybrid_powertrain) disable iff (rst_energy_management)         (rst_energy_management == 0 && power_split_device_control == 1) |->          ($past(battery_state_of_charge_prediction, 6) == 1) && fuel_economy_optimization == 1"}
{"sva": "@(negedge clk_vehicle_dynamics_control) disable iff(rst_yaw_stability == 1'b1) understeer_oversteer_mitigation |-> $past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement", "sva_description": "### Assertion description:  \n**Property Name**: p_Understeer_Oversteer_Mitigation  \n**Trigger Condition**: At every falling edge of the `clk_vehicle_dynamics_control`  \n**Disable Condition**: `disable iff (rst_yaw_stability == 1'b1)`  \n**Antecedent (LHS of Implication)**: `understeer_oversteer_mitigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement`", "sva_signals": ["clk_vehicle_dynamics_control", "rst_yaw_stability", "[0:0] understeer_oversteer_mitigation", "[0:0] lateral_acceleration_measurement", "[0:0] handling_characteristic_enhancement"], "clock": "clk_vehicle_dynamics_control", "attempts_left": 10, "sva_result": "@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability == 1'b1)     understeer_oversteer_mitigation |->      ($past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement)", "sva_name": "p_understeer_oversteer_mitigation_lateral_accel_and_handling_enhancement", "id": "1802", "full_property": "property p_Understeer_Oversteer_Mitigation;\n@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability == 1'b1)     understeer_oversteer_mitigation |->      ($past(lateral_acceleration_measurement, 7) && handling_characteristic_enhancement)\nendproperty\nassert_p_Understeer_Oversteer_Mitigation:assert property (p_Understeer_Oversteer_Mitigation) else $error(\"\");", "task_id": "1_5555", "predict_sva": "@(negedge clk_vehicle_dynamics_control) disable iff (rst_yaw_stability)         (rst_yaw_stability == 0 && understeer_oversteer_mitigation == 1) |->          (handling_characteristic_enhancement == 1 && $past(lateral_acceleration_measurement, 7) == 1)"}
{"sva": "@(negedge clk_vehicle_integration) disable iff(rst_system_orchestration == 1'b1) multi_domain_coordination |-> $past(inter_ecu_communication_validation, 11) && seamless_functionality_integration", "sva_description": "### Assertion description:  \n**Property Name**: p_multi_domain_coordination_check  \n**Trigger Condition**: At every falling edge of the `clk_vehicle_integration`  \n**Disable Condition**: disable iff (`rst_system_orchestration == 1'b1`)  \n**Antecedent (LHS of Implication)**: `multi_domain_coordination`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(inter_ecu_communication_validation, 11) && seamless_functionality_integration`  ", "sva_signals": ["clk_vehicle_integration", "rst_system_orchestration", "[0:0] multi_domain_coordination", "inter_ecu_communication_validation", "[0:0] seamless_functionality_integration"], "clock": "clk_vehicle_integration", "attempts_left": 10, "sva_result": "@(negedge clk_vehicle_integration) disable iff (rst_system_orchestration == 1'b1)     multi_domain_coordination |-> ($past(inter_ecu_communication_validation, 11) && seamless_functionality_integration)", "sva_name": "p_multi_domain_coordination_dependency", "id": "1828", "full_property": "property p_multi_domain_coordination_check;\n@(negedge clk_vehicle_integration) disable iff (rst_system_orchestration == 1'b1)     multi_domain_coordination |-> ($past(inter_ecu_communication_validation, 11) && seamless_functionality_integration)\nendproperty\nassert_p_multi_domain_coordination_check:assert property (p_multi_domain_coordination_check) else $error(\"\");", "task_id": "1_5581", "predict_sva": "@(negedge clk_vehicle_integration) disable iff (rst_system_orchestration)         (rst_system_orchestration == 0 && multi_domain_coordination == 1) |->          (seamless_functionality_integration == 1 && $past(inter_ecu_communication_validation, 11) == 1)"}
{"sva": "@(negedge clk_content_delivery) disable iff(rst_streaming_service == 1'b1) adaptive_bitrate_streaming |-> $past(network_bandwidth_estimation, 5) && quality_of_service_optimization", "sva_description": "### Assertion description:  \n**Property Name**: p_adaptive_bitrate_streaming_check  \n**Trigger Condition**: At every falling edge of the `clk_content_delivery`  \n**Disable Condition**: `disable iff (rst_streaming_service == 1'b1)`  \n**Antecedent (LHS of Implication)**: `adaptive_bitrate_streaming == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(network_bandwidth_estimation, 5) && quality_of_service_optimization`  ", "sva_signals": ["clk_content_delivery", "rst_streaming_service", "[0:0] adaptive_bitrate_streaming", "[0:0] network_bandwidth_estimation", "[0:0] quality_of_service_optimization"], "clock": "clk_content_delivery", "attempts_left": 10, "sva_result": "disable iff (rst_streaming_service == 1'b1)     @(negedge clk_content_delivery)         adaptive_bitrate_streaming == 1'b1 |->          $past(network_bandwidth_estimation, 5) && quality_of_service_optimization", "sva_name": "p_adaptive_bitrate_streaming_bandwidth_quality_check", "id": "1848", "full_property": "property p_adaptive_bitrate_streaming_check;\ndisable iff (rst_streaming_service == 1'b1)     @(negedge clk_content_delivery)         adaptive_bitrate_streaming == 1'b1 |->          $past(network_bandwidth_estimation, 5) && quality_of_service_optimization\nendproperty\nassert_p_adaptive_bitrate_streaming_check:assert property (p_adaptive_bitrate_streaming_check) else $error(\"\");", "task_id": "1_5601", "predict_sva": "@(negedge clk_content_delivery) disable iff (rst_streaming_service)         (adaptive_bitrate_streaming == 1'b1 && rst_streaming_service == 1'b0) |->          ($past(network_bandwidth_estimation, 5) == 1'b1) && quality_of_service_optimization == 1'b1"}
{"sva": "@(posedge clk_ray_tracing) disable iff(rst_acceleration_structure == 1'b1) bounding_volume_hierarchy |-> $past(ray_triangle_intersection_test, 8) && photorealistic_lighting_simulation", "sva_description": "### Assertion description:  \n**Property Name**: p_BVH_After_RayIntersection  \n**Trigger Condition**: At every rising edge of the `clk_ray_tracing`  \n**Disable Condition**: `disable iff (rst_acceleration_structure == 1'b1)`  \n**Antecedent (LHS of Implication)**: `bounding_volume_hierarchy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ray_triangle_intersection_test, 8) && photorealistic_lighting_simulation`  ", "sva_signals": ["clk_ray_tracing", "rst_acceleration_structure", "[0:0] bounding_volume_hierarchy", "[0:0] ray_triangle_intersection_test", "[0:0] photorealistic_lighting_simulation"], "clock": "clk_ray_tracing", "attempts_left": 10, "sva_result": "@(posedge clk_ray_tracing) disable iff (rst_acceleration_structure == 1'b1)     bounding_volume_hierarchy |-> $past(ray_triangle_intersection_test, 8) && photorealistic_lighting_simulation", "sva_name": "p_bounding_volume_hierarchy_allowed", "id": "1861", "full_property": "property p_BVH_After_RayIntersection;\n@(posedge clk_ray_tracing) disable iff (rst_acceleration_structure == 1'b1)     bounding_volume_hierarchy |-> $past(ray_triangle_intersection_test, 8) && photorealistic_lighting_simulation\nendproperty\nassert_p_BVH_After_RayIntersection:assert property (p_BVH_After_RayIntersection) else $error(\"\");", "task_id": "1_5614", "predict_sva": "@(posedge clk_ray_tracing) disable iff (rst_acceleration_structure)         (rst_acceleration_structure == 0 && bounding_volume_hierarchy == 1) |->          (photorealistic_lighting_simulation == 1 && $past(ray_triangle_intersection_test, 8) == 1)"}
{"sva": "@(posedge clk_virtual_reality) disable iff(rst_head_mounted_display == 1'b1) stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance", "sva_description": "### Assertion description:  \n**Property Name**: p_Stereoscopic_Rendering_Pipeline_Check  \n**Trigger Condition**: At every rising edge of the `clk_virtual_reality`  \n**Disable Condition**: `disable iff (rst_head_mounted_display == 1'b1)`  \n**Antecedent (LHS of Implication)**: `stereoscopic_rendering_pipeline`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance`  ", "sva_signals": ["clk_virtual_reality", "rst_head_mounted_display", "[0:0] stereoscopic_rendering_pipeline", "[0:0] motion_to_photon_latency_measurement", "[0:0] presence_illusion_maintenance"], "clock": "clk_virtual_reality", "attempts_left": 10, "sva_result": "@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display == 1'b1)     stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance", "sva_name": "p_stereoscopic_rendering_pipeline_latency_and_presence_check", "id": "1855", "full_property": "property p_Stereoscopic_Rendering_Pipeline_Check;\n@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display == 1'b1)     stereoscopic_rendering_pipeline |-> $past(motion_to_photon_latency_measurement, 3) && presence_illusion_maintenance\nendproperty\nassert_p_Stereoscopic_Rendering_Pipeline_Check:assert property (p_Stereoscopic_Rendering_Pipeline_Check) else $error(\"\");", "task_id": "1_5608", "predict_sva": "@(posedge clk_virtual_reality) disable iff (rst_head_mounted_display)         (rst_head_mounted_display == 0 && stereoscopic_rendering_pipeline == 1) |->          ($past(motion_to_photon_latency_measurement, 3) == 1) &&          (presence_illusion_maintenance == 1)"}
{"sva": "@(posedge clk_future_mobility) disable iff(rst_transportation_evolution) connected_autonomous_shared_electric && $past(mobility_service_optimization, 13) |-> sustainable_transportation_ecosystem", "sva_description": "### Assertion description:  \n**Property Name**: p_connected_autonomous_shared_electric_implies_sustainable_ecosystem  \n**Trigger Condition**: At every rising edge of `clk_future_mobility`  \n**Disable Condition**: `disable iff (rst_transportation_evolution)`  \n**Antecedent (LHS of Implication)**: `connected_autonomous_shared_electric && $past(mobility_service_optimization, 13)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sustainable_transportation_ecosystem`  ", "sva_signals": ["clk_future_mobility", "rst_transportation_evolution", "[0:0] connected_autonomous_shared_electric", "[0:0] mobility_service_optimization", "[0:0] sustainable_transportation_ecosystem"], "clock": "clk_future_mobility", "attempts_left": 10, "sva_result": "@(posedge clk_future_mobility) disable iff (rst_transportation_evolution)     connected_autonomous_shared_electric && $past(mobility_service_optimization, 13) |-> sustainable_transportation_ecosystem", "sva_name": "p_sustainable_transportation_ecosystem_on_mobility_service_optimization", "id": "1863", "full_property": "property p_connected_autonomous_shared_electric_implies_sustainable_ecosystem;\n@(posedge clk_future_mobility) disable iff (rst_transportation_evolution)     connected_autonomous_shared_electric && $past(mobility_service_optimization, 13) |-> sustainable_transportation_ecosystem\nendproperty\nassert_p_connected_autonomous_shared_electric_implies_sustainable_ecosystem:assert property (p_connected_autonomous_shared_electric_implies_sustainable_ecosystem) else $error(\"\");", "task_id": "1_5616", "predict_sva": "@(posedge clk_future_mobility) disable iff (rst_transportation_evolution)         (rst_transportation_evolution == 0 && connected_autonomous_shared_electric == 1 && $past(mobility_service_optimization, 13) == 1) |-> sustainable_transportation_ecosystem == 1"}
{"sva": "@(negedge clk_spatial_audio) disable iff(rst_binaural_rendering == 1'b1) head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape", "sva_description": "### Assertion description:  \n**Property Name**: p_head_tracking_compensation  \n**Trigger Condition**: At every falling edge of `clk_spatial_audio`  \n**Disable Condition**: `disable iff (rst_binaural_rendering == 1'b1)`  \n**Antecedent (LHS of Implication)**: `head_tracking_compensation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(room_impulse_response_convolution, 10) && immersive_3d_soundscape`  ", "sva_signals": ["clk", "rst_binaural_rendering", "[0:0] head_tracking_compensation", "[0:0] room_impulse_response_convolution", "[0:0] immersive_3d_soundscape", "clk_spatial_audio"], "clock": "clk_spatial_audio", "attempts_left": 10, "sva_result": "@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape", "sva_name": "p_head_tracking_compensation", "id": "1886", "full_property": "property p_head_tracking_compensation;\n@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |-> $past(room_impulse_response_convolution, 10) && immersive_3d_soundscape\nendproperty\nassert_p_head_tracking_compensation:assert property (p_head_tracking_compensation) else $error(\"\");", "task_id": "1_5637", "predict_sva": "@(negedge clk_spatial_audio) disable iff (rst_binaural_rendering == 1'b1)     head_tracking_compensation |->          ($past(room_impulse_response_convolution, 10) &&           immersive_3d_soundscape)"}
{"sva": "@(posedge clk_environmental_storytelling) disable iff(!narrative_engine_reset) procedural_quest_generation && $past(story_branch_coherence_check, 5) |-> emergent_narrative_experience", "sva_description": "### Assertion description:  \n**Property Name**: p_Emergent_Narrative_Experience  \n**Trigger Condition**: At every rising edge of the `clk_environmental_storytelling`  \n**Disable Condition**: `disable iff (!narrative_engine_reset)`  \n**Antecedent (LHS of Implication)**: `procedural_quest_generation && $past(story_branch_coherence_check, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `emergent_narrative_experience`  ", "sva_signals": ["clk_environmental_storytelling", "narrative_engine_reset", "[0:0] procedural_quest_generation", "[0:0] story_branch_coherence_check", "[0:0] emergent_narrative_experience"], "clock": "clk_environmental_storytelling", "attempts_left": 10, "sva_result": "@(posedge clk_environmental_storytelling) disable iff (!narrative_engine_reset)         procedural_quest_generation && $past(story_branch_coherence_check, 5) |-> emergent_narrative_experience", "sva_name": "p_emergent_narrative_experience_on_procedural_and_coherence", "id": "1868", "full_property": "property p_Emergent_Narrative_Experience;\n@(posedge clk_environmental_storytelling) disable iff (!narrative_engine_reset)         procedural_quest_generation && $past(story_branch_coherence_check, 5) |-> emergent_narrative_experience\nendproperty\nassert_p_Emergent_Narrative_Experience:assert property (p_Emergent_Narrative_Experience) else $error(\"\");", "task_id": "1_5621", "predict_sva": "@(posedge clk_environmental_storytelling) disable iff (narrative_engine_reset == 0)         (narrative_engine_reset == 1 && procedural_quest_generation == 1 && $past(story_branch_coherence_check, 5) == 1) |-> emergent_narrative_experience == 1"}
{"sva": "@(negedge clk_eye_tracking) disable iff(!gaze_detection_reset) foveated_rendering_optimization && $past(pupil_center_estimation, 8) |-> visual_attention_based_performance", "sva_description": "### Assertion description:  \n**Property Name**: p_Foveated_Rendering_Optimization  \n**Trigger Condition**: At every falling edge of `clk_eye_tracking`  \n**Disable Condition**: `disable iff (!gaze_detection_reset)`  \n**Antecedent (LHS of Implication)**: `foveated_rendering_optimization && $past(pupil_center_estimation, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `visual_attention_based_performance`", "sva_signals": ["clk_eye_tracking", "gaze_detection_reset", "[0:0] foveated_rendering_optimization", "[0:0] pupil_center_estimation", "[0:0] visual_attention_based_performance"], "clock": "clk_eye_tracking", "attempts_left": 10, "sva_result": "@(negedge clk_eye_tracking) disable iff (!gaze_detection_reset)     foveated_rendering_optimization && $past(pupil_center_estimation, 8) |-> visual_attention_based_performance", "sva_name": "p_visual_attention_based_performance_on_foveated_and_pupil_history", "id": "1879", "full_property": "property p_Foveated_Rendering_Optimization;\n@(negedge clk_eye_tracking) disable iff (!gaze_detection_reset)     foveated_rendering_optimization && $past(pupil_center_estimation, 8) |-> visual_attention_based_performance\nendproperty\nassert_p_Foveated_Rendering_Optimization:assert property (p_Foveated_Rendering_Optimization) else $error(\"\");", "task_id": "1_5630", "predict_sva": "@(negedge clk_eye_tracking) disable iff (!gaze_detection_reset)         (gaze_detection_reset == 1 && foveated_rendering_optimization == 1 && $past(pupil_center_estimation, 8) == 1) |-> visual_attention_based_performance == 1"}
{"sva": "@(posedge clk_sound_occlusion) disable iff(rst_audio_ray_casting) geometric_acoustics_simulation && $past(surface_material_absorption, 6) |-> realistic_audio_propagation", "sva_description": "### Assertion description:  \n**Property Name**: p_realistic_audio_propagation  \n**Trigger Condition**: At every rising edge of the `clk_sound_occlusion`  \n**Disable Condition**: `disable iff (rst_audio_ray_casting)`  \n**Antecedent (LHS of Implication)**: `geometric_acoustics_simulation && $past(surface_material_absorption, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `realistic_audio_propagation`  ", "sva_signals": ["clk_sound_occlusion", "rst_audio_ray_casting", "[0:0] geometric_acoustics_simulation", "[0:0] surface_material_absorption", "[0:0] realistic_audio_propagation"], "clock": "clk_sound_occlusion", "attempts_left": 10, "sva_result": "@(posedge clk_sound_occlusion) disable iff (rst_audio_ray_casting)         geometric_acoustics_simulation && $past(surface_material_absorption, 6) |-> realistic_audio_propagation", "sva_name": "p_realistic_audio_propagation_on_acoustics_and_absorption", "id": "1887", "full_property": "property p_realistic_audio_propagation;\n@(posedge clk_sound_occlusion) disable iff (rst_audio_ray_casting)         geometric_acoustics_simulation && $past(surface_material_absorption, 6) |-> realistic_audio_propagation\nendproperty\nassert_p_realistic_audio_propagation:assert property (p_realistic_audio_propagation) else $error(\"\");", "task_id": "1_5638", "predict_sva": "@(posedge clk_sound_occlusion) disable iff (rst_audio_ray_casting)         (rst_audio_ray_casting == 0 && geometric_acoustics_simulation == 1 && $past(surface_material_absorption, 6) == 1) |-> realistic_audio_propagation == 1"}
{"sva": "@(posedge clk_digital_twin) disable iff(!simulation_engine_rst_n) real_time_synchronization && $past(sensor_data_fusion_complete, 5) |-> virtual_model_state_update", "sva_description": "### Assertion description:  \n**Property Name**: p_virtual_model_state_update  \n**Trigger Condition**: At every rising edge of the `clk_digital_twin`  \n**Disable Condition**: `disable iff (!simulation_engine_rst_n)`  \n**Antecedent (LHS of Implication)**: `real_time_synchronization && $past(sensor_data_fusion_complete, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `virtual_model_state_update`  ", "sva_signals": ["clk_digital_twin", "simulation_engine_rst_n", "[0:0] real_time_synchronization", "[0:0] sensor_data_fusion_complete", "[0:0] virtual_model_state_update"], "clock": "clk_digital_twin", "attempts_left": 10, "sva_result": "@(posedge clk_digital_twin) disable iff (!simulation_engine_rst_n)     (real_time_synchronization && $past(sensor_data_fusion_complete, 5)) |-> virtual_model_state_update", "sva_name": "p_virtual_model_state_update_on_sync_and_fusion", "id": "1891", "full_property": "property p_virtual_model_state_update;\n@(posedge clk_digital_twin) disable iff (!simulation_engine_rst_n)     (real_time_synchronization && $past(sensor_data_fusion_complete, 5)) |-> virtual_model_state_update\nendproperty\nassert_p_virtual_model_state_update:assert property (p_virtual_model_state_update) else $error(\"\");", "task_id": "1_5642", "predict_sva": "@(posedge clk_digital_twin) disable iff (!simulation_engine_rst_n)         (simulation_engine_rst_n == 1 && real_time_synchronization == 1 && $past(sensor_data_fusion_complete, 5) == 1) |-> virtual_model_state_update == 1"}
{"sva": "@(posedge clk_additive_manufacturing) disable iff(rst_3d_printing == 1'b1) layer_deposition_control |-> $past(material_extrusion_temperature, 11) && dimensional_accuracy_maintenance", "sva_description": "### Assertion description:  \n**Property Name**: p_layer_deposition_control  \n**Trigger Condition**: At every rising edge of the `clk_additive_manufacturing`  \n**Disable Condition**: `disable iff (rst_3d_printing == 1'b1)`  \n**Antecedent (LHS of Implication)**: `layer_deposition_control`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(material_extrusion_temperature, 11) && dimensional_accuracy_maintenance`  ", "sva_signals": ["clk_additive_manufacturing", "rst_3d_printing", "[0:0] layer_deposition_control", "[0:0] material_extrusion_temperature", "[0:0] dimensional_accuracy_maintenance"], "clock": "clk_additive_manufacturing", "attempts_left": 10, "sva_result": "@(posedge clk_additive_manufacturing) disable iff (rst_3d_printing == 1'b1)     layer_deposition_control |-> $past(material_extrusion_temperature, 11) && dimensional_accuracy_maintenance", "sva_name": "p_layer_deposition_control_requires_temp_and_accuracy", "id": "1916", "full_property": "property p_layer_deposition_control;\n@(posedge clk_additive_manufacturing) disable iff (rst_3d_printing == 1'b1)     layer_deposition_control |-> $past(material_extrusion_temperature, 11) && dimensional_accuracy_maintenance\nendproperty\nassert_p_layer_deposition_control:assert property (p_layer_deposition_control) else $error(\"\");", "task_id": "1_5666", "predict_sva": "@(posedge clk_additive_manufacturing) disable iff (rst_3d_printing)         (rst_3d_printing == 0 && layer_deposition_control == 1) |->          ($past(material_extrusion_temperature, 11) == 1) &&          (dimensional_accuracy_maintenance == 1)"}
{"sva": "@(negedge clk_worker_safety) disable iff(rst_personal_protective_equipment) hazard_detection_algorithm && $past(environmental_risk_assessment, 3) |-> accident_prevention_system", "sva_description": "### Assertion description:  \n**Property Name**: p_hazard_detection_to_accident_prevention  \n**Trigger Condition**: At every falling edge of `clk_worker_safety`  \n**Disable Condition**: `disable iff (rst_personal_protective_equipment)`  \n**Antecedent (LHS of Implication)**: `hazard_detection_algorithm && $past(environmental_risk_assessment, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `accident_prevention_system`  ", "sva_signals": ["clk_worker_safety", "rst_personal_protective_equipment", "[0:0] hazard_detection_algorithm", "[0:0] environmental_risk_assessment", "[0:0] accident_prevention_system"], "clock": "clk_worker_safety", "attempts_left": 10, "sva_result": "@(negedge clk_worker_safety) disable iff (rst_personal_protective_equipment)         (hazard_detection_algorithm && $past(environmental_risk_assessment, 3)) |-> accident_prevention_system", "sva_name": "p_accident_prevention_on_hazard_and_env_risk", "id": "1917", "full_property": "property p_hazard_detection_to_accident_prevention;\n@(negedge clk_worker_safety) disable iff (rst_personal_protective_equipment)         (hazard_detection_algorithm && $past(environmental_risk_assessment, 3)) |-> accident_prevention_system\nendproperty\nassert_p_hazard_detection_to_accident_prevention:assert property (p_hazard_detection_to_accident_prevention) else $error(\"\");", "task_id": "1_5667", "predict_sva": "@(negedge clk_worker_safety) disable iff (rst_personal_protective_equipment)         (rst_personal_protective_equipment == 0 && hazard_detection_algorithm == 1 && $past(environmental_risk_assessment, 3) == 1) |-> accident_prevention_system == 1"}
{"sva": "@(posedge clk_circular_economy) disable iff(rst_waste_to_value) material_flow_optimization && $past(lifecycle_assessment_calculation, 3) |-> sustainable_business_model", "sva_description": "### Assertion description:  \n**Property Name**: p_sustainable_business_model  \n**Trigger Condition**: At every rising edge of the `clk_circular_economy`  \n**Disable Condition**: `disable iff (rst_waste_to_value)`  \n**Antecedent (LHS of Implication)**: `material_flow_optimization && $past(lifecycle_assessment_calculation, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sustainable_business_model`", "sva_signals": ["clk_circular_economy", "rst_waste_to_value", "[0:0] material_flow_optimization", "[0:0] lifecycle_assessment_calculation", "[0:0] sustainable_business_model"], "clock": "clk_circular_economy", "attempts_left": 10, "sva_result": "@(posedge clk_circular_economy) disable iff (rst_waste_to_value)     material_flow_optimization && $past(lifecycle_assessment_calculation, 3) |-> sustainable_business_model", "sva_name": "p_sustainable_business_model_on_material_flow_and_lifecycle", "id": "1941", "full_property": "property p_sustainable_business_model;\n@(posedge clk_circular_economy) disable iff (rst_waste_to_value)     material_flow_optimization && $past(lifecycle_assessment_calculation, 3) |-> sustainable_business_model\nendproperty\nassert_p_sustainable_business_model:assert property (p_sustainable_business_model) else $error(\"\");", "task_id": "1_5691", "predict_sva": "@(posedge clk_circular_economy) disable iff (rst_waste_to_value)         (rst_waste_to_value == 0 && material_flow_optimization == 1 && $past(lifecycle_assessment_calculation, 3) == 1) |-> sustainable_business_model == 1"}
{"sva": "@(negedge clk_post_quantum_cryptography) disable iff(!lattice_based_reset) quantum_resistant_algorithm && $past(ring_learning_with_errors, 5) |-> cryptographic_security_future_proofing", "sva_description": "### Assertion description:  \n**Property Name**: p_Quantum_Resistant_Security  \n**Trigger Condition**: At every falling edge of the `clk_post_quantum_cryptography`  \n**Disable Condition**: disable iff (`!lattice_based_reset`)  \n**Antecedent (LHS of Implication)**: `quantum_resistant_algorithm && $past(ring_learning_with_errors, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cryptographic_security_future_proofing`", "sva_signals": ["clk_post_quantum_cryptography", "lattice_based_reset", "[0:0] quantum_resistant_algorithm", "[0:0] ring_learning_with_errors", "[0:0] cryptographic_security_future_proofing"], "clock": "clk_post_quantum_cryptography", "attempts_left": 10, "sva_result": "@(negedge clk_post_quantum_cryptography) disable iff (!lattice_based_reset)         (quantum_resistant_algorithm && $past(ring_learning_with_errors, 5)) |-> cryptographic_security_future_proofing", "sva_name": "p_cryptographic_security_future_proofing_on_quantum_resistant_and_past_ring_learning", "id": "1962", "full_property": "property p_Quantum_Resistant_Security;\n@(negedge clk_post_quantum_cryptography) disable iff (!lattice_based_reset)         (quantum_resistant_algorithm && $past(ring_learning_with_errors, 5)) |-> cryptographic_security_future_proofing\nendproperty\nassert_p_Quantum_Resistant_Security:assert property (p_Quantum_Resistant_Security) else $error(\"\");", "task_id": "1_5712", "predict_sva": "@(negedge clk_post_quantum_cryptography) disable iff (!lattice_based_reset)         (lattice_based_reset == 1 && quantum_resistant_algorithm == 1 && $past(ring_learning_with_errors, 5) == 1) |-> cryptographic_security_future_proofing == 1"}
{"sva": "@(posedge clk_magnetogenetics) disable iff(rst_magnetic_field_stimulation) ferritin_based_actuator && $past(magnetic_nanoparticle_heating, 8) |-> remote_neural_modulation", "sva_description": "### Assertion description:  \n**Property Name**: p_remote_neural_modulation_trigger  \n**Trigger Condition**: At every rising edge of the `clk_magnetogenetics`  \n**Disable Condition**: `disable iff (rst_magnetic_field_stimulation)`  \n**Antecedent (LHS of Implication)**: `ferritin_based_actuator && $past(magnetic_nanoparticle_heating, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `remote_neural_modulation`  ", "sva_signals": ["clk_magnetogenetics", "rst_magnetic_field_stimulation", "[0:0] ferritin_based_actuator", "[0:0] magnetic_nanoparticle_heating", "[0:0] remote_neural_modulation"], "clock": "clk_magnetogenetics", "attempts_left": 10, "sva_result": "@(posedge clk_magnetogenetics) disable iff (rst_magnetic_field_stimulation)         ferritin_based_actuator && $past(magnetic_nanoparticle_heating, 8) |-> remote_neural_modulation", "sva_name": "p_remote_neural_modulation_on_actuator_and_nanoparticle_heating", "id": "1979", "full_property": "property p_remote_neural_modulation_trigger;\n@(posedge clk_magnetogenetics) disable iff (rst_magnetic_field_stimulation)         ferritin_based_actuator && $past(magnetic_nanoparticle_heating, 8) |-> remote_neural_modulation\nendproperty\nassert_p_remote_neural_modulation_trigger:assert property (p_remote_neural_modulation_trigger) else $error(\"\");", "task_id": "1_5729", "predict_sva": "@(posedge clk_magnetogenetics) disable iff (rst_magnetic_field_stimulation)         (rst_magnetic_field_stimulation == 0 && ferritin_based_actuator == 1 && $past(magnetic_nanoparticle_heating, 8) == 1) |-> remote_neural_modulation == 1"}
{"sva": "@(posedge clk_neuromorphic_memristor) disable iff(rst_synaptic_plasticity) spike_timing_dependent_plasticity && $past(memristive_weight_update, 7) |-> brain_inspired_learning", "sva_description": "### Assertion description:  \n**Property Name**: p_spike_timing_dependent_plasticity_learning  \n**Trigger Condition**: At every rising edge of the `clk_neuromorphic_memristor`  \n**Disable Condition**: `disable iff (rst_synaptic_plasticity)`  \n**Antecedent (LHS of Implication)**: `spike_timing_dependent_plasticity && $past(memristive_weight_update, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `brain_inspired_learning`  ", "sva_signals": ["clk_neuromorphic_memristor", "rst_synaptic_plasticity", "[0:0] spike_timing_dependent_plasticity", "[0:0] memristive_weight_update", "[0:0] brain_inspired_learning"], "clock": "clk_neuromorphic_memristor", "attempts_left": 10, "sva_result": "@(posedge clk_neuromorphic_memristor) disable iff (rst_synaptic_plasticity)         (spike_timing_dependent_plasticity && $past(memristive_weight_update, 7)) |-> brain_inspired_learning", "sva_name": "p_brain_inspired_learning_on_spike_and_memristive_update", "id": "1994", "full_property": "property p_spike_timing_dependent_plasticity_learning;\n@(posedge clk_neuromorphic_memristor) disable iff (rst_synaptic_plasticity)         (spike_timing_dependent_plasticity && $past(memristive_weight_update, 7)) |-> brain_inspired_learning\nendproperty\nassert_p_spike_timing_dependent_plasticity_learning:assert property (p_spike_timing_dependent_plasticity_learning) else $error(\"\");", "task_id": "1_5744", "predict_sva": "@(posedge clk_neuromorphic_memristor) disable iff (rst_synaptic_plasticity)         (rst_synaptic_plasticity == 0 && spike_timing_dependent_plasticity == 1 && $past(memristive_weight_update, 7) == 1) |-> brain_inspired_learning == 1"}
{"sva": "@(posedge clk_gene_therapy) disable iff(rst_viral_vector_delivery) adeno_associated_virus && $past(tissue_specific_promoter, 6) |-> therapeutic_gene_expression", "sva_description": "### Assertion description:  \n**Property Name**: p_therapeutic_gene_expression  \n**Trigger Condition**: At every rising edge of the `clk_gene_therapy`  \n**Disable Condition**: `disable iff (rst_viral_vector_delivery)`  \n**Antecedent (LHS of Implication)**: `adeno_associated_virus && $past(tissue_specific_promoter, 6)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `therapeutic_gene_expression`", "sva_signals": ["clk_gene_therapy", "rst_viral_vector_delivery", "[0:0] adeno_associated_virus", "[0:0] tissue_specific_promoter", "[0:0] therapeutic_gene_expression"], "clock": "clk_gene_therapy", "attempts_left": 10, "sva_result": "@(posedge clk_gene_therapy) disable iff (rst_viral_vector_delivery)         adeno_associated_virus && $past(tissue_specific_promoter, 6) |-> therapeutic_gene_expression", "sva_name": "p_therapeutic_gene_expression_on_adeno_and_tissue_specific_promoter", "id": "2000", "full_property": "property p_therapeutic_gene_expression;\n@(posedge clk_gene_therapy) disable iff (rst_viral_vector_delivery)         adeno_associated_virus && $past(tissue_specific_promoter, 6) |-> therapeutic_gene_expression\nendproperty\nassert_p_therapeutic_gene_expression:assert property (p_therapeutic_gene_expression) else $error(\"\");", "task_id": "1_5750", "predict_sva": "@(posedge clk_gene_therapy) disable iff (rst_viral_vector_delivery)         (rst_viral_vector_delivery == 0 && adeno_associated_virus == 1 && $past(tissue_specific_promoter, 6) == 1) |-> therapeutic_gene_expression == 1"}
{"sva": "@(posedge clk_food_waste_valorization) disable iff(rst_circular_economy == 1'b1) byproduct_utilization |-> $past(value_added_product_development, 7) && resource_efficiency_maximization", "sva_description": "### Assertion description:  \n**Property Name**: p_byproduct_utilization_implies_value_added_product  \n**Trigger Condition**: At every rising edge of the `clk_food_waste_valorization`  \n**Disable Condition**: `disable iff (rst_circular_economy == 1'b1)`  \n**Antecedent (LHS of Implication)**: `byproduct_utilization`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(value_added_product_development, 7) && resource_efficiency_maximization`  ", "sva_signals": ["clk_food_waste_valorization", "rst_circular_economy", "[0:0] byproduct_utilization", "[0:0] value_added_product_development", "[0:0] resource_efficiency_maximization"], "clock": "clk_food_waste_valorization", "attempts_left": 10, "sva_result": "@(posedge clk_food_waste_valorization) disable iff (rst_circular_economy == 1'b1)     byproduct_utilization |-> $past(value_added_product_development, 7) && resource_efficiency_maximization", "sva_name": "p_byproduct_utilization_dependency", "id": "2016", "full_property": "property p_byproduct_utilization_implies_value_added_product;\n@(posedge clk_food_waste_valorization) disable iff (rst_circular_economy == 1'b1)     byproduct_utilization |-> $past(value_added_product_development, 7) && resource_efficiency_maximization\nendproperty\nassert_p_byproduct_utilization_implies_value_added_product:assert property (p_byproduct_utilization_implies_value_added_product) else $error(\"\");", "task_id": "1_5766", "predict_sva": "@(posedge clk_food_waste_valorization) disable iff (rst_circular_economy)         (rst_circular_economy == 0 && byproduct_utilization == 1) |->          ($past(value_added_product_development, 7) == 1) &&          (resource_efficiency_maximization == 1)"}
{"sva": "@(posedge clk_climate_smart_agriculture) disable iff(rst_adaptation_strategy) drought_resistant_variety && $past(climate_scenario_modeling, 5) |-> agricultural_resilience_building", "sva_description": "### Assertion description:  \n**Property Name**: p_drought_resistant_variety_implies_resilience  \n**Trigger Condition**: At every rising edge of the `clk_climate_smart_agriculture`  \n**Disable Condition**: `disable iff (rst_adaptation_strategy)`  \n**Antecedent (LHS of Implication)**: `drought_resistant_variety && $past(climate_scenario_modeling, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `agricultural_resilience_building`  ", "sva_signals": ["clk_climate_smart_agriculture", "rst_adaptation_strategy", "[0:0] drought_resistant_variety", "[0:0] climate_scenario_modeling", "[0:0] agricultural_resilience_building"], "clock": "clk_climate_smart_agriculture", "attempts_left": 10, "sva_result": "@(posedge clk_climate_smart_agriculture) disable iff (rst_adaptation_strategy)     (drought_resistant_variety && $past(climate_scenario_modeling, 5)) |-> agricultural_resilience_building", "sva_name": "p_agricultural_resilience_building_on_drought_resistant_and_climate_scenario", "id": "2011", "full_property": "property p_drought_resistant_variety_implies_resilience;\n@(posedge clk_climate_smart_agriculture) disable iff (rst_adaptation_strategy)     (drought_resistant_variety && $past(climate_scenario_modeling, 5)) |-> agricultural_resilience_building\nendproperty\nassert_p_drought_resistant_variety_implies_resilience:assert property (p_drought_resistant_variety_implies_resilience) else $error(\"\");", "task_id": "1_5761", "predict_sva": "@(posedge clk_climate_smart_agriculture) disable iff (rst_adaptation_strategy)         (rst_adaptation_strategy == 0 && drought_resistant_variety == 1 && $past(climate_scenario_modeling, 5) == 1) |-> agricultural_resilience_building == 1"}
{"sva": "@(posedge clk) disable iff(reset_override) cache_miss |-> ($past(tag_compare, 1) && !$past(hit_detected, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_miss_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (reset_override)`  \n**Antecedent (LHS of Implication)**: `cache_miss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(tag_compare, 1) && !$past(hit_detected, 1))`  ", "sva_signals": ["clk", "reset_override", "cache_miss", "tag_compare", "hit_detected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reset_override)         cache_miss == 1'b1 |-> ($past(tag_compare, 1) && !$past(hit_detected, 1))", "sva_name": "p_cache_miss_preceded_by_tag_compare_no_hit", "id": "2059", "full_property": "property p_cache_miss_check;\n@(posedge clk) disable iff (reset_override)         cache_miss == 1'b1 |-> ($past(tag_compare, 1) && !$past(hit_detected, 1))\nendproperty\nassert_p_cache_miss_check:assert property (p_cache_miss_check) else $error(\"\");", "task_id": "1_5809", "predict_sva": "@(posedge clk) disable iff (reset_override)         (reset_override == 0 && cache_miss == 1) |-> ($past(tag_compare) == 1 && $past(hit_detected) == 0)"}
{"sva": "@(posedge clk) disable iff(test_mode) counter_overflow |-> ($past(counter_value, 1) == 8'hFF)", "sva_description": "### Assertion description:  \n**Property Name**: p_counter_overflow_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (test_mode)  \n**Antecedent (LHS of Implication)**: `counter_overflow == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(counter_value, 1) == 8'hFF`  ", "sva_signals": ["clk", "rst_n", "[0:0] test_mode", "[0:0] counter_overflow", "[7:0] counter_value"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (test_mode)         counter_overflow == 1'b1 |-> $past(counter_value, 1) == 8'hFF", "sva_name": "p_counter_overflow_prev_value", "id": "2064", "full_property": "property p_counter_overflow_check;\n@(posedge clk) disable iff (test_mode)         counter_overflow == 1'b1 |-> $past(counter_value, 1) == 8'hFF\nendproperty\nassert_p_counter_overflow_check:assert property (p_counter_overflow_check) else $error(\"\");", "task_id": "1_5814", "predict_sva": "@(posedge clk) disable iff (test_mode)         (test_mode == 0 && counter_overflow == 1'b1) |-> ($past(counter_value, 1) == 8'hFF)"}
{"sva": "@(posedge clk_io) disable iff(!io_ready) transmission_error |-> ($past(tx_data[7:0], 1) != $past(rx_data[7:0], 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_transmission_error_check  \n**Trigger Condition**: At every rising edge of `clk_io`  \n**Disable Condition**: disable iff (`!io_ready`)  \n**Antecedent (LHS of Implication)**: `transmission_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: The past value of `tx_data[7:0]` from 1 clock cycle ago (`$past(tx_data[7:0], 1)`) should not equal the past value of `rx_data[7:0]` from 2 clock cycles ago (`$past(rx_data[7:0], 2)`).  ", "sva_signals": ["clk_io", "io_ready", "[0:0] transmission_error", "[7:0] tx_data", "[7:0] rx_data"], "clock": "clk_io", "attempts_left": 10, "sva_result": "@(posedge clk_io) disable iff (!io_ready)     transmission_error == 1'b1 |->      $past(tx_data[7:0], 1) != $past(rx_data[7:0], 2)", "sva_name": "p_transmission_error_data_mismatch", "id": "2093", "full_property": "property p_transmission_error_check;\n@(posedge clk_io) disable iff (!io_ready)     transmission_error == 1'b1 |->      $past(tx_data[7:0], 1) != $past(rx_data[7:0], 2)\nendproperty\nassert_p_transmission_error_check:assert property (p_transmission_error_check) else $error(\"\");", "task_id": "1_5842", "predict_sva": "@(posedge clk_io) disable iff (!io_ready)         (io_ready == 1 && transmission_error == 1) |-> ($past(tx_data[7:0], 1) != $past(rx_data[7:0], 2))"}
{"sva": "@(posedge clock_main) disable iff(test_reset) pipeline_flush |-> ($past(branch_mispredict, 1) | $past(exception_occurred, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Pipeline_Flush_Cause  \n**Trigger Condition**: At every rising edge of `clock_main`  \n**Disable Condition**: `disable iff (test_reset)`  \n**Antecedent (LHS of Implication)**: `pipeline_flush == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(branch_mispredict, 1) | $past(exception_occurred, 1))`  ", "sva_signals": ["clock_main", "test_reset", "[0:0] pipeline_flush", "[0:0] branch_mispredict", "[0:0] exception_occurred"], "clock": "clock_main", "attempts_left": 10, "sva_result": "@(posedge clock_main) disable iff (test_reset)     pipeline_flush == 1'b1 |-> ($past(branch_mispredict, 1) | $past(exception_occurred, 1))", "sva_name": "p_pipeline_flush_cause_check", "id": "2114", "full_property": "property p_Pipeline_Flush_Cause;\n@(posedge clock_main) disable iff (test_reset)     pipeline_flush == 1'b1 |-> ($past(branch_mispredict, 1) | $past(exception_occurred, 1))\nendproperty\nassert_p_Pipeline_Flush_Cause:assert property (p_Pipeline_Flush_Cause) else $error(\"\");", "task_id": "1_5860", "predict_sva": "@(posedge clock_main) disable iff (test_reset)         (test_reset == 0 && pipeline_flush == 1'b1) |-> ($past(branch_mispredict) == 1'b1 || $past(exception_occurred) == 1'b1)"}
{"sva": "@(posedge clk_dma) disable iff(!dma_enable) transfer_abort |-> ($past(bus_error, 1) | $past(address_fault, 1))", "sva_description": "### Assertion description:\n**Property Name**: p_Transfer_Abort_Check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: disable iff (!dma_enable)  \n**Antecedent (LHS of Implication)**: `transfer_abort == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: ($past(bus_error, 1) | $past(address_fault, 1))  ", "sva_signals": ["clk_dma", "dma_enable", "[0:0] transfer_abort", "[0:0] bus_error", "[0:0] address_fault"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma) disable iff (!dma_enable)     transfer_abort == 1'b1 |-> ($past(bus_error, 1) | $past(address_fault, 1))", "sva_name": "p_transfer_abort_precedence", "id": "2118", "full_property": "property p_Transfer_Abort_Check;\n@(posedge clk_dma) disable iff (!dma_enable)     transfer_abort == 1'b1 |-> ($past(bus_error, 1) | $past(address_fault, 1))\nendproperty\nassert_p_Transfer_Abort_Check:assert property (p_Transfer_Abort_Check) else $error(\"\");", "task_id": "1_5864", "predict_sva": "@(posedge clk_dma) disable iff (!dma_enable)         (dma_enable == 1 && transfer_abort == 1) |-> ($past(bus_error) == 1 || $past(address_fault) == 1)"}
{"sva": "@(posedge clk_radio) disable iff(!rf_enable) carrier_detect_false |-> ($past(signal_strength[7:0], 1) < noise_floor)", "sva_description": "### Assertion description:  \n**Property Name**: p_carrier_detect_false_signal_strength  \n**Trigger Condition**: At every rising edge of the `clk_radio`  \n**Disable Condition**: `disable iff (!rf_enable)`  \n**Antecedent (LHS of Implication)**: `carrier_detect_false`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(signal_strength[7:0], 1) < noise_floor)`  ", "sva_signals": ["clk_radio", "rf_enable", "[0:0] carrier_detect_false", "[7:0] signal_strength", "[7:0] noise_floor"], "clock": "clk_radio", "attempts_left": 10, "sva_result": "@(posedge clk_radio) disable iff (!rf_enable)     carrier_detect_false |-> ($past(signal_strength[7:0], 1) < noise_floor)", "sva_name": "p_signal_strength_less_than_noise_floor_on_carrier_detect_false", "id": "2127", "full_property": "property p_carrier_detect_false_signal_strength;\n@(posedge clk_radio) disable iff (!rf_enable)     carrier_detect_false |-> ($past(signal_strength[7:0], 1) < noise_floor)\nendproperty\nassert_p_carrier_detect_false_signal_strength:assert property (p_carrier_detect_false_signal_strength) else $error(\"\");", "task_id": "1_5872", "predict_sva": "@(posedge clk_radio) disable iff (!rf_enable)         (rf_enable == 1 && carrier_detect_false == 1) |-> ($past(signal_strength[7:0], 1) < noise_floor)"}
{"sva": "@(posedge clk_flash) disable iff(!flash_ready) sector_erase_timeout |-> ($past(erase_command, 1) && $past(busy_timeout, 100))", "sva_description": "### Assertion description:  \n**Property Name**: p_Sector_Erase_Timeout  \n**Trigger Condition**: At every rising edge of the `clk_flash`  \n**Disable Condition**: disable iff (!flash_ready)  \n**Antecedent (LHS of Implication)**: `sector_erase_timeout`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(erase_command, 1) && $past(busy_timeout, 100))`  ", "sva_signals": ["clk_flash", "flash_ready", "sector_erase_timeout", "[0:0] erase_command", "[0:0] busy_timeout"], "clock": "clk_flash", "attempts_left": 10, "sva_result": "@(posedge clk_flash) disable iff (!flash_ready)     sector_erase_timeout |-> ($past(erase_command, 1) && $past(busy_timeout, 100))", "sva_name": "p_sector_erase_timeout_requires_erase_command_and_busy_timeout", "id": "2142", "full_property": "property p_Sector_Erase_Timeout;\n@(posedge clk_flash) disable iff (!flash_ready)     sector_erase_timeout |-> ($past(erase_command, 1) && $past(busy_timeout, 100))\nendproperty\nassert_p_Sector_Erase_Timeout:assert property (p_Sector_Erase_Timeout) else $error(\"\");", "task_id": "1_5887", "predict_sva": "@(posedge clk_flash) disable iff (!flash_ready)         (flash_ready == 1 && sector_erase_timeout == 1) |->          ($past(erase_command, 1) == 1 && $past(busy_timeout, 100) == 1)"}
{"sva": "@(posedge clk_dissolved_oxygen) disable iff(!oxygen_probe) aquatic_oxygen_content |-> ($past(oxygen_concentration[11:0], 1) < minimum_viable_level)", "sva_description": "### Assertion description:  \n**Property Name**: p_Aquatic_Oxygen_Content  \n**Trigger Condition**: At every rising edge of the `clk_dissolved_oxygen`  \n**Disable Condition**: disable iff (`!oxygen_probe`)  \n**Antecedent (LHS of Implication)**: `aquatic_oxygen_content == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(oxygen_concentration[11:0], 1) < minimum_viable_level)`  ", "sva_signals": ["clk_dissolved_oxygen", "oxygen_probe", "[0:0] aquatic_oxygen_content", "[11:0] oxygen_concentration", "[11:0] minimum_viable_level"], "clock": "clk_dissolved_oxygen", "attempts_left": 10, "sva_result": "@(posedge clk_dissolved_oxygen) disable iff (!oxygen_probe)     aquatic_oxygen_content == 1'b1 |-> ($past(oxygen_concentration[11:0], 1) < minimum_viable_level)", "sva_name": "p_aquatic_oxygen_content_check", "id": "2223", "full_property": "property p_Aquatic_Oxygen_Content;\n@(posedge clk_dissolved_oxygen) disable iff (!oxygen_probe)     aquatic_oxygen_content == 1'b1 |-> ($past(oxygen_concentration[11:0], 1) < minimum_viable_level)\nendproperty\nassert_p_Aquatic_Oxygen_Content:assert property (p_Aquatic_Oxygen_Content) else $error(\"\");", "task_id": "1_5964", "predict_sva": "@(posedge clk_dissolved_oxygen) disable iff (!oxygen_probe)     aquatic_oxygen_content == 1'b1 |->      ($past(oxygen_concentration[11:0], 1) < minimum_viable_level)"}
{"sva": "@(posedge clk) disable iff(validation_override) functional_safety_monitor |-> ($past(safety_critical_path, 1) && $past(fault_injection_active, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_functional_safety_monitor  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (validation_override)  \n**Antecedent (LHS of Implication)**: `functional_safety_monitor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(safety_critical_path, 1) && $past(fault_injection_active, 1))`", "sva_signals": ["clk", "validation_override", "functional_safety_monitor", "[0:0] safety_critical_path", "[0:0] fault_injection_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (validation_override)     functional_safety_monitor |-> ($past(safety_critical_path, 1) && $past(fault_injection_active, 1))", "sva_name": "p_functional_safety_monitor", "id": "2239", "full_property": "property p_functional_safety_monitor;\n@(posedge clk) disable iff (validation_override)     functional_safety_monitor |-> ($past(safety_critical_path, 1) && $past(fault_injection_active, 1))\nendproperty\nassert_p_functional_safety_monitor:assert property (p_functional_safety_monitor) else $error(\"\");", "task_id": "1_5979", "predict_sva": "@(posedge clk) disable iff (validation_override)     functional_safety_monitor |-> ($past(safety_critical_path) && $past(fault_injection_active))"}
{"sva": "@(posedge clk) disable iff(dft_mode) design_for_testability |=> ($past(scan_insertion, 1) && $past(bist_controller, 1) && $past(jtag_interface, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_design_for_testability  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (dft_mode)  \n**Antecedent (LHS of Implication)**: `design_for_testability`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `($past(scan_insertion, 1) && $past(bist_controller, 1) && $past(jtag_interface, 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] dft_mode", "[0:0] design_for_testability", "[0:0] scan_insertion", "[0:0] bist_controller", "[0:0] jtag_interface"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (dft_mode)     design_for_testability |=> ($past(scan_insertion, 1) && $past(bist_controller, 1) && $past(jtag_interface, 1))", "sva_name": "p_design_for_testability", "id": "2335", "full_property": "property p_design_for_testability;\n@(posedge clk) disable iff (dft_mode)     design_for_testability |=> ($past(scan_insertion, 1) && $past(bist_controller, 1) && $past(jtag_interface, 1))\nendproperty\nassert_p_design_for_testability:assert property (p_design_for_testability) else $error(\"\");", "task_id": "1_6063", "predict_sva": "@(posedge clk) disable iff (dft_mode)     design_for_testability |=> ($past(scan_insertion, 1) && $past(bist_controller, 1) && $past(jtag_interface, 1))"}
{"sva": "@(negedge clk_opentitan) disable iff(!opentitan_rst_n) open_source_silicon_root_of_trust |=> $past(secure_boot & hardware_security_module & cryptographic_accelerator, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_open_source_silicon_root_of_trust  \n**Trigger Condition**: At every falling edge of the `clk_opentitan`  \n**Disable Condition**: disable iff (`!opentitan_rst_n`)  \n**Antecedent (LHS of Implication)**: `open_source_silicon_root_of_trust`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(secure_boot & hardware_security_module & cryptographic_accelerator, 1)`  ", "sva_signals": ["clk_opentitan", "opentitan_rst_n", "[0:0] open_source_silicon_root_of_trust", "[0:0] secure_boot", "[0:0] hardware_security_module", "[0:0] cryptographic_accelerator"], "clock": "clk_opentitan", "attempts_left": 10, "sva_result": "@(negedge clk_opentitan) disable iff (!opentitan_rst_n)     open_source_silicon_root_of_trust |=> $past(secure_boot & hardware_security_module & cryptographic_accelerator, 1)", "sva_name": "p_open_source_silicon_root_of_trust", "id": "2355", "full_property": "property p_open_source_silicon_root_of_trust;\n@(negedge clk_opentitan) disable iff (!opentitan_rst_n)     open_source_silicon_root_of_trust |=> $past(secure_boot & hardware_security_module & cryptographic_accelerator, 1)\nendproperty\nassert_p_open_source_silicon_root_of_trust:assert property (p_open_source_silicon_root_of_trust) else $error(\"\");", "task_id": "1_6081", "predict_sva": "@(negedge clk_opentitan) disable iff (!opentitan_rst_n)     open_source_silicon_root_of_trust |=>      ($past(secure_boot & hardware_security_module & cryptographic_accelerator, 1))"}
{"sva": "@(posedge clk) disable iff(agile_development) continuous_integration_testing |-> ($past(regression_suite, 1) && $past(automated_testing, 1) && $past(version_control, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Continuous_Integration_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (agile_development)`  \n**Antecedent (LHS of Implication)**: `continuous_integration_testing == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(regression_suite, 1) && $past(automated_testing, 1) && $past(version_control, 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] agile_development", "[0:0] continuous_integration_testing", "[0:0] regression_suite", "[0:0] automated_testing", "[0:0] version_control"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (agile_development)     continuous_integration_testing == 1'b1 |->      ($past(regression_suite, 1) && $past(automated_testing, 1) && $past(version_control, 1))", "sva_name": "p_continuous_integration_testing_preconditions", "id": "2378", "full_property": "property p_Continuous_Integration_Check;\n@(posedge clk) disable iff (agile_development)     continuous_integration_testing == 1'b1 |->      ($past(regression_suite, 1) && $past(automated_testing, 1) && $past(version_control, 1))\nendproperty\nassert_p_Continuous_Integration_Check:assert property (p_Continuous_Integration_Check) else $error(\"\");", "task_id": "1_6101", "predict_sva": "@(posedge clk) disable iff (agile_development)         (agile_development == 0 && continuous_integration_testing == 1'b1) |->          ($past(regression_suite) == 1'b1 && $past(automated_testing) == 1'b1 && $past(version_control) == 1'b1)"}
{"sva": "@(posedge clk) disable iff(advanced_node) process_technology_scaling |-> ($past(design_rule_compliance, 1) && $past(parasitic_extraction, 1) && $past(yield_optimization, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_process_technology_scaling_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (advanced_node)`  \n**Antecedent (LHS of Implication)**: `process_technology_scaling == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(design_rule_compliance, 1) && $past(parasitic_extraction, 1) && $past(yield_optimization, 1))`  ", "sva_signals": ["clk", "advanced_node", "[0:0] process_technology_scaling", "[0:0] design_rule_compliance", "[0:0] parasitic_extraction", "[0:0] yield_optimization"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (advanced_node)     process_technology_scaling == 1'b1 |->         ($past(design_rule_compliance, 1) && $past(parasitic_extraction, 1) && $past(yield_optimization, 1))", "sva_name": "p_process_technology_scaling_precondition", "id": "2379", "full_property": "property p_process_technology_scaling_check;\n@(posedge clk) disable iff (advanced_node)     process_technology_scaling == 1'b1 |->         ($past(design_rule_compliance, 1) && $past(parasitic_extraction, 1) && $past(yield_optimization, 1))\nendproperty\nassert_p_process_technology_scaling_check:assert property (p_process_technology_scaling_check) else $error(\"\");", "task_id": "1_6102", "predict_sva": "@(posedge clk) disable iff (advanced_node)         (advanced_node == 0 && process_technology_scaling == 1) |->          ($past(design_rule_compliance) == 1 && $past(parasitic_extraction) == 1 && $past(yield_optimization) == 1)"}
{"sva": "@(posedge clk_dma_ctrl) disable iff(!dma_rst_async_n) direct_memory_access_transfer |-> ($past(dma_src_addr[31:0], 1) && $past(dma_dst_addr[31:0], 1) && $past(transfer_length[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_DMA_Transfer_Address_Length_Valid  \n**Trigger Condition**: At every rising edge of the `clk_dma_ctrl`  \n**Disable Condition**: `disable iff (!dma_rst_async_n)`  \n**Antecedent (LHS of Implication)**: `direct_memory_access_transfer == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(dma_src_addr[31:0], 1) && $past(dma_dst_addr[31:0], 1) && $past(transfer_length[15:0], 1))`  \n\n", "sva_signals": ["clk_dma_ctrl", "dma_rst_async_n", "[0:0] direct_memory_access_transfer", "[31:0] dma_src_addr", "[31:0] dma_dst_addr", "[15:0] transfer_length"], "clock": "clk_dma_ctrl", "attempts_left": 10, "sva_result": "@(posedge clk_dma_ctrl) disable iff (!dma_rst_async_n)     direct_memory_access_transfer == 1'b1 |->      ($past(dma_src_addr[31:0], 1) && $past(dma_dst_addr[31:0], 1) && $past(transfer_length[15:0], 1))", "sva_name": "p_dma_transfer_validity_prior_cycle", "id": "2387", "full_property": "property p_DMA_Transfer_Address_Length_Valid;\n@(posedge clk_dma_ctrl) disable iff (!dma_rst_async_n)     direct_memory_access_transfer == 1'b1 |->      ($past(dma_src_addr[31:0], 1) && $past(dma_dst_addr[31:0], 1) && $past(transfer_length[15:0], 1))\nendproperty\nassert_p_DMA_Transfer_Address_Length_Valid:assert property (p_DMA_Transfer_Address_Length_Valid) else $error(\"\");", "task_id": "1_6110", "predict_sva": "@(posedge clk_dma_ctrl) disable iff (!dma_rst_async_n)         (dma_rst_async_n == 1 && direct_memory_access_transfer == 1) |->          ($past(dma_src_addr[31:0]) != 0 && $past(dma_dst_addr[31:0]) != 0 && $past(transfer_length[15:0]) != 0)"}
{"sva": "@(negedge clk_ferroelectric) disable iff(!ferroelectric_enable) ferroelectric_field_effect_transistor |-> $past(polarization_state[7:0] & coercive_voltage[11:0] & negative_capacitance, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_ferroelectric_field_effect_transistor  \n**Trigger Condition**: At every falling edge of the `clk_ferroelectric`  \n**Disable Condition**: disable iff (`!ferroelectric_enable`)  \n**Antecedent (LHS of Implication)**: `ferroelectric_field_effect_transistor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(polarization_state[7:0] & coercive_voltage[11:0] & negative_capacitance, 1)`  ", "sva_signals": ["clk_ferroelectric", "ferroelectric_enable", "[0:0] ferroelectric_field_effect_transistor", "[7:0] polarization_state", "[11:0] coercive_voltage", "[0:0] negative_capacitance"], "clock": "clk_ferroelectric", "attempts_left": 10, "sva_result": "@(negedge clk_ferroelectric) disable iff (!ferroelectric_enable)     ferroelectric_field_effect_transistor |->          $past(polarization_state[7:0] & coercive_voltage[11:0] & negative_capacitance, 1)", "sva_name": "p_Ferroelectric_Field_Effect_Transistor", "id": "2519", "full_property": "property p_ferroelectric_field_effect_transistor;\n@(negedge clk_ferroelectric) disable iff (!ferroelectric_enable)     ferroelectric_field_effect_transistor |->          $past(polarization_state[7:0] & coercive_voltage[11:0] & negative_capacitance, 1)\nendproperty\nassert_p_ferroelectric_field_effect_transistor:assert property (p_ferroelectric_field_effect_transistor) else $error(\"\");", "task_id": "1_6209", "predict_sva": "@(negedge clk_ferroelectric) disable iff (!ferroelectric_enable)     ferroelectric_field_effect_transistor |=>      ($past(polarization_state[7:0] & coercive_voltage[11:0] & negative_capacitance, 1))"}
{"sva": "@(posedge clk_fluidic) disable iff(!fluidic_ready) microfluidic_logic_processor |-> ($past(droplet_formation[7:0], 1) && $past(channel_geometry[11:0], 1) && $past(surface_tension[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Microfluidic_Logic_Processor  \n**Trigger Condition**: At every rising edge of the `clk_fluidic`  \n**Disable Condition**: `disable iff (!fluidic_ready)`  \n**Antecedent (LHS of Implication)**: `microfluidic_logic_processor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(droplet_formation[7:0], 1) && $past(channel_geometry[11:0], 1) && $past(surface_tension[15:0], 1))`  ", "sva_signals": ["clk_fluidic", "fluidic_ready", "[0:0] microfluidic_logic_processor", "[7:0] droplet_formation", "[11:0] channel_geometry", "[15:0] surface_tension"], "clock": "clk_fluidic", "attempts_left": 10, "sva_result": "@(posedge clk_fluidic) disable iff (!fluidic_ready)     microfluidic_logic_processor |->          ($past(droplet_formation[7:0], 1) &&           $past(channel_geometry[11:0], 1) &&           $past(surface_tension[15:0], 1))", "sva_name": "p_microfluidic_logic_processor", "id": "2522", "full_property": "property p_Microfluidic_Logic_Processor;\n@(posedge clk_fluidic) disable iff (!fluidic_ready)     microfluidic_logic_processor |->          ($past(droplet_formation[7:0], 1) &&           $past(channel_geometry[11:0], 1) &&           $past(surface_tension[15:0], 1))\nendproperty\nassert_p_Microfluidic_Logic_Processor:assert property (p_Microfluidic_Logic_Processor) else $error(\"\");", "task_id": "1_6212", "predict_sva": "@(posedge clk_fluidic) disable iff (!fluidic_ready)     microfluidic_logic_processor |->          ($past(droplet_formation) != 8'b0) &&          ($past(channel_geometry) != 12'b0) &&          ($past(surface_tension) != 16'b0)"}
{"sva": "@(posedge clk_thermoelectric) disable iff(!thermoelectric_ready) thermoelectric_generator_interface |-> ($past(seebeck_voltage[11:0], 1) && $past(temperature_differential[7:0], 1) && $past(internal_resistance[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_thermoelectric_generator_interface  \n**Trigger Condition**: At every rising edge of `clk_thermoelectric`  \n**Disable Condition**: `disable iff (!thermoelectric_ready)`  \n**Antecedent (LHS of Implication)**: `thermoelectric_generator_interface == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe logical AND of the following past values sampled at the previous clock cycle:  \n1. Lower 12 bits of `seebeck_voltage` (`$past(seebeck_voltage[11:0], 1)`),  \n2. Lower 8 bits of `temperature_differential` (`$past(temperature_differential[7:0], 1)`),  \n3. Lower 8 bits of `internal_resistance` (`$past(internal_resistance[7:0], 1)`).  \n\n(Note: The consequent evaluates to true only if all three past values are non-zero.)", "sva_signals": ["clk_thermoelectric", "thermoelectric_ready", "thermoelectric_generator_interface", "[11:0] seebeck_voltage", "[7:0] temperature_differential", "[7:0] internal_resistance"], "clock": "clk_thermoelectric", "attempts_left": 10, "sva_result": "@(posedge clk_thermoelectric) disable iff (!thermoelectric_ready)     thermoelectric_generator_interface == 1'b1 |->     ($past(seebeck_voltage[11:0], 1) != 0) &&     ($past(temperature_differential[7:0], 1) != 0) &&     ($past(internal_resistance[7:0], 1) != 0)", "sva_name": "p_thermoelectric_generator_interface_inputs_nonzero", "id": "2506", "full_property": "property p_thermoelectric_generator_interface;\n@(posedge clk_thermoelectric) disable iff (!thermoelectric_ready)     thermoelectric_generator_interface == 1'b1 |->     ($past(seebeck_voltage[11:0], 1) != 0) &&     ($past(temperature_differential[7:0], 1) != 0) &&     ($past(internal_resistance[7:0], 1) != 0)\nendproperty\nassert_p_thermoelectric_generator_interface:assert property (p_thermoelectric_generator_interface) else $error(\"\");", "task_id": "1_6198", "predict_sva": "@(posedge clk_thermoelectric) disable iff (!thermoelectric_ready)         (thermoelectric_ready == 1 && thermoelectric_generator_interface == 1) |->          ($past(seebeck_voltage[11:0], 1) != 0) &&          ($past(temperature_differential[7:0], 1) != 0) &&          ($past(internal_resistance[7:0], 1) != 0)"}
{"sva": "@(posedge clk_magnetostrictive) disable iff(!magnetostrictive_ready) magnetostrictive_sensor_actuator |-> ($past(magnetic_field_strength[11:0], 1) && $past(dimensional_change[7:0], 1) && $past(coupling_factor[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_magnetostrictive_sensor_actuator  \n**Trigger Condition**: At every rising edge of the `clk_magnetostrictive`  \n**Disable Condition**: disable iff (`!magnetostrictive_ready`)  \n**Antecedent (LHS of Implication)**: `magnetostrictive_sensor_actuator == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \nThe logical AND of the following past values must hold:  \n1. `$past(magnetic_field_strength[11:0], 1)`  \n2. `$past(dimensional_change[7:0], 1)`  \n3. `$past(coupling_factor[15:0], 1)`  \n\n(Note: The exact logical operation in the consequent depends on the interpretation of the `&&` between the past values. If these are multi-bit signals, the assertion likely checks that all bits of each past value are non-zero.)", "sva_signals": ["clk_magnetostrictive", "magnetostrictive_ready", "[0:0] magnetostrictive_sensor_actuator", "[11:0] magnetic_field_strength", "[7:0] dimensional_change", "[15:0] coupling_factor"], "clock": "clk_magnetostrictive", "attempts_left": 10, "sva_result": "@(posedge clk_magnetostrictive) disable iff (!magnetostrictive_ready)     magnetostrictive_sensor_actuator == 1'b1 |->     ($past(magnetic_field_strength[11:0], 1) != 12'b0) &&     ($past(dimensional_change[7:0], 1) != 8'b0) &&     ($past(coupling_factor[15:0], 1) != 16'b0)", "sva_name": "p_magnetostrictive_sensor_actuator_nonzero_inputs", "id": "2539", "full_property": "property p_magnetostrictive_sensor_actuator;\n@(posedge clk_magnetostrictive) disable iff (!magnetostrictive_ready)     magnetostrictive_sensor_actuator == 1'b1 |->     ($past(magnetic_field_strength[11:0], 1) != 12'b0) &&     ($past(dimensional_change[7:0], 1) != 8'b0) &&     ($past(coupling_factor[15:0], 1) != 16'b0)\nendproperty\nassert_p_magnetostrictive_sensor_actuator:assert property (p_magnetostrictive_sensor_actuator) else $error(\"\");", "task_id": "1_6228", "predict_sva": "@(posedge clk_magnetostrictive) disable iff (!magnetostrictive_ready)         (magnetostrictive_ready == 1 && magnetostrictive_sensor_actuator == 1) |->          ($past(magnetic_field_strength[11:0]) != 0) &&          ($past(dimensional_change[7:0]) != 0) &&          ($past(coupling_factor[15:0]) != 0)"}
{"sva": "@(posedge clk) disable iff(x_ray_crystallography) single_crystal_diffractometer |=> ($past(bragg_reflection_intensity[15:0], 1) && $past(unit_cell_parameters[31:0], 1) && $past(structure_factor[11:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_single_crystal_diffractometer_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (x_ray_crystallography)`  \n**Antecedent (LHS of Implication)**: `single_crystal_diffractometer`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(bragg_reflection_intensity[15:0], 1) && $past(unit_cell_parameters[31:0], 1) && $past(structure_factor[11:0], 1)`  \n\n", "sva_signals": ["clk", "x_ray_crystallography", "[0:0] single_crystal_diffractometer", "[15:0] bragg_reflection_intensity", "[31:0] unit_cell_parameters", "[11:0] structure_factor"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (x_ray_crystallography)     single_crystal_diffractometer |=>          ($past(bragg_reflection_intensity[15:0], 1) &&           $past(unit_cell_parameters[31:0], 1) &&           $past(structure_factor[11:0], 1))", "sva_name": "p_single_crystal_diffractometer_input_validity", "id": "2621", "full_property": "property p_single_crystal_diffractometer_check;\n@(posedge clk) disable iff (x_ray_crystallography)     single_crystal_diffractometer |=>          ($past(bragg_reflection_intensity[15:0], 1) &&           $past(unit_cell_parameters[31:0], 1) &&           $past(structure_factor[11:0], 1))\nendproperty\nassert_p_single_crystal_diffractometer_check:assert property (p_single_crystal_diffractometer_check) else $error(\"\");", "task_id": "1_6295", "predict_sva": "@(posedge clk) disable iff (x_ray_crystallography)         (x_ray_crystallography == 0 && single_crystal_diffractometer == 1) |->          ($past(bragg_reflection_intensity[15:0]) != 0) &&          ($past(unit_cell_parameters[31:0]) != 0) &&          ($past(structure_factor[11:0]) != 0)"}
{"sva": "@(posedge clk_net_radiation) disable iff(!radiation_balance_rst_n) net_radiation_measurement |-> ($past(incoming_longwave[15:0], 1) && $past(outgoing_longwave[11:0], 1) && $past(net_shortwave[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_net_radiation_measurement  \n**Trigger Condition**: At every rising edge of the `clk_net_radiation`  \n**Disable Condition**: `disable iff (!radiation_balance_rst_n)`  \n**Antecedent (LHS of Implication)**: `net_radiation_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(incoming_longwave[15:0], 1) && $past(outgoing_longwave[11:0], 1) && $past(net_shortwave[7:0], 1))`  ", "sva_signals": ["clk_net_radiation", "radiation_balance_rst_n", "[0:0] net_radiation_measurement", "[15:0] incoming_longwave", "[11:0] outgoing_longwave", "[7:0] net_shortwave"], "clock": "clk_net_radiation", "attempts_left": 10, "sva_result": "@(posedge clk_net_radiation) disable iff (!radiation_balance_rst_n)     net_radiation_measurement |->          ($past(incoming_longwave[15:0], 1) &&           $past(outgoing_longwave[11:0], 1) &&           $past(net_shortwave[7:0], 1))", "sva_name": "p_net_radiation_measurement_inputs_valid", "id": "2720", "full_property": "property p_net_radiation_measurement;\n@(posedge clk_net_radiation) disable iff (!radiation_balance_rst_n)     net_radiation_measurement |->          ($past(incoming_longwave[15:0], 1) &&           $past(outgoing_longwave[11:0], 1) &&           $past(net_shortwave[7:0], 1))\nendproperty\nassert_p_net_radiation_measurement:assert property (p_net_radiation_measurement) else $error(\"\");", "task_id": "1_6377", "predict_sva": "@(posedge clk_net_radiation) disable iff (!radiation_balance_rst_n)         (radiation_balance_rst_n == 1 && net_radiation_measurement == 1) |->          ($past(incoming_longwave[15:0]) != 0 && $past(outgoing_longwave[11:0]) != 0 && $past(net_shortwave[7:0]) != 0)"}
{"sva": "@(posedge clk_radiometric) disable iff(!radiometric_rst_n) airborne_radiometric_survey |-> ($past(gamma_ray_spectrometry[31:0], 1) && $past(potassium_concentration[11:0], 1) && $past(uranium_thorium_ratio[15:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_radiometric_survey_check  \n**Trigger Condition**: At every rising edge of the `clk_radiometric`  \n**Disable Condition**: disable iff (`!radiometric_rst_n`)  \n**Antecedent (LHS of Implication)**: `airborne_radiometric_survey`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(gamma_ray_spectrometry[31:0], 1) && $past(potassium_concentration[11:0], 1) && $past(uranium_thorium_ratio[15:0], 1))`  ", "sva_signals": ["clk_radiometric", "radiometric_rst_n", "[0:0] airborne_radiometric_survey", "[31:0] gamma_ray_spectrometry", "[11:0] potassium_concentration", "[15:0] uranium_thorium_ratio"], "clock": "clk_radiometric", "attempts_left": 10, "sva_result": "@(posedge clk_radiometric) disable iff (!radiometric_rst_n)         airborne_radiometric_survey |->              ($past(gamma_ray_spectrometry[31:0], 1) &&               $past(potassium_concentration[11:0], 1) &&               $past(uranium_thorium_ratio[15:0], 1))", "sva_name": "p_airborne_radiometric_survey_inputs_valid_prev_cycle", "id": "2761", "full_property": "property p_radiometric_survey_check;\n@(posedge clk_radiometric) disable iff (!radiometric_rst_n)         airborne_radiometric_survey |->              ($past(gamma_ray_spectrometry[31:0], 1) &&               $past(potassium_concentration[11:0], 1) &&               $past(uranium_thorium_ratio[15:0], 1))\nendproperty\nassert_p_radiometric_survey_check:assert property (p_radiometric_survey_check) else $error(\"\");", "task_id": "1_6413", "predict_sva": "@(posedge clk_radiometric) disable iff (!radiometric_rst_n)         (radiometric_rst_n == 1 && airborne_radiometric_survey == 1) |->          ($past(gamma_ray_spectrometry) != 32'b0) &&          ($past(potassium_concentration) != 12'b0) &&          ($past(uranium_thorium_ratio) != 16'b0)"}
{"sva": "@(posedge clk) security_breach |-> !$past(access_granted) && $past(access_attempt)", "sva_description": "### Assertion description:  \n**Property Name**: p_Security_Breach_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `security_breach == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(access_granted) && $past(access_attempt)`  ", "sva_signals": ["clk", "rst_n", "[0:0] security_breach", "[0:0] access_granted", "[0:0] access_attempt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         security_breach == 1'b1 |-> !$past(access_granted) && $past(access_attempt)", "sva_name": "p_security_breach_requires_prev_access_attempt_and_no_grant", "id": "3047", "full_property": "property p_Security_Breach_Check;\n@(posedge clk)         security_breach == 1'b1 |-> !$past(access_granted) && $past(access_attempt)\nendproperty\nassert_p_Security_Breach_Check:assert property (p_Security_Breach_Check) else $error(\"\");", "task_id": "1_6658", "predict_sva": "@(posedge clk)         security_breach == 1'b1 |-> $past(access_granted) == 1'b0 && $past(access_attempt) == 1'b1"}
{"sva": "@(posedge clk) thermal_shutdown |-> $past(temperature_sensor) > critical_temp || $past(cooling_failed)", "sva_description": "### Assertion description:  \n**Property Name**: p_thermal_shutdown_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_shutdown == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(temperature_sensor) > critical_temp || $past(cooling_failed)`  ", "sva_signals": ["clk", "rst_n", "[0:0] thermal_shutdown", "[0:0] temperature_sensor", "[0:0] critical_temp", "[0:0] cooling_failed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         thermal_shutdown == 1'b1 |-> ($past(temperature_sensor) > critical_temp) || ($past(cooling_failed))", "sva_name": "p_thermal_shutdown_cause_check", "id": "3069", "full_property": "property p_thermal_shutdown_check;\n@(posedge clk)         thermal_shutdown == 1'b1 |-> ($past(temperature_sensor) > critical_temp) || ($past(cooling_failed))\nendproperty\nassert_p_thermal_shutdown_check:assert property (p_thermal_shutdown_check) else $error(\"\");", "task_id": "1_6679", "predict_sva": "@(posedge clk)         thermal_shutdown == 1'b1 |-> ($past(temperature_sensor) > critical_temp) || ($past(cooling_failed) == 1'b1)"}
{"sva": "@(posedge clk) disable iff(robotic_surgery) robotic_surgical_system |-> ($past(haptic_feedback[15:0], 1) && $past(tremor_filtering[11:0], 1) && $past(motion_scaling[7:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Robotic_Surgical_System_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (robotic_surgery)`  \n**Antecedent (LHS of Implication)**: `robotic_surgical_system == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(haptic_feedback[15:0], 1) && $past(tremor_filtering[11:0], 1) && $past(motion_scaling[7:0], 1))`  ", "sva_signals": ["clk", "rst_n", "[0:0] robotic_surgery", "[0:0] robotic_surgical_system", "[15:0] haptic_feedback", "[11:0] tremor_filtering", "[7:0] motion_scaling"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (robotic_surgery)     robotic_surgical_system == 1'b1 |->          ($past(haptic_feedback[15:0], 1) &&           $past(tremor_filtering[11:0], 1) &&           $past(motion_scaling[7:0], 1))", "sva_name": "p_robotic_surgical_system_enable_requires_previous_asserted_signals", "id": "2985", "full_property": "property p_Robotic_Surgical_System_Check;\n@(posedge clk) disable iff (robotic_surgery)     robotic_surgical_system == 1'b1 |->          ($past(haptic_feedback[15:0], 1) &&           $past(tremor_filtering[11:0], 1) &&           $past(motion_scaling[7:0], 1))\nendproperty\nassert_p_Robotic_Surgical_System_Check:assert property (p_Robotic_Surgical_System_Check) else $error(\"\");", "task_id": "1_6601", "predict_sva": "@(posedge clk) disable iff (robotic_surgery)         (robotic_surgical_system == 1'b1 && robotic_surgery == 0) |->          ($past(haptic_feedback[15:0]) != 0) &&          ($past(tremor_filtering[11:0]) != 0) &&          ($past(motion_scaling[7:0]) != 0)"}
{"sva": "@(negedge clk_i2c) disable iff(!i2c_enable) bus_collision |-> $past(sda_drive) && $past(scl_drive) && !$past(bus_free)", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_collision_check  \n**Trigger Condition**: At every falling edge of the `clk_i2c`  \n**Disable Condition**: disable iff (!i2c_enable)  \n**Antecedent (LHS of Implication)**: `bus_collision == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sda_drive) && $past(scl_drive) && !$past(bus_free)`  ", "sva_signals": ["clk_i2c", "i2c_enable", "[0:0] bus_collision", "[0:0] sda_drive", "[0:0] scl_drive", "[0:0] bus_free"], "clock": "clk_i2c", "attempts_left": 10, "sva_result": "@(negedge clk_i2c) disable iff (!i2c_enable)     bus_collision == 1'b1 |-> $past(sda_drive) && $past(scl_drive) && !$past(bus_free)", "sva_name": "p_bus_collision_check", "id": "3074", "full_property": "property p_bus_collision_check;\n@(negedge clk_i2c) disable iff (!i2c_enable)     bus_collision == 1'b1 |-> $past(sda_drive) && $past(scl_drive) && !$past(bus_free)\nendproperty\nassert_p_bus_collision_check:assert property (p_bus_collision_check) else $error(\"\");", "task_id": "1_6684", "predict_sva": "@(negedge clk_i2c) disable iff (!i2c_enable)     bus_collision == 1'b1 |->      $past(sda_drive & scl_drive & !bus_free, 1)"}
{"sva": "@(negedge clk_crypto) disable iff(!crypto_enable) key_expired |-> $past(key_age_counter) >= max_key_age", "sva_description": "### Assertion description:  \n**Property Name**: p_Key_Expired_Check  \n**Trigger Condition**: At every falling edge of `clk_crypto`  \n**Disable Condition**: disable iff `(!crypto_enable)`  \n**Antecedent (LHS of Implication)**: `key_expired`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(key_age_counter) >= max_key_age`", "sva_signals": ["clk_crypto", "crypto_enable", "[0:0] key_expired", "[0:0] key_age_counter", "[0:0] max_key_age"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(negedge clk_crypto) disable iff (!crypto_enable)     key_expired |-> $past(key_age_counter) >= max_key_age", "sva_name": "p_key_expired_key_age_check", "id": "3078", "full_property": "property p_Key_Expired_Check;\n@(negedge clk_crypto) disable iff (!crypto_enable)     key_expired |-> $past(key_age_counter) >= max_key_age\nendproperty\nassert_p_Key_Expired_Check:assert property (p_Key_Expired_Check) else $error(\"\");", "task_id": "1_6688", "predict_sva": "@(negedge clk_crypto) disable iff (!crypto_enable)         (crypto_enable == 1 && key_expired == 1) |-> ($past(key_age_counter) >= max_key_age)"}
{"sva": "@(negedge clk_flash) disable iff(!flash_ready) erase_failure |-> $past(erase_command) && !$past(erase_complete, 1000)", "sva_description": "### Assertion description:  \n**Property Name**: p_erase_failure_check  \n**Trigger Condition**: At every falling edge of `clk_flash`  \n**Disable Condition**: disable iff `!flash_ready`  \n**Antecedent (LHS of Implication)**: `erase_failure`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(erase_command) && !$past(erase_complete, 1000)`  ", "sva_signals": ["clk_flash", "flash_ready", "[0:0] erase_failure", "[0:0] erase_command", "[0:0] erase_complete"], "clock": "clk_flash", "attempts_left": 10, "sva_result": "@(negedge clk_flash) disable iff (!flash_ready)     erase_failure |-> $past(erase_command) && !$past(erase_complete, 1000)", "sva_name": "p_erase_failure_requires_command_and_no_complete", "id": "3096", "full_property": "property p_erase_failure_check;\n@(negedge clk_flash) disable iff (!flash_ready)     erase_failure |-> $past(erase_command) && !$past(erase_complete, 1000)\nendproperty\nassert_p_erase_failure_check:assert property (p_erase_failure_check) else $error(\"\");", "task_id": "1_6704", "predict_sva": "@(negedge clk_flash) disable iff (flash_ready == 0)         (flash_ready == 1 && erase_failure == 1) |-> ($past(erase_command) == 1 && !$past(erase_complete, 1000))"}
{"sva": "@(posedge clk) disable iff(!reset_n) lock_acquired |-> $past(lock_request, 3) && !$past(lock_busy)", "sva_description": "### Assertion description:  \n**Property Name**: p_lock_acquired_after_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!reset_n)  \n**Antecedent (LHS of Implication)**: `lock_acquired == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(lock_request, 3) && !$past(lock_busy)`  ", "sva_signals": ["clk", "reset_n", "[0:0] lock_acquired", "[0:0] lock_request", "[0:0] lock_busy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!reset_n)     lock_acquired == 1'b1 |-> $past(lock_request, 3) && !$past(lock_busy)", "sva_name": "p_lock_acquire_sequence_check", "id": "3102", "full_property": "property p_lock_acquired_after_request;\n@(posedge clk) disable iff (!reset_n)     lock_acquired == 1'b1 |-> $past(lock_request, 3) && !$past(lock_busy)\nendproperty\nassert_p_lock_acquired_after_request:assert property (p_lock_acquired_after_request) else $error(\"\");", "task_id": "1_6708", "predict_sva": "@(posedge clk) disable iff (!reset_n)         (reset_n == 1 && lock_acquired == 1) |-> ($past(lock_request, 3) == 1 && $past(lock_busy, 1) == 0)"}
{"sva": "@(negedge clk_audio) disable iff(!audio_power) underrun_condition |-> $past(fifo_level) < min_threshold && $past(playback_active)", "sva_description": "### Assertion description:  \n**Property Name**: p_underrun_condition_check  \n**Trigger Condition**: At every falling edge of `clk_audio`  \n**Disable Condition**: disable iff `(!audio_power)`  \n**Antecedent (LHS of Implication)**: `underrun_condition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(fifo_level) < min_threshold && $past(playback_active)`  ", "sva_signals": ["clk_audio", "audio_power", "[0:0] underrun_condition", "[0:0] fifo_level", "[0:0] min_threshold", "[0:0] playback_active"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(negedge clk_audio) disable iff (!audio_power)     underrun_condition |-> ($past(fifo_level) < min_threshold) && $past(playback_active)", "sva_name": "p_underrun_condition_check", "id": "3108", "full_property": "property p_underrun_condition_check;\n@(negedge clk_audio) disable iff (!audio_power)     underrun_condition |-> ($past(fifo_level) < min_threshold) && $past(playback_active)\nendproperty\nassert_p_underrun_condition_check:assert property (p_underrun_condition_check) else $error(\"\");", "task_id": "1_6713", "predict_sva": "@(negedge clk_audio) disable iff (!audio_power)     underrun_condition |-> ($past(fifo_level) < min_threshold) && $past(playback_active)"}
{"sva": "@(posedge clk_crypto) disable iff(crypto_bypass) key_schedule_error |-> $past(key_expansion) && ($past(round_key) == 0)", "sva_description": "### Assertion description:  \n**Property Name**: p_Key_Schedule_Error  \n**Trigger Condition**: At every rising edge of `clk_crypto`  \n**Disable Condition**: `disable iff (crypto_bypass)`  \n**Antecedent (LHS of Implication)**: `key_schedule_error`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(key_expansion) && ($past(round_key) == 0)`  ", "sva_signals": ["clk_crypto", "crypto_bypass", "[0:0] key_schedule_error", "key_expansion", "round_key"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto) disable iff (crypto_bypass)     key_schedule_error |-> $past(key_expansion) && ($past(round_key) == 0)", "sva_name": "p_key_schedule_error_requires_prev_keyexp_and_roundkey0", "id": "3133", "full_property": "property p_Key_Schedule_Error;\n@(posedge clk_crypto) disable iff (crypto_bypass)     key_schedule_error |-> $past(key_expansion) && ($past(round_key) == 0)\nendproperty\nassert_p_Key_Schedule_Error:assert property (p_Key_Schedule_Error) else $error(\"\");", "task_id": "1_6736", "predict_sva": "@(posedge clk_crypto) disable iff (crypto_bypass)         (crypto_bypass == 0 && key_schedule_error == 1) |-> ($past(key_expansion) == 1 && $past(round_key) == 0)"}
{"sva": "@(posedge clk) disable iff(scan_test_mode) pipeline_bubble_detected |-> $past(instruction_valid) && !$past(data_hazard_resolved) && stall_condition", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_bubble_detected  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (scan_test_mode)  \n**Antecedent (LHS of Implication)**: `pipeline_bubble_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(instruction_valid) && !$past(data_hazard_resolved) && stall_condition`  ", "sva_signals": ["clk", "rst_n", "[0:0] scan_test_mode", "[0:0] pipeline_bubble_detected", "[0:0] instruction_valid", "[0:0] data_hazard_resolved", "[0:0] stall_condition"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (scan_test_mode)     pipeline_bubble_detected == 1'b1 |->      ($past(instruction_valid) && !$past(data_hazard_resolved) && stall_condition)", "sva_name": "p_pipeline_bubble_cause_check", "id": "3141", "full_property": "property p_pipeline_bubble_detected;\n@(posedge clk) disable iff (scan_test_mode)     pipeline_bubble_detected == 1'b1 |->      ($past(instruction_valid) && !$past(data_hazard_resolved) && stall_condition)\nendproperty\nassert_p_pipeline_bubble_detected:assert property (p_pipeline_bubble_detected) else $error(\"\");", "task_id": "1_6743", "predict_sva": "@(posedge clk) disable iff (scan_test_mode)         (scan_test_mode == 0 && pipeline_bubble_detected == 1'b1) |->          ($past(instruction_valid) == 1'b1 && $past(data_hazard_resolved) == 1'b0 && stall_condition == 1'b1)"}
{"sva": "@(posedge clk) disable iff(test_harness_active) race_condition_detected |-> $past(signal_a_change) && $past(signal_b_change) && !$past(arbitration_done)", "sva_description": "### Assertion description:  \n**Property Name**: p_Race_Condition_Detection  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`test_harness_active`)  \n**Antecedent (LHS of Implication)**: `race_condition_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(signal_a_change) && $past(signal_b_change) && !$past(arbitration_done)`  ", "sva_signals": ["clk", "rst_n", "[0:0] test_harness_active", "[0:0] race_condition_detected", "[0:0] signal_a_change", "[0:0] signal_b_change", "[0:0] arbitration_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (test_harness_active)     race_condition_detected == 1'b1 |->      $past(signal_a_change) && $past(signal_b_change) && !$past(arbitration_done)", "sva_name": "p_race_condition_detected", "id": "3145", "full_property": "property p_Race_Condition_Detection;\n@(posedge clk) disable iff (test_harness_active)     race_condition_detected == 1'b1 |->      $past(signal_a_change) && $past(signal_b_change) && !$past(arbitration_done)\nendproperty\nassert_p_Race_Condition_Detection:assert property (p_Race_Condition_Detection) else $error(\"\");", "task_id": "1_6747", "predict_sva": "@(posedge clk) disable iff (test_harness_active)     race_condition_detected == 1'b1 |->      ($past(signal_a_change) && $past(signal_b_change)) && !$past(arbitration_done)"}
{"sva": "@(posedge clk) disable iff(!rst_n) load_balancer_switch |-> $past(server_load[7:0]) > threshold_high && $past(alternate_server_ready)", "sva_description": "### Assertion description:  \n**Property Name**: p_load_balancer_switch  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst_n)`  \n**Antecedent (LHS of Implication)**: `load_balancer_switch == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(server_load[7:0]) > threshold_high && $past(alternate_server_ready)`  ", "sva_signals": ["clk", "rst_n", "[0:0] load_balancer_switch", "[7:0] server_load", "[7:0] threshold_high", "[0:0] alternate_server_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     load_balancer_switch == 1'b1 |->      ($past(server_load[7:0]) > threshold_high) && $past(alternate_server_ready)", "sva_name": "p_load_balancer_switch_requires_prev_server_load_and_alternate_ready", "id": "3144", "full_property": "property p_load_balancer_switch;\n@(posedge clk) disable iff (!rst_n)     load_balancer_switch == 1'b1 |->      ($past(server_load[7:0]) > threshold_high) && $past(alternate_server_ready)\nendproperty\nassert_p_load_balancer_switch:assert property (p_load_balancer_switch) else $error(\"\");", "task_id": "1_6746", "predict_sva": "@(posedge clk) disable iff (!rst_n)         (rst_n == 1 && load_balancer_switch == 1) |->          ($past(server_load[7:0]) > threshold_high) && ($past(alternate_server_ready) == 1)"}
{"sva": "@(posedge clk) disable iff(burn_in_test) electromigration_warning |-> ($past(current_density) > em_threshold) && ($past(operating_hours) > reliability_limit)", "sva_description": "### Assertion description:  \n**Property Name**: p_electromigration_warning  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (burn_in_test)`  \n**Antecedent (LHS of Implication)**: `electromigration_warning`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(current_density) > em_threshold) && ($past(operating_hours) > reliability_limit)`", "sva_signals": ["clk", "rst_n", "[0:0] burn_in_test", "[0:0] electromigration_warning", "[0:0] current_density", "[0:0] em_threshold", "[0:0] operating_hours", "[0:0] reliability_limit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (burn_in_test)     electromigration_warning |-> ($past(current_density) > em_threshold) && ($past(operating_hours) > reliability_limit)", "sva_name": "p_electromigration_warning_trigger_condition", "id": "3153", "full_property": "property p_electromigration_warning;\n@(posedge clk) disable iff (burn_in_test)     electromigration_warning |-> ($past(current_density) > em_threshold) && ($past(operating_hours) > reliability_limit)\nendproperty\nassert_p_electromigration_warning:assert property (p_electromigration_warning) else $error(\"\");", "task_id": "1_6755", "predict_sva": "@(posedge clk) disable iff (burn_in_test)         (burn_in_test == 0 && electromigration_warning == 1) |->          ($past(current_density) > em_threshold) && ($past(operating_hours) > reliability_limit)"}
{"sva": "@(posedge clk_mesh) disable iff(mesh_shutdown) node_isolation |-> !$past(neighbor_alive[3:0]) && $past(heartbeat_timeout)", "sva_description": "### Assertion description:  \n**Property Name**: p_node_isolation_check  \n**Trigger Condition**: At every rising edge of the `clk_mesh`  \n**Disable Condition**: `disable iff (mesh_shutdown)`  \n**Antecedent (LHS of Implication)**: `node_isolation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(neighbor_alive[3:0]) && $past(heartbeat_timeout)`  ", "sva_signals": ["clk_mesh", "mesh_shutdown", "[0:0] node_isolation", "[3:0] neighbor_alive", "[0:0] heartbeat_timeout"], "clock": "clk_mesh", "attempts_left": 10, "sva_result": "@(posedge clk_mesh) disable iff (mesh_shutdown)     node_isolation == 1'b1 |-> !$past(neighbor_alive[3:0]) && $past(heartbeat_timeout)", "sva_name": "p_node_isolation_prev_no_neighbor_alive_and_heartbeat_timeout", "id": "3168", "full_property": "property p_node_isolation_check;\n@(posedge clk_mesh) disable iff (mesh_shutdown)     node_isolation == 1'b1 |-> !$past(neighbor_alive[3:0]) && $past(heartbeat_timeout)\nendproperty\nassert_p_node_isolation_check:assert property (p_node_isolation_check) else $error(\"\");", "task_id": "1_6767", "predict_sva": "@(posedge clk_mesh) disable iff (mesh_shutdown)         (mesh_shutdown == 0 && node_isolation == 1) |->          ($past(neighbor_alive[3:0]) == 0 && $past(heartbeat_timeout) == 1)"}
{"sva": "@(posedge clk) disable iff(reliability_test) single_event_upset_detected |-> $past(cosmic_ray_strike) && ($past(flip_flop_state) != $past(expected_state))", "sva_description": "### Assertion description:  \n**Property Name**: p_single_event_upset_detection  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (reliability_test)`  \n**Antecedent (LHS of Implication)**: `single_event_upset_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cosmic_ray_strike) && ($past(flip_flop_state) != $past(expected_state))`  ", "sva_signals": ["clk", "rst_n", "[0:0] single_event_upset_detected", "[0:0] reliability_test", "[0:0] cosmic_ray_strike", "[0:0] flip_flop_state", "[0:0] expected_state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (reliability_test)     single_event_upset_detected == 1'b1 |->          $past(cosmic_ray_strike) && ($past(flip_flop_state) != $past(expected_state))", "sva_name": "p_single_event_upset_cause_check", "id": "3237", "full_property": "property p_single_event_upset_detection;\n@(posedge clk) disable iff (reliability_test)     single_event_upset_detected == 1'b1 |->          $past(cosmic_ray_strike) && ($past(flip_flop_state) != $past(expected_state))\nendproperty\nassert_p_single_event_upset_detection:assert property (p_single_event_upset_detection) else $error(\"\");", "task_id": "1_6831", "predict_sva": "@(posedge clk) disable iff (reliability_test)         (reliability_test == 0 && single_event_upset_detected == 1) |->          ($past(cosmic_ray_strike) == 1 && $past(flip_flop_state) != $past(expected_state))"}
{"sva": "@(negedge clk_exhaust) disable iff(emissions_test_mode) catalytic_converter_efficiency |-> ($past(upstream_oxygen) != $past(downstream_oxygen)) && $past(converter_temperature_optimal)", "sva_description": "### Assertion description:  \n**Property Name**: p_Catalytic_Converter_Efficiency  \n**Trigger Condition**: At every falling edge of the `clk_exhaust`  \n**Disable Condition**: `disable iff (emissions_test_mode)`  \n**Antecedent (LHS of Implication)**: `catalytic_converter_efficiency`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(upstream_oxygen) != $past(downstream_oxygen)) && $past(converter_temperature_optimal)`", "sva_signals": ["clk_exhaust", "emissions_test_mode", "catalytic_converter_efficiency", "[0:0] upstream_oxygen", "[0:0] downstream_oxygen", "[0:0] converter_temperature_optimal"], "clock": "clk_exhaust", "attempts_left": 10, "sva_result": "@(negedge clk_exhaust) disable iff (emissions_test_mode)     catalytic_converter_efficiency |->      ($past(upstream_oxygen) != $past(downstream_oxygen)) && $past(converter_temperature_optimal)", "sva_name": "p_catalytic_converter_efficiency_prev_oxygen_and_temp", "id": "3255", "full_property": "property p_Catalytic_Converter_Efficiency;\n@(negedge clk_exhaust) disable iff (emissions_test_mode)     catalytic_converter_efficiency |->      ($past(upstream_oxygen) != $past(downstream_oxygen)) && $past(converter_temperature_optimal)\nendproperty\nassert_p_Catalytic_Converter_Efficiency:assert property (p_Catalytic_Converter_Efficiency) else $error(\"\");", "task_id": "1_6845", "predict_sva": "@(negedge clk_exhaust) disable iff (emissions_test_mode)         (emissions_test_mode == 0 && catalytic_converter_efficiency == 1) |->          ($past(upstream_oxygen) != $past(downstream_oxygen) && $past(converter_temperature_optimal) == 1)"}
{"sva": "@(posedge clk) disable iff(dealer_mode) fuel_pump_prime_sequence |-> $past(ignition_key_on) && !$past(fuel_pressure_buildup, 15) && $past(pump_motor_energized)", "sva_description": "### Assertion description:  \n**Property Name**: p_fuel_pump_prime_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (dealer_mode)`  \n**Antecedent (LHS of Implication)**: `fuel_pump_prime_sequence == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ignition_key_on) && !$past(fuel_pressure_buildup, 15) && $past(pump_motor_energized)`  ", "sva_signals": ["clk", "rst_n", "[0:0] dealer_mode", "[0:0] fuel_pump_prime_sequence", "[0:0] ignition_key_on", "[0:0] fuel_pressure_buildup", "[0:0] pump_motor_energized"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (dealer_mode)     fuel_pump_prime_sequence == 1'b1 |->      $past(ignition_key_on) &&      !$past(fuel_pressure_buildup, 15) &&      $past(pump_motor_energized)", "sva_name": "p_fuel_pump_prime_sequence_allowed", "id": "3276", "full_property": "property p_fuel_pump_prime_sequence;\n@(posedge clk) disable iff (dealer_mode)     fuel_pump_prime_sequence == 1'b1 |->      $past(ignition_key_on) &&      !$past(fuel_pressure_buildup, 15) &&      $past(pump_motor_energized)\nendproperty\nassert_p_fuel_pump_prime_sequence:assert property (p_fuel_pump_prime_sequence) else $error(\"\");", "task_id": "1_6866", "predict_sva": "@(posedge clk) disable iff (dealer_mode)         (dealer_mode == 0 && fuel_pump_prime_sequence == 1'b1) |->          ($past(ignition_key_on) == 1'b1 && !$past(fuel_pressure_buildup, 15) && $past(pump_motor_energized) == 1'b1)"}
{"sva": "@(posedge clk_adblue) disable iff(!adblue_system_ready) selective_catalytic_reduction |-> ($past(nox_concentration) > emission_limit) && ($past(urea_injection_rate) == 0)", "sva_description": "### Assertion description:  \n**Property Name**: p_Selective_Catalytic_Reduction  \n**Trigger Condition**: At every rising edge of the `clk_adblue`  \n**Disable Condition**: `disable iff (!adblue_system_ready)`  \n**Antecedent (LHS of Implication)**: `selective_catalytic_reduction`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(nox_concentration) > emission_limit) && ($past(urea_injection_rate) == 0)`  ", "sva_signals": ["clk_adblue", "adblue_system_ready", "selective_catalytic_reduction", "nox_concentration", "emission_limit", "urea_injection_rate"], "clock": "clk_adblue", "attempts_left": 10, "sva_result": "@(posedge clk_adblue) disable iff (!adblue_system_ready)     selective_catalytic_reduction |->          ($past(nox_concentration) > emission_limit) && ($past(urea_injection_rate) == 0)", "sva_name": "p_selective_catalytic_reduction_precondition", "id": "3295", "full_property": "property p_Selective_Catalytic_Reduction;\n@(posedge clk_adblue) disable iff (!adblue_system_ready)     selective_catalytic_reduction |->          ($past(nox_concentration) > emission_limit) && ($past(urea_injection_rate) == 0)\nendproperty\nassert_p_Selective_Catalytic_Reduction:assert property (p_Selective_Catalytic_Reduction) else $error(\"\");", "task_id": "1_6885", "predict_sva": "@(posedge clk_adblue) disable iff (!adblue_system_ready)         (adblue_system_ready == 1 && selective_catalytic_reduction == 1) |->          ($past(nox_concentration) > emission_limit) &&          ($past(urea_injection_rate) == 0)"}
{"sva": "@(posedge clk) disable iff(research_reactor_mode) criticality_safety_margin |-> ($past(reactivity_insertion_rate) > max_safe_rate) && !$past(negative_reactivity_applied)", "sva_description": "### Assertion description:  \n**Property Name**: p_Criticality_Safety_Margin  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (research_reactor_mode)`  \n**Antecedent (LHS of Implication)**: `criticality_safety_margin`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(reactivity_insertion_rate) > max_safe_rate) && !$past(negative_reactivity_applied)`  ", "sva_signals": ["clk", "research_reactor_mode", "criticality_safety_margin", "reactivity_insertion_rate", "max_safe_rate", "negative_reactivity_applied"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (research_reactor_mode)     criticality_safety_margin |-> ($past(reactivity_insertion_rate) > max_safe_rate) && !$past(negative_reactivity_applied)", "sva_name": "p_criticality_safety_margin_prev_rate_and_neg_reactivity", "id": "3318", "full_property": "property p_Criticality_Safety_Margin;\n@(posedge clk) disable iff (research_reactor_mode)     criticality_safety_margin |-> ($past(reactivity_insertion_rate) > max_safe_rate) && !$past(negative_reactivity_applied)\nendproperty\nassert_p_Criticality_Safety_Margin:assert property (p_Criticality_Safety_Margin) else $error(\"\");", "task_id": "1_6906", "predict_sva": "@(posedge clk) disable iff (research_reactor_mode)         (research_reactor_mode == 0 && criticality_safety_margin == 1) |->          ($past(reactivity_insertion_rate) > max_safe_rate) &&          ($past(negative_reactivity_applied) == 0)"}
{"sva": "@(negedge clk_meteorological) disable iff(weather_monitoring_unavailable) atmospheric_dispersion_modeling |-> $past(radioactive_release_in_progress) && ($past(wind_direction_stability) == unfavorable_conditions)", "sva_description": "### Assertion description:  \n**Property Name**: p_Atmospheric_Dispersion_Modeling  \n**Trigger Condition**: At every falling edge of the `clk_meteorological`  \n**Disable Condition**: `disable iff (weather_monitoring_unavailable)`  \n**Antecedent (LHS of Implication)**: `atmospheric_dispersion_modeling`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(radioactive_release_in_progress) && ($past(wind_direction_stability) == unfavorable_conditions)`  ", "sva_signals": ["clk_meteorological", "weather_monitoring_unavailable", "atmospheric_dispersion_modeling", "radioactive_release_in_progress", "wind_direction_stability", "unfavorable_conditions"], "clock": "clk_meteorological", "attempts_left": 10, "sva_result": "@(negedge clk_meteorological) disable iff (weather_monitoring_unavailable)     atmospheric_dispersion_modeling |->      $past(radioactive_release_in_progress) && ($past(wind_direction_stability) == unfavorable_conditions)", "sva_name": "p_atmospheric_dispersion_modeling_precondition", "id": "3328", "full_property": "property p_Atmospheric_Dispersion_Modeling;\n@(negedge clk_meteorological) disable iff (weather_monitoring_unavailable)     atmospheric_dispersion_modeling |->      $past(radioactive_release_in_progress) && ($past(wind_direction_stability) == unfavorable_conditions)\nendproperty\nassert_p_Atmospheric_Dispersion_Modeling:assert property (p_Atmospheric_Dispersion_Modeling) else $error(\"\");", "task_id": "1_6916", "predict_sva": "@(negedge clk_meteorological) disable iff (weather_monitoring_unavailable)         (weather_monitoring_unavailable == 0 && atmospheric_dispersion_modeling == 1) |->          ($past(radioactive_release_in_progress) == 1 && $past(wind_direction_stability) == unfavorable_conditions)"}
{"sva": "@(posedge clk_waste_handling) disable iff(!waste_system_operational) radioactive_waste_containment |-> $past(container_seal_integrity) && ($past(radiation_leakage) > acceptable_background)", "sva_description": "### Assertion description:  \n**Property Name**: p_radioactive_waste_containment_check  \n**Trigger Condition**: At every rising edge of the `clk_waste_handling`  \n**Disable Condition**: disable iff (`!waste_system_operational`)  \n**Antecedent (LHS of Implication)**: `radioactive_waste_containment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(container_seal_integrity) && ($past(radiation_leakage) > acceptable_background)`  ", "sva_signals": ["clk_waste_handling", "waste_system_operational", "[0:0] radioactive_waste_containment", "container_seal_integrity", "radiation_leakage", "acceptable_background"], "clock": "clk_waste_handling", "attempts_left": 10, "sva_result": "@(posedge clk_waste_handling) disable iff (!waste_system_operational)     radioactive_waste_containment |->          $past(container_seal_integrity) && ($past(radiation_leakage) > acceptable_background)", "sva_name": "p_radioactive_waste_containment_preconditions", "id": "3329", "full_property": "property p_radioactive_waste_containment_check;\n@(posedge clk_waste_handling) disable iff (!waste_system_operational)     radioactive_waste_containment |->          $past(container_seal_integrity) && ($past(radiation_leakage) > acceptable_background)\nendproperty\nassert_p_radioactive_waste_containment_check:assert property (p_radioactive_waste_containment_check) else $error(\"\");", "task_id": "1_6917", "predict_sva": "@(posedge clk_waste_handling) disable iff (!waste_system_operational)         (waste_system_operational == 1 && radioactive_waste_containment == 1) |->          ($past(container_seal_integrity) == 1 && $past(radiation_leakage) > acceptable_background)"}
{"sva": "@(negedge clk_steam_dump) disable iff(steam_dump_unavailable) plant_cooldown_rate |-> ($past(cooldown_rate) > max_cooldown_rate) && $past(primary_to_secondary_heat_transfer)", "sva_description": "### Assertion description:  \n**Property Name**: p_plant_cooldown_rate_check  \n**Trigger Condition**: At every falling edge of `clk_steam_dump`  \n**Disable Condition**: `disable iff (steam_dump_unavailable)`  \n**Antecedent (LHS of Implication)**: `plant_cooldown_rate`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(cooldown_rate) > max_cooldown_rate) && $past(primary_to_secondary_heat_transfer)`", "sva_signals": ["clk_steam_dump", "steam_dump_unavailable", "[0:0] plant_cooldown_rate", "[0:0] cooldown_rate", "[0:0] max_cooldown_rate", "[0:0] primary_to_secondary_heat_transfer"], "clock": "clk_steam_dump", "attempts_left": 10, "sva_result": "disable iff (steam_dump_unavailable)     @(negedge clk_steam_dump)         plant_cooldown_rate |-> ($past(cooldown_rate) > max_cooldown_rate) && $past(primary_to_secondary_heat_transfer)", "sva_name": "p_plant_cooldown_rate_requires_prev_cooldown_and_heat_transfer", "id": "3340", "full_property": "property p_plant_cooldown_rate_check;\ndisable iff (steam_dump_unavailable)     @(negedge clk_steam_dump)         plant_cooldown_rate |-> ($past(cooldown_rate) > max_cooldown_rate) && $past(primary_to_secondary_heat_transfer)\nendproperty\nassert_p_plant_cooldown_rate_check:assert property (p_plant_cooldown_rate_check) else $error(\"\");", "task_id": "1_6928", "predict_sva": "@(negedge clk_steam_dump) disable iff (steam_dump_unavailable)         (steam_dump_unavailable == 0 && plant_cooldown_rate == 1) |->          ($past(cooldown_rate) > max_cooldown_rate && $past(primary_to_secondary_heat_transfer) == 1)"}
{"sva": "@(posedge clk_control_room) disable iff(!habitability_system_functional) operator_dose_protection |-> $past(control_room_radiation_level) > habitability_limit && !$past(isolation_mode_activated, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Operator_Dose_Protection  \n**Trigger Condition**: At every rising edge of `clk_control_room`  \n**Disable Condition**: `disable iff (!habitability_system_functional)`  \n**Antecedent (LHS of Implication)**: `operator_dose_protection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(control_room_radiation_level) > habitability_limit && !$past(isolation_mode_activated, 3)`  ", "sva_signals": ["clk_control_room", "habitability_system_functional", "[0:0] operator_dose_protection", "[15:0] control_room_radiation_level", "[15:0] habitability_limit", "[0:0] isolation_mode_activated"], "clock": "clk_control_room", "attempts_left": 10, "sva_result": "@(posedge clk_control_room) disable iff (!habitability_system_functional)     operator_dose_protection |-> ($past(control_room_radiation_level) > habitability_limit) &&                                  !$past(isolation_mode_activated, 3)", "sva_name": "p_operator_dose_protection_requires_high_radiation_and_no_isolation", "id": "3361", "full_property": "property p_Operator_Dose_Protection;\n@(posedge clk_control_room) disable iff (!habitability_system_functional)     operator_dose_protection |-> ($past(control_room_radiation_level) > habitability_limit) &&                                  !$past(isolation_mode_activated, 3)\nendproperty\nassert_p_Operator_Dose_Protection:assert property (p_Operator_Dose_Protection) else $error(\"\");", "task_id": "1_6948", "predict_sva": "@(posedge clk_control_room) disable iff (!habitability_system_functional)         (habitability_system_functional == 1 && operator_dose_protection == 1) |->          ($past(control_room_radiation_level) > habitability_limit) &&          ($past(isolation_mode_activated, 3) == 0)"}
{"sva": "@(posedge clk_satellite) disable iff(satellite_eclipse) solar_panel_orientation |-> ($past(sun_angle_azimuth) != $past(panel_azimuth_angle)) && $past(power_generation_suboptimal)", "sva_description": "### Assertion description:  \n**Property Name**: p_solar_panel_orientation  \n**Trigger Condition**: At every rising edge of the `clk_satellite`  \n**Disable Condition**: `disable iff (satellite_eclipse)`  \n**Antecedent (LHS of Implication)**: `solar_panel_orientation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(sun_angle_azimuth) != $past(panel_azimuth_angle)) && $past(power_generation_suboptimal)`  ", "sva_signals": ["clk_satellite", "satellite_eclipse", "[0:0] solar_panel_orientation", "[0:0] sun_angle_azimuth", "[0:0] panel_azimuth_angle", "[0:0] power_generation_suboptimal"], "clock": "clk_satellite", "attempts_left": 10, "sva_result": "@(posedge clk_satellite) disable iff (satellite_eclipse)     solar_panel_orientation == 1'b1 |->      ($past(sun_angle_azimuth) != $past(panel_azimuth_angle)) && $past(power_generation_suboptimal)", "sva_name": "p_solar_panel_orientation_suboptimal_check", "id": "3365", "full_property": "property p_solar_panel_orientation;\n@(posedge clk_satellite) disable iff (satellite_eclipse)     solar_panel_orientation == 1'b1 |->      ($past(sun_angle_azimuth) != $past(panel_azimuth_angle)) && $past(power_generation_suboptimal)\nendproperty\nassert_p_solar_panel_orientation:assert property (p_solar_panel_orientation) else $error(\"\");", "task_id": "1_6952", "predict_sva": "@(posedge clk_satellite) disable iff (satellite_eclipse)         (satellite_eclipse == 0 && solar_panel_orientation == 1) |->          ($past(sun_angle_azimuth) != $past(panel_azimuth_angle) && $past(power_generation_suboptimal) == 1)"}
{"sva": "@(negedge clk_targeting_pod) disable iff(targeting_system_fault) laser_designation_accuracy |-> ($past(target_coordinates_updated) && ($past(laser_spot_tracker_error) > designation_tolerance))", "sva_description": "### Assertion description:  \n**Property Name**: p_laser_designation_accuracy  \n**Trigger Condition**: At every falling edge of the `clk_targeting_pod`  \n**Disable Condition**: disable iff (`targeting_system_fault`)  \n**Antecedent (LHS of Implication)**: `laser_designation_accuracy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(target_coordinates_updated) && ($past(laser_spot_tracker_error) > designation_tolerance))`", "sva_signals": ["clk", "rst_n", "[0:0] laser_designation_accuracy", "[0:0] targeting_system_fault", "[0:0] target_coordinates_updated", "[0:0] laser_spot_tracker_error", "[0:0] designation_tolerance", "clk_targeting_pod"], "clock": "clk_targeting_pod", "attempts_left": 10, "sva_result": "@(negedge clk_targeting_pod) disable iff (targeting_system_fault)     laser_designation_accuracy |-> ($past(target_coordinates_updated) && ($past(laser_spot_tracker_error) > designation_tolerance))", "sva_name": "p_laser_designation_accuracy_prev_coordinates_and_error_check", "id": "3421", "full_property": "property p_laser_designation_accuracy;\n@(negedge clk_targeting_pod) disable iff (targeting_system_fault)     laser_designation_accuracy |-> ($past(target_coordinates_updated) && ($past(laser_spot_tracker_error) > designation_tolerance))\nendproperty\nassert_p_laser_designation_accuracy:assert property (p_laser_designation_accuracy) else $error(\"\");", "task_id": "1_7006", "predict_sva": "@(negedge clk_targeting_pod) disable iff (targeting_system_fault)         (targeting_system_fault == 0 && laser_designation_accuracy == 1) |->          ($past(target_coordinates_updated) == 1 && $past(laser_spot_tracker_error) > designation_tolerance)"}
{"sva": "@(posedge clk_submarine) disable iff(surface_mode) periscope_depth_control |-> ($past(hull_pressure_differential) > crush_depth_warning) && !$past(ballast_tank_blow_initiated, 7)", "sva_description": "### Assertion description:  \n**Property Name**: p_Periscope_Depth_Control_Safety  \n**Trigger Condition**: At every rising edge of the `clk_submarine`  \n**Disable Condition**: `disable iff (surface_mode)`  \n**Antecedent (LHS of Implication)**: `periscope_depth_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `hull_pressure_differential` (sampled at the previous clock edge) must be greater than `crush_depth_warning`.  \n- The past value of `ballast_tank_blow_initiated` (sampled 7 clock cycles ago) must be `0` (i.e., `!$past(ballast_tank_blow_initiated, 7)`).  \n\n### Notes:  \n- The assertion ensures that when `periscope_depth_control` is active, the submarine's hull pressure differential is safe (above the warning threshold) and no ballast tank blow was initiated in the last 7 clock cycles.  \n- The check is disabled if `surface_mode` is active (surface operation likely bypasses depth-related safety checks).", "sva_signals": ["clk_submarine", "[0:0] surface_mode", "[0:0] periscope_depth_control", "[0:0] hull_pressure_differential", "[0:0] crush_depth_warning", "[0:0] ballast_tank_blow_initiated"], "clock": "clk_submarine", "attempts_left": 10, "sva_result": "@(posedge clk_submarine) disable iff (surface_mode)     periscope_depth_control == 1'b1 |->      ($past(hull_pressure_differential) > crush_depth_warning) &&     (!$past(ballast_tank_blow_initiated, 7))", "sva_name": "p_periscope_depth_control_safety_check", "id": "3428", "full_property": "property p_Periscope_Depth_Control_Safety;\n@(posedge clk_submarine) disable iff (surface_mode)     periscope_depth_control == 1'b1 |->      ($past(hull_pressure_differential) > crush_depth_warning) &&     (!$past(ballast_tank_blow_initiated, 7))\nendproperty\nassert_p_Periscope_Depth_Control_Safety:assert property (p_Periscope_Depth_Control_Safety) else $error(\"\");", "task_id": "1_7013", "predict_sva": "@(posedge clk_submarine) disable iff (surface_mode)         (surface_mode == 0 && periscope_depth_control == 1) |->          ($past(hull_pressure_differential) > crush_depth_warning) &&          ($past(ballast_tank_blow_initiated, 7) == 0)"}
{"sva": "@(negedge clk_night_vision) disable iff(daylight_operations) low_light_imaging_system |-> ($past(ambient_light_level) < night_vision_threshold) && ($past(image_intensifier_gain) == minimum_gain)", "sva_description": "### Assertion description:  \n**Property Name**: p_Low_Light_Imaging_Check  \n**Trigger Condition**: At every falling edge of `clk_night_vision`  \n**Disable Condition**: `disable iff (daylight_operations)`  \n**Antecedent (LHS of Implication)**: `low_light_imaging_system == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `ambient_light_level` must be less than `night_vision_threshold` (`$past(ambient_light_level) < night_vision_threshold`), **and**  \n- The past value of `image_intensifier_gain` must equal `minimum_gain` (`$past(image_intensifier_gain) == minimum_gain`).  \n\n### Key Notes:  \n1. **Edge Sensitivity**: The assertion triggers on the **negedge** of `clk_night_vision`, unlike the typical `posedge` in the examples.  \n2. **Disable Condition**: The assertion is **disabled during `daylight_operations`** (active-high disable).  \n3. **Temporal Check**: The consequent uses `$past` to verify historical values of `ambient_light_level` and `image_intensifier_gain` at the previous clock edge.  \n4. **Combined Conditions**: The consequent requires **both** sub-conditions to hold simultaneously (logical AND).  \n\nThis assertion ensures that when the low-light imaging system is active, the ambient light level was below the threshold **and** the gain was at its minimum in the preceding cycle.", "sva_signals": ["clk_night_vision", "daylight_operations", "low_light_imaging_system", "[15:0] ambient_light_level", "[15:0] night_vision_threshold", "[15:0] image_intensifier_gain", "[15:0] minimum_gain"], "clock": "clk_night_vision", "attempts_left": 10, "sva_result": "@(negedge clk_night_vision) disable iff (daylight_operations)     low_light_imaging_system == 1'b1 |->     ($past(ambient_light_level) < night_vision_threshold) &&     ($past(image_intensifier_gain) == minimum_gain)", "sva_name": "p_low_light_imaging_activation_condition", "id": "3431", "full_property": "property p_Low_Light_Imaging_Check;\n@(negedge clk_night_vision) disable iff (daylight_operations)     low_light_imaging_system == 1'b1 |->     ($past(ambient_light_level) < night_vision_threshold) &&     ($past(image_intensifier_gain) == minimum_gain)\nendproperty\nassert_p_Low_Light_Imaging_Check:assert property (p_Low_Light_Imaging_Check) else $error(\"\");", "task_id": "1_7016", "predict_sva": "@(negedge clk_night_vision) disable iff (daylight_operations)         (daylight_operations == 0 && low_light_imaging_system == 1) |->          ($past(ambient_light_level) < night_vision_threshold) &&          ($past(image_intensifier_gain) == minimum_gain)"}
{"sva": "@(negedge clk_stockpile) disable iff(material_handling_system_offline) ore_stockpile_management |-> ($past(conveyor_belt_load_sensor) > belt_capacity_limit) && !$past(material_flow_diversion_activated, 6)", "sva_description": "### Assertion description:  \n**Property Name**: p_ore_stockpile_management_check  \n**Trigger Condition**: At every falling edge of `clk_stockpile`  \n**Disable Condition**: disable iff (`material_handling_system_offline`)  \n**Antecedent (LHS of Implication)**: `ore_stockpile_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `conveyor_belt_load_sensor` (sampled at the previous trigger event) must be greater than `belt_capacity_limit`, **and**  \n- The past value of `material_flow_diversion_activated` (sampled 6 clock cycles before the current trigger event) must be `0` (`!` negated).  \n\n### Key Notes:  \n1. **Edge Sensitivity**: The assertion evaluates on the **negedge** of `clk_stockpile`, unlike the typical `posedge` in the examples.  \n2. **Temporal Lookback**:  \n   - `$past(conveyor_belt_load_sensor)` refers to the value **one** `clk_stockpile` cycle before the current evaluation.  \n   - `$past(material_flow_diversion_activated, 6)` checks the value **six** cycles prior.  \n3. **Combined Consequent**: Both conditions must hold simultaneously for the assertion to pass.  \n4. **Disable Condition**: The assertion is ignored if `material_handling_system_offline` is active (asynchronous reset).  \n\n### Formal Interpretation:  \n\"If `ore_stockpile_management` is active at a falling clock edge, then in the previous cycle, the conveyor belt was overloaded (`> belt_capacity_limit`), and six cycles ago, material flow diversion was **not** activated.\"", "sva_signals": ["clk_stockpile", "material_handling_system_offline", "[0:0] ore_stockpile_management", "[0:0] conveyor_belt_load_sensor", "[0:0] belt_capacity_limit", "[0:0] material_flow_diversion_activated"], "clock": "clk_stockpile", "attempts_left": 10, "sva_result": "@(negedge clk_stockpile) disable iff (material_handling_system_offline)     ore_stockpile_management |->      ($past(conveyor_belt_load_sensor) > belt_capacity_limit) &&      (!$past(material_flow_diversion_activated, 6))", "sva_name": "p_ore_stockpile_management_check", "id": "3516", "full_property": "property p_ore_stockpile_management_check;\n@(negedge clk_stockpile) disable iff (material_handling_system_offline)     ore_stockpile_management |->      ($past(conveyor_belt_load_sensor) > belt_capacity_limit) &&      (!$past(material_flow_diversion_activated, 6))\nendproperty\nassert_p_ore_stockpile_management_check:assert property (p_ore_stockpile_management_check) else $error(\"\");", "task_id": "1_7098", "predict_sva": "@(negedge clk_stockpile) disable iff (material_handling_system_offline)     ore_stockpile_management |->          ($past(conveyor_belt_load_sensor) > belt_capacity_limit) &&         ($past(material_flow_diversion_activated, 6) == 0)"}
{"sva": "@(negedge clk_continuous_miner) disable iff(cutting_head_inspection_overdue) underground_coal_extraction |-> ($past(cutting_head_vibration_level) > acceptable_vibration_threshold) && !$past(cutting_operation_suspended, 5)", "sva_description": "### Assertion description:  \n**Property Name**: p_Underground_Coal_Extraction_Safety  \n**Trigger Condition**: At every falling edge of the `clk_continuous_miner`  \n**Disable Condition**: `disable iff (cutting_head_inspection_overdue)`  \n**Antecedent (LHS of Implication)**: `underground_coal_extraction == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `cutting_head_vibration_level` must be greater than `acceptable_vibration_threshold` (`$past(cutting_head_vibration_level) > acceptable_vibration_threshold`)  \n- The cutting operation must not have been suspended 5 cycles ago (`!$past(cutting_operation_suspended, 5)`)  \n\n(Note: The consequent combines two conditions with a logical AND (`&&`), ensuring both safety checks are met when coal extraction is active.)", "sva_signals": ["clk_continuous_miner", "cutting_head_inspection_overdue", "underground_coal_extraction", "cutting_head_vibration_level", "acceptable_vibration_threshold", "cutting_operation_suspended"], "clock": "clk_continuous_miner", "attempts_left": 10, "sva_result": "@(negedge clk_continuous_miner) disable iff (cutting_head_inspection_overdue)     underground_coal_extraction == 1'b1 |->     ($past(cutting_head_vibration_level) > acceptable_vibration_threshold) &&     (!$past(cutting_operation_suspended, 5))", "sva_name": "p_underground_coal_extraction_safety_check", "id": "3538", "full_property": "property p_Underground_Coal_Extraction_Safety;\n@(negedge clk_continuous_miner) disable iff (cutting_head_inspection_overdue)     underground_coal_extraction == 1'b1 |->     ($past(cutting_head_vibration_level) > acceptable_vibration_threshold) &&     (!$past(cutting_operation_suspended, 5))\nendproperty\nassert_p_Underground_Coal_Extraction_Safety:assert property (p_Underground_Coal_Extraction_Safety) else $error(\"\");", "task_id": "1_7120", "predict_sva": "@(negedge clk_continuous_miner) disable iff (cutting_head_inspection_overdue)         (underground_coal_extraction == 1'b1 && cutting_head_inspection_overdue == 1'b0) |->          ($past(cutting_head_vibration_level) > acceptable_vibration_threshold) &&          ($past(cutting_operation_suspended, 5) == 1'b0)"}
{"sva": "@(negedge clk_seawater_pump) disable iff(pump_cavitation_alarm) cooling_water_intake_system |-> ($past(pump_suction_pressure) < net_positive_suction_head_required) && $past(pump_motor_overload_detected)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cooling_Water_Intake_Safety  \n**Trigger Condition**: At every falling edge of `clk_seawater_pump`  \n**Disable Condition**: `disable iff (pump_cavitation_alarm)`  \n**Antecedent (LHS of Implication)**: `cooling_water_intake_system == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(pump_suction_pressure) < net_positive_suction_head_required) && $past(pump_motor_overload_detected)`  ", "sva_signals": ["clk_seawater_pump", "pump_cavitation_alarm", "cooling_water_intake_system", "[0:0] pump_suction_pressure", "[0:0] net_positive_suction_head_required", "[0:0] pump_motor_overload_detected"], "clock": "clk_seawater_pump", "attempts_left": 10, "sva_result": "@(negedge clk_seawater_pump) disable iff (pump_cavitation_alarm)     cooling_water_intake_system == 1'b1 |->      ($past(pump_suction_pressure) < net_positive_suction_head_required) &&      $past(pump_motor_overload_detected)", "sva_name": "p_cooling_water_intake_safety_check", "id": "3552", "full_property": "property p_Cooling_Water_Intake_Safety;\n@(negedge clk_seawater_pump) disable iff (pump_cavitation_alarm)     cooling_water_intake_system == 1'b1 |->      ($past(pump_suction_pressure) < net_positive_suction_head_required) &&      $past(pump_motor_overload_detected)\nendproperty\nassert_p_Cooling_Water_Intake_Safety:assert property (p_Cooling_Water_Intake_Safety) else $error(\"\");", "task_id": "1_7134", "predict_sva": "@(negedge clk_seawater_pump) disable iff (pump_cavitation_alarm)         (pump_cavitation_alarm == 0 && cooling_water_intake_system == 1) |->          ($past(pump_suction_pressure) < net_positive_suction_head_required) &&          ($past(pump_motor_overload_detected) == 1)"}
{"sva": "@(posedge clk) disable iff(!pest_monitoring_system_active) integrated_pest_management |-> $past(insect_trap_count_threshold_exceeded) && ($past(biological_control_agent_release) == release_not_authorized)", "sva_description": "### Assertion description:  \n**Property Name**: p_Integrated_Pest_Management_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!pest_monitoring_system_active)`  \n**Antecedent (LHS of Implication)**: `integrated_pest_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(insect_trap_count_threshold_exceeded) && ($past(biological_control_agent_release) == release_not_authorized)`  ", "sva_signals": ["clk", "pest_monitoring_system_active", "integrated_pest_management", "insect_trap_count_threshold_exceeded", "biological_control_agent_release", "release_not_authorized"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!pest_monitoring_system_active)     integrated_pest_management |->          $past(insect_trap_count_threshold_exceeded) &&          ($past(biological_control_agent_release) == release_not_authorized)", "sva_name": "p_integrated_pest_management_precondition_check", "id": "3592", "full_property": "property p_Integrated_Pest_Management_Check;\n@(posedge clk) disable iff (!pest_monitoring_system_active)     integrated_pest_management |->          $past(insect_trap_count_threshold_exceeded) &&          ($past(biological_control_agent_release) == release_not_authorized)\nendproperty\nassert_p_Integrated_Pest_Management_Check:assert property (p_Integrated_Pest_Management_Check) else $error(\"\");", "task_id": "1_7173", "predict_sva": "@(posedge clk) disable iff (!pest_monitoring_system_active)         (pest_monitoring_system_active == 1 && integrated_pest_management == 1) |->          ($past(insect_trap_count_threshold_exceeded) == 1 &&           $past(biological_control_agent_release) == release_not_authorized)"}
{"sva": "@(posedge clk_seed_planter) disable iff(!field_preparation_complete) precision_seeding_depth_control |-> ($past(soil_compaction_measurement) > optimal_seeding_conditions) && ($past(planting_depth_adjustment) == no_depth_modification)", "sva_description": "### Assertion description:  \n**Property Name**: p_precision_seeding_depth_control  \n**Trigger Condition**: At every rising edge of the `clk_seed_planter`  \n**Disable Condition**: disable iff (`!field_preparation_complete`)  \n**Antecedent (LHS of Implication)**: `precision_seeding_depth_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(soil_compaction_measurement) > optimal_seeding_conditions)`  \n- `&& ($past(planting_depth_adjustment) == no_depth_modification)`  \n\nThe assertion checks that whenever precision seeding depth control is enabled (`precision_seeding_depth_control` is high), the following conditions must hold:  \n1. The past value of `soil_compaction_measurement` must be greater than `optimal_seeding_conditions`.  \n2. The past value of `planting_depth_adjustment` must indicate no depth modification (`no_depth_modification`).  \nThe assertion is disabled if `field_preparation_complete` is not asserted (active-low reset condition).", "sva_signals": ["clk", "field_preparation_complete", "[0:0] precision_seeding_depth_control", "[0:0] optimal_seeding_conditions", "[0:0] no_depth_modification", "[0:0] soil_compaction_measurement", "[0:0] planting_depth_adjustment", "clk_seed_planter"], "clock": "clk_seed_planter", "attempts_left": 10, "sva_result": "@(posedge clk_seed_planter) disable iff (!field_preparation_complete)     precision_seeding_depth_control == 1'b1 |->          ($past(soil_compaction_measurement) > optimal_seeding_conditions) &&          ($past(planting_depth_adjustment) == no_depth_modification)", "sva_name": "p_precision_seeding_depth_control_conditions", "id": "3612", "full_property": "property p_precision_seeding_depth_control;\n@(posedge clk_seed_planter) disable iff (!field_preparation_complete)     precision_seeding_depth_control == 1'b1 |->          ($past(soil_compaction_measurement) > optimal_seeding_conditions) &&          ($past(planting_depth_adjustment) == no_depth_modification)\nendproperty\nassert_p_precision_seeding_depth_control:assert property (p_precision_seeding_depth_control) else $error(\"\");", "task_id": "1_7192", "predict_sva": "@(posedge clk_seed_planter) disable iff (!field_preparation_complete)         (field_preparation_complete == 1 && precision_seeding_depth_control == 1) |->          ($past(soil_compaction_measurement) > optimal_seeding_conditions) &&          ($past(planting_depth_adjustment) == no_depth_modification)"}
{"sva": "@(negedge clk_dredging) disable iff(environmental_dredging_permit_suspended) harbor_depth_maintenance |-> ($past(sediment_contamination_level) > environmental_disposal_threshold) && !$past(contaminated_material_isolation_procedure_initiated, 9)", "sva_description": "### Assertion description:  \n**Property Name**: p_Harbor_Depth_Maintenance_Check  \n**Trigger Condition**: At every falling edge of the `clk_dredging` signal  \n**Disable Condition**: `disable iff (environmental_dredging_permit_suspended)`  \n**Antecedent (LHS of Implication)**: `harbor_depth_maintenance == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `sediment_contamination_level` (sampled at the previous negedge of `clk_dredging`) must be greater than `environmental_disposal_threshold`.  \n- The past value of `contaminated_material_isolation_procedure_initiated` (sampled 9 cycles before the current negedge of `clk_dredging`) must be `0` (i.e., the procedure was not initiated at that time).  \n\nThe assertion ensures that when harbor depth maintenance is active, the sediment contamination level historically exceeded the threshold, and no contaminated material isolation procedure was initiated 9 cycles prior. The check is disabled if the environmental dredging permit is suspended.", "sva_signals": ["clk_dredging", "environmental_dredging_permit_suspended", "[0:0] harbor_depth_maintenance", "[0:0] sediment_contamination_level", "[0:0] environmental_disposal_threshold", "[0:0] contaminated_material_isolation_procedure_initiated"], "clock": "clk_dredging", "attempts_left": 10, "sva_result": "@(negedge clk_dredging) disable iff (environmental_dredging_permit_suspended)     harbor_depth_maintenance == 1'b1 |->      ($past(sediment_contamination_level) > environmental_disposal_threshold) &&     ($past(contaminated_material_isolation_procedure_initiated, 9) == 1'b0)", "sva_name": "p_harbor_depth_maintenance_sediment_contamination_check", "id": "3603", "full_property": "property p_Harbor_Depth_Maintenance_Check;\n@(negedge clk_dredging) disable iff (environmental_dredging_permit_suspended)     harbor_depth_maintenance == 1'b1 |->      ($past(sediment_contamination_level) > environmental_disposal_threshold) &&     ($past(contaminated_material_isolation_procedure_initiated, 9) == 1'b0)\nendproperty\nassert_p_Harbor_Depth_Maintenance_Check:assert property (p_Harbor_Depth_Maintenance_Check) else $error(\"\");", "task_id": "1_7183", "predict_sva": "@(negedge clk_dredging) disable iff (environmental_dredging_permit_suspended)         (environmental_dredging_permit_suspended == 0 && harbor_depth_maintenance == 1'b1) |->          ($past(sediment_contamination_level) > environmental_disposal_threshold) &&          ($past(contaminated_material_isolation_procedure_initiated, 9) == 0)"}
{"sva": "@(posedge clk) disable iff(maritime_security_alert_level_elevated) port_facility_access_control |-> $past(unauthorized_vessel_approach_detected) && ($past(security_response_protocol_activation) != threat_assessment_completed)", "sva_description": "### Assertion description:  \n**Property Name**: p_Port_Facility_Access_Control  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (maritime_security_alert_level_elevated)`  \n**Antecedent (LHS of Implication)**: `port_facility_access_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(unauthorized_vessel_approach_detected) && ($past(security_response_protocol_activation) != threat_assessment_completed)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] port_facility_access_control", "[0:0] maritime_security_alert_level_elevated", "[0:0] unauthorized_vessel_approach_detected", "[0:0] security_response_protocol_activation", "[0:0] threat_assessment_completed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (maritime_security_alert_level_elevated)     port_facility_access_control == 1'b1 |->          $past(unauthorized_vessel_approach_detected) &&          ($past(security_response_protocol_activation) != threat_assessment_completed)", "sva_name": "p_port_facility_access_control_security_response_protocol_check", "id": "3613", "full_property": "property p_Port_Facility_Access_Control;\n@(posedge clk)     disable iff (maritime_security_alert_level_elevated)     port_facility_access_control == 1'b1 |->          $past(unauthorized_vessel_approach_detected) &&          ($past(security_response_protocol_activation) != threat_assessment_completed)\nendproperty\nassert_p_Port_Facility_Access_Control:assert property (p_Port_Facility_Access_Control) else $error(\"\");", "task_id": "1_7193", "predict_sva": "@(posedge clk) disable iff (maritime_security_alert_level_elevated)         (maritime_security_alert_level_elevated == 0 && port_facility_access_control == 1) |->          ($past(unauthorized_vessel_approach_detected) == 1 && $past(security_response_protocol_activation) != threat_assessment_completed)"}
{"sva": "@(negedge clk_mushroom_house) disable iff(controlled_atmosphere_cultivation_system_fault) mushroom_production_environmental_control |-> ($past(carbon_dioxide_concentration) != mushroom_growth_optimization_level) && ($past(humidity_control_system_response) == setpoint_deviation_excessive)", "sva_description": "### Assertion description:  \n**Property Name**: p_Mushroom_Production_Control  \n**Trigger Condition**: At every falling edge of the `clk_mushroom_house`;  \n**Disable Condition**: disable iff (`controlled_atmosphere_cultivation_system_fault`)  \n**Antecedent (LHS of Implication)**: `mushroom_production_environmental_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `($past(carbon_dioxide_concentration) != mushroom_growth_optimization_level)`  \n- **AND**  \n- `($past(humidity_control_system_response) == setpoint_deviation_excessive)`  ", "sva_signals": ["clk_mushroom_house", "controlled_atmosphere_cultivation_system_fault", "[0:0] mushroom_production_environmental_control", "[0:0] carbon_dioxide_concentration", "[0:0] mushroom_growth_optimization_level", "[0:0] humidity_control_system_response", "[0:0] setpoint_deviation_excessive"], "clock": "clk_mushroom_house", "attempts_left": 10, "sva_result": "@(negedge clk_mushroom_house) disable iff (controlled_atmosphere_cultivation_system_fault)     mushroom_production_environmental_control == 1'b1 |->     ($past(carbon_dioxide_concentration) != mushroom_growth_optimization_level) &&     ($past(humidity_control_system_response) == setpoint_deviation_excessive)", "sva_name": "p_mushroom_environmental_control_check", "id": "3646", "full_property": "property p_Mushroom_Production_Control;\n@(negedge clk_mushroom_house) disable iff (controlled_atmosphere_cultivation_system_fault)     mushroom_production_environmental_control == 1'b1 |->     ($past(carbon_dioxide_concentration) != mushroom_growth_optimization_level) &&     ($past(humidity_control_system_response) == setpoint_deviation_excessive)\nendproperty\nassert_p_Mushroom_Production_Control:assert property (p_Mushroom_Production_Control) else $error(\"\");", "task_id": "1_7226", "predict_sva": "@(negedge clk_mushroom_house) disable iff (controlled_atmosphere_cultivation_system_fault)     mushroom_production_environmental_control == 1'b1 |->      ($past(carbon_dioxide_concentration) != mushroom_growth_optimization_level) &&     ($past(humidity_control_system_response) == setpoint_deviation_excessive)"}
{"sva": "@(posedge clk) disable iff(farm_to_market_traceability_system_offline) food_safety_cold_chain_monitoring |-> $past(refrigerated_transport_temperature_log) && ($past(temperature_excursion_duration) > food_safety_tolerance_time)", "sva_description": "### Assertion description:  \n**Property Name**: p_Food_Safety_Cold_Chain_Monitoring  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (farm_to_market_traceability_system_offline)`  \n**Antecedent (LHS of Implication)**: `food_safety_cold_chain_monitoring == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(refrigerated_transport_temperature_log) && ($past(temperature_excursion_duration) > food_safety_tolerance_time)`  ", "sva_signals": ["clk", "farm_to_market_traceability_system_offline", "food_safety_cold_chain_monitoring", "refrigerated_transport_temperature_log", "temperature_excursion_duration", "food_safety_tolerance_time"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (farm_to_market_traceability_system_offline)     food_safety_cold_chain_monitoring == 1'b1 |->     $past(refrigerated_transport_temperature_log) &&      ($past(temperature_excursion_duration) > food_safety_tolerance_time)", "sva_name": "p_food_safety_cold_chain_monitoring_temperature_log_and_excursion_check", "id": "3621", "full_property": "property p_Food_Safety_Cold_Chain_Monitoring;\n@(posedge clk) disable iff (farm_to_market_traceability_system_offline)     food_safety_cold_chain_monitoring == 1'b1 |->     $past(refrigerated_transport_temperature_log) &&      ($past(temperature_excursion_duration) > food_safety_tolerance_time)\nendproperty\nassert_p_Food_Safety_Cold_Chain_Monitoring:assert property (p_Food_Safety_Cold_Chain_Monitoring) else $error(\"\");", "task_id": "1_7201", "predict_sva": "@(posedge clk) disable iff (farm_to_market_traceability_system_offline)         (farm_to_market_traceability_system_offline == 0 && food_safety_cold_chain_monitoring == 1) |->          ($past(refrigerated_transport_temperature_log) == 1 && $past(temperature_excursion_duration) > food_safety_tolerance_time)"}
{"sva": "@(posedge clk_agricultural_weather) disable iff(!climate_change_adaptation_strategy_implementation) extreme_weather_event_preparedness |-> $past(weather_pattern_anomaly_detection) && ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_Extreme_Weather_Preparedness  \n**Trigger Condition**: At every rising edge of the `clk_agricultural_weather`  \n**Disable Condition**: `disable iff (!climate_change_adaptation_strategy_implementation)`  \n**Antecedent (LHS of Implication)**: `extreme_weather_event_preparedness`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(weather_pattern_anomaly_detection) && ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)`  ", "sva_signals": ["clk_agricultural_weather", "climate_change_adaptation_strategy_implementation", "[0:0] extreme_weather_event_preparedness", "[0:0] weather_pattern_anomaly_detection", "[0:0] crop_resilience_measure_effectiveness", "[0:0] climate_risk_mitigation_adequacy"], "clock": "clk_agricultural_weather", "attempts_left": 10, "sva_result": "@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)     extreme_weather_event_preparedness |->          $past(weather_pattern_anomaly_detection) &&          ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)", "sva_name": "p_extreme_weather_event_preparedness_dependency", "id": "3663", "full_property": "property p_Extreme_Weather_Preparedness;\n@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)     extreme_weather_event_preparedness |->          $past(weather_pattern_anomaly_detection) &&          ($past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)\nendproperty\nassert_p_Extreme_Weather_Preparedness:assert property (p_Extreme_Weather_Preparedness) else $error(\"\");", "task_id": "1_7243", "predict_sva": "@(posedge clk_agricultural_weather) disable iff (!climate_change_adaptation_strategy_implementation)         (climate_change_adaptation_strategy_implementation == 1 && extreme_weather_event_preparedness == 1) |->          ($past(weather_pattern_anomaly_detection) == 1 && $past(crop_resilience_measure_effectiveness) < climate_risk_mitigation_adequacy)"}
{"sva": "@(posedge clk_textile_export) disable iff(!international_shipping_logistics_coordination) global_supply_chain_optimization |-> $past(delivery_schedule_reliability_performance) && ($past(transportation_cost_efficiency) < profit_margin_sustainability_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Global_Supply_Chain_Optimization  \n**Trigger Condition**: At every rising edge of the `clk_textile_export`  \n**Disable Condition**: `disable iff (!international_shipping_logistics_coordination)`  \n**Antecedent (LHS of Implication)**: `global_supply_chain_optimization == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(delivery_schedule_reliability_performance) && ($past(transportation_cost_efficiency) < profit_margin_sustainability_requirement)`  ", "sva_signals": ["clk_textile_export", "international_shipping_logistics_coordination", "global_supply_chain_optimization", "[0:0] delivery_schedule_reliability_performance", "[0:0] transportation_cost_efficiency", "[0:0] profit_margin_sustainability_requirement"], "clock": "clk_textile_export", "attempts_left": 10, "sva_result": "@(posedge clk_textile_export) disable iff (!international_shipping_logistics_coordination)     global_supply_chain_optimization == 1'b1 |->      $past(delivery_schedule_reliability_performance) &&      ($past(transportation_cost_efficiency) < profit_margin_sustainability_requirement)", "sva_name": "p_global_supply_chain_optimization_prev_performance_check", "id": "3683", "full_property": "property p_Global_Supply_Chain_Optimization;\n@(posedge clk_textile_export) disable iff (!international_shipping_logistics_coordination)     global_supply_chain_optimization == 1'b1 |->      $past(delivery_schedule_reliability_performance) &&      ($past(transportation_cost_efficiency) < profit_margin_sustainability_requirement)\nendproperty\nassert_p_Global_Supply_Chain_Optimization:assert property (p_Global_Supply_Chain_Optimization) else $error(\"\");", "task_id": "1_7261", "predict_sva": "@(posedge clk_textile_export) disable iff (!international_shipping_logistics_coordination)         (international_shipping_logistics_coordination == 1 && global_supply_chain_optimization == 1) |->          ($past(delivery_schedule_reliability_performance) == 1 &&           $past(transportation_cost_efficiency) < profit_margin_sustainability_requirement)"}
{"sva": "@(negedge clk_plumbing_system) disable iff(!water_supply_connection_authorized) plumbing_pressure_test_protocol |-> ($past(pipe_joint_integrity_inspection_completion) && $past(water_pressure_test_duration_adequate)) && ($past(leak_detection_sensitivity) == detection_threshold_insufficient)", "sva_description": "### Assertion description:  \n**Property Name**: plumbing_pressure_test_protocol  \n**Trigger Condition**: At every falling edge of the `clk_plumbing_system`  \n**Disable Condition**: `disable iff (!water_supply_connection_authorized)`  \n**Antecedent (LHS of Implication)**: `plumbing_pressure_test_protocol`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(pipe_joint_integrity_inspection_completion) && $past(water_pressure_test_duration_adequate)) && ($past(leak_detection_sensitivity) == detection_threshold_insufficient)`  ", "sva_signals": ["clk_plumbing_system", "water_supply_connection_authorized", "plumbing_pressure_test_protocol", "pipe_joint_integrity_inspection_completion", "water_pressure_test_duration_adequate", "leak_detection_sensitivity", "detection_threshold_insufficient"], "clock": "clk_plumbing_system", "attempts_left": 10, "sva_result": "@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)     plumbing_pressure_test_protocol |->          ($past(pipe_joint_integrity_inspection_completion) &&           $past(water_pressure_test_duration_adequate)) &&          ($past(leak_detection_sensitivity) == detection_threshold_insufficient)", "sva_name": "p_pressure_test_protocol_preconditions", "id": "3771", "full_property": "property plumbing_pressure_test_protocol;\n@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)     plumbing_pressure_test_protocol |->          ($past(pipe_joint_integrity_inspection_completion) &&           $past(water_pressure_test_duration_adequate)) &&          ($past(leak_detection_sensitivity) == detection_threshold_insufficient)\nendproperty\nassert_plumbing_pressure_test_protocol:assert property (plumbing_pressure_test_protocol) else $error(\"\");", "task_id": "1_7347", "predict_sva": "@(negedge clk_plumbing_system) disable iff (!water_supply_connection_authorized)         (water_supply_connection_authorized == 1 && plumbing_pressure_test_protocol == 1) |->          ($past(pipe_joint_integrity_inspection_completion) == 1) &&          ($past(water_pressure_test_duration_adequate) == 1) &&          ($past(leak_detection_sensitivity) == detection_threshold_insufficient)"}
{"sva": "@(posedge clk) disable iff(climate_change_tourism_adaptation_strategy_development) climate_resilient_tourism_planning |-> ($past(climate_impact_vulnerability_assessment) && $past(adaptation_measure_implementation_readiness)) && ($past(climate_resilience_tourism_infrastructure_development) == climate_change_mitigation_tourism_sector_contribution_insufficient)", "sva_description": "### Assertion description:  \n**Property Name**: p_Climate_Resilient_Tourism_Planning  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (climate_change_tourism_adaptation_strategy_development)`  \n**Antecedent (LHS of Implication)**: `climate_resilient_tourism_planning == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of:  \n  1. `$past(climate_impact_vulnerability_assessment)`  \n  2. `$past(adaptation_measure_implementation_readiness)`  \n- AND the comparison:  \n  `$past(climate_resilience_tourism_infrastructure_development) == climate_change_mitigation_tourism_sector_contribution_insufficient`  \n\n(Note: The consequent combines two conditions: a logical AND of two past values and an equality check between a past value and a current signal.)", "sva_signals": ["clk", "[0:0] climate_change_tourism_adaptation_strategy_development", "[0:0] climate_resilient_tourism_planning", "[0:0] climate_impact_vulnerability_assessment", "[0:0] adaptation_measure_implementation_readiness", "[0:0] climate_resilience_tourism_infrastructure_development", "[0:0] climate_change_mitigation_tourism_sector_contribution_insufficient"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (climate_change_tourism_adaptation_strategy_development)     climate_resilient_tourism_planning == 1'b1 |->     ($past(climate_impact_vulnerability_assessment) &       $past(adaptation_measure_implementation_readiness)) &&     ($past(climate_resilience_tourism_infrastructure_development) ==       climate_change_mitigation_tourism_sector_contribution_insufficient)", "sva_name": "p_climate_resilient_tourism_planning_dependency", "id": "3751", "full_property": "property p_Climate_Resilient_Tourism_Planning;\n@(posedge clk)     disable iff (climate_change_tourism_adaptation_strategy_development)     climate_resilient_tourism_planning == 1'b1 |->     ($past(climate_impact_vulnerability_assessment) &       $past(adaptation_measure_implementation_readiness)) &&     ($past(climate_resilience_tourism_infrastructure_development) ==       climate_change_mitigation_tourism_sector_contribution_insufficient)\nendproperty\nassert_p_Climate_Resilient_Tourism_Planning:assert property (p_Climate_Resilient_Tourism_Planning) else $error(\"\");", "task_id": "1_7327", "predict_sva": "@(posedge clk) disable iff (climate_change_tourism_adaptation_strategy_development)         (climate_resilient_tourism_planning == 1'b1 && climate_change_tourism_adaptation_strategy_development == 1'b0) |->          ($past(climate_impact_vulnerability_assessment) == 1'b1 &&           $past(climate_resilience_tourism_infrastructure_development) == climate_change_mitigation_tourism_sector_contribution_insufficient)"}
{"sva": "@(negedge clk_content_streaming) disable iff(bandwidth_optimization_algorithm_disabled) game_asset_streaming |-> ($past(asset_loading_priority_queue_management) && $past(memory_usage_optimization_strategy)) && ($past(streaming_performance_efficiency) != seamless_gameplay_experience_maintenance)", "sva_description": "### Assertion description:  \n**Property Name**: p_Game_Asset_Streaming_Check  \n**Trigger Condition**: At every falling edge of the `clk_content_streaming`  \n**Disable Condition**: `disable iff (bandwidth_optimization_algorithm_disabled)`  \n**Antecedent (LHS of Implication)**: `game_asset_streaming == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(asset_loading_priority_queue_management) && $past(memory_usage_optimization_strategy)) && ($past(streaming_performance_efficiency) != seamless_gameplay_experience_maintenance)`  ", "sva_signals": ["clk", "rst_n", "[0:0] bandwidth_optimization_algorithm_disabled", "[0:0] game_asset_streaming", "[0:0] asset_loading_priority_queue_management", "[0:0] memory_usage_optimization_strategy", "[0:0] streaming_performance_efficiency", "[0:0] seamless_gameplay_experience_maintenance", "clk_content_streaming"], "clock": "clk_content_streaming", "attempts_left": 10, "sva_result": "@(negedge clk_content_streaming) disable iff (bandwidth_optimization_algorithm_disabled)     game_asset_streaming == 1'b1 |->      ($past(asset_loading_priority_queue_management) && $past(memory_usage_optimization_strategy)) &&      ($past(streaming_performance_efficiency) != seamless_gameplay_experience_maintenance)", "sva_name": "p_game_asset_streaming_priority_queue_memory_check", "id": "3821", "full_property": "property p_Game_Asset_Streaming_Check;\n@(negedge clk_content_streaming) disable iff (bandwidth_optimization_algorithm_disabled)     game_asset_streaming == 1'b1 |->      ($past(asset_loading_priority_queue_management) && $past(memory_usage_optimization_strategy)) &&      ($past(streaming_performance_efficiency) != seamless_gameplay_experience_maintenance)\nendproperty\nassert_p_Game_Asset_Streaming_Check:assert property (p_Game_Asset_Streaming_Check) else $error(\"\");", "task_id": "1_7394", "predict_sva": "@(negedge clk_content_streaming) disable iff (bandwidth_optimization_algorithm_disabled)         (bandwidth_optimization_algorithm_disabled == 0 && game_asset_streaming == 1) |->          ($past(asset_loading_priority_queue_management) == 1 &&           $past(memory_usage_optimization_strategy) == 1 &&           $past(streaming_performance_efficiency) != seamless_gameplay_experience_maintenance)"}
{"sva": "@(posedge clk_neutron_source) disable iff(neutron_flux_monitoring_system_fault) neutron_scattering_experiment |-> ($past(neutron_beam_collimation_accuracy) && $past(sample_positioning_precision)) && ($past(scattering_pattern_resolution) < experimental_data_quality_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Neutron_Scattering_Experiment  \n**Trigger Condition**: At every rising edge of the `clk_neutron_source`  \n**Disable Condition**: `disable iff (neutron_flux_monitoring_system_fault)`  \n**Antecedent (LHS of Implication)**: `neutron_scattering_experiment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(neutron_beam_collimation_accuracy) && $past(sample_positioning_precision)) && ($past(scattering_pattern_resolution) < experimental_data_quality_requirement)`  ", "sva_signals": ["clk_neutron_source", "neutron_flux_monitoring_system_fault", "neutron_scattering_experiment", "[0:0] neutron_beam_collimation_accuracy", "[0:0] sample_positioning_precision", "[0:0] scattering_pattern_resolution", "[0:0] experimental_data_quality_requirement"], "clock": "clk_neutron_source", "attempts_left": 10, "sva_result": "@(posedge clk_neutron_source) disable iff (neutron_flux_monitoring_system_fault)     neutron_scattering_experiment |->      ($past(neutron_beam_collimation_accuracy) && $past(sample_positioning_precision)) &&      ($past(scattering_pattern_resolution) < experimental_data_quality_requirement)", "sva_name": "p_neutron_scattering_experiment_quality_check", "id": "3863", "full_property": "property p_Neutron_Scattering_Experiment;\n@(posedge clk_neutron_source) disable iff (neutron_flux_monitoring_system_fault)     neutron_scattering_experiment |->      ($past(neutron_beam_collimation_accuracy) && $past(sample_positioning_precision)) &&      ($past(scattering_pattern_resolution) < experimental_data_quality_requirement)\nendproperty\nassert_p_Neutron_Scattering_Experiment:assert property (p_Neutron_Scattering_Experiment) else $error(\"\");", "task_id": "1_7435", "predict_sva": "@(posedge clk_neutron_source) disable iff (neutron_flux_monitoring_system_fault)         (neutron_flux_monitoring_system_fault == 0 && neutron_scattering_experiment == 1) |->          ($past(neutron_beam_collimation_accuracy) == 1 &&           $past(sample_positioning_precision) == 1 &&           $past(scattering_pattern_resolution) < experimental_data_quality_requirement)"}
{"sva": "@(negedge clk_particle_accelerator) disable iff(!beam_injection_system_ready) high_energy_particle_collision |-> ($past(beam_energy_ramping_profile) && $past(magnetic_field_synchronization)) && ($past(collision_luminosity_achievement) < target_interaction_rate)", "sva_description": "### Assertion description:  \n**Property Name**: p_High_Energy_Particle_Collision  \n**Trigger Condition**: At every falling edge of the `clk_particle_accelerator`  \n**Disable Condition**: disable iff (`!beam_injection_system_ready`)  \n**Antecedent (LHS of Implication)**: `high_energy_particle_collision == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of two conditions must hold:  \n  1. The logical AND of the past values of `beam_energy_ramping_profile` and `magnetic_field_synchronization` (sampled at the previous clock edge).  \n  2. The past value of `collision_luminosity_achievement` (sampled at the previous clock edge) must be less than `target_interaction_rate`.  ", "sva_signals": ["clk_particle_accelerator", "beam_injection_system_ready", "high_energy_particle_collision", "[0:0] beam_energy_ramping_profile", "[0:0] magnetic_field_synchronization", "[0:0] collision_luminosity_achievement", "[0:0] target_interaction_rate"], "clock": "clk_particle_accelerator", "attempts_left": 10, "sva_result": "@(negedge clk_particle_accelerator) disable iff (!beam_injection_system_ready)     high_energy_particle_collision == 1'b1 |->     ($past(beam_energy_ramping_profile) && $past(magnetic_field_synchronization)) &&     ($past(collision_luminosity_achievement) < target_interaction_rate)", "sva_name": "p_high_energy_collision_requires_prior_conditions", "id": "3883", "full_property": "property p_High_Energy_Particle_Collision;\n@(negedge clk_particle_accelerator) disable iff (!beam_injection_system_ready)     high_energy_particle_collision == 1'b1 |->     ($past(beam_energy_ramping_profile) && $past(magnetic_field_synchronization)) &&     ($past(collision_luminosity_achievement) < target_interaction_rate)\nendproperty\nassert_p_High_Energy_Particle_Collision:assert property (p_High_Energy_Particle_Collision) else $error(\"\");", "task_id": "1_7455", "predict_sva": "@(negedge clk_particle_accelerator) disable iff (!beam_injection_system_ready)         (beam_injection_system_ready == 1 && high_energy_particle_collision == 1) |->          ($past(beam_energy_ramping_profile) == 1 && $past(magnetic_field_synchronization) == 1) &&          ($past(collision_luminosity_achievement) < target_interaction_rate)"}
{"sva": "@(negedge clk_nuclear_magnetic_resonance) disable iff(!magnetic_field_homogeneity_shimming_optimized) high_field_nmr_spectroscopy |-> ($past(magnetic_field_uniformity_measurement) && $past(rf_pulse_sequence_calibration_accuracy)) && ($past(spectral_resolution_enhancement) == molecular_structure_analysis_precision_inadequacy)", "sva_description": "### Assertion description:  \n**Property Name**: p_HighFieldNMRSpectroscopy  \n**Trigger Condition**: At every falling edge of the `clk_nuclear_magnetic_resonance`  \n**Disable Condition**: `disable iff (!magnetic_field_homogeneity_shimming_optimized)`  \n**Antecedent (LHS of Implication)**: `high_field_nmr_spectroscopy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`($past(magnetic_field_uniformity_measurement) && $past(rf_pulse_sequence_calibration_accuracy)) && ($past(spectral_resolution_enhancement) == molecular_structure_analysis_precision_inadequacy)`  ", "sva_signals": ["clk_nuclear_magnetic_resonance", "magnetic_field_homogeneity_shimming_optimized", "[0:0] high_field_nmr_spectroscopy", "[0:0] magnetic_field_uniformity_measurement", "[0:0] rf_pulse_sequence_calibration_accuracy", "[0:0] spectral_resolution_enhancement", "[0:0] molecular_structure_analysis_precision_inadequacy"], "clock": "clk_nuclear_magnetic_resonance", "attempts_left": 10, "sva_result": "@(negedge clk_nuclear_magnetic_resonance) disable iff (!magnetic_field_homogeneity_shimming_optimized)     high_field_nmr_spectroscopy |->      ($past(magnetic_field_uniformity_measurement) && $past(rf_pulse_sequence_calibration_accuracy)) &&      ($past(spectral_resolution_enhancement) == molecular_structure_analysis_precision_inadequacy)", "sva_name": "p_high_field_nmr_spectroscopy_check", "id": "3892", "full_property": "property p_HighFieldNMRSpectroscopy;\n@(negedge clk_nuclear_magnetic_resonance) disable iff (!magnetic_field_homogeneity_shimming_optimized)     high_field_nmr_spectroscopy |->      ($past(magnetic_field_uniformity_measurement) && $past(rf_pulse_sequence_calibration_accuracy)) &&      ($past(spectral_resolution_enhancement) == molecular_structure_analysis_precision_inadequacy)\nendproperty\nassert_p_HighFieldNMRSpectroscopy:assert property (p_HighFieldNMRSpectroscopy) else $error(\"\");", "task_id": "1_7464", "predict_sva": "@(negedge clk_nuclear_magnetic_resonance) disable iff (!magnetic_field_homogeneity_shimming_optimized)     high_field_nmr_spectroscopy |->          ($past(magnetic_field_uniformity_measurement) &&           $past(rf_pulse_sequence_calibration_accuracy)) &&         ($past(spectral_resolution_enhancement) == molecular_structure_analysis_precision_inadequacy)"}
{"sva": "@(posedge clk_superconducting_magnet) disable iff(quench_protection_system_armed) high_field_magnet_operation |-> ($past(superconducting_wire_current_density) > critical_current_threshold) && !$past(magnet_quench_detection_response, 2)", "sva_description": "### Assertion description:  \n**Property Name**: p_High_Field_Magnet_Operation_Safety  \n**Trigger Condition**: At every rising edge of `clk_superconducting_magnet`  \n**Disable Condition**: `disable iff (quench_protection_system_armed)`  \n**Antecedent (LHS of Implication)**: `high_field_magnet_operation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `superconducting_wire_current_density` (sampled at the previous clock cycle) must be greater than `critical_current_threshold`.  \n- The past value of `magnet_quench_detection_response` (sampled two clock cycles earlier) must be `0` (i.e., no quench detection response was active).  \n\nThe assertion ensures that during high-field magnet operation:  \n1. The superconducting wire current density did not exceed the critical threshold in the immediately preceding cycle.  \n2. No quench detection response was triggered two cycles prior.  \nIf either condition fails while `quench_protection_system_armed` is inactive, the assertion will fire.", "sva_signals": ["clk_superconducting_magnet", "quench_protection_system_armed", "high_field_magnet_operation", "[0:0] superconducting_wire_current_density", "[0:0] critical_current_threshold", "[0:0] magnet_quench_detection_response"], "clock": "clk_superconducting_magnet", "attempts_left": 10, "sva_result": "@(posedge clk_superconducting_magnet) disable iff (quench_protection_system_armed)     high_field_magnet_operation == 1'b1 |->     ($past(superconducting_wire_current_density, 1) > critical_current_threshold) &&     ($past(magnet_quench_detection_response, 2) == 1'b0)", "sva_name": "p_high_field_magnet_operation_quench_protection_check", "id": "3893", "full_property": "property p_High_Field_Magnet_Operation_Safety;\n@(posedge clk_superconducting_magnet) disable iff (quench_protection_system_armed)     high_field_magnet_operation == 1'b1 |->     ($past(superconducting_wire_current_density, 1) > critical_current_threshold) &&     ($past(magnet_quench_detection_response, 2) == 1'b0)\nendproperty\nassert_p_High_Field_Magnet_Operation_Safety:assert property (p_High_Field_Magnet_Operation_Safety) else $error(\"\");", "task_id": "1_7465", "predict_sva": "@(posedge clk_superconducting_magnet) disable iff (quench_protection_system_armed)         (quench_protection_system_armed == 0 && high_field_magnet_operation == 1'b1) |->          ($past(superconducting_wire_current_density, 1) > critical_current_threshold) &&          ($past(magnet_quench_detection_response, 2) == 0)"}
{"sva": "@(negedge clk_communication) disable iff(deep_space_network_antenna_maintenance) interplanetary_communication |-> ($past(signal_transmission_power_optimization) && $past(data_compression_efficiency_maximization)) && ($past(communication_link_reliability) < mission_critical_data_transmission_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_Interplanetary_Communication_Check  \n**Trigger Condition**: At every falling edge of `clk_communication`  \n**Disable Condition**: `disable iff (deep_space_network_antenna_maintenance)`  \n**Antecedent (LHS of Implication)**: `interplanetary_communication == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that the logical AND of two past conditions must hold:  \n  1. `$past(signal_transmission_power_optimization)`  \n  2. `$past(data_compression_efficiency_maximization)`  \n- Additionally, the past value of `communication_link_reliability` must be strictly less than `mission_critical_data_transmission_requirement`.  \n\n### Key Notes:  \n1. The assertion evaluates **only when** `interplanetary_communication` is active (LHS condition).  \n2. The check is **disabled** during `deep_space_network_antenna_maintenance`.  \n3. The consequent combines:  \n   - Historical states of power optimization and data compression efficiency.  \n   - A reliability threshold comparison against mission requirements.  \n4. All temporal checks (e.g., `$past`) are relative to the negedge of `clk_communication`.  \n\n---  \n(Output adheres strictly to the requested format.)", "sva_signals": ["clk_communication", "deep_space_network_antenna_maintenance", "[0:0] interplanetary_communication", "[0:0] signal_transmission_power_optimization", "[0:0] data_compression_efficiency_maximization", "[0:0] communication_link_reliability", "[0:0] mission_critical_data_transmission_requirement"], "clock": "clk_communication", "attempts_left": 10, "sva_result": "@(negedge clk_communication) disable iff (deep_space_network_antenna_maintenance)     interplanetary_communication == 1'b1 |->      ($past(signal_transmission_power_optimization) &&       $past(data_compression_efficiency_maximization)) &&     ($past(communication_link_reliability) < mission_critical_data_transmission_requirement)", "sva_name": "p_interplanetary_communication_preconditions", "id": "3969", "full_property": "property p_Interplanetary_Communication_Check;\n@(negedge clk_communication) disable iff (deep_space_network_antenna_maintenance)     interplanetary_communication == 1'b1 |->      ($past(signal_transmission_power_optimization) &&       $past(data_compression_efficiency_maximization)) &&     ($past(communication_link_reliability) < mission_critical_data_transmission_requirement)\nendproperty\nassert_p_Interplanetary_Communication_Check:assert property (p_Interplanetary_Communication_Check) else $error(\"\");", "task_id": "1_7540", "predict_sva": "@(negedge clk_communication) disable iff (deep_space_network_antenna_maintenance)         (deep_space_network_antenna_maintenance == 0 && interplanetary_communication == 1) |->          ($past(signal_transmission_power_optimization) == 1 &&           $past(data_compression_efficiency_maximization) == 1 &&           ($past(communication_link_reliability) < mission_critical_data_transmission_requirement))"}
{"id": "304_3_0007", "name": "p_int_ctrl_resp_high_or_low_3", "sva": "@(posedge clk_int)     (irq_high || irq_low) and !int_mask |-> ##1 int_ack", "ori_sva": "property p_int_ctrl_resp_high_or_low_3;\n@(posedge clk_int)     (irq_high || irq_low) and !int_mask |-> ##1 int_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Interrupt_Acknowledge  \n**Trigger Condition**: At every rising edge of `clk_int`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(irq_high || irq_low) && !int_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 int_ack`  ", "sva_signals": ["clk_int", "[0:0] irq_high", "[0:0] irq_low", "[0:0] int_mask", "[0:0] int_ack"], "clock": "clk_int", "attempts_left": 10, "sva_result": "@(posedge clk_int)         (irq_high || irq_low) && !int_mask |-> ##1 int_ack", "sva_name": "p_int_ack_after_irq", "full_property": "property p_Interrupt_Acknowledge;\n@(posedge clk_int)         (irq_high || irq_low) && !int_mask |-> ##1 int_ack\nendproperty\nassert_p_Interrupt_Acknowledge:assert property (p_Interrupt_Acknowledge) else $error(\"\");", "task_id": "1_7649", "predict_sva": "@(posedge clk_int)     (irq_high || irq_low) && !int_mask |-> ##1 int_ack"}
{"sva": "@(posedge clk_cardiac_pacemaker) disable iff(!heart_rhythm_sensing_reliability_verified) cardiac_rhythm_management |-> $past(intrinsic_heart_rate_detection_sensitivity) && ($past(pacing_threshold_adjustment_accuracy) < cardiac_stimulation_safety_margin)", "sva_description": "### Assertion description:  \n**Property Name**: p_cardiac_rhythm_management  \n**Trigger Condition**: At every rising edge of the `clk_cardiac_pacemaker`  \n**Disable Condition**: `disable iff (!heart_rhythm_sensing_reliability_verified)`  \n**Antecedent (LHS of Implication)**: `cardiac_rhythm_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(intrinsic_heart_rate_detection_sensitivity) && ($past(pacing_threshold_adjustment_accuracy) < cardiac_stimulation_safety_margin)`  \n\n", "sva_signals": ["clk_cardiac_pacemaker", "heart_rhythm_sensing_reliability_verified", "[0:0] cardiac_rhythm_management", "[0:0] intrinsic_heart_rate_detection_sensitivity", "[0:0] pacing_threshold_adjustment_accuracy", "[0:0] cardiac_stimulation_safety_margin"], "clock": "clk_cardiac_pacemaker", "attempts_left": 10, "sva_result": "@(posedge clk_cardiac_pacemaker) disable iff (!heart_rhythm_sensing_reliability_verified)     cardiac_rhythm_management |->      $past(intrinsic_heart_rate_detection_sensitivity) &&      ($past(pacing_threshold_adjustment_accuracy) < cardiac_stimulation_safety_margin)", "sva_name": "p_cardiac_rhythm_management_safety_margin_check", "id": "3992", "full_property": "property p_cardiac_rhythm_management;\n@(posedge clk_cardiac_pacemaker) disable iff (!heart_rhythm_sensing_reliability_verified)     cardiac_rhythm_management |->      $past(intrinsic_heart_rate_detection_sensitivity) &&      ($past(pacing_threshold_adjustment_accuracy) < cardiac_stimulation_safety_margin)\nendproperty\nassert_p_cardiac_rhythm_management:assert property (p_cardiac_rhythm_management) else $error(\"\");", "task_id": "1_7562", "predict_sva": "@(posedge clk_cardiac_pacemaker) disable iff (!heart_rhythm_sensing_reliability_verified)         (heart_rhythm_sensing_reliability_verified == 1 && cardiac_rhythm_management == 1) |->          ($past(intrinsic_heart_rate_detection_sensitivity) == 1 &&           $past(pacing_threshold_adjustment_accuracy) < cardiac_stimulation_safety_margin)"}
{"sva": "@(posedge clk_wearable_health) disable iff(sensor_data_quality_degradation_detected) continuous_health_monitoring |-> $past(physiological_parameter_measurement_accuracy) && ($past(health_trend_analysis_predictive_capability) < preventive_healthcare_intervention_timing_optimization)", "sva_description": "### Assertion description:  \n**Property Name**: p_Continuous_Health_Monitoring_Quality  \n**Trigger Condition**: At every rising edge of the `clk_wearable_health`  \n**Disable Condition**: `disable iff (sensor_data_quality_degradation_detected)`  \n**Antecedent (LHS of Implication)**: `continuous_health_monitoring == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(physiological_parameter_measurement_accuracy) && ($past(health_trend_analysis_predictive_capability) < preventive_healthcare_intervention_timing_optimization)`  ", "sva_signals": ["clk_wearable_health", "[0:0] sensor_data_quality_degradation_detected", "[0:0] continuous_health_monitoring", "[0:0] physiological_parameter_measurement_accuracy", "[0:0] health_trend_analysis_predictive_capability", "[0:0] preventive_healthcare_intervention_timing_optimization"], "clock": "clk_wearable_health", "attempts_left": 10, "sva_result": "@(posedge clk_wearable_health) disable iff (sensor_data_quality_degradation_detected)     continuous_health_monitoring == 1'b1 |->      $past(physiological_parameter_measurement_accuracy) &&      ($past(health_trend_analysis_predictive_capability) < preventive_healthcare_intervention_timing_optimization)", "sva_name": "p_Continuous_Health_Monitoring_Check", "id": "4051", "full_property": "property p_Continuous_Health_Monitoring_Quality;\n@(posedge clk_wearable_health) disable iff (sensor_data_quality_degradation_detected)     continuous_health_monitoring == 1'b1 |->      $past(physiological_parameter_measurement_accuracy) &&      ($past(health_trend_analysis_predictive_capability) < preventive_healthcare_intervention_timing_optimization)\nendproperty\nassert_p_Continuous_Health_Monitoring_Quality:assert property (p_Continuous_Health_Monitoring_Quality) else $error(\"\");", "task_id": "1_7619", "predict_sva": "@(posedge clk_wearable_health) disable iff (sensor_data_quality_degradation_detected)     continuous_health_monitoring == 1'b1 |->      ($past(physiological_parameter_measurement_accuracy) &&       ($past(health_trend_analysis_predictive_capability) < preventive_healthcare_intervention_timing_optimization))"}
{"id": "310_7_0093", "name": "async_rst_sync_release_p7", "sva": "@(posedge clk_sys)     async_rst_n == 0 |-> $stable(sync_rst_n)", "ori_sva": "property async_rst_sync_release_p7;\n@(posedge clk_sys)     async_rst_n == 0 |-> $stable(sync_rst_n);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AsyncRst_StableSyncRst  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `async_rst_n == 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(sync_rst_n)`  ", "sva_signals": ["clk_sys", "async_rst_n", "sync_rst_n"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     async_rst_n == 0 |-> $stable(sync_rst_n)", "sva_name": "p_sync_rst_n_stable_during_async_rst_n_low", "full_property": "property p_AsyncRst_StableSyncRst;\n@(posedge clk_sys)     async_rst_n == 0 |-> $stable(sync_rst_n)\nendproperty\nassert_p_AsyncRst_StableSyncRst:assert property (p_AsyncRst_StableSyncRst) else $error(\"\");", "task_id": "1_7683", "predict_sva": "@(posedge clk_sys)         async_rst_n == 0 |-> $stable(sync_rst_n)"}
{"sva": "@(negedge clk_time_dilation_compensation) disable iff(relativistic_effects_calculation_uncertainty_excessive) near_light_speed_travel |-> ($past(relativistic_propulsion_system_performance_validation) && $past(time_synchronization_protocol_effectiveness)) && ($past(interstellar_travel_time_optimization) != relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation)", "sva_description": "### Assertion description:  \n**Property Name**: p_Near_Light_Speed_Travel_Validation  \n**Trigger Condition**: At every falling edge of the `clk_time_dilation_compensation`  \n**Disable Condition**: disable iff (`relativistic_effects_calculation_uncertainty_excessive`)  \n**Antecedent (LHS of Implication)**: `near_light_speed_travel == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that the logical AND of the following two conditions holds true:  \n  1. The past values of `relativistic_propulsion_system_performance_validation` and `time_synchronization_protocol_effectiveness` are both true (`$past(relativistic_propulsion_system_performance_validation) && $past(time_synchronization_protocol_effectiveness)`).  \n  2. The past value of `interstellar_travel_time_optimization` does not equal the current value of `relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation` (`$past(interstellar_travel_time_optimization) != relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation`).  \n\n**Note**: The assertion is disabled if `relativistic_effects_calculation_uncertainty_excessive` is active (high). The check is triggered on the negedge of the clock signal `clk_time_dilation_compensation`.", "sva_signals": ["clk", "relativistic_effects_calculation_uncertainty_excessive", "near_light_speed_travel", "relativistic_propulsion_system_performance_validation", "time_synchronization_protocol_effectiveness", "interstellar_travel_time_optimization", "relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation", "clk_time_dilation_compensation"], "clock": "clk_time_dilation_compensation", "attempts_left": 10, "sva_result": "@(negedge clk_time_dilation_compensation) disable iff (relativistic_effects_calculation_uncertainty_excessive)     near_light_speed_travel == 1'b1 |->     ($past(relativistic_propulsion_system_performance_validation) &&       $past(time_synchronization_protocol_effectiveness)) &&     ($past(interstellar_travel_time_optimization) != relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation)", "sva_name": "p_near_light_speed_travel_propulsion_and_time_sync_check", "id": "3995", "full_property": "property p_Near_Light_Speed_Travel_Validation;\n@(negedge clk_time_dilation_compensation) disable iff (relativistic_effects_calculation_uncertainty_excessive)     near_light_speed_travel == 1'b1 |->     ($past(relativistic_propulsion_system_performance_validation) &&       $past(time_synchronization_protocol_effectiveness)) &&     ($past(interstellar_travel_time_optimization) != relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation)\nendproperty\nassert_p_Near_Light_Speed_Travel_Validation:assert property (p_Near_Light_Speed_Travel_Validation) else $error(\"\");", "task_id": "1_7565", "predict_sva": "@(negedge clk_time_dilation_compensation) disable iff (relativistic_effects_calculation_uncertainty_excessive)         (relativistic_effects_calculation_uncertainty_excessive == 0 && near_light_speed_travel == 1) |->          ($past(relativistic_propulsion_system_performance_validation) == 1 &&           $past(time_synchronization_protocol_effectiveness) == 1 &&           $past(interstellar_travel_time_optimization) != relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation)"}
{"id": "327_3_0207", "name": "p_int_mask_combined", "sva": "@(posedge clk_int)     int_pending && (global_en || local_en) |-> int_effective", "ori_sva": "property p_int_mask_combined;\n@(posedge clk_int)     int_pending && (global_en || local_en) |-> int_effective;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_int_effective  \n**Trigger Condition**: At every rising edge of the `clk_int`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `int_pending && (global_en || local_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `int_effective`", "sva_signals": ["clk_int", "[0:0] int_pending", "[0:0] global_en", "[0:0] local_en", "[0:0] int_effective"], "clock": "clk_int", "attempts_left": 10, "sva_result": "@(posedge clk_int)         (int_pending && (global_en || local_en)) |-> int_effective", "sva_name": "p_int_effective_on_pending_and_enable", "full_property": "property p_int_effective;\n@(posedge clk_int)         (int_pending && (global_en || local_en)) |-> int_effective\nendproperty\nassert_p_int_effective:assert property (p_int_effective) else $error(\"\");", "task_id": "1_7794", "predict_sva": "@(posedge clk_int)         (int_pending == 1 && (global_en == 1 || local_en == 1)) |-> int_effective == 1"}
{"id": "335_7_0285", "name": "p_bus_contention_7", "sva": "@(posedge clk_signal)     $stable(bus_request ^ bus_grant) |-> $stable(bus_ack)", "ori_sva": "property p_bus_contention_7;\n@(posedge clk_signal)     $stable(bus_request ^ bus_grant) |-> $stable(bus_ack);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_ack_stable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(bus_request ^ bus_grant)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(bus_ack)`  ", "sva_signals": ["clk_signal", "[0:0] bus_request", "[0:0] bus_grant", "[0:0] bus_ack"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $stable(bus_request ^ bus_grant) |-> $stable(bus_ack)", "sva_name": "p_bus_ack_stable_when_request_grant_stable", "full_property": "property p_bus_ack_stable;\n@(posedge clk_signal)     $stable(bus_request ^ bus_grant) |-> $stable(bus_ack)\nendproperty\nassert_p_bus_ack_stable:assert property (p_bus_ack_stable) else $error(\"\");", "task_id": "1_7840", "predict_sva": "@(posedge clk_signal)         $stable(bus_request ^ bus_grant) |-> $stable(bus_ack)"}
{"id": "336_2_0299", "name": "boot_mode_sel_p2", "sva": "@(posedge clk_sys)     boot_sel[0] && !(direct_boot || secure_boot) |=> $fell(boot_sel[0])", "ori_sva": "property boot_mode_sel_p2;\n@(posedge clk_sys)     boot_sel[0] && !(direct_boot || secure_boot) |=> $fell(boot_sel[0]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_boot_sel_fall  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `boot_sel[0] && !(direct_boot || secure_boot)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$fell(boot_sel[0])`  ", "sva_signals": ["clk_sys", "[0:0] boot_sel", "[0:0] direct_boot", "[0:0] secure_boot"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (boot_sel[0] && !(direct_boot || secure_boot)) |=> $fell(boot_sel[0])", "sva_name": "p_boot_sel_fall_transition", "full_property": "property p_boot_sel_fall;\n@(posedge clk_sys)     (boot_sel[0] && !(direct_boot || secure_boot)) |=> $fell(boot_sel[0])\nendproperty\nassert_p_boot_sel_fall:assert property (p_boot_sel_fall) else $error(\"\");", "task_id": "1_7843", "predict_sva": "@(posedge clk_sys)         (boot_sel[0] == 1 && direct_boot == 0 && secure_boot == 0) |-> ##1 (boot_sel[0] == 0 && $past(boot_sel[0]) == 1)"}
{"id": "353_10_0421", "name": "p_cal_done_valid_xor_check", "sva": "@(posedge clk_ddr)     !(cal_done ^ cal_valid)", "ori_sva": "property p_cal_done_valid_xor_check;\n@(posedge clk_ddr)     !(cal_done ^ cal_valid)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cal_done_valid  \n**Trigger Condition**: At every rising edge of the `clk_ddr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (Direct assertion, not an implication)  \n**Implication Operator**: None (Direct assertion)  \n**Consequent (RHS of Implication)**: `!(cal_done ^ cal_valid)`  \n\n(Note: This is a direct assertion without an implication operator (`|->` or `|=>`). It checks that `cal_done` and `cal_valid` are always equal at every rising edge of `clk_ddr`.)", "sva_signals": ["clk_ddr", "cal_done", "cal_valid"], "clock": "clk_ddr", "attempts_left": 10, "sva_result": "@(posedge clk_ddr) !(cal_done ^ cal_valid)", "sva_name": "p_cal_done_cal_valid_equal", "full_property": "property p_cal_done_valid;\n@(posedge clk_ddr) !(cal_done ^ cal_valid)\nendproperty\nassert_p_cal_done_valid:assert property (p_cal_done_valid) else $error(\"\");", "task_id": "1_7963", "predict_sva": "@(posedge clk_ddr)         1 |-> (cal_done == cal_valid)"}
{"id": "349_7_0397", "name": "p_multi_trigger_ack_required", "sva": "@(posedge clk)     (trigger_A && trigger_B && threshold_exceed) |-> ##1 ack_received", "ori_sva": "property p_multi_trigger_ack_required;\n@(posedge clk)     (trigger_A && trigger_B && threshold_exceed) |-> ##1 ack_received;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Ack_After_Trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `trigger_A && trigger_B && threshold_exceed`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 ack_received`  \n\n(Note: The property checks that if `trigger_A`, `trigger_B`, and `threshold_exceed` are all true at a rising clock edge, then in the next cycle (`##1`), `ack_received` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] trigger_A", "[0:0] trigger_B", "[0:0] threshold_exceed", "[0:0] ack_received"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (trigger_A && trigger_B && threshold_exceed) |-> ##1 ack_received", "sva_name": "p_ack_received_on_triggers_and_threshold", "full_property": "property p_Ack_After_Trigger;\n@(posedge clk)         (trigger_A && trigger_B && threshold_exceed) |-> ##1 ack_received\nendproperty\nassert_p_Ack_After_Trigger:assert property (p_Ack_After_Trigger) else $error(\"\");", "task_id": "1_7940", "predict_sva": "@(posedge clk)         (trigger_A == 1 && trigger_B == 1 && threshold_exceed == 1) |-> ##1 (ack_received == 1)"}
{"id": "361_1_0485", "name": "crc_match_when_valid", "sva": "@(posedge clk_crc)     data_valid |-> ((crc_result ^ golden_crc) == 0)", "ori_sva": "property crc_match_when_valid;\n@(posedge clk_crc)     data_valid |-> ((crc_result ^ golden_crc) == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crc_match  \n**Trigger Condition**: At every rising edge of the `clk_crc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `((crc_result ^ golden_crc) == 0)`  \n\n(Note: The assertion checks that whenever `data_valid` is high at a rising edge of `clk_crc`, the XOR result of `crc_result` and `golden_crc` must be zero, indicating they match.)", "sva_signals": ["clk_crc", "[0:0] data_valid", "[0:0] crc_result", "[0:0] golden_crc"], "clock": "clk_crc", "attempts_left": 10, "sva_result": "@(posedge clk_crc)     data_valid == 1'b1 |-> ((crc_result ^ golden_crc) == 0)", "sva_name": "p_crc_result_matches_golden", "full_property": "property p_crc_match;\n@(posedge clk_crc)     data_valid == 1'b1 |-> ((crc_result ^ golden_crc) == 0)\nendproperty\nassert_p_crc_match:assert property (p_crc_match) else $error(\"\");", "task_id": "1_8009", "predict_sva": "@(posedge clk_crc)         data_valid == 1'b1 |-> (crc_result ^ golden_crc) == 0"}
{"id": "362_9_0509", "name": "p_err_priority", "sva": "@(posedge clk_sys)     (parity_err && timeout_err) |-> global_err_int", "ori_sva": "property p_err_priority;\n@(posedge clk_sys)     (parity_err && timeout_err) |-> global_err_int;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Timeout_Error  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(parity_err && timeout_err)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `global_err_int`", "sva_signals": ["clk_sys", "[0:0] parity_err", "[0:0] timeout_err", "[0:0] global_err_int"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (parity_err && timeout_err) |-> global_err_int", "sva_name": "p_global_err_int_on_both_parity_and_timeout", "full_property": "property p_Parity_Timeout_Error;\n@(posedge clk_sys)     (parity_err && timeout_err) |-> global_err_int\nendproperty\nassert_p_Parity_Timeout_Error:assert property (p_Parity_Timeout_Error) else $error(\"\");", "task_id": "1_8025", "predict_sva": "@(posedge clk_sys)         (parity_err == 1 && timeout_err == 1) |-> (global_err_int == 1)"}
{"id": "368_8_0556", "name": "wakeup_response_time_p", "sva": "@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##[1:3] system_wakeup", "ori_sva": "property wakeup_response_time_p;\n@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##[1:3] system_wakeup;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Wakeup_Sequence  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(gpio_wakeup || rtc_wakeup || comm_wakeup)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] system_wakeup`  ", "sva_signals": ["clk_sys", "[0:0] gpio_wakeup", "[0:0] rtc_wakeup", "[0:0] comm_wakeup", "[0:0] system_wakeup"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##[1:3] system_wakeup", "sva_name": "p_system_wakeup_within_3_cycles_after_wakeup_source", "full_property": "property p_Wakeup_Sequence;\n@(posedge clk_sys)     (gpio_wakeup || rtc_wakeup || comm_wakeup) |-> ##[1:3] system_wakeup\nendproperty\nassert_p_Wakeup_Sequence:assert property (p_Wakeup_Sequence) else $error(\"\");", "task_id": "1_8065", "predict_sva": "@(posedge clk_sys)         (gpio_wakeup == 1 || rtc_wakeup == 1 || comm_wakeup == 1) |-> ##[1:3] system_wakeup == 1"}
{"id": "370_1_0572", "name": "parity_error_detection_1", "sva": "@(posedge clk_signal)     $rose(even_parity) |-> (odd_parity != even_parity)", "ori_sva": "property parity_error_detection_1;\n@(posedge clk_signal)     $rose(even_parity) |-> (odd_parity != even_parity);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Parity_Check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(even_parity)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(odd_parity != even_parity)`", "sva_signals": ["clk_signal", "[0:0] even_parity", "[0:0] odd_parity"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(even_parity) |-> (odd_parity != even_parity)", "sva_name": "p_even_parity_rise_odd_parity_not_equal", "full_property": "property p_Parity_Check;\n@(posedge clk_signal)     $rose(even_parity) |-> (odd_parity != even_parity)\nendproperty\nassert_p_Parity_Check:assert property (p_Parity_Check) else $error(\"\");", "task_id": "1_8073", "predict_sva": "@(posedge clk_signal)         $rose(even_parity) |-> (odd_parity != even_parity)"}
{"id": "379_4_0673", "name": "scramble_xor_with_reset_p", "sva": "@(posedge clk)     !rst_n || !scramble_en || (raw_data ^ scrambler_out == poly)", "ori_sva": "property scramble_xor_with_reset_p;\n@(posedge clk)     !rst_n || !scramble_en || (raw_data ^ scrambler_out == poly);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Scramble_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple assertion without implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `!rst_n || !scramble_en || (raw_data ^ scrambler_out == poly)`  ", "sva_signals": ["clk", "rst_n", "scramble_en", "[0:0] raw_data", "[0:0] scrambler_out", "[0:0] poly"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !rst_n || !scramble_en || (raw_data ^ scrambler_out == poly)", "sva_name": "p_xor_equals_poly_when_scrambling", "full_property": "property p_Scramble_Check;\n@(posedge clk)         !rst_n || !scramble_en || (raw_data ^ scrambler_out == poly)\nendproperty\nassert_p_Scramble_Check:assert property (p_Scramble_Check) else $error(\"\");", "task_id": "1_8127", "predict_sva": "@(posedge clk)         (rst_n == 1 && scramble_en == 1) |-> (raw_data ^ scrambler_out) == poly"}
{"id": "379_6_0662", "name": "scramble_xor_consecutive_p", "sva": "@(posedge clk)     scramble_en |-> (raw_data ^ scrambler_out == poly) and                     (##1 scramble_en |-> (raw_data ^ scrambler_out == poly))", "ori_sva": "property scramble_xor_consecutive_p;\n@(posedge clk)     scramble_en |-> (raw_data ^ scrambler_out == poly) and                     (##1 scramble_en |-> (raw_data ^ scrambler_out == poly));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Scramble_Data_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `scramble_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n1. Immediate check: `(raw_data ^ scrambler_out == poly)`  \n2. Next-cycle check (recursive): `(##1 scramble_en |-> (raw_data ^ scrambler_out == poly))`  ", "sva_signals": ["clk", "rst_n", "[0:0] scramble_en", "[0:0] raw_data", "[0:0] scrambler_out", "[0:0] poly"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     scramble_en == 1'b1 |->          ((raw_data ^ scrambler_out == poly) and         (##1 scramble_en |-> (raw_data ^ scrambler_out == poly)))", "sva_name": "p_scramble_xor_equals_poly", "full_property": "property p_Scramble_Data_Check;\n@(posedge clk)     scramble_en == 1'b1 |->          ((raw_data ^ scrambler_out == poly) and         (##1 scramble_en |-> (raw_data ^ scrambler_out == poly)))\nendproperty\nassert_p_Scramble_Data_Check:assert property (p_Scramble_Data_Check) else $error(\"\");", "task_id": "1_8128", "predict_sva": "@(posedge clk)         scramble_en == 1'b1 |-> (raw_data ^ scrambler_out) == poly"}
{"id": "380_3_0688", "name": "p_wdt_timeout_or_feed_3", "sva": "@(posedge clk_signal)     !wdt_expire |=> (wdt_timeout || $past(!wdt_expire))", "ori_sva": "property p_wdt_timeout_or_feed_3;\n@(posedge clk_signal)     !wdt_expire |=> (wdt_timeout || $past(!wdt_expire));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_WDT_Timeout_After_No_Expire  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!wdt_expire`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(wdt_timeout || $past(!wdt_expire))`  ", "sva_signals": ["clk_signal", "[0:0] wdt_expire", "[0:0] wdt_timeout"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     !wdt_expire |=> (wdt_timeout || $past(!wdt_expire))", "sva_name": "p_wdt_expire_timeout_check", "full_property": "property p_WDT_Timeout_After_No_Expire;\n@(posedge clk_signal)     !wdt_expire |=> (wdt_timeout || $past(!wdt_expire))\nendproperty\nassert_p_WDT_Timeout_After_No_Expire:assert property (p_WDT_Timeout_After_No_Expire) else $error(\"\");", "task_id": "1_8131", "predict_sva": "@(posedge clk_signal)     !wdt_expire |-> ##1 (wdt_timeout || $past(!wdt_expire))"}
{"id": "384_1_0691", "name": "cfg_lock_no_write_p1", "sva": "@(posedge clk_signal)     $rose(cfg_lock) |-> !reg_write", "ori_sva": "property cfg_lock_no_write_p1;\n@(posedge clk_signal)     $rose(cfg_lock) |-> !reg_write;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_CfgLock_RegWrite  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cfg_lock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write`", "sva_signals": ["clk_signal", "[0:0] cfg_lock", "[0:0] reg_write"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(cfg_lock) |-> !reg_write", "sva_name": "p_cfg_lock_reg_write_deasserted", "full_property": "property p_CfgLock_RegWrite;\n@(posedge clk_signal)         $rose(cfg_lock) |-> !reg_write\nendproperty\nassert_p_CfgLock_RegWrite:assert property (p_CfgLock_RegWrite) else $error(\"\");", "task_id": "1_8158", "predict_sva": "@(posedge clk_signal)         $rose(cfg_lock) |-> reg_write == 0"}
{"id": "385_7_0712", "name": "bus_contention_check_7", "sva": "@(posedge sys_clk)     (bus_request ^ bus_grant) && !$stable(bus_grant) |-> bus_ack", "ori_sva": "property bus_contention_check_7;\n@(posedge sys_clk)     (bus_request ^ bus_grant) && !$stable(bus_grant) |-> bus_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_ack_after_request_grant_change  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(bus_request ^ bus_grant) && !$stable(bus_grant)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bus_ack`  ", "sva_signals": ["sys_clk", "[0:0] bus_request", "[0:0] bus_grant", "[0:0] bus_ack"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)         ((bus_request ^ bus_grant) && !$stable(bus_grant)) |-> bus_ack", "sva_name": "p_bus_ack_on_bus_request_grant_change", "full_property": "property p_bus_ack_after_request_grant_change;\n@(posedge sys_clk)         ((bus_request ^ bus_grant) && !$stable(bus_grant)) |-> bus_ack\nendproperty\nassert_p_bus_ack_after_request_grant_change:assert property (p_bus_ack_after_request_grant_change) else $error(\"\");", "task_id": "1_8171", "predict_sva": "@(posedge sys_clk)         (bus_request ^ bus_grant) && !$stable(bus_grant) |-> bus_ack == 1"}
{"id": "385_8_0717", "name": "bus_contention_check_8", "sva": "@(negedge bus_clk)     $past(bus_request ^ bus_grant, 1) |-> bus_ack", "ori_sva": "property bus_contention_check_8;\n@(negedge bus_clk)     $past(bus_request ^ bus_grant, 1) |-> bus_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_ack_after_xor  \n**Trigger Condition**: At every falling edge of the `bus_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(bus_request ^ bus_grant, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bus_ack`", "sva_signals": ["bus_clk", "bus_request", "[0:0] bus_grant", "[0:0] bus_ack"], "clock": "bus_clk", "attempts_left": 10, "sva_result": "@(negedge bus_clk)     $past(bus_request ^ bus_grant, 1) |-> bus_ack", "sva_name": "p_bus_ack_on_xor_request_grant", "full_property": "property p_bus_ack_after_xor;\n@(negedge bus_clk)     $past(bus_request ^ bus_grant, 1) |-> bus_ack\nendproperty\nassert_p_bus_ack_after_xor:assert property (p_bus_ack_after_xor) else $error(\"\");", "task_id": "1_8172", "predict_sva": "@(negedge bus_clk)         $past(bus_request ^ bus_grant) |-> bus_ack == 1"}
{"id": "393_4_0764", "name": "secure_access_p4", "sva": "@(posedge clk_main)     $rose(secure_region) |-> !untrusted_access", "ori_sva": "property secure_access_p4;\n@(posedge clk_main)     $rose(secure_region) |-> !untrusted_access;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Secure_Region_Access  \n**Trigger Condition**: At every rising edge of the `clk_main`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(secure_region)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!untrusted_access`  \n\nThe assertion checks that whenever the `secure_region` signal transitions from low to high (i.e., at its rising edge), there should be no `untrusted_access` occurring at the same time. This ensures that untrusted access is prohibited when entering a secure region.", "sva_signals": ["clk_main", "secure_region", "untrusted_access"], "clock": "clk_main", "attempts_left": 10, "sva_result": "@(posedge clk_main)         $rose(secure_region) |-> !untrusted_access", "sva_name": "p_no_untrusted_access_on_secure_region_rise", "full_property": "property p_Secure_Region_Access;\n@(posedge clk_main)         $rose(secure_region) |-> !untrusted_access\nendproperty\nassert_p_Secure_Region_Access:assert property (p_Secure_Region_Access) else $error(\"\");", "task_id": "1_8218", "predict_sva": "@(posedge clk_main)         $rose(secure_region) |-> untrusted_access == 0"}
{"id": "394_1_0762", "name": "core_results_consistent_1", "sva": "@(posedge clk_sys)     (core_1_result ^ core_2_result) == 0", "ori_sva": "property core_results_consistent_1;\n@(posedge clk_sys)     (core_1_result ^ core_2_result) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_core_results_match  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (Direct assertion)  \n**Implication Operator**: None (Direct assertion)  \n**Consequent (RHS of Implication)**: `(core_1_result ^ core_2_result) == 0` (The XOR of `core_1_result` and `core_2_result` must equal 0, meaning the results must match)  ", "sva_signals": ["clk_sys", "[0:0] core_1_result", "[0:0] core_2_result"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (core_1_result ^ core_2_result) == 0", "sva_name": "p_core_results_match", "full_property": "property p_core_results_match;\n@(posedge clk_sys)     (core_1_result ^ core_2_result) == 0\nendproperty\nassert_p_core_results_match:assert property (p_core_results_match) else $error(\"\");", "task_id": "1_8223", "predict_sva": "@(posedge clk_sys)         1 |-> (core_1_result == core_2_result)"}
{"id": "394_6_0784", "name": "core_results_consistent_6", "sva": "@(posedge clk_sys)     $changed(core_1_result) |-> !$changed(core_2_result)", "ori_sva": "property core_results_consistent_6;\n@(posedge clk_sys)     $changed(core_1_result) |-> !$changed(core_2_result);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_No_Change_Core2_When_Core1_Changes  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(core_1_result)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$changed(core_2_result)`  ", "sva_signals": ["clk_sys", "[0:0] core_1_result", "[0:0] core_2_result"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $changed(core_1_result) |-> !$changed(core_2_result)", "sva_name": "p_core_1_result_change_core_2_stable", "full_property": "property p_No_Change_Core2_When_Core1_Changes;\n@(posedge clk_sys)         $changed(core_1_result) |-> !$changed(core_2_result)\nendproperty\nassert_p_No_Change_Core2_When_Core1_Changes:assert property (p_No_Change_Core2_When_Core1_Changes) else $error(\"\");", "task_id": "1_8226", "predict_sva": "@(posedge clk_sys)         $changed(core_1_result) |-> !$changed(core_2_result)"}
{"id": "399_6_0841", "name": "p_multi_trigger_response", "sva": "@(posedge clk_signal)     (trigger_A && trigger_B && threshold_exceed) |-> ##2 response_signal", "ori_sva": "property p_multi_trigger_response;\n@(posedge clk_signal)     (trigger_A && trigger_B && threshold_exceed) |-> ##2 response_signal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_trigger_response  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `trigger_A && trigger_B && threshold_exceed`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 response_signal`  ", "sva_signals": ["clk", "rst_n", "[0:0] trigger_A", "[0:0] trigger_B", "[0:0] threshold_exceed", "[0:0] response_signal", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (trigger_A && trigger_B && threshold_exceed) |-> ##2 response_signal", "sva_name": "p_Response_Signal_After_Trigger", "full_property": "property p_trigger_response;\n@(posedge clk_signal)         (trigger_A && trigger_B && threshold_exceed) |-> ##2 response_signal\nendproperty\nassert_p_trigger_response:assert property (p_trigger_response) else $error(\"\");", "task_id": "1_8259", "predict_sva": "@(posedge clk_signal)     (trigger_A && trigger_B && threshold_exceed) |=> ##2 response_signal"}
{"id": "401_3_0848", "name": "mode_sel_debug_mode", "sva": "@(posedge clk_signal)     (mode_sel == 2'b10) |-> (debug_mode && !normal_mode && !test_mode)", "ori_sva": "property mode_sel_debug_mode;\n@(posedge clk_signal)     (mode_sel == 2'b10) |-> (debug_mode && !normal_mode && !test_mode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Mode_Selection  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mode_sel == 2'b10`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `debug_mode && !normal_mode && !test_mode`", "sva_signals": ["clk_signal", "[1:0] mode_sel", "[0:0] debug_mode", "[0:0] normal_mode", "[0:0] test_mode"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         mode_sel == 2'b10 |-> (debug_mode && !normal_mode && !test_mode)", "sva_name": "p_debug_mode_assertion_on_mode_sel_10", "full_property": "property p_Mode_Selection;\n@(posedge clk_signal)         mode_sel == 2'b10 |-> (debug_mode && !normal_mode && !test_mode)\nendproperty\nassert_p_Mode_Selection:assert property (p_Mode_Selection) else $error(\"\");", "task_id": "1_8273", "predict_sva": "@(posedge clk_signal)         mode_sel == 2'b10 |-> debug_mode == 1 && normal_mode == 0 && test_mode == 0"}
{"id": "428_8_1047", "name": "p_no_early_termination", "sva": "@(posedge clk)     bus_transfer_active && !bus_transfer_done |-> transfer_count[5:0] != 6'b0", "ori_sva": "property p_no_early_termination;\n@(posedge clk)     bus_transfer_active && !bus_transfer_done |-> transfer_count[5:0] != 6'b0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Transfer_Count_Non_Zero  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bus_transfer_active && !bus_transfer_done`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `transfer_count[5:0] != 6'b0`  \n\nThe assertion checks that whenever a bus transfer is active (`bus_transfer_active == 1`) and not yet completed (`bus_transfer_done == 0`), the lower 6 bits of `transfer_count` must not be zero. This ensures the transfer counter is non-zero during an active transfer.", "sva_signals": ["clk", "rst_n", "[0:0] bus_transfer_active", "[0:0] bus_transfer_done", "[5:0] transfer_count"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (bus_transfer_active && !bus_transfer_done) |-> (transfer_count[5:0] != 6'b0)", "sva_name": "p_transfer_count_nonzero_during_active", "full_property": "property p_Transfer_Count_Non_Zero;\n@(posedge clk)         (bus_transfer_active && !bus_transfer_done) |-> (transfer_count[5:0] != 6'b0)\nendproperty\nassert_p_Transfer_Count_Non_Zero:assert property (p_Transfer_Count_Non_Zero) else $error(\"\");", "task_id": "1_8295", "predict_sva": "@(posedge clk)         (bus_transfer_active == 1 && bus_transfer_done == 0) |-> (transfer_count[5:0] != 6'b0)"}
{"id": "436_5_1106", "name": "p_aes_rounds_stable", "sva": "@(posedge clk_core)     !aes_round_en_i |=> (aes_round_cnt_o == $past(aes_round_cnt_o))", "ori_sva": "property p_aes_rounds_stable;\n@(posedge clk_core)     !aes_round_en_i |=> (aes_round_cnt_o == $past(aes_round_cnt_o));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AesRoundCntStable  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!aes_round_en_i`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `aes_round_cnt_o == $past(aes_round_cnt_o)`  ", "sva_signals": ["clk_core", "aes_round_en_i", "[0:0] aes_round_cnt_o"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     !aes_round_en_i |=> aes_round_cnt_o == $past(aes_round_cnt_o)", "sva_name": "p_aes_round_cnt_stable_when_idle", "full_property": "property p_AesRoundCntStable;\n@(posedge clk_core)     !aes_round_en_i |=> aes_round_cnt_o == $past(aes_round_cnt_o)\nendproperty\nassert_p_AesRoundCntStable:assert property (p_AesRoundCntStable) else $error(\"\");", "task_id": "1_8301", "predict_sva": "@(posedge clk_core)         aes_round_en_i == 0 |-> ##1 aes_round_cnt_o == $past(aes_round_cnt_o)"}
{"id": "479_2_1473", "name": "p_sequence_stable_to_decoder_lock", "sva": "@(posedge clk_signal)     $stable(pn_sequence) |-> ##[100:500] $rose(decoder_lock)", "ori_sva": "property p_sequence_stable_to_decoder_lock;\n@(posedge clk_signal)     $stable(pn_sequence) |-> ##[100:500] $rose(decoder_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_PN_Sequence_To_Decoder_Lock  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(pn_sequence)` (the `pn_sequence` signal remains unchanged from the previous clock cycle)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:500] $rose(decoder_lock)` (within 100 to 500 clock cycles after the antecedent holds, the `decoder_lock` signal must transition from low to high)", "sva_signals": ["clk_signal", "[0:0] pn_sequence", "[0:0] decoder_lock"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $stable(pn_sequence) |-> ##[100:500] $rose(decoder_lock)", "sva_name": "p_decoder_lock_rise_after_pn_sequence_stability", "full_property": "property p_Stable_PN_Sequence_To_Decoder_Lock;\n@(posedge clk_signal)     $stable(pn_sequence) |-> ##[100:500] $rose(decoder_lock)\nendproperty\nassert_p_Stable_PN_Sequence_To_Decoder_Lock:assert property (p_Stable_PN_Sequence_To_Decoder_Lock) else $error(\"\");", "task_id": "1_8450", "predict_sva": "@(posedge clk_signal)         $stable(pn_sequence) |-> ##[100:500] $rose(decoder_lock)"}
{"id": "483_5_1494", "name": "p_avb_no_buffer_overflow_during_sequence", "sva": "@(posedge clk_sys)     $fell(stream_reserve) |->      ##1 !buffer_overflow throughout      (##[1:5] $stable(qos_class) ##[100:200] $rose(timesync_ready) ##1 $fell(stream_active))", "ori_sva": "property p_avb_no_buffer_overflow_during_sequence;\n@(posedge clk_sys)     $fell(stream_reserve) |->      ##1 !buffer_overflow throughout      (##[1:5] $stable(qos_class) ##[100:200] $rose(timesync_ready) ##1 $fell(stream_active));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stream_reserve_fell_sequence  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(stream_reserve)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`##1 !buffer_overflow throughout (##[1:5] $stable(qos_class) ##[100:200] $rose(timesync_ready) ##1 $fell(stream_active))`  \n\n**Detailed Consequent Breakdown**:  \n1. **Initial Delay**: After the antecedent is true (`$fell(stream_reserve)`), the consequent starts with a 1-cycle delay (`##1`).  \n2. **Buffer Overflow Check**: From the next cycle onward, `!buffer_overflow` must hold continuously (`throughout`) for the entire sequence.  \n3. **Sequence Requirements**:  \n   - **Stable QoS Class**: Within 1 to 5 cycles after the initial delay, `qos_class` must stabilize (`$stable(qos_class)`).  \n   - **Timesync Ready Rise**: Between 100 to 200 cycles after `qos_class` stabilizes, `timesync_ready` must rise (`$rose(timesync_ready)`).  \n   - **Stream Active Fall**: Exactly 1 cycle after `timesync_ready` rises, `stream_active` must fall (`$fell(stream_active)`).  \n\n**Note**: The `throughout` operator ensures `!buffer_overflow` holds continuously from the cycle after the antecedent until the end of the sequence.", "sva_signals": ["clk_sys", "stream_reserve", "buffer_overflow", "qos_class", "timesync_ready", "stream_active"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(stream_reserve) |->      ##1 (!buffer_overflow throughout          (##[1:5] $stable(qos_class)          ##[100:200] $rose(timesync_ready)          ##1 $fell(stream_active)))", "sva_name": "p_stream_reserve_fall_sequence", "full_property": "property p_stream_reserve_fell_sequence;\n@(posedge clk_sys)     $fell(stream_reserve) |->      ##1 (!buffer_overflow throughout          (##[1:5] $stable(qos_class)          ##[100:200] $rose(timesync_ready)          ##1 $fell(stream_active)))\nendproperty\nassert_p_stream_reserve_fell_sequence:assert property (p_stream_reserve_fell_sequence) else $error(\"\");", "task_id": "1_8468", "predict_sva": "@(posedge clk_sys)     $fell(stream_reserve) |->      ##1 (!buffer_overflow throughout (         ##[1:5] $stable(qos_class) ##[100:200] $rose(timesync_ready)     )) ##1 $fell(stream_active)"}
{"id": "502_6_0078", "name": "ddr_burst_cas_ras_window_6", "sva": "@(posedge ddr_clk)     $rose(ddr_cmd) |-> ##2 (cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n) ##2 burst_term", "ori_sva": "property ddr_burst_cas_ras_window_6;\n@(posedge ddr_clk)     $rose(ddr_cmd) |-> ##2 (cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n) ##2 burst_term;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ddr_burst_cas_ras_window_6  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ddr_cmd)` (The rising edge of `ddr_cmd` signal)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`##2 (cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n) ##2 burst_term`  \nThis means:  \n- After 2 clock cycles (`##2`), a specific sequence must occur:  \n  - `cas_n` is active, followed by `ras_n` within 2 to 8 clock cycles (`##[2:8]`),  \n  - then `cas_n` again after 1 clock cycle (`##1`),  \n  - followed by `ras_n` within 2 to 8 clock cycles (`##[2:8]`),  \n  - repeated 4 times in total,  \n  - and finally, `burst_term` must be active after 2 clock cycles (`##2`).  \n\nThe assertion checks that after the rising edge of `ddr_cmd`, the specified CAS-RAS sequence occurs exactly as described, followed by the burst termination signal.", "sva_signals": ["ddr_clk", "ddr_cmd", "cas_n", "ras_n", "burst_term"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)     $rose(ddr_cmd) |->      ##2 (cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n) ##2 burst_term", "sva_name": "p_ddr_burst_cas_ras_window", "full_property": "property ddr_burst_cas_ras_window_6;\n@(posedge ddr_clk)     $rose(ddr_cmd) |->      ##2 (cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n ##1 cas_n ##[2:8] ras_n) ##2 burst_term\nendproperty\nassert_ddr_burst_cas_ras_window_6:assert property (ddr_burst_cas_ras_window_6) else $error(\"\");", "task_id": "1_8571", "predict_sva": "@(posedge ddr_clk)    $rose(ddr_cmd) |-> ##2 (        (cas_n ##[2:8] ras_n)[*4] ##2 burst_term    )"}
{"id": "503_2_0016", "name": "pcie_tlp_header_data_sequence", "sva": "@(posedge clk)     header_valid |-> ##[1:2] data_valid", "ori_sva": "property pcie_tlp_header_data_sequence;\n@(posedge clk)     header_valid |-> ##[1:2] data_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_tlp_header_data_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `header_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] data_valid` (data_valid must be asserted within 1 to 2 clock cycles after header_valid is asserted)", "sva_signals": ["clk", "rst_n", "[0:0] header_valid", "[0:0] data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     header_valid == 1'b1 |-> ##[1:2] data_valid", "sva_name": "p_data_valid_within_2_cycles_after_header_valid", "full_property": "property pcie_tlp_header_data_sequence;\n@(posedge clk)     header_valid == 1'b1 |-> ##[1:2] data_valid\nendproperty\nassert_pcie_tlp_header_data_sequence:assert property (pcie_tlp_header_data_sequence) else $error(\"\");", "task_id": "1_8574", "predict_sva": "@(posedge clk)         header_valid == 1'b1 |-> ##[1:2] data_valid == 1'b1"}
{"id": "515_8_0116", "name": "p_result_valid_after_full_sequence", "sva": "@(posedge clk_signal)     (fir_enable ##2 (coeff_load ##[1:3] mac_cycle)[*16]) |-> ##1 result_valid", "ori_sva": "property p_result_valid_after_full_sequence;\n@(posedge clk_signal)     (fir_enable ##2 (coeff_load ##[1:3] mac_cycle)[*16]) |-> ##1 result_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_result_valid_after_full_sequence  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fir_enable ##2 (coeff_load ##[1:3] mac_cycle)[*16])`  \n- The antecedent describes a sequence where:  \n  1. `fir_enable` is asserted, followed by 2 clock cycles delay (`##2`),  \n  2. Then, a subsequence `(coeff_load ##[1:3] mac_cycle)` repeats **16 times** (`[*16]`).  \n     - The subsequence means `coeff_load` is asserted, followed by `mac_cycle` occurring **1 to 3 clock cycles later** (`##[1:3]`).  \n\n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 result_valid`  \n- The consequent requires that **1 clock cycle after the antecedent sequence completes**, `result_valid` must be asserted.  \n\n### Summary:  \nThe property checks that after a specific sequence of events (`fir_enable` followed by 16 repetitions of `coeff_load` and `mac_cycle` with variable delays), `result_valid` is asserted in the next clock cycle.", "sva_signals": ["clk_signal", "[0:0] fir_enable", "[0:0] coeff_load", "[0:0] mac_cycle", "[0:0] result_valid"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (fir_enable ##2 (coeff_load ##[1:3] mac_cycle)[*16]) |-> ##1 result_valid", "sva_name": "p_result_valid_after_coeff_mac_sequence", "full_property": "property p_result_valid_after_full_sequence;\n@(posedge clk_signal)     (fir_enable ##2 (coeff_load ##[1:3] mac_cycle)[*16]) |-> ##1 result_valid\nendproperty\nassert_p_result_valid_after_full_sequence:assert property (p_result_valid_after_full_sequence) else $error(\"\");", "task_id": "1_8617", "predict_sva": "@(posedge clk_signal)         fir_enable == 1 |-> ##2 ((             (coeff_load == 1) [*16] ##[1:3] (mac_cycle == 1)         ) ##1 (result_valid == 1)"}
{"id": "574_4_0505", "name": "simd_mul_result_p4", "sva": "@(posedge clk)     $changed(simd_mul) && simd_mul |-> (simd_result == (src0 * src1))", "ori_sva": "property simd_mul_result_p4;\n@(posedge clk)     $changed(simd_mul) && simd_mul |-> (simd_result == (src0 * src1));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_mul_result_p4  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(simd_mul) && simd_mul`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `simd_result == (src0 * src1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_mul", "[0:0] simd_result", "[0:0] src0", "[0:0] src1"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $changed(simd_mul) && simd_mul |-> simd_result == (src0 * src1)", "sva_name": "p_simd_mul_change_update", "full_property": "property simd_mul_result_p4;\n@(posedge clk)         $changed(simd_mul) && simd_mul |-> simd_result == (src0 * src1)\nendproperty\nassert_simd_mul_result_p4:assert property (simd_mul_result_p4) else $error(\"\");", "task_id": "1_8674", "predict_sva": "@(posedge clk)         $changed(simd_mul) && simd_mul |-> simd_result == (src0 * src1)"}
{"id": "521_10_0163", "name": "weight_load_exactly_nine_times", "sva": "@(posedge clk_signal)     conv_start |-> ##2 (weight_load[*9] ##1 pool_en)[*3]", "ori_sva": "property weight_load_exactly_nine_times;\n@(posedge clk_signal)     conv_start |-> ##2 (weight_load[*9] ##1 pool_en)[*3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: weight_load_exactly_nine_times  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `conv_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 (weight_load[*9] ##1 pool_en)[*3]`  \n**Explanation of Consequent**:  \n- After 2 clock cycles (`##2`), the following sequence must repeat exactly 3 times (`[*3]`):  \n  1. `weight_load` must be asserted for exactly 9 consecutive clock cycles (`weight_load[*9]`), followed by  \n  2. `pool_en` being asserted in the very next clock cycle (`##1 pool_en`).  \n\nThis ensures that whenever `conv_start` is asserted, the weight loading operation (`weight_load`) occurs exactly 9 times in each of 3 separate phases, with `pool_en` triggered immediately after each phase.", "sva_signals": ["clk", "rst_n", "[0:0] conv_start", "[0:0] weight_load", "[0:0] pool_en", "clk_signal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     conv_start == 1'b1 |-> ##2 (weight_load[*9] ##1 pool_en)[*3]", "sva_name": "p_conv_start_weight_load_pool_en_sequence_3x", "full_property": "property weight_load_exactly_nine_times;\n@(posedge clk_signal)     conv_start == 1'b1 |-> ##2 (weight_load[*9] ##1 pool_en)[*3]\nendproperty\nassert_weight_load_exactly_nine_times:assert property (weight_load_exactly_nine_times) else $error(\"\");", "task_id": "1_8631", "predict_sva": "@(posedge clk_signal)         conv_start == 1'b1 |-> ##2 ((             (weight_load == 1'b1 [*9]) ##1 (pool_en == 1'b1)         ) [*3])"}
{"id": "590_5_0660", "name": "p_simd_cmp_src0_change", "sva": "@(posedge clk_simd)     $changed(src0_data) |-> ##[1:2] $rose(simd_cmp)", "ori_sva": "property p_simd_cmp_src0_change;\n@(posedge clk_simd)     $changed(src0_data) |-> ##[1:2] $rose(simd_cmp);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_cmp_src0_change  \n**Trigger Condition**: At every rising edge of `clk_simd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(src0_data)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] $rose(simd_cmp)`  ", "sva_signals": ["clk_simd", "rst_n", "[0:0] src0_data", "[0:0] simd_cmp"], "clock": "clk_simd", "attempts_left": 10, "sva_result": "@(posedge clk_simd)     $changed(src0_data) |-> ##[1:2] $rose(simd_cmp)", "sva_name": "p_simd_cmp_src0_change", "full_property": "property p_simd_cmp_src0_change;\n@(posedge clk_simd)     $changed(src0_data) |-> ##[1:2] $rose(simd_cmp)\nendproperty\nassert_p_simd_cmp_src0_change:assert property (p_simd_cmp_src0_change) else $error(\"\");", "task_id": "1_8751", "predict_sva": "@(posedge clk_simd)     $changed(src0_data) |-> ##[1:2] $rose(simd_cmp)"}
{"id": "597_10_0711", "name": "p_simd_thread_unique_10", "sva": "@(posedge clk)     $rose(simd_thread_issue) |-> $countones(thread_id ^ (thread_id - 1)) == 1", "ori_sva": "property p_simd_thread_unique_10;\n@(posedge clk)     $rose(simd_thread_issue) |-> $countones(thread_id ^ (thread_id - 1)) == 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_thread_unique_10  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_thread_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$countones(thread_id ^ (thread_id - 1)) == 1`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_thread_issue", "[0:0] thread_id"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_thread_issue) |-> ($countones(thread_id ^ (thread_id - 1)) == 1)", "sva_name": "p_simd_thread_unique_2", "full_property": "property p_simd_thread_unique_10;\n@(posedge clk)     $rose(simd_thread_issue) |-> ($countones(thread_id ^ (thread_id - 1)) == 1)\nendproperty\nassert_p_simd_thread_unique_10:assert property (p_simd_thread_unique_10) else $error(\"\");", "task_id": "1_8789", "predict_sva": "@(posedge clk)         $rose(simd_thread_issue) |-> $countones(thread_id ^ (thread_id - 1)) == 1"}
{"id": "602_6_0738", "name": "p_simd_illegal_opcode_delay_posedge", "sva": "@(posedge clk)     $rose(simd_issue) |-> ##1 !(illegal_opcode)", "ori_sva": "property p_simd_illegal_opcode_delay_posedge;\n@(posedge clk)     $rose(simd_issue) |-> ##1 !(illegal_opcode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_illegal_opcode_delay_posedge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)` (a rising edge is detected on `simd_issue`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !(illegal_opcode)` (in the next clock cycle, `illegal_opcode` must be low (0))", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] illegal_opcode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_issue) |-> ##1 !illegal_opcode", "sva_name": "p_simd_issue_no_illegal_opcode_on_rise", "full_property": "property p_simd_illegal_opcode_delay_posedge;\n@(posedge clk)         $rose(simd_issue) |-> ##1 !illegal_opcode\nendproperty\nassert_p_simd_illegal_opcode_delay_posedge:assert property (p_simd_illegal_opcode_delay_posedge) else $error(\"\");", "task_id": "1_8821", "predict_sva": "@(posedge clk)         $rose(simd_issue) |-> ##1 illegal_opcode == 0"}
{"id": "603_5_0763", "name": "simd_priority_change_only_when_not_issued", "sva": "@(posedge clk)     $changed(simd_priority) |-> !$past(simd_issue)", "ori_sva": "property simd_priority_change_only_when_not_issued;\n@(posedge clk)     $changed(simd_priority) |-> !$past(simd_issue);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_priority_change_only_when_not_issued  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(simd_priority)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(simd_issue)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_priority", "[0:0] simd_issue"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $changed(simd_priority) |-> !$past(simd_issue)", "sva_name": "p_simd_priority_change_no_issue", "full_property": "property simd_priority_change_only_when_not_issued;\n@(posedge clk)     $changed(simd_priority) |-> !$past(simd_issue)\nendproperty\nassert_simd_priority_change_only_when_not_issued:assert property (simd_priority_change_only_when_not_issued) else $error(\"\");", "task_id": "1_8827", "predict_sva": "@(posedge clk)         $changed(simd_priority) |-> !$past(simd_issue)"}
{"id": "615_4_0833", "name": "p_simd_ewidth_set_64", "sva": "@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 64)", "ori_sva": "property p_simd_ewidth_set_64;\n@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg == 64);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_ewidth_set_64  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_ewidth_set)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ewidth_cfg == 64`", "sva_signals": ["clk", "rst_n", "[0:0] simd_ewidth_set", "[6:0] ewidth_cfg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg == 64", "sva_name": "p_simd_ewidth_set_64", "full_property": "property p_simd_ewidth_set_64;\n@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg == 64\nendproperty\nassert_p_simd_ewidth_set_64:assert property (p_simd_ewidth_set_64) else $error(\"\");", "task_id": "1_8896", "predict_sva": "@(posedge clk)         $rose(simd_ewidth_set) |-> (ewidth_cfg == 64)"}
{"id": "615_5_0859", "name": "p_simd_ewidth_set_valid", "sva": "@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg inside {8, 16, 32, 64})", "ori_sva": "property p_simd_ewidth_set_valid;\n@(posedge clk)     $rose(simd_ewidth_set) |-> (ewidth_cfg inside {8, 16, 32, 64});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_ewidth_set_valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_ewidth_set)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ewidth_cfg inside {8, 16, 32, 64}`", "sva_signals": ["clk", "rst_n", "[0:0] simd_ewidth_set", "[31:0] ewidth_cfg"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg inside {8, 16, 32, 64}", "sva_name": "p_simd_ewidth_cfg_valid_transition", "full_property": "property p_simd_ewidth_set_valid;\n@(posedge clk)         $rose(simd_ewidth_set) |-> ewidth_cfg inside {8, 16, 32, 64}\nendproperty\nassert_p_simd_ewidth_set_valid:assert property (p_simd_ewidth_set_valid) else $error(\"\");", "task_id": "1_8897", "predict_sva": "@(posedge clk)         $rose(simd_ewidth_set) |-> (ewidth_cfg == 8 || ewidth_cfg == 16 || ewidth_cfg == 32 || ewidth_cfg == 64)"}
{"id": "620_5_0898", "name": "simd_segment_write_overflow_protection_p5", "sva": "@(posedge clk)     simd_segment_write && (segment_idx >= NUM_SEGMENT) |=> $fell(simd_segment_write)", "ori_sva": "property simd_segment_write_overflow_protection_p5;\n@(posedge clk)     simd_segment_write && (segment_idx >= NUM_SEGMENT) |=> $fell(simd_segment_write);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_write_overflow_protection_p5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `simd_segment_write && (segment_idx >= NUM_SEGMENT)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$fell(simd_segment_write)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_segment_write", "[0:0] segment_idx", "[0:0] NUM_SEGMENT"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (simd_segment_write && (segment_idx >= NUM_SEGMENT)) |=> $fell(simd_segment_write)", "sva_name": "simd_segment_overflow_protection_p2", "full_property": "property simd_segment_write_overflow_protection_p5;\n@(posedge clk)     (simd_segment_write && (segment_idx >= NUM_SEGMENT)) |=> $fell(simd_segment_write)\nendproperty\nassert_simd_segment_write_overflow_protection_p5:assert property (simd_segment_write_overflow_protection_p5) else $error(\"\");", "task_id": "1_8922", "predict_sva": "@(posedge clk)         (simd_segment_write && (segment_idx >= NUM_SEGMENT)) |=> $fell(simd_segment_write)"}
{"id": "623_2_0930", "name": "batch_norm_delay_check", "sva": "@(posedge clk)     disable iff (!rst_n)     valid_in |=> (batchnorm_out == $past(scale * input_data + bias, 1))", "ori_sva": "property batch_norm_delay_check;\n@(posedge clk)     disable iff (!rst_n)     valid_in |=> (batchnorm_out == $past(scale * input_data + bias, 1));\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: batch_norm_delay_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `valid_in`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `batchnorm_out == $past(scale * input_data + bias, 1)`  \n\nThe assertion checks that if `valid_in` is true at a clock edge, then in the next cycle (`|=>`), `batchnorm_out` should equal the past value of `scale * input_data + bias` (delayed by 1 cycle). The assertion is disabled when `rst_n` is low.", "sva_signals": ["clk", "rst_n", "valid_in", "batchnorm_out", "scale", "input_data", "bias"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     valid_in |=> batchnorm_out == $past(scale * input_data + bias, 1)", "sva_name": "p_batchnorm_out_on_valid_in", "full_property": "property batch_norm_delay_check;\n@(posedge clk) disable iff (!rst_n)     valid_in |=> batchnorm_out == $past(scale * input_data + bias, 1)\nendproperty\nassert_batch_norm_delay_check:assert property (batch_norm_delay_check) else $error(\"\");", "task_id": "1_8940", "predict_sva": "@(posedge clk) disable iff (!rst_n)         (rst_n == 1 && valid_in == 1) |-> ##1 batchnorm_out == $past(scale * input_data + bias)"}
{"id": "636_5_1021", "name": "p_data_bus_no_x_valid", "sva": "@(posedge clk)     data_valid |-> !$isunknown(data_bus)", "ori_sva": "property p_data_bus_no_x_valid;\n@(posedge clk)     data_valid |-> !$isunknown(data_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_bus_no_x_valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(data_bus)`  \n\n(Note: The assertion checks that whenever `data_valid` is high, the `data_bus` must not contain any unknown ('X' or 'Z') values.)", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[7:0] data_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     data_valid == 1'b1 |-> !$isunknown(data_bus)", "sva_name": "p_data_bus_no_unknown_when_valid", "full_property": "property p_data_bus_no_x_valid;\n@(posedge clk)     data_valid == 1'b1 |-> !$isunknown(data_bus)\nendproperty\nassert_p_data_bus_no_x_valid:assert property (p_data_bus_no_x_valid) else $error(\"\");", "task_id": "1_8996", "predict_sva": "@(posedge clk)         data_valid == 1'b1 |-> $isunknown(data_bus) == 0"}
{"id": "637_4_1023", "name": "can_len_legal_p4", "sva": "@(posedge can_clk)     can_frame_active && !can_error_flag |-> can_len <= CAN_MAX_LEN", "ori_sva": "property can_len_legal_p4;\n@(posedge can_clk)     can_frame_active && !can_error_flag |-> can_len <= CAN_MAX_LEN;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_len_legal_p4  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_frame_active && !can_error_flag`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `can_len <= CAN_MAX_LEN`", "sva_signals": ["can_clk", "can_error_flag", "[0:0] can_frame_active", "[0:0] can_len", "[0:0] CAN_MAX_LEN"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         (can_frame_active && !can_error_flag) |-> (can_len <= CAN_MAX_LEN)", "sva_name": "p_can_frame_length_check", "full_property": "property can_len_legal_p4;\n@(posedge can_clk)         (can_frame_active && !can_error_flag) |-> (can_len <= CAN_MAX_LEN)\nendproperty\nassert_can_len_legal_p4:assert property (can_len_legal_p4) else $error(\"\");", "task_id": "1_9003", "predict_sva": "@(posedge can_clk)         (can_frame_active == 1 && can_error_flag == 0) |-> (can_len <= CAN_MAX_LEN)"}
{"id": "647_5_1123", "name": "p_context_saved_before_switch", "sva": "@(posedge clk_core)     thread_switch_grant |-> $past(thread_context_saved, 1)", "ori_sva": "property p_context_saved_before_switch;\n@(posedge clk_core)     thread_switch_grant |-> $past(thread_context_saved, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_context_saved_before_switch  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thread_switch_grant`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(thread_context_saved, 1)`  \n\n(Explanation: The assertion checks that whenever a thread switch is granted (`thread_switch_grant` is true), the thread context must have been saved (`thread_context_saved` was true) in the previous clock cycle.)", "sva_signals": ["clk_core", "rst_n", "[0:0] thread_switch_grant", "[0:0] thread_context_saved"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     thread_switch_grant |-> $past(thread_context_saved, 1)", "sva_name": "p_thread_switch_grant_requires_context_saved", "full_property": "property p_context_saved_before_switch;\n@(posedge clk_core)     thread_switch_grant |-> $past(thread_context_saved, 1)\nendproperty\nassert_p_context_saved_before_switch:assert property (p_context_saved_before_switch) else $error(\"\");", "task_id": "1_9044", "predict_sva": "@(posedge clk_core)         thread_switch_grant == 1 |-> $past(thread_context_saved, 1) == 1"}
{"id": "651_4_1171", "name": "p_no_credit_change_at_max", "sva": "@(posedge cxl_clk)     (credit_cnt == MAX_CREDIT) |-> !credit_inc", "ori_sva": "property p_no_credit_change_at_max;\n@(posedge cxl_clk)     (credit_cnt == MAX_CREDIT) |-> !credit_inc;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_credit_change_at_max  \n**Trigger Condition**: At every rising edge of the `cxl_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `credit_cnt == MAX_CREDIT`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!credit_inc`  \n\nThe assertion checks that whenever the `credit_cnt` reaches `MAX_CREDIT`, the signal `credit_inc` must be low (i.e., no further credit increment is allowed at maximum credit count).", "sva_signals": ["cxl_clk", "[0:0] credit_cnt", "[0:0] MAX_CREDIT", "[0:0] credit_inc"], "clock": "cxl_clk", "attempts_left": 10, "sva_result": "@(posedge cxl_clk)         credit_cnt == MAX_CREDIT |-> !credit_inc", "sva_name": "p_credit_inc_blocked_at_max", "full_property": "property p_no_credit_change_at_max;\n@(posedge cxl_clk)         credit_cnt == MAX_CREDIT |-> !credit_inc\nendproperty\nassert_p_no_credit_change_at_max:assert property (p_no_credit_change_at_max) else $error(\"\");", "task_id": "1_9067", "predict_sva": "@(posedge cxl_clk)         credit_cnt == MAX_CREDIT |-> credit_inc == 0"}
{"id": "648_6_1120", "name": "mul_result_overflow_check_p6", "sva": "@(posedge clk)     disable iff (!rst_n)     (mul_in1_unsigned || mul_in2_unsigned) |-> (mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0)", "ori_sva": "property mul_result_overflow_check_p6;\n@(posedge clk)     disable iff (!rst_n)     (mul_in1_unsigned || mul_in2_unsigned) |-> (mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mul_result_overflow_check_p6  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff `(!rst_n)`  \n**Antecedent (LHS of Implication)**: `(mul_in1_unsigned || mul_in2_unsigned)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0)`  ", "sva_signals": ["clk", "rst_n", "[0:0] mul_in1_unsigned", "[0:0] mul_in2_unsigned", "[31:0] mul_result", "[31:0] MUL_MAX_UNSIGNED"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)         (mul_in1_unsigned || mul_in2_unsigned) |-> (mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0)", "sva_name": "p_mul_result_unsigned_range_check", "full_property": "property mul_result_overflow_check_p6;\n@(posedge clk) disable iff (!rst_n)         (mul_in1_unsigned || mul_in2_unsigned) |-> (mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0)\nendproperty\nassert_mul_result_overflow_check_p6:assert property (mul_result_overflow_check_p6) else $error(\"\");", "task_id": "1_9049", "predict_sva": "@(posedge clk) disable iff (!rst_n)         (rst_n == 1 && (mul_in1_unsigned == 1 || mul_in2_unsigned == 1)) |->          (mul_result <= MUL_MAX_UNSIGNED && mul_result >= 0)"}
{"id": "653_7_1174", "name": "p_vc_sel_packet_boundary", "sva": "@(posedge clk)     packet_end |=> $onehot(vc_sel)", "ori_sva": "property p_vc_sel_packet_boundary;\n@(posedge clk)     packet_end |=> $onehot(vc_sel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_vc_sel_packet_boundary  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_end == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$onehot(vc_sel)`  \n\n(Note: `|=>` is a non-overlapping implication, meaning the consequent is checked in the next clock cycle after the antecedent is true. `$onehot(vc_sel)` ensures that exactly one bit in `vc_sel` is high at a time.)", "sva_signals": ["clk", "rst_n", "[0:0] packet_end", "[0:0] vc_sel"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         packet_end == 1'b1 |=> $onehot(vc_sel)", "sva_name": "p_vc_sel_onehot_on_packet_end", "full_property": "property p_vc_sel_packet_boundary;\n@(posedge clk)         packet_end == 1'b1 |=> $onehot(vc_sel)\nendproperty\nassert_p_vc_sel_packet_boundary:assert property (p_vc_sel_packet_boundary) else $error(\"\");", "task_id": "1_9087", "predict_sva": "@(posedge clk)         packet_end == 1'b1 |-> ##1 $onehot(vc_sel)"}
{"id": "652_5_1181", "name": "tlp_header_required_fields_present", "sva": "@(posedge clk_tlp)     tlp_header_valid |-> (tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0])", "ori_sva": "property tlp_header_required_fields_present;\n@(posedge clk_tlp)     tlp_header_valid |-> (tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: tlp_header_required_fields_present  \n**Trigger Condition**: At every rising edge of the `clk_tlp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_header_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0])`  ", "sva_signals": ["clk_tlp", "[1:0] tlp_fmt", "[1:0] tlp_type", "[9:0] tlp_length", "[9:0] tlp_dw_count", "tlp_header_valid"], "clock": "clk_tlp", "attempts_left": 10, "sva_result": "@(posedge clk_tlp)     tlp_header_valid |-> (tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0])", "sva_name": "p_tlp_header_valid_fmt_type_length_dw_count_alignment", "full_property": "property tlp_header_required_fields_present;\n@(posedge clk_tlp)     tlp_header_valid |-> (tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0])\nendproperty\nassert_tlp_header_required_fields_present:assert property (tlp_header_required_fields_present) else $error(\"\");", "task_id": "1_9077", "predict_sva": "@(posedge clk_tlp)         tlp_header_valid == 1 |-> (tlp_fmt[1:0] == tlp_type[1:0]) && (tlp_length[9:0] == tlp_dw_count[9:0])"}
{"id": "657_10_1216", "name": "p_channel_gain_transition", "sva": "@(posedge clk_signal)     (channel_gain == MIN_GAIN) |=> channel_gain <= MAX_GAIN", "ori_sva": "property p_channel_gain_transition;\n@(posedge clk_signal)     (channel_gain == MIN_GAIN) |=> channel_gain <= MAX_GAIN;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_channel_gain_transition  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(channel_gain == MIN_GAIN)`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `channel_gain <= MAX_GAIN` in the next clock cycle  ", "sva_signals": ["clk_signal", "[0:0] channel_gain", "[0:0] MIN_GAIN", "[0:0] MAX_GAIN"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (channel_gain == MIN_GAIN) |=> (channel_gain <= MAX_GAIN)", "sva_name": "p_channel_gain_min_max_limit", "full_property": "property p_channel_gain_transition;\n@(posedge clk_signal)     (channel_gain == MIN_GAIN) |=> (channel_gain <= MAX_GAIN)\nendproperty\nassert_p_channel_gain_transition:assert property (p_channel_gain_transition) else $error(\"\");", "task_id": "1_9103", "predict_sva": "@(posedge clk_signal)         channel_gain == MIN_GAIN |-> ##1 channel_gain <= MAX_GAIN"}
{"id": "663_1_1256", "name": "p_write_voltage_min_check", "sva": "@(posedge clk)     write_voltage >= V_SET_MIN", "ori_sva": "property p_write_voltage_min_check;\n@(posedge clk)     write_voltage >= V_SET_MIN;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_write_voltage_min_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Assertion Condition**: `write_voltage >= V_SET_MIN`  \n\n(Note: This is a simple assertion without implication, so it doesn't have Antecedent/Consequent structure. It directly checks the condition at every clock edge.)", "sva_signals": ["clk", "rst_n", "[15:0] write_voltage", "[15:0] V_SET_MIN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     write_voltage >= V_SET_MIN", "sva_name": "p_write_voltage_min_limit", "full_property": "property p_write_voltage_min_check;\n@(posedge clk)     write_voltage >= V_SET_MIN\nendproperty\nassert_p_write_voltage_min_check:assert property (p_write_voltage_min_check) else $error(\"\");", "task_id": "1_9141", "predict_sva": "@(posedge clk)         1 |-> write_voltage >= V_SET_MIN"}
{"id": "658_4_1210", "name": "ldpc_check_pass_p4", "sva": "@(posedge clk_sys)     ldpc_check_start |-> ##[1:100] ldpc_check_done && (ldpc_check_status == 1'b1)", "ori_sva": "property ldpc_check_pass_p4;\n@(posedge clk_sys)     ldpc_check_start |-> ##[1:100] ldpc_check_done && (ldpc_check_status == 1'b1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ldpc_check_pass_p4  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ldpc_check_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 100 clock cycles (`##[1:100]`), both `ldpc_check_done` must be true and `ldpc_check_status` must equal `1'b1`.  ", "sva_signals": ["clk_sys", "[0:0] ldpc_check_start", "[0:0] ldpc_check_done", "[0:0] ldpc_check_status"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ldpc_check_start == 1'b1 |-> ##[1:100] (ldpc_check_done == 1'b1 && ldpc_check_status == 1'b1)", "sva_name": "p_ldpc_check_done_and_status_within_100_cycles", "full_property": "property ldpc_check_pass_p4;\n@(posedge clk_sys)     ldpc_check_start == 1'b1 |-> ##[1:100] (ldpc_check_done == 1'b1 && ldpc_check_status == 1'b1)\nendproperty\nassert_ldpc_check_pass_p4:assert property (ldpc_check_pass_p4) else $error(\"\");", "task_id": "1_9113", "predict_sva": "@(posedge clk_sys)         ldpc_check_start == 1'b1 |-> ##[1:100] (ldpc_check_done == 1'b1 && ldpc_check_status == 1'b1)"}
{"id": "666_10_1314", "name": "p_sparse_ratio_power_check", "sva": "@(posedge clk)     (power_mode == LOW_POWER) |-> (sparse_ratio <= MAX_SPARSE)", "ori_sva": "property p_sparse_ratio_power_check;\n@(posedge clk)     (power_mode == LOW_POWER) |-> (sparse_ratio <= MAX_SPARSE);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sparse_ratio_power_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_mode == LOW_POWER`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sparse_ratio <= MAX_SPARSE`", "sva_signals": ["clk", "rst_n", "[0:0] power_mode", "[0:0] LOW_POWER", "[0:0] sparse_ratio", "[0:0] MAX_SPARSE"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (power_mode == LOW_POWER) |-> (sparse_ratio <= MAX_SPARSE)", "sva_name": "p_sparse_ratio_within_max_when_low_power", "full_property": "property p_sparse_ratio_power_check;\n@(posedge clk)     (power_mode == LOW_POWER) |-> (sparse_ratio <= MAX_SPARSE)\nendproperty\nassert_p_sparse_ratio_power_check:assert property (p_sparse_ratio_power_check) else $error(\"\");", "task_id": "1_9156", "predict_sva": "@(posedge clk)         power_mode == LOW_POWER |-> sparse_ratio <= MAX_SPARSE"}
{"id": "673_7_1370", "name": "stack_comm_no_x_p7", "sva": "@(posedge clk_sys)     $rose(comm_request) |=> !$isunknown(stack_comm_bus)", "ori_sva": "property stack_comm_no_x_p7;\n@(posedge clk_sys)     $rose(comm_request) |=> !$isunknown(stack_comm_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stack_comm_no_x_p7  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(comm_request)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!$isunknown(stack_comm_bus)`  ", "sva_signals": ["clk_sys", "[0:0] comm_request", "stack_comm_bus"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(comm_request) |=> !$isunknown(stack_comm_bus)", "sva_name": "stack_comm_no_x_p6", "full_property": "property stack_comm_no_x_p7;\n@(posedge clk_sys)         $rose(comm_request) |=> !$isunknown(stack_comm_bus)\nendproperty\nassert_stack_comm_no_x_p7:assert property (stack_comm_no_x_p7) else $error(\"\");", "task_id": "1_9201", "predict_sva": "@(posedge clk_sys)         $rose(comm_request) |-> !$isunknown(stack_comm_bus)"}
{"id": "676_3_1391", "name": "p_activation_out_range_3", "sva": "@(posedge clk)     !$isunknown(activation_out) && activation_ready |-> activation_out <= 1", "ori_sva": "property p_activation_out_range_3;\n@(posedge clk)     !$isunknown(activation_out) && activation_ready |-> activation_out <= 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_activation_out_range_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!$isunknown(activation_out) && activation_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `activation_out <= 1`", "sva_signals": ["clk", "rst_n", "[0:0] activation_out", "[0:0] activation_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !$isunknown(activation_out) && activation_ready |-> activation_out <= 1", "sva_name": "p_activation_out_max_value_when_ready", "full_property": "property p_activation_out_range_3;\n@(posedge clk)         !$isunknown(activation_out) && activation_ready |-> activation_out <= 1\nendproperty\nassert_p_activation_out_range_3:assert property (p_activation_out_range_3) else $error(\"\");", "task_id": "1_9217", "predict_sva": "@(posedge clk)         (activation_out !== 'x && activation_ready) |-> (activation_out <= 1)"}
{"id": "677_3_1386", "name": "batchnorm_param_stable_p3", "sva": "@(posedge clk)     !training_mode |=> $stable(batchnorm_param)", "ori_sva": "property batchnorm_param_stable_p3;\n@(posedge clk)     !training_mode |=> $stable(batchnorm_param);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: batchnorm_param_stable_p3  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!training_mode`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(batchnorm_param)`  ", "sva_signals": ["clk", "rst_n", "[0:0] training_mode", "[0:0] batchnorm_param"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !training_mode |=> $stable(batchnorm_param)", "sva_name": "batchnorm_param_stable", "full_property": "property batchnorm_param_stable_p3;\n@(posedge clk)     !training_mode |=> $stable(batchnorm_param)\nendproperty\nassert_batchnorm_param_stable_p3:assert property (batchnorm_param_stable_p3) else $error(\"\");", "task_id": "1_9226", "predict_sva": "@(posedge clk)         !training_mode |-> $stable(batchnorm_param)"}
{"id": "676_6_1381", "name": "p_activation_out_range_6", "sva": "@(posedge clk)     activation_start ##1 activation_busy |-> prev_activation_out >= 0 && prev_activation_out <= 1", "ori_sva": "property p_activation_out_range_6;\n@(posedge clk)     activation_start ##1 activation_busy |-> prev_activation_out >= 0 && prev_activation_out <= 1;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_activation_out_range_6  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `activation_start ##1 activation_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `prev_activation_out >= 0 && prev_activation_out <= 1`  ", "sva_signals": ["clk", "rst_n", "[0:0] activation_start", "[0:0] activation_busy", "prev_activation_out", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     activation_start ##1 activation_busy |-> (prev_activation_out >= 0 && prev_activation_out <= 1)", "sva_name": "p_prev_activation_out_range_on_busy", "full_property": "property p_activation_out_range_6;\n@(posedge clk)     activation_start ##1 activation_busy |-> (prev_activation_out >= 0 && prev_activation_out <= 1)\nendproperty\nassert_p_activation_out_range_6:assert property (p_activation_out_range_6) else $error(\"\");", "task_id": "1_9220", "predict_sva": "@(posedge clk)         activation_start == 1 |-> ##1 (activation_busy == 1) |-> (prev_activation_out >= 0 && prev_activation_out <= 1)"}
{"id": "685_5_1474", "name": "error_flag_max_one_cycle", "sva": "@(posedge clk)     ecc_error_flag |-> ##1 !ecc_error_flag", "ori_sva": "property error_flag_max_one_cycle;\n@(posedge clk)     ecc_error_flag |-> ##1 !ecc_error_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: error_flag_max_one_cycle  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_error_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !ecc_error_flag`  ", "sva_signals": ["clk", "rst_n", "[0:0] ecc_error_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ecc_error_flag == 1'b1 |-> ##1 !ecc_error_flag", "sva_name": "p_ecc_error_flag_assertion_limit", "full_property": "property error_flag_max_one_cycle;\n@(posedge clk)         ecc_error_flag == 1'b1 |-> ##1 !ecc_error_flag\nendproperty\nassert_error_flag_max_one_cycle:assert property (error_flag_max_one_cycle) else $error(\"\");", "task_id": "1_9254", "predict_sva": "@(posedge clk)         ecc_error_flag == 1'b1 |-> ##1 ecc_error_flag == 1'b0"}
{"id": "698_1_1588", "name": "p_mul_result_concat", "sva": "@(posedge clk)     (mul_done) |-> ({mul_hi, mul_lo} == (mul_op1 * mul_op2))", "ori_sva": "property p_mul_result_concat;\n@(posedge clk)     (mul_done) |-> ({mul_hi, mul_lo} == (mul_op1 * mul_op2));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mul_result_concat  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mul_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `{mul_hi, mul_lo} == (mul_op1 * mul_op2)`", "sva_signals": ["clk", "rst_n", "[0:0] mul_done", "[15:0] mul_hi", "[15:0] mul_lo", "[15:0] mul_op1", "[15:0] mul_op2"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         mul_done == 1'b1 |-> {mul_hi, mul_lo} == (mul_op1 * mul_op2)", "sva_name": "p_mul_result_concatenation", "full_property": "property p_mul_result_concat;\n@(posedge clk)         mul_done == 1'b1 |-> {mul_hi, mul_lo} == (mul_op1 * mul_op2)\nendproperty\nassert_p_mul_result_concat:assert property (p_mul_result_concat) else $error(\"\");", "task_id": "1_9303", "predict_sva": "@(posedge clk)         mul_done == 1'b1 |-> {mul_hi, mul_lo} == (mul_op1 * mul_op2)"}
{"id": "700_5_1598", "name": "p_thread_switch_mutex", "sva": "@(posedge clk)     $onehot0(thread_switch & ~$past(thread_switch))", "ori_sva": "property p_thread_switch_mutex;\n@(posedge clk)     $onehot0(thread_switch & ~$past(thread_switch));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_thread_switch_mutex  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Property Check**: The `thread_switch` signal must satisfy the condition `$onehot0(thread_switch & ~$past(thread_switch))`.  \n- ", "sva_signals": ["clk", "rst_n", "[0:0] thread_switch"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $onehot0(thread_switch & ~$past(thread_switch))", "sva_name": "p_thread_switch_one_hot", "full_property": "property p_thread_switch_mutex;\n@(posedge clk)         $onehot0(thread_switch & ~$past(thread_switch))\nendproperty\nassert_p_thread_switch_mutex:assert property (p_thread_switch_mutex) else $error(\"\");", "task_id": "1_9313", "predict_sva": "@(posedge clk)         (thread_switch & ~ $past(thread_switch)) == 1'b1"}
{"id": "724_9_1802", "name": "stride_feature_map_align", "sva": "@(posedge clk_signal)     (final_window_pos == feature_width - kernel_size) |->      ((feature_width - kernel_size) % cfg_stride == 0)", "ori_sva": "property stride_feature_map_align;\n@(posedge clk_signal)     (final_window_pos == feature_width - kernel_size) |->      ((feature_width - kernel_size) % cfg_stride == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stride_feature_map_align  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `final_window_pos == feature_width - kernel_size`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(feature_width - kernel_size) % cfg_stride == 0`", "sva_signals": ["clk_signal", "[0:0] final_window_pos", "[0:0] feature_width", "[0:0] kernel_size", "[0:0] cfg_stride"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         (final_window_pos == (feature_width - kernel_size)) |->          ((feature_width - kernel_size) % cfg_stride == 0)", "sva_name": "p_final_window_pos_stride_alignment", "full_property": "property stride_feature_map_align;\n@(posedge clk_signal)         (final_window_pos == (feature_width - kernel_size)) |->          ((feature_width - kernel_size) % cfg_stride == 0)\nendproperty\nassert_stride_feature_map_align:assert property (stride_feature_map_align) else $error(\"\");", "task_id": "1_9427", "predict_sva": "@(posedge clk_signal)         final_window_pos == feature_width - kernel_size |-> (feature_width - kernel_size) % cfg_stride == 0"}
{"id": "738_1_1939", "name": "p_err_state_no_new_frame_1", "sva": "@(posedge can_clk)     can_error_state |-> !can_tx_frame_start", "ori_sva": "property p_err_state_no_new_frame_1;\n@(posedge can_clk)     can_error_state |-> !can_tx_frame_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_err_state_no_new_frame_1  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_state`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!can_tx_frame_start`", "sva_signals": ["can_clk", "[0:0] can_error_state", "[0:0] can_tx_frame_start"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_error_state |-> !can_tx_frame_start", "sva_name": "p_no_frame_start_in_error_state", "full_property": "property p_err_state_no_new_frame_1;\n@(posedge can_clk)         can_error_state |-> !can_tx_frame_start\nendproperty\nassert_p_err_state_no_new_frame_1:assert property (p_err_state_no_new_frame_1) else $error(\"\");", "task_id": "1_9488", "predict_sva": "@(posedge can_clk)         can_error_state == 1 |-> can_tx_frame_start == 0"}
{"id": "738_8_1924", "name": "p_err_state_no_new_frame_8", "sva": "@(posedge can_clk)     can_error_status[3] |-> !can_tx_start_bit", "ori_sva": "property p_err_state_no_new_frame_8;\n@(posedge can_clk)     can_error_status[3] |-> !can_tx_start_bit;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_err_state_no_new_frame_8  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_status[3] == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!can_tx_start_bit`", "sva_signals": ["can_clk", "can_error_status[3:0]", "can_tx_start_bit"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_error_status[3] == 1'b1 |-> !can_tx_start_bit", "sva_name": "p_can_error_status_no_tx_start", "full_property": "property p_err_state_no_new_frame_8;\n@(posedge can_clk)         can_error_status[3] == 1'b1 |-> !can_tx_start_bit\nendproperty\nassert_p_err_state_no_new_frame_8:assert property (p_err_state_no_new_frame_8) else $error(\"\");", "task_id": "1_9495", "predict_sva": "@(posedge can_clk)         can_error_status[3] == 1'b1 |-> can_tx_start_bit == 1'b0"}
{"id": "742_4_1935", "name": "p_avb_sync_period_stable", "sva": "@(posedge avb_clk)     $fell(avb_sync_signal) |-> ##[8:12] $rose(avb_sync_signal)", "ori_sva": "property p_avb_sync_period_stable;\n@(posedge avb_clk)     $fell(avb_sync_signal) |-> ##[8:12] $rose(avb_sync_signal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_avb_sync_period_stable  \n**Trigger Condition**: At every rising edge of the `avb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(avb_sync_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:12] $rose(avb_sync_signal)`  ", "sva_signals": ["avb_clk", "avb_sync_signal", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "avb_clk", "attempts_left": 10, "sva_result": "@(posedge avb_clk)     $fell(avb_sync_signal) |-> ##[8:12] $rose(avb_sync_signal)", "sva_name": "p_avb_sync_signal_rise_within_8_to_12_cycles", "full_property": "property p_avb_sync_period_stable;\n@(posedge avb_clk)     $fell(avb_sync_signal) |-> ##[8:12] $rose(avb_sync_signal)\nendproperty\nassert_p_avb_sync_period_stable:assert property (p_avb_sync_period_stable) else $error(\"\");", "task_id": "1_9508", "predict_sva": "@(posedge avb_clk)         $fell(avb_sync_signal) |-> ##[8:12] $rose(avb_sync_signal)"}
{"id": "744_4_1979", "name": "p_no_other_reg_write", "sva": "@(posedge clk_core)     atomic_op_active |-> !(reg_write_enable && (reg_write_thread != current_thread_id))", "ori_sva": "property p_no_other_reg_write;\n@(posedge clk_core)     atomic_op_active |-> !(reg_write_enable && (reg_write_thread != current_thread_id));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_other_reg_write  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `atomic_op_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(reg_write_enable && (reg_write_thread != current_thread_id))`", "sva_signals": ["clk_core", "[0:0] atomic_op_active", "[0:0] reg_write_enable", "[0:0] reg_write_thread", "[0:0] current_thread_id"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     atomic_op_active |-> !(reg_write_enable && (reg_write_thread != current_thread_id))", "sva_name": "p_no_reg_write_during_atomic_op", "full_property": "property p_no_other_reg_write;\n@(posedge clk_core)     atomic_op_active |-> !(reg_write_enable && (reg_write_thread != current_thread_id))\nendproperty\nassert_p_no_other_reg_write:assert property (p_no_other_reg_write) else $error(\"\");", "task_id": "1_9516", "predict_sva": "@(posedge clk_core)         atomic_op_active == 1 |-> reg_write_enable == 0 || (reg_write_thread == current_thread_id)"}
{"id": "744_6_1984", "name": "p_reg_access_owner", "sva": "@(posedge clk_core)     reg_access_request && atomic_op_active |-> reg_access_thread == current_thread_id", "ori_sva": "property p_reg_access_owner;\n@(posedge clk_core)     reg_access_request && atomic_op_active |-> reg_access_thread == current_thread_id;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_reg_access_owner  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reg_access_request && atomic_op_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `reg_access_thread == current_thread_id`", "sva_signals": ["clk_core", "[0:0] reg_access_request", "[0:0] atomic_op_active", "[0:0] reg_access_thread", "[0:0] current_thread_id"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         (reg_access_request && atomic_op_active) |-> (reg_access_thread == current_thread_id)", "sva_name": "p_reg_access_thread_assignment", "full_property": "property p_reg_access_owner;\n@(posedge clk_core)         (reg_access_request && atomic_op_active) |-> (reg_access_thread == current_thread_id)\nendproperty\nassert_p_reg_access_owner:assert property (p_reg_access_owner) else $error(\"\");", "task_id": "1_9518", "predict_sva": "@(posedge clk_core)         (reg_access_request == 1 && atomic_op_active == 1) |-> (reg_access_thread == current_thread_id)"}
{"id": "751_2_2034", "name": "pcie_train_state_no_skip_2", "sva": "@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_POLLING) |-> ##[1:2] (train_state_next inside {TRAIN_STATE_DETECT, TRAIN_STATE_CONFIG})", "ori_sva": "property pcie_train_state_no_skip_2;\n@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_POLLING) |-> ##[1:2] (train_state_next inside {TRAIN_STATE_DETECT, TRAIN_STATE_CONFIG});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_train_state_no_skip_2  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(train_state_curr == TRAIN_STATE_POLLING)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] (train_state_next inside {TRAIN_STATE_DETECT, TRAIN_STATE_CONFIG})`", "sva_signals": ["pcie_clk", "train_state_curr", "train_state_next", "TRAIN_STATE_POLLING", "TRAIN_STATE_DETECT", "TRAIN_STATE_CONFIG"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_POLLING) |->      ##[1:2] (train_state_next inside {TRAIN_STATE_DETECT, TRAIN_STATE_CONFIG})", "sva_name": "p_train_state_polling_next_state_window", "full_property": "property pcie_train_state_no_skip_2;\n@(posedge pcie_clk)     $rose(train_state_curr == TRAIN_STATE_POLLING) |->      ##[1:2] (train_state_next inside {TRAIN_STATE_DETECT, TRAIN_STATE_CONFIG})\nendproperty\nassert_pcie_train_state_no_skip_2:assert property (pcie_train_state_no_skip_2) else $error(\"\");", "task_id": "1_9558", "predict_sva": "@(posedge pcie_clk)         $rose(train_state_curr == TRAIN_STATE_POLLING) |-> ##[1:2] (train_state_next == TRAIN_STATE_DETECT || train_state_next == TRAIN_STATE_CONFIG)"}
{"id": "754_2_2069", "name": "p_no_new_channel_until_old_released", "sva": "@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel", "ori_sva": "property p_no_new_channel_until_old_released;\n@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_new_channel_until_old_released  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(sel_channel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(release_old_channel) && !ack_old_channel`  ", "sva_signals": ["clk_signal", "[0:0] sel_channel", "[0:0] release_old_channel", "[0:0] ack_old_channel"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel", "sva_name": "p_sel_channel_change_release_ack_check", "full_property": "property p_no_new_channel_until_old_released;\n@(posedge clk_signal)     $changed(sel_channel) |-> $past(release_old_channel) && !ack_old_channel\nendproperty\nassert_p_no_new_channel_until_old_released:assert property (p_no_new_channel_until_old_released) else $error(\"\");", "task_id": "1_9579", "predict_sva": "@(posedge clk_signal)         $changed(sel_channel) |-> ($past(release_old_channel) == 1 && ack_old_channel == 0)"}
{"id": "757_4_2083", "name": "p_unique_rb_per_slot_4", "sva": "@(posedge pdcch_clk)     rb_allocated && $past(rb_allocated) |-> $past(rb_index) != rb_index", "ori_sva": "property p_unique_rb_per_slot_4;\n@(posedge pdcch_clk)     rb_allocated && $past(rb_allocated) |-> $past(rb_index) != rb_index;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_unique_rb_per_slot_4  \n**Trigger Condition**: At every rising edge of `pdcch_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rb_allocated && $past(rb_allocated)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(rb_index) != rb_index`  ", "sva_signals": ["pdcch_clk", "rb_allocated", "rb_index"], "clock": "pdcch_clk", "attempts_left": 10, "sva_result": "@(posedge pdcch_clk)     (rb_allocated && $past(rb_allocated)) |-> ($past(rb_index) != rb_index)", "sva_name": "p_unique_rb_allocation_per_slot", "full_property": "property p_unique_rb_per_slot_4;\n@(posedge pdcch_clk)     (rb_allocated && $past(rb_allocated)) |-> ($past(rb_index) != rb_index)\nendproperty\nassert_p_unique_rb_per_slot_4:assert property (p_unique_rb_per_slot_4) else $error(\"\");", "task_id": "1_9598", "predict_sva": "@(posedge pdcch_clk)         (rb_allocated && $past(rb_allocated)) |-> ($past(rb_index) != rb_index)"}
{"id": "762_5_2138", "name": "p_sequential_access", "sva": "@(posedge clk_matrix)     matrix_element_access |=> (next_element_access == $past(current_element) + 1)", "ori_sva": "property p_sequential_access;\n@(posedge clk_matrix)     matrix_element_access |=> (next_element_access == $past(current_element) + 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sequential_access  \n**Trigger Condition**: At every rising edge of the `clk_matrix`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `matrix_element_access`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `next_element_access == ($past(current_element) + 1)`  ", "sva_signals": ["clk_matrix", "[0:0] matrix_element_access", "[0:0] next_element_access", "[0:0] current_element"], "clock": "clk_matrix", "attempts_left": 10, "sva_result": "@(posedge clk_matrix)     matrix_element_access |=> next_element_access == ($past(current_element) + 1)", "sva_name": "p_matrix_element_access_increment", "full_property": "property p_sequential_access;\n@(posedge clk_matrix)     matrix_element_access |=> next_element_access == ($past(current_element) + 1)\nendproperty\nassert_p_sequential_access:assert property (p_sequential_access) else $error(\"\");", "task_id": "1_9610", "predict_sva": "@(posedge clk_matrix)         matrix_element_access == 1 |-> ##1 next_element_access == $past(current_element) + 1"}
{"id": "763_10_2147", "name": "write_pulse_overlap_check", "sva": "@(posedge clk_write)     write_enable |-> !read_enable", "ori_sva": "property write_pulse_overlap_check;\n@(posedge clk_write)     write_enable |-> !read_enable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: write_pulse_overlap_check  \n**Trigger Condition**: At every rising edge of the `clk_write`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!read_enable`  ", "sva_signals": ["clk", "rst_n", "[0:0] write_enable", "[0:0] read_enable", "clk_write"], "clock": "clk_write", "attempts_left": 10, "sva_result": "@(posedge clk_write)         write_enable == 1'b1 |-> !read_enable", "sva_name": "p_no_write_read_overlap", "full_property": "property write_pulse_overlap_check;\n@(posedge clk_write)         write_enable == 1'b1 |-> !read_enable\nendproperty\nassert_write_pulse_overlap_check:assert property (write_pulse_overlap_check) else $error(\"\");", "task_id": "1_9613", "predict_sva": "@(posedge clk_write)         write_enable == 1'b1 |-> read_enable == 1'b0"}
{"id": "772_2_2217", "name": "batchnorm_output_range", "sva": "@(posedge clk_core)     bn_valid_out |-> (bn_out >= -3 && bn_out <= 3)", "ori_sva": "property batchnorm_output_range;\n@(posedge clk_core)     bn_valid_out |-> (bn_out >= -3 && bn_out <= 3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: batchnorm_output_range  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bn_valid_out == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(bn_out >= -3 && bn_out <= 3)`", "sva_signals": ["clk_core", "[0:0] bn_valid_out", "[2:0] bn_out"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         bn_valid_out == 1'b1 |-> (bn_out >= -3 && bn_out <= 3)", "sva_name": "p_bn_out_range_when_valid", "full_property": "property batchnorm_output_range;\n@(posedge clk_core)         bn_valid_out == 1'b1 |-> (bn_out >= -3 && bn_out <= 3)\nendproperty\nassert_batchnorm_output_range:assert property (batchnorm_output_range) else $error(\"\");", "task_id": "1_9669", "predict_sva": "@(posedge clk_core)         bn_valid_out == 1'b1 |-> -3 <= bn_out <= 3"}
{"id": "772_3_2223", "name": "layer_output_alignment", "sva": "@(posedge clk_core)     batch_valid_out |-> (batch_cnt == next_layer_batch_cnt)", "ori_sva": "property layer_output_alignment;\n@(posedge clk_core)     batch_valid_out |-> (batch_cnt == next_layer_batch_cnt);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: layer_output_alignment  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `batch_valid_out == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `batch_cnt == next_layer_batch_cnt`", "sva_signals": ["clk_core", "batch_valid_out", "[0:0] batch_cnt", "[0:0] next_layer_batch_cnt"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         batch_valid_out == 1'b1 |-> batch_cnt == next_layer_batch_cnt", "sva_name": "p_batch_cnt_matches_next_layer_batch_cnt_on_batch_valid_out", "full_property": "property layer_output_alignment;\n@(posedge clk_core)         batch_valid_out == 1'b1 |-> batch_cnt == next_layer_batch_cnt\nendproperty\nassert_layer_output_alignment:assert property (layer_output_alignment) else $error(\"\");", "task_id": "1_9670", "predict_sva": "@(posedge clk_core)         batch_valid_out == 1'b1 |-> batch_cnt == next_layer_batch_cnt"}
{"id": "773_3_2233", "name": "no_overflow_16bit", "sva": "@(posedge clk_quant)     (quant_bits == 16) && quant_enable |-> quant_data inside {[-32768:32767]}", "ori_sva": "property no_overflow_16bit;\n@(posedge clk_quant)     (quant_bits == 16) && quant_enable |-> quant_data inside {[-32768:32767]};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_overflow_16bit  \n**Trigger Condition**: At every rising edge of the `clk_quant`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(quant_bits == 16) && quant_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `quant_data inside {[-32768:32767]}`  ", "sva_signals": ["clk", "rst_n", "[15:0] quant_bits", "[0:0] quant_enable", "[15:0] quant_data", "[15:0] clk_quant"], "clock": "clk_quant", "attempts_left": 10, "sva_result": "@(posedge clk_quant)     (quant_bits == 16) && quant_enable |-> quant_data inside {[-32768:32767]}", "sva_name": "p_quant_data_signed_16bit_range", "full_property": "property no_overflow_16bit;\n@(posedge clk_quant)     (quant_bits == 16) && quant_enable |-> quant_data inside {[-32768:32767]}\nendproperty\nassert_no_overflow_16bit:assert property (no_overflow_16bit) else $error(\"\");", "task_id": "1_9679", "predict_sva": "@(posedge clk_quant)         (quant_bits == 16 && quant_enable == 1) |-> (quant_data >= -32768 && quant_data <= 32767)"}
{"id": "776_10_2259", "name": "p_wmask_valid_with_cmd", "sva": "@(posedge ddr_clk)     write_cmd |-> wmask_valid", "ori_sva": "property p_wmask_valid_with_cmd;\n@(posedge ddr_clk)     write_cmd |-> wmask_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wmask_valid_with_cmd  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_cmd == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wmask_valid == 1'b1`", "sva_signals": ["ddr_clk", "[0:0] write_cmd", "[0:0] wmask_valid"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         write_cmd == 1'b1 |-> wmask_valid == 1'b1", "sva_name": "p_write_cmd_wmask_valid", "full_property": "property p_wmask_valid_with_cmd;\n@(posedge ddr_clk)         write_cmd == 1'b1 |-> wmask_valid == 1'b1\nendproperty\nassert_p_wmask_valid_with_cmd:assert property (p_wmask_valid_with_cmd) else $error(\"\");", "task_id": "1_9699", "predict_sva": "@(posedge ddr_clk)         write_cmd == 1'b1 |-> wmask_valid == 1'b1"}
{"id": "775_6_2265", "name": "write_after_activation", "sva": "@(posedge mem_clk)     (bank_write_req && row_active_status) |-> ##[1:4] write_ack", "ori_sva": "property write_after_activation;\n@(posedge mem_clk)     (bank_write_req && row_active_status) |-> ##[1:4] write_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: write_after_activation  \n**Trigger Condition**: At every rising edge of the `mem_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bank_write_req && row_active_status`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] write_ack`  ", "sva_signals": ["mem_clk", "[0:0] bank_write_req", "[0:0] row_active_status", "[0:0] write_ack"], "clock": "mem_clk", "attempts_left": 10, "sva_result": "@(posedge mem_clk)     (bank_write_req && row_active_status) |-> ##[1:4] write_ack", "sva_name": "p_write_ack_within_4_cycles_after_bank_write_req_and_row_active_status", "full_property": "property write_after_activation;\n@(posedge mem_clk)     (bank_write_req && row_active_status) |-> ##[1:4] write_ack\nendproperty\nassert_write_after_activation:assert property (write_after_activation) else $error(\"\");", "task_id": "1_9696", "predict_sva": "@(posedge mem_clk)         (bank_write_req == 1 && row_active_status == 1) |-> ##[1:4] write_ack == 1"}
{"id": "779_6_2298", "name": "switch_completion_time", "sva": "@(posedge can_clk)     $changed(active_channel) |-> ##[1:3] $stable(active_channel)", "ori_sva": "property switch_completion_time;\n@(posedge can_clk)     $changed(active_channel) |-> ##[1:3] $stable(active_channel);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: switch_completion_time  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(active_channel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $stable(active_channel)`  ", "sva_signals": ["can_clk", "active_channel"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         $changed(active_channel) |-> ##[1:3] $stable(active_channel)", "sva_name": "p_active_channel_stability_after_change", "full_property": "property switch_completion_time;\n@(posedge can_clk)         $changed(active_channel) |-> ##[1:3] $stable(active_channel)\nendproperty\nassert_switch_completion_time:assert property (switch_completion_time) else $error(\"\");", "task_id": "1_9729", "predict_sva": "@(posedge can_clk)         $changed(active_channel) |-> ##[1:3] $stable(active_channel)"}
{"id": "776_7_2271", "name": "p_partial_write_wmask_coverage", "sva": "@(posedge ddr_clk)     partial_write |-> wmask inside {8'h00, 8'h0F, 8'hF0, 8'hFF}", "ori_sva": "property p_partial_write_wmask_coverage;\n@(posedge ddr_clk)     partial_write |-> wmask inside {8'h00, 8'h0F, 8'hF0, 8'hFF};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_partial_write_wmask_coverage  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `partial_write == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wmask inside {8'h00, 8'h0F, 8'hF0, 8'hFF}`  \n\n(Note: The consequent checks if `wmask` has one of the four valid patterns for partial writes: all bits masked `8'h00`, lower nibble masked `8'h0F`, upper nibble masked `8'hF0`, or no bits masked `8'hFF`.)", "sva_signals": ["ddr_clk", "[0:0] partial_write", "[7:0] wmask"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         partial_write == 1'b1 |-> wmask inside {8'h00, 8'h0F, 8'hF0, 8'hFF}", "sva_name": "p_partial_write_wmask_valid_pattern", "full_property": "property p_partial_write_wmask_coverage;\n@(posedge ddr_clk)         partial_write == 1'b1 |-> wmask inside {8'h00, 8'h0F, 8'hF0, 8'hFF}\nendproperty\nassert_p_partial_write_wmask_coverage:assert property (p_partial_write_wmask_coverage) else $error(\"\");", "task_id": "1_9703", "predict_sva": "@(posedge ddr_clk)         partial_write == 1'b1 |-> (wmask == 8'h00 || wmask == 8'h0F || wmask == 8'hF0 || wmask == 8'hFF)"}
{"id": "783_6_2329", "name": "p_csr_no_simult_rw", "sva": "@(posedge clk_csr)     csr_read_enable |-> !csr_write_enable", "ori_sva": "property p_csr_no_simult_rw;\n@(posedge clk_csr)     csr_read_enable |-> !csr_write_enable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_csr_no_simult_rw  \n**Trigger Condition**: At every rising edge of the `clk_csr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `csr_read_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!csr_write_enable`  ", "sva_signals": ["clk_csr", "rst_n", "[0:0] csr_read_enable", "[0:0] csr_write_enable"], "clock": "clk_csr", "attempts_left": 10, "sva_result": "@(posedge clk_csr)     csr_read_enable == 1'b1 |-> !csr_write_enable", "sva_name": "p_csr_read_write_mutual_exclusion", "full_property": "property p_csr_no_simult_rw;\n@(posedge clk_csr)     csr_read_enable == 1'b1 |-> !csr_write_enable\nendproperty\nassert_p_csr_no_simult_rw:assert property (p_csr_no_simult_rw) else $error(\"\");", "task_id": "1_9766", "predict_sva": "@(posedge clk_csr)         csr_read_enable == 1'b1 |-> csr_write_enable == 1'b0"}
{"id": "781_6_2345", "name": "amo_data_integrity", "sva": "@(posedge clk_core)     amo_grant_1 && amo_grant_2 |->      (amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2)", "ori_sva": "property amo_data_integrity;\n@(posedge clk_core)     amo_grant_1 && amo_grant_2 |->      (amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: amo_data_integrity  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `amo_grant_1 && amo_grant_2`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2)`", "sva_signals": ["clk_core", "[0:0] amo_grant_1", "[0:0] amo_grant_2", "[0:0] amo_wr_reg_1", "[0:0] amo_wr_reg_2", "[0:0] amo_addr_1", "[0:0] amo_addr_2"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         (amo_grant_1 && amo_grant_2) |-> ((amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2))", "sva_name": "p_amo_data_integrity_on_simultaneous_grant", "full_property": "property amo_data_integrity;\n@(posedge clk_core)         (amo_grant_1 && amo_grant_2) |-> ((amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2))\nendproperty\nassert_amo_data_integrity:assert property (amo_data_integrity) else $error(\"\");", "task_id": "1_9747", "predict_sva": "@(posedge clk_core)         (amo_grant_1 == 1 && amo_grant_2 == 1) |-> (amo_addr_1 != amo_addr_2) && (amo_wr_reg_1 != amo_wr_reg_2)"}
{"id": "784_9_2357", "name": "p_reg_write_protect", "sva": "@(posedge clk_copro)     busy_flag |-> !reg_write_enable", "ori_sva": "property p_reg_write_protect;\n@(posedge clk_copro)     busy_flag |-> !reg_write_enable;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_reg_write_protect  \n**Trigger Condition**: At every rising edge of the `clk_copro`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `busy_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reg_write_enable`", "sva_signals": ["clk_copro", "[0:0] busy_flag", "[0:0] reg_write_enable"], "clock": "clk_copro", "attempts_left": 10, "sva_result": "@(posedge clk_copro)     busy_flag == 1'b1 |-> !reg_write_enable", "sva_name": "p_reg_write_protect_during_busy", "full_property": "property p_reg_write_protect;\n@(posedge clk_copro)     busy_flag == 1'b1 |-> !reg_write_enable\nendproperty\nassert_p_reg_write_protect:assert property (p_reg_write_protect) else $error(\"\");", "task_id": "1_9773", "predict_sva": "@(posedge clk_copro)         busy_flag == 1'b1 |-> reg_write_enable == 1'b0"}
{"id": "791_6_2471", "name": "p_ch_gain_convergence_time", "sva": "@(posedge clk_ch_est)     $rose(ch_est_start) |-> ##[1:20] $stable(ch_gain_est)", "ori_sva": "property p_ch_gain_convergence_time;\n@(posedge clk_ch_est)     $rose(ch_est_start) |-> ##[1:20] $stable(ch_gain_est);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ch_gain_convergence_time  \n**Trigger Condition**: At every rising edge of `clk_ch_est`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ch_est_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:20] $stable(ch_gain_est)`  ", "sva_signals": ["clk_ch_est", "ch_est_start", "ch_gain_est"], "clock": "clk_ch_est", "attempts_left": 10, "sva_result": "@(posedge clk_ch_est)     $rose(ch_est_start) |-> ##[1:20] $stable(ch_gain_est)", "sva_name": "p_ch_gain_stable_after_est_start", "full_property": "property p_ch_gain_convergence_time;\n@(posedge clk_ch_est)     $rose(ch_est_start) |-> ##[1:20] $stable(ch_gain_est)\nendproperty\nassert_p_ch_gain_convergence_time:assert property (p_ch_gain_convergence_time) else $error(\"\");", "task_id": "1_9842", "predict_sva": "@(posedge clk_ch_est)     $rose(ch_est_start) |-> ##[1:20] $stable(ch_gain_est)"}
{"id": "798_10_2533", "name": "zero_element_identification", "sva": "@(posedge clk_sparse)     (matrix_data[bit_idx] == 0) |-> !non_zero_mask[bit_idx]", "ori_sva": "property zero_element_identification;\n@(posedge clk_sparse)     (matrix_data[bit_idx] == 0) |-> !non_zero_mask[bit_idx];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: zero_element_identification  \n**Trigger Condition**: At every rising edge of the `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `matrix_data[bit_idx] == 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!non_zero_mask[bit_idx]`", "sva_signals": ["clk_sparse", "[0:0] matrix_data", "[0:0] non_zero_mask", "[0:0] bit_idx"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)         matrix_data[bit_idx] == 0 |-> !non_zero_mask[bit_idx]", "sva_name": "p_non_zero_mask_deassert_on_zero_matrix_data", "full_property": "property zero_element_identification;\n@(posedge clk_sparse)         matrix_data[bit_idx] == 0 |-> !non_zero_mask[bit_idx]\nendproperty\nassert_zero_element_identification:assert property (zero_element_identification) else $error(\"\");", "task_id": "1_9891", "predict_sva": "@(posedge clk_sparse)         matrix_data[bit_idx] == 0 |-> non_zero_mask[bit_idx] == 0"}
{"id": "811_14_2707", "name": "channel_est_accuracy", "sva": "@(posedge clk_mimo)     channel_est_done |-> channel_est_error < max_error_threshold", "ori_sva": "property channel_est_accuracy;\n@(posedge clk_mimo)     channel_est_done |-> channel_est_error < max_error_threshold;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: channel_est_accuracy  \n**Trigger Condition**: At every rising edge of the `clk_mimo`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `channel_est_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `channel_est_error < max_error_threshold`", "sva_signals": ["clk_mimo", "[0:0] channel_est_done", "[0:0] channel_est_error", "[0:0] max_error_threshold"], "clock": "clk_mimo", "attempts_left": 10, "sva_result": "@(posedge clk_mimo)     channel_est_done == 1'b1 |-> channel_est_error < max_error_threshold", "sva_name": "p_channel_est_error_threshold_check", "full_property": "property channel_est_accuracy;\n@(posedge clk_mimo)     channel_est_done == 1'b1 |-> channel_est_error < max_error_threshold\nendproperty\nassert_channel_est_accuracy:assert property (channel_est_accuracy) else $error(\"\");", "task_id": "1_10006", "predict_sva": "@(posedge clk_mimo)         channel_est_done == 1'b1 |-> channel_est_error < max_error_threshold"}
{"id": "815_1_2744", "name": "sparse_zero_skip", "sva": "@(posedge clk_sparse)     (sparse_val == 0) |-> ##1 !mult_en", "ori_sva": "property sparse_zero_skip;\n@(posedge clk_sparse)     (sparse_val == 0) |-> ##1 !mult_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sparse_zero_skip  \n**Trigger Condition**: At every rising edge of the `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sparse_val == 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !mult_en`  ", "sva_signals": ["clk_sparse", "[0:0] sparse_val", "[0:0] mult_en"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)         sparse_val == 0 |-> ##1 !mult_en", "sva_name": "p_mult_en_deassert_on_sparse_zero", "full_property": "property sparse_zero_skip;\n@(posedge clk_sparse)         sparse_val == 0 |-> ##1 !mult_en\nendproperty\nassert_sparse_zero_skip:assert property (sparse_zero_skip) else $error(\"\");", "task_id": "1_10039", "predict_sva": "@(posedge clk_sparse)         sparse_val == 0 |-> ##1 mult_en == 0"}
{"id": "823_4_2823", "name": "post_error_communication", "sva": "@(posedge i2c_clk)     $fell(i2c_bus_error) |-> ##[1:10] $rose(i2c_start)", "ori_sva": "property post_error_communication;\n@(posedge i2c_clk)     $fell(i2c_bus_error) |-> ##[1:10] $rose(i2c_start);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: post_error_communication  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(i2c_bus_error)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] $rose(i2c_start)`  ", "sva_signals": ["i2c_clk", "i2c_bus_error", "i2c_start"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     $fell(i2c_bus_error) |-> ##[1:10] $rose(i2c_start)", "sva_name": "arbitration_recovery", "full_property": "property post_error_communication;\n@(posedge i2c_clk)     $fell(i2c_bus_error) |-> ##[1:10] $rose(i2c_start)\nendproperty\nassert_post_error_communication:assert property (post_error_communication) else $error(\"\");", "task_id": "1_10117", "predict_sva": "@(posedge i2c_clk)     $fell(i2c_bus_error) |-> ##[1:10] $rose(i2c_start)"}
{"id": "826_5_2884", "name": "p_no_data_loss", "sva": "@(posedge spi_clk)     $changed(cpol) || $changed(cpha) |-> ##[1:4] $stable(spi_data_counter)", "ori_sva": "property p_no_data_loss;\n@(posedge spi_clk)     $changed(cpol) || $changed(cpha) |-> ##[1:4] $stable(spi_data_counter);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_data_loss  \n**Trigger Condition**: At every rising edge of the `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(cpol) || $changed(cpha)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] $stable(spi_data_counter)`  ", "sva_signals": ["spi_clk", "rst_n", "[0:0] cpol", "[0:0] cpha", "[0:0] spi_data_counter"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     ($changed(cpol) || $changed(cpha)) |-> ##[1:4] $stable(spi_data_counter)", "sva_name": "p_spi_data_counter_stability_after_mode_change", "full_property": "property p_no_data_loss;\n@(posedge spi_clk)     ($changed(cpol) || $changed(cpha)) |-> ##[1:4] $stable(spi_data_counter)\nendproperty\nassert_p_no_data_loss:assert property (p_no_data_loss) else $error(\"\");", "task_id": "1_10142", "predict_sva": "@(posedge spi_clk)         ($changed(cpol) || $changed(cpha)) |-> ##[1:4] $stable(spi_data_counter)"}
{"id": "827_1_2864", "name": "cs_mutual_exclusion", "sva": "@(posedge spi_clk)     $onehot0(cs_n)", "ori_sva": "property cs_mutual_exclusion;\n@(posedge spi_clk)     $onehot0(cs_n);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cs_mutual_exclusion  \n**Trigger Condition**: At every rising edge of `spi_clk`  \n**Disable Condition**: None  \n**Assertion Check**: `$onehot0(cs_n)`  \n**Description**: The assertion checks that at every rising edge of `spi_clk`, the signal `cs_n` is either all zeros or has at most one bit set (one-hot or all-zero condition).  \n\n(Note: This assertion does not follow the implication (`|->`) structure like the examples but instead directly checks a condition using `$onehot0`.)", "sva_signals": ["spi_clk", "[0:0] cs_n"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     $onehot0(cs_n)", "sva_name": "p_cs_n_onehot0", "full_property": "property cs_mutual_exclusion;\n@(posedge spi_clk)     $onehot0(cs_n)\nendproperty\nassert_cs_mutual_exclusion:assert property (cs_mutual_exclusion) else $error(\"\");", "task_id": "1_10149", "predict_sva": "@(posedge spi_clk)         $onehot0(cs_n) == 1"}
{"id": "828_8_2889", "name": "no_data_corruption_after_underflow", "sva": "@(posedge spi_clk)     fifo_underflow_flag |-> ##[1:10] $stable(spi_rx_data)", "ori_sva": "property no_data_corruption_after_underflow;\n@(posedge spi_clk)     fifo_underflow_flag |-> ##[1:10] $stable(spi_rx_data);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: no_data_corruption_after_underflow  \n**Trigger Condition**: At every rising edge of the `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_underflow_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] $stable(spi_rx_data)`  ", "sva_signals": ["spi_clk", "fifo_underflow_flag", "[0:0] spi_rx_data"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     fifo_underflow_flag == 1'b1 |-> ##[1:10] $stable(spi_rx_data)", "sva_name": "p_spi_rx_data_stability_after_fifo_underflow", "full_property": "property no_data_corruption_after_underflow;\n@(posedge spi_clk)     fifo_underflow_flag == 1'b1 |-> ##[1:10] $stable(spi_rx_data)\nendproperty\nassert_no_data_corruption_after_underflow:assert property (no_data_corruption_after_underflow) else $error(\"\");", "task_id": "1_10165", "predict_sva": "@(posedge spi_clk)         fifo_underflow_flag == 1'b1 |-> ##[1:10] spi_rx_data == $past(spi_rx_data)"}
{"id": "830_1_2918", "name": "slave_safe_after_master_reset", "sva": "@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0)", "ori_sva": "property slave_safe_after_master_reset;\n@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: slave_safe_after_master_reset  \n**Trigger Condition**: At every rising edge of `spi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(master_reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0)`  ", "sva_signals": ["spi_clk", "[0:0] master_reset_n", "[0:0] slave_cs_n", "[0:0] slave_sck", "[0:0] slave_mosi"], "clock": "spi_clk", "attempts_left": 10, "sva_result": "@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0)", "sva_name": "p_slave_safe_state_after_reset", "full_property": "property slave_safe_after_master_reset;\n@(posedge spi_clk)     $fell(master_reset_n) |-> ##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0)\nendproperty\nassert_slave_safe_after_master_reset:assert property (slave_safe_after_master_reset) else $error(\"\");", "task_id": "1_10180", "predict_sva": "@(posedge spi_clk)         $fell(master_reset_n) |-> ##[1:5] (slave_cs_n == 1'b1 && slave_sck == 1'b0 && slave_mosi == 1'b0)"}
{"id": "836_10_2997", "name": "write_data_integrity", "sva": "@(posedge ddr_clk)     (wr_data_valid_ && wr_data_strobe_) |-> ##1 $stable(wr_data_)", "ori_sva": "property write_data_integrity;\n@(posedge ddr_clk)     (wr_data_valid_ && wr_data_strobe_) |-> ##1 $stable(wr_data_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: write_data_integrity  \n**Trigger Condition**: At every rising edge of `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wr_data_valid_ && wr_data_strobe_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(wr_data_)`  ", "sva_signals": ["ddr_clk", "[0:0] wr_data_valid_", "[0:0] wr_data_strobe_", "[0:0] wr_data_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)     (wr_data_valid_ && wr_data_strobe_) |-> ##1 $stable(wr_data_)", "sva_name": "p_wr_data_stable_when_valid_and_strobe", "full_property": "property write_data_integrity;\n@(posedge ddr_clk)     (wr_data_valid_ && wr_data_strobe_) |-> ##1 $stable(wr_data_)\nendproperty\nassert_write_data_integrity:assert property (write_data_integrity) else $error(\"\");", "task_id": "1_10237", "predict_sva": "@(posedge ddr_clk)         (wr_data_valid_ == 1 && wr_data_strobe_ == 1) |-> ##1 wr_data_ == $past(wr_data_)"}
{"id": "838_7_3008", "name": "ecc_single_bit_not_uncorrectable", "sva": "@(posedge ecc_clk)     ecc_corrected |-> !ecc_uncorrectable_error", "ori_sva": "property ecc_single_bit_not_uncorrectable;\n@(posedge ecc_clk)     ecc_corrected |-> !ecc_uncorrectable_error;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_single_bit_not_uncorrectable  \n**Trigger Condition**: At every rising edge of the `ecc_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_corrected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!ecc_uncorrectable_error`  ", "sva_signals": ["ecc_clk", "[0:0] ecc_corrected", "[0:0] ecc_uncorrectable_error"], "clock": "ecc_clk", "attempts_left": 10, "sva_result": "@(posedge ecc_clk)         ecc_corrected == 1'b1 |-> !ecc_uncorrectable_error", "sva_name": "p_ecc_corrected_no_uncorrectable_error", "full_property": "property ecc_single_bit_not_uncorrectable;\n@(posedge ecc_clk)         ecc_corrected == 1'b1 |-> !ecc_uncorrectable_error\nendproperty\nassert_ecc_single_bit_not_uncorrectable:assert property (ecc_single_bit_not_uncorrectable) else $error(\"\");", "task_id": "1_10272", "predict_sva": "@(posedge ecc_clk)         ecc_corrected == 1'b1 |-> ecc_uncorrectable_error == 1'b0"}
{"id": "847_4_3118", "name": "pcie_tlp_crc_check_valid", "sva": "@(posedge pcie_clk)     tlp_end_of_packet |-> ##1 crc_check_valid", "ori_sva": "property pcie_tlp_crc_check_valid;\n@(posedge pcie_clk)     tlp_end_of_packet |-> ##1 crc_check_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_tlp_crc_check_valid  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_end_of_packet`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 crc_check_valid`", "sva_signals": ["pcie_clk", "[0:0] tlp_end_of_packet", "[0:0] crc_check_valid"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)         tlp_end_of_packet |-> ##1 crc_check_valid", "sva_name": "p_crc_check_valid_after_tlp_end_of_packet", "full_property": "property pcie_tlp_crc_check_valid;\n@(posedge pcie_clk)         tlp_end_of_packet |-> ##1 crc_check_valid\nendproperty\nassert_pcie_tlp_crc_check_valid:assert property (pcie_tlp_crc_check_valid) else $error(\"\");", "task_id": "1_10365", "predict_sva": "@(posedge pcie_clk)         tlp_end_of_packet == 1 |-> ##1 crc_check_valid == 1"}
{"id": "849_9_3157", "name": "pcie_max_payload_size_respected", "sva": "@(posedge pcie_clk)     disable iff (~pcie_reset_n)     packet_valid |-> packet_size <= max_payload_size", "ori_sva": "property pcie_max_payload_size_respected;\n@(posedge pcie_clk)     disable iff (~pcie_reset_n)     packet_valid |-> packet_size <= max_payload_size;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_max_payload_size_respected  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: disable iff (~pcie_reset_n)  \n**Antecedent (LHS of Implication)**: `packet_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `packet_size <= max_payload_size`", "sva_signals": ["pcie_clk", "pcie_reset_n", "[0:0] packet_valid", "[0:0] packet_size", "[0:0] max_payload_size"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk) disable iff (~pcie_reset_n)     packet_valid == 1'b1 |-> packet_size <= max_payload_size", "sva_name": "p_packet_valid_payload_check", "full_property": "property pcie_max_payload_size_respected;\n@(posedge pcie_clk) disable iff (~pcie_reset_n)     packet_valid == 1'b1 |-> packet_size <= max_payload_size\nendproperty\nassert_pcie_max_payload_size_respected:assert property (pcie_max_payload_size_respected) else $error(\"\");", "task_id": "1_10381", "predict_sva": "@(posedge pcie_clk) disable iff (!pcie_reset_n)     packet_valid == 1'b1 |-> packet_size <= max_payload_size"}
{"id": "847_9_3143", "name": "pcie_tlp_retransmit_sequence_id", "sva": "@(posedge pcie_clk)     (tlp_retransmitted && tlp_sequence_valid) |-> tlp_sequence_id == retransmit_sequence_id", "ori_sva": "property pcie_tlp_retransmit_sequence_id;\n@(posedge pcie_clk)     (tlp_retransmitted && tlp_sequence_valid) |-> tlp_sequence_id == retransmit_sequence_id;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_tlp_retransmit_sequence_id  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_retransmitted && tlp_sequence_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tlp_sequence_id == retransmit_sequence_id`", "sva_signals": ["pcie_clk", "tlp_retransmitted", "tlp_sequence_valid", "tlp_sequence_id", "retransmit_sequence_id"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)         (tlp_retransmitted && tlp_sequence_valid) |-> (tlp_sequence_id == retransmit_sequence_id)", "sva_name": "p_tlp_sequence_id_match_on_retransmit", "full_property": "property pcie_tlp_retransmit_sequence_id;\n@(posedge pcie_clk)         (tlp_retransmitted && tlp_sequence_valid) |-> (tlp_sequence_id == retransmit_sequence_id)\nendproperty\nassert_pcie_tlp_retransmit_sequence_id:assert property (pcie_tlp_retransmit_sequence_id) else $error(\"\");", "task_id": "1_10370", "predict_sva": "@(posedge pcie_clk)         (tlp_retransmitted == 1 && tlp_sequence_valid == 1) |-> (tlp_sequence_id == retransmit_sequence_id)"}
{"id": "850_5_3175", "name": "training_completion_timeout", "sva": "@(posedge serdes_clk)     $rose(link_training_start) |-> ##[0:1000] $fell(link_training_start)", "ori_sva": "property training_completion_timeout;\n@(posedge serdes_clk)     $rose(link_training_start) |-> ##[0:1000] $fell(link_training_start);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: training_completion_timeout  \n**Trigger Condition**: At every rising edge of `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(link_training_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:1000] $fell(link_training_start)`  ", "sva_signals": ["serdes_clk", "link_training_start"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)     $rose(link_training_start) |-> ##[0:1000] $fell(link_training_start)", "sva_name": "p_link_training_completion_window", "full_property": "property training_completion_timeout;\n@(posedge serdes_clk)     $rose(link_training_start) |-> ##[0:1000] $fell(link_training_start)\nendproperty\nassert_training_completion_timeout:assert property (training_completion_timeout) else $error(\"\");", "task_id": "1_10390", "predict_sva": "@(posedge serdes_clk)         $rose(link_training_start) |-> ##[0:1000] $fell(link_training_start)"}
{"id": "853_6_3221", "name": "p_signal_lock_stability", "sva": "@(posedge clk_cdr)     $fell(signal_lock) |-> ##[10:100] $rose(signal_lock)", "ori_sva": "property p_signal_lock_stability;\n@(posedge clk_cdr)     $fell(signal_lock) |-> ##[10:100] $rose(signal_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_signal_lock_stability  \n**Trigger Condition**: At every rising edge of the `clk_cdr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(signal_lock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:100] $rose(signal_lock)`  ", "sva_signals": ["clk_cdr", "[0:0] signal_lock"], "clock": "clk_cdr", "attempts_left": 10, "sva_result": "@(posedge clk_cdr)     $fell(signal_lock) |-> ##[10:100] $rose(signal_lock)", "sva_name": "p_signal_lock_relock_within_10_100_cycles", "full_property": "property p_signal_lock_stability;\n@(posedge clk_cdr)     $fell(signal_lock) |-> ##[10:100] $rose(signal_lock)\nendproperty\nassert_p_signal_lock_stability:assert property (p_signal_lock_stability) else $error(\"\");", "task_id": "1_10420", "predict_sva": "@(posedge clk_cdr)         $fell(signal_lock) |-> ##[10:100] $rose(signal_lock)"}
{"id": "859_12_3300", "name": "p_power_ok_sequence", "sva": "@(posedge mcu_clk)     $rose(pwr_ok_signal) |-> ##[1:5] (core_regs == $past(core_regs, 5))", "ori_sva": "property p_power_ok_sequence;\n@(posedge mcu_clk)     $rose(pwr_ok_signal) |-> ##[1:5] (core_regs == $past(core_regs, 5));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_ok_sequence  \n**Trigger Condition**: At every rising edge of `mcu_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pwr_ok_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] (core_regs == $past(core_regs, 5))`  ", "sva_signals": ["mcu_clk", "pwr_ok_signal", "core_regs"], "clock": "mcu_clk", "attempts_left": 10, "sva_result": "@(posedge mcu_clk)         $rose(pwr_ok_signal) |-> ##[1:5] (core_regs == $past(core_regs, 5))", "sva_name": "p_core_regs_stability_after_pwr_ok", "full_property": "property p_power_ok_sequence;\n@(posedge mcu_clk)         $rose(pwr_ok_signal) |-> ##[1:5] (core_regs == $past(core_regs, 5))\nendproperty\nassert_p_power_ok_sequence:assert property (p_power_ok_sequence) else $error(\"\");", "task_id": "1_10476", "predict_sva": "@(posedge mcu_clk)         $rose(pwr_ok_signal) |-> ##[1:5] core_regs == $past(core_regs, 5)"}
{"id": "863_12_3337", "name": "interrupt_ep_polling", "sva": "@(posedge usb_clk)     usb_ep3_poll_enable |-> ##[1:100] usb_ep3_data_ready", "ori_sva": "property interrupt_ep_polling;\n@(posedge usb_clk)     usb_ep3_poll_enable |-> ##[1:100] usb_ep3_data_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: interrupt_ep_polling  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_ep3_poll_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] usb_ep3_data_ready == 1'b1`  ", "sva_signals": ["usb_clk", "usb_ep3_poll_enable", "[0:0] usb_ep3_data_ready"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_ep3_poll_enable == 1'b1 |-> ##[1:100] usb_ep3_data_ready == 1'b1", "sva_name": "p_usb_ep3_data_ready_within_100_cycles", "full_property": "property interrupt_ep_polling;\n@(posedge usb_clk)     usb_ep3_poll_enable == 1'b1 |-> ##[1:100] usb_ep3_data_ready == 1'b1\nendproperty\nassert_interrupt_ep_polling:assert property (interrupt_ep_polling) else $error(\"\");", "task_id": "1_10512", "predict_sva": "@(posedge usb_clk)         usb_ep3_poll_enable == 1'b1 |-> ##[1:100] usb_ep3_data_ready == 1'b1"}
{"id": "863_7_3355", "name": "data_packet_integrity", "sva": "@(posedge usb_clk)     usb_data_valid |-> ##1 (usb_data_crc == $past(usb_calc_crc))", "ori_sva": "property data_packet_integrity;\n@(posedge usb_clk)     usb_data_valid |-> ##1 (usb_data_crc == $past(usb_calc_crc))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_packet_integrity  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (usb_data_crc == $past(usb_calc_crc))`  ", "sva_signals": ["usb_clk", "[0:0] usb_data_valid", "[0:0] usb_data_crc", "[0:0] usb_calc_crc"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_data_valid == 1'b1 |-> ##1 (usb_data_crc == $past(usb_calc_crc))", "sva_name": "p_usb_data_crc_match", "full_property": "property data_packet_integrity;\n@(posedge usb_clk)     usb_data_valid == 1'b1 |-> ##1 (usb_data_crc == $past(usb_calc_crc))\nendproperty\nassert_data_packet_integrity:assert property (data_packet_integrity) else $error(\"\");", "task_id": "1_10520", "predict_sva": "@(posedge usb_clk)         usb_data_valid == 1'b1 |-> ##1 usb_data_crc == $past(usb_calc_crc)"}
{"id": "865_8_3368", "name": "usb_bulk_out_handshake", "sva": "@(posedge usb_clk)     (usb_bulk_out_transfer && usb_pid_valid) |-> ##[1:4] (usb_ack_received || usb_nak_received || usb_stall_received)", "ori_sva": "property usb_bulk_out_handshake;\n@(posedge usb_clk)     (usb_bulk_out_transfer && usb_pid_valid) |-> ##[1:4] (usb_ack_received || usb_nak_received || usb_stall_received);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_bulk_out_handshake  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_bulk_out_transfer && usb_pid_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] (usb_ack_received || usb_nak_received || usb_stall_received)`  ", "sva_signals": ["usb_clk", "usb_bulk_out_transfer", "usb_pid_valid", "usb_ack_received", "usb_nak_received", "usb_stall_received"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     (usb_bulk_out_transfer && usb_pid_valid) |-> ##[1:4] (usb_ack_received || usb_nak_received || usb_stall_received)", "sva_name": "p_usb_bulk_out_transfer_handshake_window", "full_property": "property usb_bulk_out_handshake;\n@(posedge usb_clk)     (usb_bulk_out_transfer && usb_pid_valid) |-> ##[1:4] (usb_ack_received || usb_nak_received || usb_stall_received)\nendproperty\nassert_usb_bulk_out_handshake:assert property (usb_bulk_out_handshake) else $error(\"\");", "task_id": "1_10545", "predict_sva": "@(posedge usb_clk)         (usb_bulk_out_transfer == 1 && usb_pid_valid == 1) |-> ##[1:4] (usb_ack_received == 1 || usb_nak_received == 1 || usb_stall_received == 1)"}
{"id": "878_11_3545", "name": "temperature_monitor_response", "sva": "@(posedge flash_clk)     (temp_sensor_critical && !shutdown_override) |-> ##[1:5] write_throttling_enabled", "ori_sva": "property temperature_monitor_response;\n@(posedge flash_clk)     (temp_sensor_critical && !shutdown_override) |-> ##[1:5] write_throttling_enabled;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: temperature_monitor_response  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_sensor_critical && !shutdown_override`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] write_throttling_enabled`  ", "sva_signals": ["flash_clk", "shutdown_override", "[0:0] temp_sensor_critical", "[0:0] write_throttling_enabled"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         (temp_sensor_critical && !shutdown_override) |-> ##[1:5] write_throttling_enabled", "sva_name": "p_write_throttling_enable_on_critical_temp", "full_property": "property temperature_monitor_response;\n@(posedge flash_clk)         (temp_sensor_critical && !shutdown_override) |-> ##[1:5] write_throttling_enabled\nendproperty\nassert_temperature_monitor_response:assert property (temperature_monitor_response) else $error(\"\");", "task_id": "1_10672", "predict_sva": "@(posedge flash_clk)         (temp_sensor_critical == 1 && shutdown_override == 0) |-> ##[1:5] write_throttling_enabled == 1"}
{"id": "878_2_3526", "name": "bad_block_remap_after_wear", "sva": "@(posedge flash_clk)     (write_cycle_count >= max_rated_cycles) |-> ##2 remap_controller_active", "ori_sva": "property bad_block_remap_after_wear;\n@(posedge flash_clk)     (write_cycle_count >= max_rated_cycles) |-> ##2 remap_controller_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bad_block_remap_after_wear  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_cycle_count >= max_rated_cycles`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 remap_controller_active`  ", "sva_signals": ["flash_clk", "[0:0] write_cycle_count", "[0:0] max_rated_cycles", "[0:0] remap_controller_active"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active", "sva_name": "p_remap_controller_activation_after_max_cycles", "full_property": "property bad_block_remap_after_wear;\n@(posedge flash_clk)         write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active\nendproperty\nassert_bad_block_remap_after_wear:assert property (bad_block_remap_after_wear) else $error(\"\");", "task_id": "1_10675", "predict_sva": "@(posedge flash_clk)         write_cycle_count >= max_rated_cycles |-> ##2 remap_controller_active == 1"}
{"id": "881_2_3564", "name": "address_mapping_unique", "sva": "@(posedge flash_clk)     (flash_addr_valid && (flash_addr_bus[31:28] == 4'h0)) |->     ##1 $onehot0(flash_chip_select)", "ori_sva": "property address_mapping_unique;\n@(posedge flash_clk)     (flash_addr_valid && (flash_addr_bus[31:28] == 4'h0)) |->     ##1 $onehot0(flash_chip_select);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: address_mapping_unique  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flash_addr_valid && (flash_addr_bus[31:28] == 4'h0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $onehot0(flash_chip_select)`  ", "sva_signals": ["flash_clk", "[0:0] flash_addr_valid", "[31:0] flash_addr_bus", "[0:0] flash_chip_select"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)     (flash_addr_valid && (flash_addr_bus[31:28] == 4'h0)) |-> ##1 $onehot0(flash_chip_select)", "sva_name": "p_flash_chip_select_onehot0_on_valid_addr", "full_property": "property address_mapping_unique;\n@(posedge flash_clk)     (flash_addr_valid && (flash_addr_bus[31:28] == 4'h0)) |-> ##1 $onehot0(flash_chip_select)\nendproperty\nassert_address_mapping_unique:assert property (address_mapping_unique) else $error(\"\");", "task_id": "1_10709", "predict_sva": "@(posedge flash_clk)         (flash_addr_valid == 1 && flash_addr_bus[31:28] == 4'h0) |-> ##1 $onehot0(flash_chip_select)"}
{"id": "886_8_3634", "name": "sink_cap_response_time", "sva": "@(posedge pd_clk)     $rose(pd_source_cap_sent) |-> ##[1:15] pd_sink_cap_received", "ori_sva": "property sink_cap_response_time;\n@(posedge pd_clk)     $rose(pd_source_cap_sent) |-> ##[1:15] pd_sink_cap_received;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sink_cap_response_time  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pd_source_cap_sent)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:15] pd_sink_cap_received`  ", "sva_signals": ["pd_clk", "pd_source_cap_sent", "pd_sink_cap_received"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     $rose(pd_source_cap_sent) |-> ##[1:15] pd_sink_cap_received", "sva_name": "p_sink_cap_received_within_15_cycles_after_source_cap_sent", "full_property": "property sink_cap_response_time;\n@(posedge pd_clk)     $rose(pd_source_cap_sent) |-> ##[1:15] pd_sink_cap_received\nendproperty\nassert_sink_cap_response_time:assert property (sink_cap_response_time) else $error(\"\");", "task_id": "1_10775", "predict_sva": "@(posedge pd_clk)         $rose(pd_source_cap_sent) |-> ##[1:15] pd_sink_cap_received"}
{"id": "887_6_3640", "name": "consecutive_error_handling", "sva": "@(posedge pd_clk)     pd_error_count > 3 |-> ##1 pd_safe_shutdown", "ori_sva": "property consecutive_error_handling;\n@(posedge pd_clk)     pd_error_count > 3 |-> ##1 pd_safe_shutdown;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: consecutive_error_handling  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pd_error_count > 3`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 pd_safe_shutdown`  ", "sva_signals": ["pd_clk", "[0:0] pd_error_count", "[0:0] pd_safe_shutdown"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     pd_error_count > 3 |-> ##1 pd_safe_shutdown", "sva_name": "p_pd_safe_shutdown_on_error_count", "full_property": "property consecutive_error_handling;\n@(posedge pd_clk)     pd_error_count > 3 |-> ##1 pd_safe_shutdown\nendproperty\nassert_consecutive_error_handling:assert property (consecutive_error_handling) else $error(\"\");", "task_id": "1_10783", "predict_sva": "@(posedge pd_clk)         pd_error_count > 3 |-> ##1 pd_safe_shutdown == 1"}
{"id": "888_4_3670", "name": "p_frame_rate_sync", "sva": "@(posedge isp_clk)     $changed(frame_rate_ctrl) |-> ##[1:5] $stable(vsync_period)", "ori_sva": "property p_frame_rate_sync;\n@(posedge isp_clk)     $changed(frame_rate_ctrl) |-> ##[1:5] $stable(vsync_period);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_frame_rate_sync  \n**Trigger Condition**: At every rising edge of `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(frame_rate_ctrl)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $stable(vsync_period)`  ", "sva_signals": ["isp_clk", "[0:0] frame_rate_ctrl", "[0:0] vsync_period"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     $changed(frame_rate_ctrl) |-> ##[1:5] $stable(vsync_period)", "sva_name": "p_vsync_period_stability_after_frame_rate_ctrl_change", "full_property": "property p_frame_rate_sync;\n@(posedge isp_clk)     $changed(frame_rate_ctrl) |-> ##[1:5] $stable(vsync_period)\nendproperty\nassert_p_frame_rate_sync:assert property (p_frame_rate_sync) else $error(\"\");", "task_id": "1_10792", "predict_sva": "@(posedge isp_clk)         $changed(frame_rate_ctrl) |-> ##[1:5] $stable(vsync_period)"}
{"id": "894_14_3727", "name": "output_saturation", "sva": "@(posedge dsp_clk)     (dsp_output > 'h7FFF_FFFF) |-> dsp_output == 'h7FFF_FFFF", "ori_sva": "property output_saturation;\n@(posedge dsp_clk)     (dsp_output > 'h7FFF_FFFF) |-> dsp_output == 'h7FFF_FFFF;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: output_saturation  \n**Trigger Condition**: At every rising edge of the `dsp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dsp_output > 'h7FFF_FFFF`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dsp_output == 'h7FFF_FFFF`", "sva_signals": ["dsp_clk", "[31:0] dsp_output"], "clock": "dsp_clk", "attempts_left": 10, "sva_result": "@(posedge dsp_clk)         dsp_output > 'h7FFF_FFFF |-> dsp_output == 'h7FFF_FFFF", "sva_name": "p_dsp_output_saturation", "full_property": "property output_saturation;\n@(posedge dsp_clk)         dsp_output > 'h7FFF_FFFF |-> dsp_output == 'h7FFF_FFFF\nendproperty\nassert_output_saturation:assert property (output_saturation) else $error(\"\");", "task_id": "1_10859", "predict_sva": "@(posedge dsp_clk)         dsp_output > 'h7FFF_FFFF |-> dsp_output == 'h7FFF_FFFF"}
{"id": "10_17_0465", "name": "p_past_val_17", "sva": "@(posedge clk)     $past(flush, 1) |-> $past(cache_hit, 2) == 0", "ori_sva": "property p_past_val_17;\n@(posedge clk)     $past(flush, 1) |-> $past(cache_hit, 2) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Flush_Cache_Hit_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(flush, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cache_hit, 2) == 0`  ", "sva_signals": ["clk", "rst_n", "[0:0] flush", "[0:0] cache_hit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(flush, 1) |-> $past(cache_hit, 2) == 0;", "sva_name": "p_flush_cache_hit_check", "full_property": "property p_Flush_Cache_Hit_Check;\n@(posedge clk)         $past(flush, 1) |-> $past(cache_hit, 2) == 0;\nendproperty\nassert_p_Flush_Cache_Hit_Check:assert property (p_Flush_Cache_Hit_Check) else $error(\"\");", "task_id": "2_5", "predict_sva": "@(posedge clk)         $past(flush, 1) |-> !$past(cache_hit, 2)"}
{"id": "10_21_0473", "name": "p_past_val_21", "sva": "@(posedge clk)     $past(packet_start, 3) |-> $past(header_valid, 2)", "ori_sva": "property p_past_val_21;\n@(posedge clk)     $past(packet_start, 3) |-> $past(header_valid, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Start_Header_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(packet_start, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(header_valid, 2)`  ", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] header_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(packet_start, 3) |-> $past(header_valid, 2);", "sva_name": "p_header_valid_after_packet_start", "full_property": "property p_Packet_Start_Header_Valid;\n@(posedge clk)         $past(packet_start, 3) |-> $past(header_valid, 2);\nendproperty\nassert_p_Packet_Start_Header_Valid:assert property (p_Packet_Start_Header_Valid) else $error(\"\");", "task_id": "2_10", "predict_sva": "@(posedge clk)         $past(packet_start, 3) |-> $past(header_valid, 2)"}
{"id": "10_32_0476", "name": "p_past_val_32", "sva": "@(posedge clk)     $past(sync_pulse, 2) |-> $past(sync_req, 3)", "ori_sva": "property p_past_val_32;\n@(posedge clk)     $past(sync_pulse, 2) |-> $past(sync_req, 3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Req_After_Pulse  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(sync_pulse, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sync_req, 3)`  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] sync_req"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(sync_pulse, 2) |-> $past(sync_req, 3);", "sva_name": "p_sync_pulse_sync_req_relation", "full_property": "property p_Sync_Req_After_Pulse;\n@(posedge clk)         $past(sync_pulse, 2) |-> $past(sync_req, 3);\nendproperty\nassert_p_Sync_Req_After_Pulse:assert property (p_Sync_Req_After_Pulse) else $error(\"\");", "task_id": "2_23", "predict_sva": "@(posedge clk)         $past(sync_pulse, 2) |-> $past(sync_req, 3)"}
{"id": "10_37_0474", "name": "p_past_val_37", "sva": "@(posedge clk)     $past(clock_gate_en, 3) |-> $past(clock_active, 4)", "ori_sva": "property p_past_val_37;\n@(posedge clk)     $past(clock_gate_en, 3) |-> $past(clock_active, 4);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Past_Clock_Gate_Enable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(clock_gate_en, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(clock_active, 4)`  ", "sva_signals": ["clk", "rst_n", "[0:0] clock_gate_en", "[0:0] clock_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(clock_gate_en, 3) |-> $past(clock_active, 4);", "sva_name": "p_clock_gate_en_clock_active_relation", "full_property": "property p_Past_Clock_Gate_Enable;\n@(posedge clk)         $past(clock_gate_en, 3) |-> $past(clock_active, 4);\nendproperty\nassert_p_Past_Clock_Gate_Enable:assert property (p_Past_Clock_Gate_Enable) else $error(\"\");", "task_id": "2_26", "predict_sva": "@(posedge clk)         $past(clock_gate_en, 3) |-> $past(clock_active, 4)"}
{"id": "11_10_0519", "name": "p_and_10", "sva": "@(posedge clk)     (fifo_empty && rd_en) |-> ##1 underflow", "ori_sva": "property p_and_10;\n@(posedge clk)     (fifo_empty && rd_en) |-> ##1 underflow\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Underflow  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_empty && rd_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 underflow`  \n\n(Note: The assertion checks that if the FIFO is empty (`fifo_empty`) and a read operation is attempted (`rd_en`), then in the next clock cycle (`##1`), an underflow condition (`underflow`) must occur.)", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] rd_en", "[0:0] underflow"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         fifo_empty && rd_en |-> ##1 underflow;", "sva_name": "p_fifo_underflow_on_empty_read", "full_property": "property p_Fifo_Underflow;\n@(posedge clk)         fifo_empty && rd_en |-> ##1 underflow;\nendproperty\nassert_p_Fifo_Underflow:assert property (p_Fifo_Underflow) else $error(\"\");", "task_id": "2_49", "predict_sva": "@(posedge clk)         (fifo_empty == 1 && rd_en == 1) |-> ##1 (underflow == 1)"}
{"id": "11_12_0494", "name": "p_and_12", "sva": "@(posedge clk)     (ack && !err) && (timeout_counter == 0) |-> complete", "ori_sva": "property p_and_12;\n@(posedge clk)     (ack && !err) && (timeout_counter == 0) |-> complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_AckNoErrTimeoutComplete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(ack && !err) && (timeout_counter == 0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `complete`", "sva_signals": ["clk", "rst_n", "[0:0] ack", "[0:0] err", "[0:0] complete", "[0:0] timeout_counter"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (ack && !err) && (timeout_counter == 0) |-> complete;", "sva_name": "p_complete_on_ack_and_no_timeout", "full_property": "property p_AckNoErrTimeoutComplete;\n@(posedge clk)         (ack && !err) && (timeout_counter == 0) |-> complete;\nendproperty\nassert_p_AckNoErrTimeoutComplete:assert property (p_AckNoErrTimeoutComplete) else $error(\"\");", "task_id": "2_50", "predict_sva": "@(posedge clk)         (ack == 1 && err == 0 && timeout_counter == 0) |-> (complete == 1)"}
{"id": "11_19_0537", "name": "p_and_19", "sva": "@(posedge clk)     (temp_high && !fan_on) |-> ##[1:3] fan_start", "ori_sva": "property p_and_19;\n@(posedge clk)     (temp_high && !fan_on) |-> ##[1:3] fan_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fan_Start_After_Temp_High  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_high && !fan_on`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] fan_start`  ", "sva_signals": ["clk", "rst_n", "[0:0] temp_high", "[0:0] fan_on", "[0:0] fan_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (temp_high && !fan_on) |-> ##[1:3] fan_start;", "sva_name": "p_fan_start_within_3_cycles_after_temp_high", "full_property": "property p_Fan_Start_After_Temp_High;\n@(posedge clk)         (temp_high && !fan_on) |-> ##[1:3] fan_start;\nendproperty\nassert_p_Fan_Start_After_Temp_High:assert property (p_Fan_Start_After_Temp_High) else $error(\"\");", "task_id": "2_55", "predict_sva": "@(posedge clk)         (temp_high == 1 && fan_on == 0) |-> ##[1:3] fan_start == 1"}
{"id": "11_43_0542", "name": "p_and_43", "sva": "@(posedge clk)     (uart_tx_empty && uart_tx_en) && !uart_busy |-> uart_tx_start", "ori_sva": "property p_and_43;\n@(posedge clk)     (uart_tx_empty && uart_tx_en) && !uart_busy |-> uart_tx_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_uart_tx_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(uart_tx_empty && uart_tx_en) && !uart_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `uart_tx_start`", "sva_signals": ["clk", "rst_n", "[0:0] uart_tx_empty", "[0:0] uart_tx_en", "[0:0] uart_busy", "[0:0] uart_tx_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (uart_tx_empty && uart_tx_en) && !uart_busy |-> uart_tx_start;", "sva_name": "p_uart_tx_start_when_empty_and_en", "full_property": "property p_uart_tx_start;\n@(posedge clk)         (uart_tx_empty && uart_tx_en) && !uart_busy |-> uart_tx_start;\nendproperty\nassert_p_uart_tx_start:assert property (p_uart_tx_start) else $error(\"\");", "task_id": "2_81", "predict_sva": "@(posedge clk)         (uart_tx_empty == 1 && uart_tx_en == 1 && uart_busy == 0) |-> (uart_tx_start == 1)"}
{"id": "12_11_0565", "name": "p_or_11", "sva": "@(posedge clk)     (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt", "ori_sva": "property p_or_11;\n@(posedge clk)     (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Interrupt_On_Fifo_Error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fifo_overflow || fifo_underflow)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 error_interrupt`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_overflow", "[0:0] fifo_underflow", "[0:0] error_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt;", "sva_name": "p_error_interrupt_after_fifo_error", "full_property": "property p_Error_Interrupt_On_Fifo_Error;\n@(posedge clk)         (fifo_overflow || fifo_underflow) |-> ##1 error_interrupt;\nendproperty\nassert_p_Error_Interrupt_On_Fifo_Error:assert property (p_Error_Interrupt_On_Fifo_Error) else $error(\"\");", "task_id": "2_96", "predict_sva": "@(posedge clk)         (fifo_overflow == 1 || fifo_underflow == 1) |-> ##1 error_interrupt == 1"}
{"id": "12_19_0550", "name": "p_or_19", "sva": "@(posedge clk)     (calib_start || manual_override) |-> calib_active", "ori_sva": "property p_or_19;\n@(posedge clk)     (calib_start || manual_override) |-> calib_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_calib_activation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(calib_start || manual_override)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `calib_active`", "sva_signals": ["clk", "rst_n", "[0:0] calib_start", "[0:0] manual_override", "[0:0] calib_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (calib_start || manual_override) |-> calib_active;", "sva_name": "p_calib_active_on_start_or_override", "full_property": "property p_calib_activation;\n@(posedge clk)         (calib_start || manual_override) |-> calib_active;\nendproperty\nassert_p_calib_activation:assert property (p_calib_activation) else $error(\"\");", "task_id": "2_103", "predict_sva": "@(posedge clk)         (calib_start == 1 || manual_override == 1) |-> calib_active == 1"}
{"id": "12_26_0578", "name": "p_or_26", "sva": "@(posedge clk)     (sensor_a_alert || sensor_b_alert) |-> safety_trigger", "ori_sva": "property p_or_26;\n@(posedge clk)     (sensor_a_alert || sensor_b_alert) |-> safety_trigger\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sensor_Alert_Trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_a_alert || sensor_b_alert`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `safety_trigger`", "sva_signals": ["clk", "rst_n", "[0:0] sensor_a_alert", "[0:0] sensor_b_alert", "[0:0] safety_trigger"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sensor_a_alert || sensor_b_alert) |-> safety_trigger;", "sva_name": "p_safety_trigger_on_sensor_alert", "full_property": "property p_Sensor_Alert_Trigger;\n@(posedge clk)         (sensor_a_alert || sensor_b_alert) |-> safety_trigger;\nendproperty\nassert_p_Sensor_Alert_Trigger:assert property (p_Sensor_Alert_Trigger) else $error(\"\");", "task_id": "2_111", "predict_sva": "@(posedge clk)         (sensor_a_alert == 1 || sensor_b_alert == 1) |-> safety_trigger == 1"}
{"id": "12_29_0589", "name": "p_or_29", "sva": "@(posedge clk)     (voltage_high || voltage_low) |-> power_adjust", "ori_sva": "property p_or_29;\n@(posedge clk)     (voltage_high || voltage_low) |-> power_adjust\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Adjust_On_Voltage  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(voltage_high || voltage_low)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `power_adjust`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_high", "[0:0] voltage_low", "[0:0] power_adjust"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (voltage_high || voltage_low) |-> power_adjust;", "sva_name": "p_power_adjust_on_voltage_event", "full_property": "property p_Power_Adjust_On_Voltage;\n@(posedge clk)         (voltage_high || voltage_low) |-> power_adjust;\nendproperty\nassert_p_Power_Adjust_On_Voltage:assert property (p_Power_Adjust_On_Voltage) else $error(\"\");", "task_id": "2_115", "predict_sva": "@(posedge clk)         (voltage_high == 1 || voltage_low == 1) |-> power_adjust == 1"}
{"id": "12_32_0570", "name": "p_or_32", "sva": "@(posedge clk)     (phase_err || freq_err) |-> pll_adjust", "ori_sva": "property p_or_32;\n@(posedge clk)     (phase_err || freq_err) |-> pll_adjust\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PLL_Adjust_On_Error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phase_err || freq_err`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pll_adjust`", "sva_signals": ["clk", "rst_n", "[0:0] phase_err", "[0:0] freq_err", "[0:0] pll_adjust"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (phase_err || freq_err) |-> pll_adjust;", "sva_name": "p_pll_adjust_on_error", "full_property": "property p_PLL_Adjust_On_Error;\n@(posedge clk)         (phase_err || freq_err) |-> pll_adjust;\nendproperty\nassert_p_PLL_Adjust_On_Error:assert property (p_PLL_Adjust_On_Error) else $error(\"\");", "task_id": "2_119", "predict_sva": "@(posedge clk)         (phase_err == 1 || freq_err == 1) |-> pll_adjust == 1"}
{"id": "12_34_0587", "name": "p_or_34", "sva": "@(posedge clk)     (mem_read || mem_write) |-> mem_ready", "ori_sva": "property p_or_34;\n@(posedge clk)     (mem_read || mem_write) |-> mem_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_access_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(mem_read || mem_write)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mem_ready`", "sva_signals": ["clk", "rst_n", "[0:0] mem_read", "[0:0] mem_write", "[0:0] mem_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (mem_read || mem_write) |-> mem_ready;", "sva_name": "p_mem_ready_on_read_or_write", "full_property": "property p_mem_access_ready;\n@(posedge clk)         (mem_read || mem_write) |-> mem_ready;\nendproperty\nassert_p_mem_access_ready:assert property (p_mem_access_ready) else $error(\"\");", "task_id": "2_121", "predict_sva": "@(posedge clk)         (mem_read == 1 || mem_write == 1) |-> mem_ready == 1"}
{"id": "12_40_0583", "name": "p_or_40", "sva": "@(posedge clk)     (clock_stable || reset_released) |-> init_sequence", "ori_sva": "property p_or_40;\n@(posedge clk)     (clock_stable || reset_released) |-> init_sequence\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Init_Sequence_Trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(clock_stable || reset_released)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `init_sequence`", "sva_signals": ["clk", "rst_n", "[0:0] clock_stable", "[0:0] reset_released", "[0:0] init_sequence"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (clock_stable || reset_released) |-> init_sequence;", "sva_name": "p_init_sequence_on_stable_or_reset", "full_property": "property p_Init_Sequence_Trigger;\n@(posedge clk)         (clock_stable || reset_released) |-> init_sequence;\nendproperty\nassert_p_Init_Sequence_Trigger:assert property (p_Init_Sequence_Trigger) else $error(\"\");", "task_id": "2_128", "predict_sva": "@(posedge clk)         (clock_stable == 1 || reset_released == 1) |-> init_sequence == 1"}
{"id": "12_48_0592", "name": "p_or_48", "sva": "@(posedge clk)     (voltage_ok || current_ok) |-> power_ok", "ori_sva": "property p_or_48;\n@(posedge clk)     (voltage_ok || current_ok) |-> power_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_ok_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(voltage_ok || current_ok)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `power_ok`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_ok", "[0:0] current_ok", "[0:0] power_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (voltage_ok || current_ok) |-> power_ok;", "sva_name": "p_power_ok_when_voltage_or_current_ok", "full_property": "property p_power_ok_check;\n@(posedge clk)         (voltage_ok || current_ok) |-> power_ok;\nendproperty\nassert_p_power_ok_check:assert property (p_power_ok_check) else $error(\"\");", "task_id": "2_136", "predict_sva": "@(posedge clk)         (voltage_ok == 1 || current_ok == 1) |-> power_ok == 1"}
{"id": "13_34_0644", "name": "p_not_34", "sva": "@(posedge clk) !(authentication_fail && !retry) |-> authenticated", "ori_sva": "property p_not_34;\n@(posedge clk) !(authentication_fail && !retry) |-> authenticated;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Authentication_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(authentication_fail && !retry)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `authenticated`  ", "sva_signals": ["clk", "rst_n", "[0:0] authentication_fail", "[0:0] retry", "[0:0] authenticated"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(authentication_fail && !retry) |-> authenticated;", "sva_name": "p_authenticated_asserted_when_not_auth_fail_and_retry", "full_property": "property p_Authentication_Check;\n@(posedge clk)         !(authentication_fail && !retry) |-> authenticated;\nendproperty\nassert_p_Authentication_Check:assert property (p_Authentication_Check) else $error(\"\");", "task_id": "2_171", "predict_sva": "@(posedge clk)         !(authentication_fail && !retry) |-> authenticated"}
{"id": "13_43_0640", "name": "p_not_43", "sva": "@(posedge clk) !(pipeline_stall && !flush) |-> pipeline_flow", "ori_sva": "property p_not_43;\n@(posedge clk) !(pipeline_stall && !flush) |-> pipeline_flow;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_flow  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(pipeline_stall && !flush)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pipeline_flow`", "sva_signals": ["clk", "rst_n", "[0:0] pipeline_stall", "[0:0] flush", "[0:0] pipeline_flow"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(pipeline_stall && !flush) |-> pipeline_flow;", "sva_name": "p_pipeline_flow_on_no_stall_or_flush", "full_property": "property p_pipeline_flow;\n@(posedge clk)         !(pipeline_stall && !flush) |-> pipeline_flow;\nendproperty\nassert_p_pipeline_flow:assert property (p_pipeline_flow) else $error(\"\");", "task_id": "2_183", "predict_sva": "@(posedge clk)         !(pipeline_stall && !flush) |-> pipeline_flow == 1"}
{"id": "1_35_0057", "name": "p_fixed_delay_35", "sva": "@(posedge clk)     (infiniband_packet_valid && !congestion) |-> ##4 infiniband_ack", "ori_sva": "property p_fixed_delay_35;\n@(posedge clk)     (infiniband_packet_valid && !congestion) |-> ##4 infiniband_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Infiniband_Ack_After_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `infiniband_packet_valid && !congestion`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 infiniband_ack`  \n\n(Explanation: The assertion checks that if an Infiniband packet is valid (`infiniband_packet_valid`) and there is no congestion (`!congestion`), then exactly 4 clock cycles later, an acknowledgment (`infiniband_ack`) must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] infiniband_packet_valid", "[0:0] congestion", "[0:0] infiniband_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (infiniband_packet_valid && !congestion) |-> ##4 infiniband_ack;", "sva_name": "p_infiniband_ack_after_packet_valid_no_congestion", "full_property": "property p_Infiniband_Ack_After_Valid;\n@(posedge clk)         (infiniband_packet_valid && !congestion) |-> ##4 infiniband_ack;\nendproperty\nassert_p_Infiniband_Ack_After_Valid:assert property (p_Infiniband_Ack_After_Valid) else $error(\"\");", "task_id": "2_285", "predict_sva": "@(posedge clk)         (infiniband_packet_valid == 1 && congestion == 0) |-> ##4 (infiniband_ack == 1)"}
{"id": "3_34_0119", "name": "p_bist_start_complete", "sva": "@(posedge clk)     bist_start |-> (bist_complete && !bist_error)", "ori_sva": "property p_bist_start_complete;\n@(posedge clk)     bist_start |-> (bist_complete && !bist_error);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bist_start_complete  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bist_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bist_complete && !bist_error`", "sva_signals": ["clk", "rst_n", "[0:0] bist_start", "[0:0] bist_complete", "[0:0] bist_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         bist_start == 1'b1 |-> bist_complete && !bist_error;", "sva_name": "p_bist_start_complete_no_error", "full_property": "property p_bist_start_complete;\n@(posedge clk)         bist_start == 1'b1 |-> bist_complete && !bist_error;\nendproperty\nassert_p_bist_start_complete:assert property (p_bist_start_complete) else $error(\"\");", "task_id": "2_380", "predict_sva": "@(posedge clk)         bist_start == 1'b1 |-> bist_complete == 1'b1 && bist_error == 1'b0"}
{"id": "3_40_0101", "name": "p_scan_chain_shift", "sva": "@(posedge clk)     scan_shift_en |-> (scan_data_out && !scan_capture)", "ori_sva": "property p_scan_chain_shift;\n@(posedge clk)     scan_shift_en |-> (scan_data_out && !scan_capture);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_scan_shift_en_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `scan_shift_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(scan_data_out && !scan_capture)`", "sva_signals": ["clk", "rst_n", "[0:0] scan_shift_en", "[0:0] scan_data_out", "[0:0] scan_capture"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     scan_shift_en == 1'b1 |-> (scan_data_out && !scan_capture);", "sva_name": "p_scan_shift_en_data_capture", "full_property": "property p_scan_shift_en_check;\n@(posedge clk)     scan_shift_en == 1'b1 |-> (scan_data_out && !scan_capture);\nendproperty\nassert_p_scan_shift_en_check:assert property (p_scan_shift_en_check) else $error(\"\");", "task_id": "2_387", "predict_sva": "@(posedge clk)         scan_shift_en == 1'b1 |-> scan_data_out == 1'b1 && scan_capture == 1'b0"}
{"id": "3_46_0154", "name": "p_bus_error_terminate", "sva": "@(posedge clk)     bus_error |-> (transaction_terminate && !bus_ok)", "ori_sva": "property p_bus_error_terminate;\n@(posedge clk)     bus_error |-> (transaction_terminate && !bus_ok);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Bus_Error_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bus_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(transaction_terminate && !bus_ok)`  \n\nThe assertion checks that whenever a bus error occurs (`bus_error` is high), the transaction must be terminated (`transaction_terminate` is high) and the bus must not be in an OK state (`!bus_ok`) at the same clock edge.", "sva_signals": ["clk", "rst_n", "[0:0] bus_error", "[0:0] transaction_terminate", "[0:0] bus_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         bus_error == 1'b1 |-> (transaction_terminate && !bus_ok);", "sva_name": "p_bus_error_transaction_terminate_and_bus_not_ok", "full_property": "property p_Bus_Error_Check;\n@(posedge clk)         bus_error == 1'b1 |-> (transaction_terminate && !bus_ok);\nendproperty\nassert_p_Bus_Error_Check:assert property (p_Bus_Error_Check) else $error(\"\");", "task_id": "2_393", "predict_sva": "@(posedge clk)         bus_error == 1'b1 |-> transaction_terminate == 1'b1 && bus_ok == 1'b0"}
{"id": "4_13_0193", "name": "p_pipeline_stage_valid", "sva": "@(posedge clk)     stage1_valid |=> stage2_valid", "ori_sva": "property p_pipeline_stage_valid;\n@(posedge clk)     stage1_valid |=> stage2_valid;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Stage1_to_Stage2_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `stage1_valid == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `stage2_valid == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent should be checked in the next clock cycle after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] stage1_valid", "[0:0] stage2_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         stage1_valid == 1'b1 |=> stage2_valid == 1'b1;", "sva_name": "p_stage2_valid_after_stage1_valid", "full_property": "property p_Stage1_to_Stage2_Valid;\n@(posedge clk)         stage1_valid == 1'b1 |=> stage2_valid == 1'b1;\nendproperty\nassert_p_Stage1_to_Stage2_Valid:assert property (p_Stage1_to_Stage2_Valid) else $error(\"\");", "task_id": "2_407", "predict_sva": "@(posedge clk)         stage1_valid == 1'b1 |-> ##1 stage2_valid == 1'b1"}
{"id": "5_13_0215", "name": "p_13", "sva": "@(posedge clk)     (error_flag && !reset)[*3] |-> system_halt", "ori_sva": "property p_13;\n@(posedge clk)     (error_flag && !reset)[*3] |-> system_halt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Error_Flag_Halt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(error_flag && !reset)[*3]` (error_flag is high and reset is low for 3 consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `system_halt` (the system enters a halt state)", "sva_signals": ["clk", "reset", "[0:0] error_flag", "[0:0] system_halt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (error_flag && !reset)[*3] |-> system_halt;", "sva_name": "p_system_halt_on_error_flag_and_reset", "full_property": "property p_Error_Flag_Halt;\n@(posedge clk)     (error_flag && !reset)[*3] |-> system_halt;\nendproperty\nassert_p_Error_Flag_Halt:assert property (p_Error_Flag_Halt) else $error(\"\");", "task_id": "2_456", "predict_sva": "@(posedge clk)         (error_flag == 1 && reset == 0) [*3] |-> system_halt == 1"}
{"id": "10_2_0450", "name": "p_fifo_ptr_wrap", "sva": "@(posedge clk)     $past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20 |-> wr_ptr == 'h21", "ori_sva": "property p_fifo_ptr_wrap;\n@(posedge clk)     $past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20 |-> wr_ptr == 'h21;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wr_ptr_sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wr_ptr == 'h21`  ", "sva_signals": ["clk", "rst_n", "[4:0] wr_ptr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20) |-> (wr_ptr == 'h21);", "sva_name": "p_wr_ptr_increment_sequence", "full_property": "property p_wr_ptr_sequence;\n@(posedge clk)         ($past(wr_ptr,3) == 'h1F && $past(wr_ptr,2) == 'h20) |-> (wr_ptr == 'h21);\nendproperty\nassert_p_wr_ptr_sequence:assert property (p_wr_ptr_sequence) else $error(\"\");", "task_id": "2_662", "predict_sva": "@(posedge clk)         ($past(wr_ptr, 3) == 'h1F && $past(wr_ptr, 2) == 'h20) |-> (wr_ptr == 'h21)"}
{"id": "10_40_0496", "name": "p_sdram_refresh", "sva": "@(posedge clk)     $past(ref_cnt,7) == 0 |-> $past(ref_req,1)", "ori_sva": "property p_sdram_refresh;\n@(posedge clk)     $past(ref_cnt,7) == 0 |-> $past(ref_req,1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_RefReq_After_ZeroRefCnt  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(ref_cnt, 7) == 0`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ref_req, 1)`  ", "sva_signals": ["clk", "rst_n", "[15:0] ref_cnt", "[0:0] ref_req"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(ref_cnt, 7) == 0 |-> $past(ref_req, 1);", "sva_name": "p_ref_req_after_ref_cnt_zero_7cycles", "full_property": "property p_RefReq_After_ZeroRefCnt;\n@(posedge clk)         $past(ref_cnt, 7) == 0 |-> $past(ref_req, 1);\nendproperty\nassert_p_RefReq_After_ZeroRefCnt:assert property (p_RefReq_After_ZeroRefCnt) else $error(\"\");", "task_id": "2_673", "predict_sva": "@(posedge clk)         $past(ref_cnt, 7) == 0 |-> $past(ref_req, 1) == 1"}
{"id": "10_48_0489", "name": "p_clock_domain_crossing", "sva": "@(posedge clk)     $past(sync_stage1,2) == $past(sync_stage2,1)", "ori_sva": "property p_clock_domain_crossing;\n@(posedge clk)     $past(sync_stage1,2) == $past(sync_stage2,1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Stages_Match  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a direct assertion, not an implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `$past(sync_stage1, 2) == $past(sync_stage2, 1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_stage1", "[0:0] sync_stage2"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(sync_stage1, 2) == $past(sync_stage2, 1);", "sva_name": "p_sync_stage1_sync_stage2_relation", "full_property": "property p_Sync_Stages_Match;\n@(posedge clk)     $past(sync_stage1, 2) == $past(sync_stage2, 1);\nendproperty\nassert_p_Sync_Stages_Match:assert property (p_Sync_Stages_Match) else $error(\"\");", "task_id": "2_680", "predict_sva": "@(posedge clk)         $past(sync_stage1, 2) == $past(sync_stage2, 1)"}
{"id": "11_5_0509", "name": "p_and_5", "sva": "@(negedge clk) (fifo_full && write_en) |-> $past(error, 1)", "ori_sva": "property p_and_5;\n@(negedge clk) (fifo_full && write_en) |-> $past(error, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FifoFull_WriteEn_Error  \n**Trigger Condition**: At every negedge of the `clk`;  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_full && write_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(error, 1)`  \n\n(Note: The assertion checks that whenever `fifo_full` and `write_en` are both true at the falling edge of `clk`, the value of `error` from the previous clock cycle must be true.)", "sva_signals": ["clk", "rst_n", "[0:0] fifo_full", "[0:0] write_en", "[0:0] error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (fifo_full && write_en) |-> $past(error, 1);", "sva_name": "p_error_asserted_on_fifo_full_write", "full_property": "property p_FifoFull_WriteEn_Error;\n@(negedge clk)     (fifo_full && write_en) |-> $past(error, 1);\nendproperty\nassert_p_FifoFull_WriteEn_Error:assert property (p_FifoFull_WriteEn_Error) else $error(\"\");", "task_id": "2_730", "predict_sva": "@(negedge clk)         (fifo_full == 1 && write_en == 1) |-> ($past(error) == 1)"}
{"id": "12_3_0569", "name": "p_or_3", "sva": "@(posedge clk)     (valid || bypass) && ready |-> ##2 done", "ori_sva": "property p_or_3;\n@(posedge clk)     (valid || bypass) && ready |-> ##2 done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_valid_bypass_ready_to_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(valid || bypass) && ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 done`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] bypass", "[0:0] ready", "[0:0] done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((valid || bypass) && ready) |-> ##2 done;", "sva_name": "p_done_after_valid_or_bypass_ready", "full_property": "property p_valid_bypass_ready_to_done;\n@(posedge clk)         ((valid || bypass) && ready) |-> ##2 done;\nendproperty\nassert_p_valid_bypass_ready_to_done:assert property (p_valid_bypass_ready_to_done) else $error(\"\");", "task_id": "2_764", "predict_sva": "@(posedge clk)         ((valid || bypass) && ready) |-> ##2 done"}
{"id": "12_37_0607", "name": "p_or_37", "sva": "@(posedge clk)     (phase_lock || freq_lock) |-> locked_status", "ori_sva": "property p_or_37;\n@(posedge clk)     (phase_lock || freq_lock) |-> locked_status\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Locked_Status  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(phase_lock || freq_lock)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `locked_status`", "sva_signals": ["clk", "rst_n", "[0:0] phase_lock", "[0:0] freq_lock", "[0:0] locked_status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (phase_lock || freq_lock) |-> locked_status;", "sva_name": "p_locked_status_assertion", "full_property": "property p_Locked_Status;\n@(posedge clk)         (phase_lock || freq_lock) |-> locked_status;\nendproperty\nassert_p_Locked_Status:assert property (p_Locked_Status) else $error(\"\");", "task_id": "2_761", "predict_sva": "@(posedge clk)         (phase_lock == 1 || freq_lock == 1) |-> locked_status == 1"}
{"id": "13_24_0626", "name": "p_not_24", "sva": "@(posedge clk) !(!tx_empty && !rx_full) |-> uart_busy", "ori_sva": "property p_not_24;\n@(posedge clk) !(!tx_empty && !rx_full) |-> uart_busy;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Uart_Busy_Condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!tx_empty && !rx_full)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `uart_busy`  ", "sva_signals": ["clk", "rst_n", "[0:0] uart_busy", "[0:0] tx_empty", "[0:0] rx_full"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!tx_empty && !rx_full) |-> uart_busy;", "sva_name": "p_uart_busy_assertion", "full_property": "property p_Uart_Busy_Condition;\n@(posedge clk)         !(!tx_empty && !rx_full) |-> uart_busy;\nendproperty\nassert_p_Uart_Busy_Condition:assert property (p_Uart_Busy_Condition) else $error(\"\");", "task_id": "2_797", "predict_sva": "@(posedge clk)         (tx_empty == 1 || rx_full == 1) |-> uart_busy == 1"}
{"id": "13_25_0634", "name": "p_not_25", "sva": "@(posedge clk) !(!pwr_good && !low_voltage) |-> shutdown", "ori_sva": "property p_not_25;\n@(posedge clk) !(!pwr_good && !low_voltage) |-> shutdown;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Shutdown_Condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!pwr_good && !low_voltage)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `shutdown`  \n\n(Note: The antecedent simplifies to `pwr_good || low_voltage` by De Morgan's laws)", "sva_signals": ["clk", "rst_n", "[0:0] pwr_good", "[0:0] low_voltage", "[0:0] shutdown"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pwr_good || low_voltage) |-> shutdown;", "sva_name": "p_shutdown_on_power_or_low_voltage", "full_property": "property p_Shutdown_Condition;\n@(posedge clk)         (pwr_good || low_voltage) |-> shutdown;\nendproperty\nassert_p_Shutdown_Condition:assert property (p_Shutdown_Condition) else $error(\"\");", "task_id": "2_798", "predict_sva": "@(posedge clk)         (pwr_good == 1 || low_voltage == 1) |-> shutdown == 1"}
{"id": "13_48_0649", "name": "p_not_48", "sva": "@(posedge clk) !(!tcam_match && tcam_search) |-> tcam_miss", "ori_sva": "property p_not_48;\n@(posedge clk) !(!tcam_match && tcam_search) |-> tcam_miss;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_TcamMiss  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!tcam_match && tcam_search)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tcam_miss`  ", "sva_signals": ["clk", "rst_n", "[0:0] tcam_match", "[0:0] tcam_search", "[0:0] tcam_miss"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!tcam_match && tcam_search) |-> tcam_miss;", "sva_name": "p_tcam_miss_assertion", "full_property": "property p_TcamMiss;\n@(posedge clk)         !(!tcam_match && tcam_search) |-> tcam_miss;\nendproperty\nassert_p_TcamMiss:assert property (p_TcamMiss) else $error(\"\");", "task_id": "2_823", "predict_sva": "@(posedge clk)         !(!tcam_match && tcam_search) |-> tcam_miss"}
{"id": "15_37_0726", "name": "p_pll_lock_1", "sva": "@(posedge clk) disable iff(pll_rst) pll_enable |-> ##100 pll_locked", "ori_sva": "property p_pll_lock_1;\n@(posedge clk) disable iff(pll_rst) pll_enable |-> ##100 pll_locked;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pll_locked_after_enable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`pll_rst`)  \n**Antecedent (LHS of Implication)**: `pll_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 100 clock cycles (`##100`), `pll_locked` must be true (`pll_locked == 1'b1`)  ", "sva_signals": ["clk", "pll_rst", "[0:0] pll_enable", "[0:0] pll_locked"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (pll_rst)     pll_enable == 1'b1 |-> ##100 pll_locked == 1'b1;", "sva_name": "p_pll_locked_after_enable", "full_property": "property p_pll_locked_after_enable;\n@(posedge clk) disable iff (pll_rst)     pll_enable == 1'b1 |-> ##100 pll_locked == 1'b1;\nendproperty\nassert_p_pll_locked_after_enable:assert property (p_pll_locked_after_enable) else $error(\"\");", "task_id": "2_879", "predict_sva": "@(posedge clk) disable iff (pll_rst)         (pll_rst == 0 && pll_enable == 1) |-> ##100 (pll_locked == 1)"}
{"id": "1_16_0001", "name": "p_pipeline_full_after_start", "sva": "@(posedge clk)     pipeline_start |-> ##6 pipeline_full", "ori_sva": "property p_pipeline_full_after_start;\n@(posedge clk)     pipeline_start |-> ##6 pipeline_full;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pipeline_full_after_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pipeline_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 pipeline_full == 1'b1`  \n\n(Note: The assertion checks that if `pipeline_start` is high, then exactly 6 clock cycles later, `pipeline_full` must be high.)", "sva_signals": ["clk", "rst_n", "[0:0] pipeline_start", "[0:0] pipeline_full"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         pipeline_start == 1'b1 |-> ##6 pipeline_full == 1'b1;", "sva_name": "p_pipeline_full_after_start_6cycles", "full_property": "property p_pipeline_full_after_start;\n@(posedge clk)         pipeline_start == 1'b1 |-> ##6 pipeline_full == 1'b1;\nendproperty\nassert_p_pipeline_full_after_start:assert property (p_pipeline_full_after_start) else $error(\"\");", "task_id": "2_906", "predict_sva": "@(posedge clk)         pipeline_start == 1'b1 |-> ##6 pipeline_full == 1'b1"}
{"id": "1_29_0017", "name": "p_cmd_accept_after_valid", "sva": "@(posedge clk)     cmd_valid |-> ##1 cmd_accept", "ori_sva": "property p_cmd_accept_after_valid;\n@(posedge clk)     cmd_valid |-> ##1 cmd_accept;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cmd_valid_accept  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 cmd_accept == 1'b1`  \n\n(Note: The consequent checks that `cmd_accept` is asserted one clock cycle after `cmd_valid` is high.)", "sva_signals": ["clk", "rst_n", "[0:0] cmd_valid", "[0:0] cmd_accept"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         cmd_valid == 1'b1 |-> ##1 cmd_accept == 1'b1;", "sva_name": "p_cmd_accept_after_cmd_valid", "full_property": "property p_cmd_valid_accept;\n@(posedge clk)         cmd_valid == 1'b1 |-> ##1 cmd_accept == 1'b1;\nendproperty\nassert_p_cmd_valid_accept:assert property (p_cmd_valid_accept) else $error(\"\");", "task_id": "2_920", "predict_sva": "@(posedge clk)         cmd_valid == 1'b1 |-> ##1 cmd_accept == 1'b1"}
{"id": "1_48_0047", "name": "p_watchdog_bark_after_timeout", "sva": "@(posedge clk)     wdt_timeout |-> ##1 watchdog_bark", "ori_sva": "property p_watchdog_bark_after_timeout;\n@(posedge clk)     wdt_timeout |-> ##1 watchdog_bark;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_wdt_timeout_to_bark  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wdt_timeout == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 watchdog_bark`", "sva_signals": ["clk", "rst_n", "[0:0] wdt_timeout", "[0:0] watchdog_bark"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         wdt_timeout == 1'b1 |-> ##1 watchdog_bark;", "sva_name": "p_watchdog_bark_on_timeout", "full_property": "property p_wdt_timeout_to_bark;\n@(posedge clk)         wdt_timeout == 1'b1 |-> ##1 watchdog_bark;\nendproperty\nassert_p_wdt_timeout_to_bark:assert property (p_wdt_timeout_to_bark) else $error(\"\");", "task_id": "2_941", "predict_sva": "@(posedge clk)         wdt_timeout == 1'b1 |-> ##1 watchdog_bark == 1'b1"}
{"id": "2_46_0120", "name": "p_sd_card_read_latency", "sva": "@(posedge clk) sd_read_cmd |-> ##[5:10] sd_data_ready", "ori_sva": "property p_sd_card_read_latency;\n@(posedge clk) sd_read_cmd |-> ##[5:10] sd_data_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sd_read_cmd_to_data_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sd_read_cmd == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] sd_data_ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] sd_read_cmd", "[0:0] sd_data_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready;", "sva_name": "p_sd_data_ready_within_5_to_10_cycles_after_read_cmd", "full_property": "property p_sd_read_cmd_to_data_ready;\n@(posedge clk)         sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready;\nendproperty\nassert_p_sd_read_cmd_to_data_ready:assert property (p_sd_read_cmd_to_data_ready) else $error(\"\");", "task_id": "2_989", "predict_sva": "@(posedge clk)         sd_read_cmd == 1'b1 |-> ##[5:10] sd_data_ready == 1'b1"}
{"id": "3_10_0111", "name": "p_10", "sva": "@(posedge clk)     (mem_access && mem_protect_en) |-> (mem_protect_ok || mem_error)", "ori_sva": "property p_10;\n@(posedge clk)     (mem_access && mem_protect_en) |-> (mem_protect_ok || mem_error);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_access_protection  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_access && mem_protect_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mem_protect_ok || mem_error`", "sva_signals": ["clk", "rst_n", "[0:0] mem_access", "[0:0] mem_protect_en", "[0:0] mem_protect_ok", "[0:0] mem_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         mem_access && mem_protect_en |-> mem_protect_ok || mem_error;", "sva_name": "p_mem_protect_access_result", "full_property": "property p_mem_access_protection;\n@(posedge clk)         mem_access && mem_protect_en |-> mem_protect_ok || mem_error;\nendproperty\nassert_p_mem_access_protection:assert property (p_mem_access_protection) else $error(\"\");", "task_id": "2_1001", "predict_sva": "@(posedge clk)         (mem_access == 1 && mem_protect_en == 1) |-> (mem_protect_ok == 1 || mem_error == 1)"}
{"id": "3_14_0093", "name": "p_14", "sva": "@(posedge clk)     (power_gate_req && !power_gate_block) |-> power_gate_ack", "ori_sva": "property p_14;\n@(posedge clk)     (power_gate_req && !power_gate_block) |-> power_gate_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_gate_ack  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_gate_req && !power_gate_block`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `power_gate_ack`", "sva_signals": ["clk", "rst_n", "[0:0] power_gate_req", "[0:0] power_gate_block", "[0:0] power_gate_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (power_gate_req && !power_gate_block) |-> power_gate_ack;", "sva_name": "p_power_gate_ack_on_req_and_not_blocked", "full_property": "property p_power_gate_ack;\n@(posedge clk)         (power_gate_req && !power_gate_block) |-> power_gate_ack;\nendproperty\nassert_p_power_gate_ack:assert property (p_power_gate_ack) else $error(\"\");", "task_id": "2_1005", "predict_sva": "@(posedge clk)         (power_gate_req == 1 && power_gate_block == 0) |-> (power_gate_ack == 1)"}
{"id": "3_16_0149", "name": "p_16", "sva": "@(posedge clk)     (key_valid && key_type == admin) |-> (access_granted && !access_denied)", "ori_sva": "property p_16;\n@(posedge clk)     (key_valid && key_type == admin) |-> (access_granted && !access_denied);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Access_Granted_For_Admin  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `key_valid && (key_type == admin)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(access_granted && !access_denied)`  ", "sva_signals": ["clk", "rst_n", "[0:0] key_valid", "[0:0] key_type", "[0:0] admin", "[0:0] access_granted", "[0:0] access_denied"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (key_valid && (key_type == admin)) |-> (access_granted && !access_denied);", "sva_name": "p_admin_key_access_grant", "full_property": "property p_Access_Granted_For_Admin;\n@(posedge clk)         (key_valid && (key_type == admin)) |-> (access_granted && !access_denied);\nendproperty\nassert_p_Access_Granted_For_Admin:assert property (p_Access_Granted_For_Admin) else $error(\"\");", "task_id": "2_1006", "predict_sva": "@(posedge clk)         (key_valid == 1 && key_type == admin) |-> (access_granted == 1 && access_denied == 0)"}
{"id": "3_41_0133", "name": "p_41", "sva": "@(posedge clk)     (gpio_int_rise && gpio_int_en) |-> gpio_int_status", "ori_sva": "property p_41;\n@(posedge clk)     (gpio_int_rise && gpio_int_en) |-> gpio_int_status;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gpio_int_status  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gpio_int_rise && gpio_int_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gpio_int_status`", "sva_signals": ["clk", "rst_n", "[0:0] gpio_int_rise", "[0:0] gpio_int_en", "[0:0] gpio_int_status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (gpio_int_rise && gpio_int_en) |-> gpio_int_status;", "sva_name": "p_gpio_int_status_assertion", "full_property": "property p_gpio_int_status;\n@(posedge clk)         (gpio_int_rise && gpio_int_en) |-> gpio_int_status;\nendproperty\nassert_p_gpio_int_status:assert property (p_gpio_int_status) else $error(\"\");", "task_id": "2_1034", "predict_sva": "@(posedge clk)         (gpio_int_rise == 1 && gpio_int_en == 1) |-> (gpio_int_status == 1)"}
{"id": "3_43_0126", "name": "p_43", "sva": "@(posedge clk)     (jtag_ir_shift && jtag_en) |-> jtag_ir_capture", "ori_sva": "property p_43;\n@(posedge clk)     (jtag_ir_shift && jtag_en) |-> jtag_ir_capture;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_jtag_ir_capture  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `jtag_ir_shift && jtag_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `jtag_ir_capture`", "sva_signals": ["clk", "rst_n", "[0:0] jtag_ir_shift", "[0:0] jtag_en", "[0:0] jtag_ir_capture"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         jtag_ir_shift && jtag_en |-> jtag_ir_capture;", "sva_name": "p_jtag_ir_capture_on_shift_and_en", "full_property": "property p_jtag_ir_capture;\n@(posedge clk)         jtag_ir_shift && jtag_en |-> jtag_ir_capture;\nendproperty\nassert_p_jtag_ir_capture:assert property (p_jtag_ir_capture) else $error(\"\");", "task_id": "2_1036", "predict_sva": "@(posedge clk)         (jtag_ir_shift == 1 && jtag_en == 1) |-> (jtag_ir_capture == 1)"}
{"id": "3_44_0139", "name": "p_44", "sva": "@(posedge clk)     (crypto_key_ready && crypto_start) |-> crypto_busy", "ori_sva": "property p_44;\n@(posedge clk)     (crypto_key_ready && crypto_start) |-> crypto_busy;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crypto_busy_trigger  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crypto_key_ready && crypto_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crypto_busy`", "sva_signals": ["clk", "rst_n", "[0:0] crypto_key_ready", "[0:0] crypto_start", "[0:0] crypto_busy"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (crypto_key_ready && crypto_start) |-> crypto_busy;", "sva_name": "p_crypto_busy_when_key_ready_and_start", "full_property": "property p_crypto_busy_trigger;\n@(posedge clk)         (crypto_key_ready && crypto_start) |-> crypto_busy;\nendproperty\nassert_p_crypto_busy_trigger:assert property (p_crypto_busy_trigger) else $error(\"\");", "task_id": "2_1037", "predict_sva": "@(posedge clk)         (crypto_key_ready == 1 && crypto_start == 1) |-> (crypto_busy == 1)"}
{"id": "3_46_0137", "name": "p_46", "sva": "@(posedge clk)     (pcie_tlp_received && pcie_tlp_type == mem_rd) |-> pcie_tlp_processing", "ori_sva": "property p_46;\n@(posedge clk)     (pcie_tlp_received && pcie_tlp_type == mem_rd) |-> pcie_tlp_processing;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pcie_Tlp_Processing  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pcie_tlp_received && pcie_tlp_type == mem_rd`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pcie_tlp_processing`", "sva_signals": ["clk", "rst_n", "[0:0] pcie_tlp_received", "[0:0] pcie_tlp_type", "[0:0] mem_rd", "[0:0] pcie_tlp_processing"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (pcie_tlp_received && pcie_tlp_type == mem_rd) |-> pcie_tlp_processing;", "sva_name": "p_pcie_tlp_mem_rd_processing", "full_property": "property p_Pcie_Tlp_Processing;\n@(posedge clk)     (pcie_tlp_received && pcie_tlp_type == mem_rd) |-> pcie_tlp_processing;\nendproperty\nassert_p_Pcie_Tlp_Processing:assert property (p_Pcie_Tlp_Processing) else $error(\"\");", "task_id": "2_1039", "predict_sva": "@(posedge clk)         (pcie_tlp_received == 1 && pcie_tlp_type == mem_rd) |-> (pcie_tlp_processing == 1)"}
{"id": "5_25_0236", "name": "p_fixed_rep_25", "sva": "@(posedge clk) (encryption_busy)[*12] |-> encryption_done", "ori_sva": "property p_fixed_rep_25;\n@(posedge clk) (encryption_busy)[*12] |-> encryption_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encryption_busy_to_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_busy` remains true for 12 consecutive clock cycles (`encryption_busy[*12]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `encryption_done` is true in the same cycle as the 12th occurrence of `encryption_busy`  ", "sva_signals": ["clk", "rst_n", "[0:0] encryption_busy", "[0:0] encryption_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     encryption_busy[*12] |-> encryption_done;", "sva_name": "p_encryption_done_after_12_busy_cycles", "full_property": "property p_encryption_busy_to_done;\n@(posedge clk)     encryption_busy[*12] |-> encryption_done;\nendproperty\nassert_p_encryption_busy_to_done:assert property (p_encryption_busy_to_done) else $error(\"\");", "task_id": "2_1111", "predict_sva": "@(posedge clk)         encryption_busy [*12] |-> encryption_done"}
{"id": "3_7_0112", "name": "p_7", "sva": "@(posedge clk)     (cmd_valid && (cmd_type == 3'b101)) |-> (resp_ready && resp_type == 2'b01)", "ori_sva": "property p_7;\n@(posedge clk)     (cmd_valid && (cmd_type == 3'b101)) |-> (resp_ready && resp_type == 2'b01);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cmd_valid_resp_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_valid && (cmd_type == 3'b101)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `resp_ready && resp_type == 2'b01`", "sva_signals": ["clk", "rst_n", "[2:0] cmd_type", "[0:0] cmd_valid", "[1:0] resp_type", "[0:0] resp_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (cmd_valid && (cmd_type == 3'b101)) |-> (resp_ready && (resp_type == 2'b01));", "sva_name": "p_cmd_type_101_resp_ready_type_01", "full_property": "property p_cmd_valid_resp_ready;\n@(posedge clk)     (cmd_valid && (cmd_type == 3'b101)) |-> (resp_ready && (resp_type == 2'b01));\nendproperty\nassert_p_cmd_valid_resp_ready:assert property (p_cmd_valid_resp_ready) else $error(\"\");", "task_id": "2_1047", "predict_sva": "@(posedge clk)         (cmd_valid == 1 && cmd_type == 3'b101) |-> (resp_ready == 1 && resp_type == 2'b01)"}
{"id": "5_27_0222", "name": "p_fixed_rep_27", "sva": "@(posedge clk) (sync_pulse)[*4] |-> sync_achieved", "ori_sva": "property p_fixed_rep_27;\n@(posedge clk) (sync_pulse)[*4] |-> sync_achieved;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_achieved  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse` occurring consecutively for 4 clock cycles (`sync_pulse[*4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sync_achieved` must be true  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] sync_achieved"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sync_pulse[*4] |-> sync_achieved;", "sva_name": "p_sync_achieved_after_4_sync_pulse", "full_property": "property p_sync_achieved;\n@(posedge clk)         sync_pulse[*4] |-> sync_achieved;\nendproperty\nassert_p_sync_achieved:assert property (p_sync_achieved) else $error(\"\");", "task_id": "2_1113", "predict_sva": "@(posedge clk)         sync_pulse [*4] |-> sync_achieved"}
{"id": "5_7_0188", "name": "p_fixed_rep_7", "sva": "@(posedge clk) sync[*4] |-> ##4 $stable(signal)", "ori_sva": "property p_fixed_rep_7;\n@(posedge clk) sync[*4] |-> ##4 $stable(signal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_stable_signal  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync` is true for 4 consecutive clock cycles (`sync[*4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 4 clock cycles (`##4`), `signal` remains stable (`$stable(signal)`)  ", "sva_signals": ["clk", "rst_n", "[0:0] sync", "[0:0] signal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         sync[*4] |-> ##4 $stable(signal);", "sva_name": "p_signal_stable_after_sync_4cycles", "full_property": "property p_sync_stable_signal;\n@(posedge clk)         sync[*4] |-> ##4 $stable(signal);\nendproperty\nassert_p_sync_stable_signal:assert property (p_sync_stable_signal) else $error(\"\");", "task_id": "2_1141", "predict_sva": "@(posedge clk)         sync [*4] |-> ##1 signal == $past(signal)"}
{"id": "4_34_0196", "name": "p_dma_transfer_start_after_request", "sva": "@(posedge clk)     dma_req |=> ##3 dma_start", "ori_sva": "property p_dma_transfer_start_after_request;\n@(posedge clk)     dma_req |=> ##3 dma_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_start_after_req  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_req == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##3 dma_start == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent should be checked starting from the next clock cycle after the antecedent is true, and `##3` means the consequent is expected to be true 3 clock cycles after that next cycle.)", "sva_signals": ["clk", "rst_n", "[0:0] dma_req", "[0:0] dma_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     dma_req == 1'b1 |=> ##3 dma_start == 1'b1;", "sva_name": "p_dma_start_after_dma_req_4cycles", "full_property": "property p_dma_start_after_req;\n@(posedge clk)     dma_req == 1'b1 |=> ##3 dma_start == 1'b1;\nendproperty\nassert_p_dma_start_after_req:assert property (p_dma_start_after_req) else $error(\"\");", "task_id": "2_1162", "predict_sva": "@(posedge clk)         dma_req == 1'b1 |-> ##3 dma_start == 1'b1"}
{"id": "6_41_0298", "name": "prop_41", "sva": "@(posedge clk)      (alarm_active && !alarm_silenced)[*4:8] |-> ##3 alarm_triggered", "ori_sva": "property prop_41;\n@(posedge clk)      (alarm_active && !alarm_silenced)[*4:8] |-> ##3 alarm_triggered\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Alarm_Trigger_Sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(alarm_active && !alarm_silenced)` holds true consecutively for 4 to 8 clock cycles (`[*4:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3` (3 clock cycles after the sequence ends), `alarm_triggered` must be true  ", "sva_signals": ["clk", "rst_n", "[0:0] alarm_active", "[0:0] alarm_silenced", "[0:0] alarm_triggered"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (alarm_active && !alarm_silenced)[*4:8] |-> ##3 alarm_triggered;", "sva_name": "p_alarm_triggered_after_active_window", "full_property": "property p_Alarm_Trigger_Sequence;\n@(posedge clk)     (alarm_active && !alarm_silenced)[*4:8] |-> ##3 alarm_triggered;\nendproperty\nassert_p_Alarm_Trigger_Sequence:assert property (p_Alarm_Trigger_Sequence) else $error(\"\");", "task_id": "2_1176", "predict_sva": "@(posedge clk)         (alarm_active && !alarm_silenced) [*4:8] |-> ##3 alarm_triggered == 1"}
{"id": "7_37_0334", "name": "p_rose_37", "sva": "@(posedge clk) $rose(underflow) |-> error_flag", "ori_sva": "property p_rose_37;\n@(posedge clk) $rose(underflow) |-> error_flag\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Underflow_Error  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(underflow)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_flag`", "sva_signals": ["clk", "rst_n", "[0:0] underflow", "[0:0] error_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(underflow) |-> error_flag;", "sva_name": "p_error_flag_on_underflow_rise", "full_property": "property p_Underflow_Error;\n@(posedge clk)         $rose(underflow) |-> error_flag;\nendproperty\nassert_p_Underflow_Error:assert property (p_Underflow_Error) else $error(\"\");", "task_id": "2_1218", "predict_sva": "@(posedge clk)         $rose(underflow) |-> error_flag == 1"}
{"id": "7_45_0369", "name": "p_rose_45", "sva": "@(posedge clk) $rose(qualifier) |-> data_qualified", "ori_sva": "property p_rose_45;\n@(posedge clk) $rose(qualifier) |-> data_qualified\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Qualifier_Rise_Data_Qualified  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(qualifier)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_qualified`", "sva_signals": ["clk", "rst_n", "[0:0] qualifier", "[0:0] data_qualified"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(qualifier) |-> data_qualified;", "sva_name": "p_qualifier_rise_data_qualified", "full_property": "property p_Qualifier_Rise_Data_Qualified;\n@(posedge clk)         $rose(qualifier) |-> data_qualified;\nendproperty\nassert_p_Qualifier_Rise_Data_Qualified:assert property (p_Qualifier_Rise_Data_Qualified) else $error(\"\");", "task_id": "2_1228", "predict_sva": "@(posedge clk)         $rose(qualifier) |-> data_qualified == 1"}
{"id": "7_4_0275", "name": "p_rose_4", "sva": "@(posedge clk) $rose(valid) |-> ##2 ready", "ori_sva": "property p_rose_4;\n@(posedge clk) $rose(valid) |-> ##2 ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Valid_Rose_To_Ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(valid) |-> ##2 ready;", "sva_name": "p_valid_ready_latency2", "full_property": "property p_Valid_Rose_To_Ready;\n@(posedge clk)         $rose(valid) |-> ##2 ready;\nendproperty\nassert_p_Valid_Rose_To_Ready:assert property (p_Valid_Rose_To_Ready) else $error(\"\");", "task_id": "2_1233", "predict_sva": "@(posedge clk)         $rose(valid) |-> ##2 ready"}
{"id": "8_3_0337", "name": "p_fell_enable_no_write", "sva": "@(posedge clk)     $fell(enable) |-> !write_en", "ori_sva": "property p_fell_enable_no_write;\n@(posedge clk)     $fell(enable) |-> !write_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fell_Enable_No_Write  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!write_en`  ", "sva_signals": ["clk", "rst_n", "[0:0] enable", "[0:0] write_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(enable) |-> !write_en;", "sva_name": "p_write_en_not_asserted_on_enable_fall", "full_property": "property p_Fell_Enable_No_Write;\n@(posedge clk)         $fell(enable) |-> !write_en;\nendproperty\nassert_p_Fell_Enable_No_Write:assert property (p_Fell_Enable_No_Write) else $error(\"\");", "task_id": "2_1269", "predict_sva": "@(posedge clk)         $fell(enable) |-> write_en == 0"}
{"id": "10_14_0445", "name": "p_past_packet_start", "sva": "@(posedge clk)     $past(packet_start,1) |-> ##[1:3] packet_valid", "ori_sva": "property p_past_packet_start;\n@(posedge clk)     $past(packet_start,1) |-> ##[1:3] packet_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_packet_start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(packet_start, 1)` (packet_start was true 1 clock cycle ago)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] packet_valid` (packet_valid must be true within 1 to 3 clock cycles after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(packet_start, 1) |-> ##[1:3] packet_valid;", "sva_name": "p_packet_valid_after_start", "full_property": "property p_past_packet_start;\n@(posedge clk)         $past(packet_start, 1) |-> ##[1:3] packet_valid;\nendproperty\nassert_p_past_packet_start:assert property (p_past_packet_start) else $error(\"\");", "task_id": "2_1341", "predict_sva": "@(posedge clk)         $past(packet_start, 1) |-> ##[1:3] packet_valid"}
{"id": "10_1_0439", "name": "p_past_data_stable_2cyc", "sva": "@(posedge clk)     $past(data_valid,2) |-> data_stable", "ori_sva": "property p_past_data_stable_2cyc;\n@(posedge clk)     $past(data_valid,2) |-> data_stable;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_past_data_stable_2cyc  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(data_valid, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_stable`", "sva_signals": ["clk", "rst_n", "[0:0] data_valid", "[0:0] data_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(data_valid, 2) |-> data_stable;", "sva_name": "p_data_stable_after_data_valid", "full_property": "property p_past_data_stable_2cyc;\n@(posedge clk)         $past(data_valid, 2) |-> data_stable;\nendproperty\nassert_p_past_data_stable_2cyc:assert property (p_past_data_stable_2cyc) else $error(\"\");", "task_id": "2_1346", "predict_sva": "@(posedge clk)         $past(data_valid, 2) == 1 |-> data_stable == 1"}
{"id": "10_50_0527", "name": "p_past_yield_request", "sva": "@(posedge clk)     $past(yield_req,5) |-> arbitration_grant", "ori_sva": "property p_past_yield_request;\n@(posedge clk)     $past(yield_req,5) |-> arbitration_grant;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_past_yield_request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(yield_req, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `arbitration_grant`", "sva_signals": ["clk", "rst_n", "[0:0] yield_req", "[0:0] arbitration_grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(yield_req, 5) |-> arbitration_grant;", "sva_name": "p_arbitration_grant_after_yield_req_5cycles", "full_property": "property p_past_yield_request;\n@(posedge clk)         $past(yield_req, 5) |-> arbitration_grant;\nendproperty\nassert_p_past_yield_request:assert property (p_past_yield_request) else $error(\"\");", "task_id": "2_1379", "predict_sva": "@(posedge clk)         $past(yield_req, 5) == 1 |-> arbitration_grant == 1"}
{"id": "11_29_0542", "name": "p_and_29", "sva": "@(posedge clk)     (pll_lock && !pll_reset) |-> clock_output_valid", "ori_sva": "property p_and_29;\n@(posedge clk)     (pll_lock && !pll_reset) |-> clock_output_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_29  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(pll_lock && !pll_reset)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `clock_output_valid`", "sva_signals": ["clk", "pll_lock", "pll_reset", "clock_output_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pll_lock && !pll_reset) |-> clock_output_valid;", "sva_name": "p_clock_output_valid_when_pll_locked", "full_property": "property p_and_29;\n@(posedge clk)         (pll_lock && !pll_reset) |-> clock_output_valid;\nendproperty\nassert_p_and_29:assert property (p_and_29) else $error(\"\");", "task_id": "2_1406", "predict_sva": "@(posedge clk)         (pll_lock == 1 && pll_reset == 0) |-> (clock_output_valid == 1)"}
{"id": "11_3_0505", "name": "p_and_3", "sva": "@(posedge clk)     (start_transfer && fifo_not_empty) |=> transfer_complete", "ori_sva": "property p_and_3;\n@(posedge clk)     (start_transfer && fifo_not_empty) |=> transfer_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start_transfer && fifo_not_empty`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `transfer_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] start_transfer", "[0:0] fifo_not_empty", "[0:0] transfer_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         start_transfer && fifo_not_empty |=> transfer_complete;", "sva_name": "p_transfer_complete_on_start_and_fifo_not_empty", "full_property": "property p_and_3;\n@(posedge clk)         start_transfer && fifo_not_empty |=> transfer_complete;\nendproperty\nassert_p_and_3:assert property (p_and_3) else $error(\"\");", "task_id": "2_1418", "predict_sva": "@(posedge clk)         (start_transfer == 1 && fifo_not_empty == 1) |-> ##1 (transfer_complete == 1)"}
{"id": "11_8_0512", "name": "p_and_8", "sva": "@(posedge clk)     (interrupt_pending && !interrupt_mask) |-> interrupt_ack", "ori_sva": "property p_and_8;\n@(posedge clk)     (interrupt_pending && !interrupt_mask) |-> interrupt_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `interrupt_pending && !interrupt_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interrupt_ack`", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_pending", "[0:0] interrupt_mask", "[0:0] interrupt_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (interrupt_pending && !interrupt_mask) |-> interrupt_ack;", "sva_name": "p_interrupt_ack_on_pending_and_unmasked", "full_property": "property p_and_8;\n@(posedge clk)         (interrupt_pending && !interrupt_mask) |-> interrupt_ack;\nendproperty\nassert_p_and_8:assert property (p_and_8) else $error(\"\");", "task_id": "2_1433", "predict_sva": "@(posedge clk)         (interrupt_pending == 1 && interrupt_mask == 0) |-> (interrupt_ack == 1)"}
{"id": "12_17_0557", "name": "p_or_17", "sva": "@(posedge clk)     (buffer_full || threshold_reached) && write_enable |-> flow_control", "ori_sva": "property p_or_17;\n@(posedge clk)     (buffer_full || threshold_reached) && write_enable |-> flow_control\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_17  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(buffer_full || threshold_reached) && write_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `flow_control`", "sva_signals": ["clk", "rst_n", "[0:0] buffer_full", "[0:0] threshold_reached", "[0:0] write_enable", "[0:0] flow_control"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((buffer_full || threshold_reached) && write_enable) |-> flow_control;", "sva_name": "p_flow_control_on_full_or_threshold_and_write", "full_property": "property p_or_17;\n@(posedge clk)         ((buffer_full || threshold_reached) && write_enable) |-> flow_control;\nendproperty\nassert_p_or_17:assert property (p_or_17) else $error(\"\");", "task_id": "2_1442", "predict_sva": "@(posedge clk)         (buffer_full == 1 || threshold_reached == 1) && write_enable == 1 |-> flow_control == 1"}
{"id": "12_22_0571", "name": "p_or_22", "sva": "@(posedge clk)     $past(fifo_write,2) || $past(mem_write,2) |-> write_pending", "ori_sva": "property p_or_22;\n@(posedge clk)     $past(fifo_write,2) || $past(mem_write,2) |-> write_pending\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_22  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(fifo_write, 2) || $past(mem_write, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `write_pending`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_write", "[0:0] mem_write", "[0:0] write_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(fifo_write, 2) || $past(mem_write, 2)) |-> write_pending;", "sva_name": "p_write_pending_after_fifo_or_mem_write", "full_property": "property p_or_22;\n@(posedge clk)         ($past(fifo_write, 2) || $past(mem_write, 2)) |-> write_pending;\nendproperty\nassert_p_or_22:assert property (p_or_22) else $error(\"\");", "task_id": "2_1448", "predict_sva": "@(posedge clk)         ($past(fifo_write, 2) == 1 || $past(mem_write, 2) == 1) |-> write_pending == 1"}
{"id": "12_26_0583", "name": "p_or_26", "sva": "@(posedge clk)     (pattern_match || signature_detect) && validation_enable |-> match_flag", "ori_sva": "property p_or_26;\n@(posedge clk)     (pattern_match || signature_detect) && validation_enable |-> match_flag\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(pattern_match || signature_detect) && validation_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `match_flag`", "sva_signals": ["clk", "rst_n", "[0:0] pattern_match", "[0:0] signature_detect", "[0:0] validation_enable", "[0:0] match_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((pattern_match || signature_detect) && validation_enable) |-> match_flag;", "sva_name": "p_match_flag_on_pattern_or_signature", "full_property": "property p_or_26;\n@(posedge clk)         ((pattern_match || signature_detect) && validation_enable) |-> match_flag;\nendproperty\nassert_p_or_26:assert property (p_or_26) else $error(\"\");", "task_id": "2_1452", "predict_sva": "@(posedge clk)         (pattern_match == 1 || signature_detect == 1) && validation_enable == 1 |-> match_flag == 1"}
{"id": "12_3_0567", "name": "p_or_3", "sva": "@(posedge clk)     (enable_a || enable_b) && reset_n |-> data_ready", "ori_sva": "property p_or_3;\n@(posedge clk)     (enable_a || enable_b) && reset_n |-> data_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(enable_a || enable_b) && reset_n`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_ready`", "sva_signals": ["clk", "reset_n", "[0:0] enable_a", "[0:0] enable_b", "[0:0] data_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((enable_a || enable_b) && reset_n) |-> data_ready;", "sva_name": "p_data_ready_when_enable_and_reset", "full_property": "property p_or_3;\n@(posedge clk)         ((enable_a || enable_b) && reset_n) |-> data_ready;\nendproperty\nassert_p_or_3:assert property (p_or_3) else $error(\"\");", "task_id": "2_1467", "predict_sva": "@(posedge clk) disable iff (!reset_n)         (enable_a == 1 || enable_b == 1) && reset_n == 1 |-> data_ready == 1"}
{"id": "12_43_0580", "name": "p_or_43", "sva": "@(posedge clk)     $past(valid_op,5) || $past(forced_op,5) |-> result_ready", "ori_sva": "property p_or_43;\n@(posedge clk)     $past(valid_op,5) || $past(forced_op,5) |-> result_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_43  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(valid_op, 5) || $past(forced_op, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `result_ready`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid_op", "[0:0] forced_op", "[0:0] result_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(valid_op, 5) || $past(forced_op, 5)) |-> result_ready;", "sva_name": "p_result_ready_after_op", "full_property": "property p_or_43;\n@(posedge clk)         ($past(valid_op, 5) || $past(forced_op, 5)) |-> result_ready;\nendproperty\nassert_p_or_43:assert property (p_or_43) else $error(\"\");", "task_id": "2_1471", "predict_sva": "@(posedge clk)         ($past(valid_op, 5) || $past(forced_op, 5)) |-> result_ready"}
{"id": "12_8_0544", "name": "p_or_8", "sva": "@(posedge clk)     (fifo_empty || fifo_underflow) && read_enable |-> fifo_error", "ori_sva": "property p_or_8;\n@(posedge clk)     (fifo_empty || fifo_underflow) && read_enable |-> fifo_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fifo_empty || fifo_underflow) && read_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fifo_error`", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] fifo_underflow", "[0:0] read_enable", "[0:0] fifo_error"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_empty || fifo_underflow) && read_enable |-> fifo_error;", "sva_name": "p_fifo_error_on_empty_or_underflow_read", "full_property": "property p_or_8;\n@(posedge clk)         (fifo_empty || fifo_underflow) && read_enable |-> fifo_error;\nendproperty\nassert_p_or_8:assert property (p_or_8) else $error(\"\");", "task_id": "2_1483", "predict_sva": "@(posedge clk)         (fifo_empty == 1 || fifo_underflow == 1) && read_enable == 1 |-> fifo_error == 1"}
{"id": "13_12_0632", "name": "p_not_12", "sva": "@(posedge clk) !(!wr_en && rd_en) |-> !conflict", "ori_sva": "property p_not_12;\n@(posedge clk) !(!wr_en && rd_en) |-> !conflict;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_12  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!wr_en && rd_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!conflict`  ", "sva_signals": ["clk", "rst_n", "[0:0] wr_en", "[0:0] rd_en", "[0:0] conflict"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!wr_en && rd_en) |-> !conflict;", "sva_name": "p_no_conflict_when_not_wr_rd", "full_property": "property p_not_12;\n@(posedge clk)         !(!wr_en && rd_en) |-> !conflict;\nendproperty\nassert_p_not_12:assert property (p_not_12) else $error(\"\");", "task_id": "2_1486", "predict_sva": "@(posedge clk)         !( !wr_en && rd_en ) |-> conflict == 0"}
{"id": "13_18_0618", "name": "p_not_18", "sva": "@(posedge clk) !(full || empty) |-> partial", "ori_sva": "property p_not_18;\n@(posedge clk) !(full || empty) |-> partial;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_18  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(full || empty)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `partial`", "sva_signals": ["clk", "rst_n", "[0:0] full", "[0:0] empty", "[0:0] partial"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(full || empty) |-> partial;", "sva_name": "p_partial_asserted_when_not_full_and_not_empty", "full_property": "property p_not_18;\n@(posedge clk)         !(full || empty) |-> partial;\nendproperty\nassert_p_not_18:assert property (p_not_18) else $error(\"\");", "task_id": "2_1492", "predict_sva": "@(posedge clk)         (full == 0 && empty == 0) |-> (partial == 1)"}
{"id": "13_32_0623", "name": "p_not_32", "sva": "@(posedge clk) !(phase_a && !phase_b) |-> phase_ok", "ori_sva": "property p_not_32;\n@(posedge clk) !(phase_a && !phase_b) |-> phase_ok;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_32  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(phase_a && !phase_b)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `phase_ok`", "sva_signals": ["clk", "rst_n", "[0:0] phase_a", "[0:0] phase_b", "[0:0] phase_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !(phase_a && !phase_b) |-> phase_ok;", "sva_name": "p_phase_ok_assertion", "full_property": "property p_not_32;\n@(posedge clk)     !(phase_a && !phase_b) |-> phase_ok;\nendproperty\nassert_p_not_32:assert property (p_not_32) else $error(\"\");", "task_id": "2_1507", "predict_sva": "@(posedge clk)         !(phase_a && !phase_b) |-> phase_ok"}
{"id": "13_46_0666", "name": "p_not_46", "sva": "@(posedge clk) !(clock_div2 && !clock_div4) |-> clock_normal", "ori_sva": "property p_not_46;\n@(posedge clk) !(clock_div2 && !clock_div4) |-> clock_normal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_46  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(clock_div2 && !clock_div4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `clock_normal`", "sva_signals": ["clk", "rst_n", "[0:0] clock_div2", "[0:0] clock_div4", "[0:0] clock_normal"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(clock_div2 && !clock_div4) |-> clock_normal;", "sva_name": "p_clock_normal_assertion", "full_property": "property p_not_46;\n@(posedge clk)         !(clock_div2 && !clock_div4) |-> clock_normal;\nendproperty\nassert_p_not_46:assert property (p_not_46) else $error(\"\");", "task_id": "2_1522", "predict_sva": "@(posedge clk)         !(clock_div2 && !clock_div4) |-> clock_normal"}
{"id": "13_47_0635", "name": "p_not_47", "sva": "@(posedge clk) !(!reset_async && reset_sync) |-> !reset_active", "ori_sva": "property p_not_47;\n@(posedge clk) !(!reset_async && reset_sync) |-> !reset_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_47  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!reset_async && reset_sync)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!reset_active`", "sva_signals": ["clk", "reset_async", "reset_sync", "[0:0] reset_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     !(!reset_async && reset_sync) |-> !reset_active;", "sva_name": "p_reset_active_deassertion_on_async_sync", "full_property": "property p_not_47;\n@(posedge clk)     !(!reset_async && reset_sync) |-> !reset_active;\nendproperty\nassert_p_not_47:assert property (p_not_47) else $error(\"\");", "task_id": "2_1523", "predict_sva": "@(posedge clk)         !(!reset_async && reset_sync) |-> reset_active == 0"}
{"id": "13_6_0645", "name": "p_not_6", "sva": "@(posedge clk) !(!start && stop) |-> done", "ori_sva": "property p_not_6;\n@(posedge clk) !(!start && stop) |-> done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_6  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!start && stop)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `done`", "sva_signals": ["clk", "rst_n", "[0:0] start", "[0:0] stop", "[0:0] done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(!start && stop) |-> done;", "sva_name": "p_done_asserted_when_not_stop_without_start", "full_property": "property p_not_6;\n@(posedge clk)         !(!start && stop) |-> done;\nendproperty\nassert_p_not_6:assert property (p_not_6) else $error(\"\");", "task_id": "2_1529", "predict_sva": "@(posedge clk)         !( !start && stop ) |-> done == 1"}
{"id": "14_1_0662", "name": "p_cond_1", "sva": "@(posedge clk)     if (mode) req |-> ack else 1'b1", "ori_sva": "property p_cond_1;\n@(posedge clk)     if (mode) req |-> ack else 1'b1\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cond_1  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mode` is evaluated first; if `mode` is true, then `req` is the antecedent. If `mode` is false, the antecedent is implicitly `1'b1` (always true).  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: If `mode` is true, the consequent is `ack`. If `mode` is false, the assertion evaluates to `1'b1` (trivially passes).  \n\n### Notes:  \n- The assertion is **conditional** based on `mode`.  \n- When `mode` is true, it checks that `req` implies `ack` (`req |-> ack`).  \n- When `mode` is false, the assertion always holds (`1'b1`).  \n- No disable condition is specified.", "sva_signals": ["clk", "rst_n", "[0:0] mode", "[0:0] req", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (mode ? req : 1'b1) |-> (mode ? ack : 1'b1);", "sva_name": "p_ack_follows_req_when_mode", "full_property": "property p_cond_1;\n@(posedge clk)     (mode ? req : 1'b1) |-> (mode ? ack : 1'b1);\nendproperty\nassert_p_cond_1:assert property (p_cond_1) else $error(\"\");", "task_id": "2_1538", "predict_sva": "@(posedge clk)         mode == 1 |-> req == 1 |-> ack == 1"}
{"id": "15_31_0724", "name": "p_error_correction", "sva": "@(posedge clk) disable iff(!ecc_enable)     error_detected |-> ##1 error_corrected", "ori_sva": "property p_error_correction;\n@(posedge clk) disable iff(!ecc_enable)     error_detected |-> ##1 error_corrected;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_error_correction  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!ecc_enable)  \n**Antecedent (LHS of Implication)**: `error_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 error_corrected == 1'b1`", "sva_signals": ["clk", "[0:0] ecc_enable", "[0:0] error_detected", "[0:0] error_corrected"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!ecc_enable)     error_detected == 1'b1 |-> ##1 error_corrected == 1'b1;", "sva_name": "p_error_correction_on_ecc_enabled", "full_property": "property p_error_correction;\n@(posedge clk) disable iff (!ecc_enable)     error_detected == 1'b1 |-> ##1 error_corrected == 1'b1;\nendproperty\nassert_p_error_correction:assert property (p_error_correction) else $error(\"\");", "task_id": "2_1571", "predict_sva": "@(posedge clk) disable iff (ecc_enable == 0)         (ecc_enable == 1'b1 && error_detected == 1'b1) |-> ##1 (error_corrected == 1'b1)"}
{"id": "1_44_0009", "name": "p_fixed_delay_44", "sva": "@(posedge clk)     encryption_start |-> ##7 encryption_done", "ori_sva": "property p_fixed_delay_44;\n@(posedge clk)     encryption_start |-> ##7 encryption_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_44  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encryption_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##7 encryption_done == 1'b1`  \n\n(Note: The assertion checks that exactly 7 clock cycles after `encryption_start` is asserted, `encryption_done` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] encryption_start", "[0:0] encryption_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         encryption_start == 1'b1 |-> ##7 encryption_done == 1'b1;", "sva_name": "p_encryption_done_after_start_7cycles", "full_property": "property p_fixed_delay_44;\n@(posedge clk)         encryption_start == 1'b1 |-> ##7 encryption_done == 1'b1;\nendproperty\nassert_p_fixed_delay_44:assert property (p_fixed_delay_44) else $error(\"\");", "task_id": "2_1634", "predict_sva": "@(posedge clk)         encryption_start == 1'b1 |-> ##7 encryption_done == 1'b1"}
{"id": "1_7_0054", "name": "p_fixed_delay_7", "sva": "@(posedge clk)     cmd_valid |-> ##3 cmd_ack", "ori_sva": "property p_fixed_delay_7;\n@(posedge clk)     cmd_valid |-> ##3 cmd_ack;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_fixed_delay_7  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 cmd_ack == 1'b1`  \n\n(Note: The `##3` denotes that `cmd_ack` must be asserted exactly 3 clock cycles after `cmd_valid` is detected.)", "sva_signals": ["clk", "rst_n", "[0:0] cmd_valid", "[0:0] cmd_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         cmd_valid == 1'b1 |-> ##3 cmd_ack == 1'b1;", "sva_name": "p_cmd_ack_after_cmd_valid_3cycles", "full_property": "property p_fixed_delay_7;\n@(posedge clk)         cmd_valid == 1'b1 |-> ##3 cmd_ack == 1'b1;\nendproperty\nassert_p_fixed_delay_7:assert property (p_fixed_delay_7) else $error(\"\");", "task_id": "2_1643", "predict_sva": "@(posedge clk)         cmd_valid == 1'b1 |-> ##3 cmd_ack == 1'b1"}
{"id": "2_5_0077", "name": "prop_5", "sva": "@(posedge clk)      packet_start |-> ##[3:7] packet_end", "ori_sva": "property prop_5;\n@(posedge clk)      packet_start |-> ##[3:7] packet_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] packet_end` (packet_end must occur between 3 to 7 clock cycles after packet_start)", "sva_signals": ["clk", "rst_n", "[0:0] packet_start", "[0:0] packet_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         packet_start == 1'b1 |-> ##[3:7] packet_end;", "sva_name": "p_packet_end_within_3_to_7_cycles_after_start", "full_property": "property prop_5;\n@(posedge clk)         packet_start == 1'b1 |-> ##[3:7] packet_end;\nendproperty\nassert_prop_5:assert property (prop_5) else $error(\"\");", "task_id": "2_1692", "predict_sva": "@(posedge clk)         packet_start == 1'b1 |-> ##[3:7] packet_end == 1'b1"}
{"id": "2_8_0029", "name": "prop_8", "sva": "@(posedge clk)      read_req |-> ##[5:12] read_data_valid", "ori_sva": "property prop_8;\n@(posedge clk)      read_req |-> ##[5:12] read_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `read_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:12] read_data_valid == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] read_req", "[0:0] read_data_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     read_req == 1'b1 |-> ##[5:12] read_data_valid == 1'b1;", "sva_name": "p_read_data_valid_within_5_to_12_cycles_after_read_req", "full_property": "property prop_8;\n@(posedge clk)     read_req == 1'b1 |-> ##[5:12] read_data_valid == 1'b1;\nendproperty\nassert_prop_8:assert property (prop_8) else $error(\"\");", "task_id": "2_1695", "predict_sva": "@(posedge clk)         read_req == 1'b1 |-> ##[5:12] read_data_valid == 1'b1"}
{"id": "3_46_0148", "name": "p_overlap_46", "sva": "@(posedge clk)     (gps_fix_acquired && !gps_data_invalid) |-> gps_timestamp_valid", "ori_sva": "property p_overlap_46;\n@(posedge clk)     (gps_fix_acquired && !gps_data_invalid) |-> gps_timestamp_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_46  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gps_fix_acquired && !gps_data_invalid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gps_timestamp_valid`", "sva_signals": ["clk", "rst_n", "[0:0] gps_fix_acquired", "[0:0] gps_data_invalid", "[0:0] gps_timestamp_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (gps_fix_acquired && !gps_data_invalid) |-> gps_timestamp_valid;", "sva_name": "p_gps_timestamp_valid_on_fix_and_valid_data", "full_property": "property p_overlap_46;\n@(posedge clk)         (gps_fix_acquired && !gps_data_invalid) |-> gps_timestamp_valid;\nendproperty\nassert_p_overlap_46:assert property (p_overlap_46) else $error(\"\");", "task_id": "2_1736", "predict_sva": "@(posedge clk)         (gps_fix_acquired == 1 && gps_data_invalid == 0) |-> (gps_timestamp_valid == 1)"}
{"id": "3_48_0129", "name": "p_overlap_48", "sva": "@(posedge clk)     (wifi_connect_req && !wifi_disabled) |-> wifi_connect_ack", "ori_sva": "property p_overlap_48;\n@(posedge clk)     (wifi_connect_req && !wifi_disabled) |-> wifi_connect_ack;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_overlap_48  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wifi_connect_req && !wifi_disabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `wifi_connect_ack`", "sva_signals": ["clk", "rst_n", "[0:0] wifi_connect_req", "[0:0] wifi_disabled", "[0:0] wifi_connect_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (wifi_connect_req && !wifi_disabled) |-> wifi_connect_ack;", "sva_name": "p_wifi_connection_ack_on_req", "full_property": "property p_overlap_48;\n@(posedge clk)         (wifi_connect_req && !wifi_disabled) |-> wifi_connect_ack;\nendproperty\nassert_p_overlap_48:assert property (p_overlap_48) else $error(\"\");", "task_id": "2_1738", "predict_sva": "@(posedge clk)         (wifi_connect_req == 1 && wifi_disabled == 0) |-> (wifi_connection_ack == 1)"}
{"id": "6_31_0287", "name": "p_var_rep_31", "sva": "@(posedge clk)     (data_phase && !ack_phase)[*2:5] |-> protocol_violation", "ori_sva": "property p_var_rep_31;\n@(posedge clk)     (data_phase && !ack_phase)[*2:5] |-> protocol_violation;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_31  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(data_phase && !ack_phase)[*2:5]` (The condition `data_phase` is true and `ack_phase` is false for 2 to 5 consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `protocol_violation` (The signal `protocol_violation` must be true when the antecedent condition is met)", "sva_signals": ["clk", "rst_n", "[0:0] data_phase", "[0:0] ack_phase", "[0:0] protocol_violation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (data_phase && !ack_phase)[*2:5] |-> protocol_violation;", "sva_name": "p_protocol_violation_on_data_phase_without_ack", "full_property": "property p_var_rep_31;\n@(posedge clk)     (data_phase && !ack_phase)[*2:5] |-> protocol_violation;\nendproperty\nassert_p_var_rep_31:assert property (p_var_rep_31) else $error(\"\");", "task_id": "2_1823", "predict_sva": "@(posedge clk)         (data_phase == 1 && ack_phase == 0) [*2:5] |-> protocol_violation == 1"}
{"id": "6_50_0284", "name": "p_var_rep_50", "sva": "@(posedge clk)     (sensor_active && !sensor_data)[*8:20] |-> sensor_timeout", "ori_sva": "property p_var_rep_50;\n@(posedge clk)     (sensor_active && !sensor_data)[*8:20] |-> sensor_timeout;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_50  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(sensor_active && !sensor_data)` repeated consecutively for 8 to 20 clock cycles (`[*8:20]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sensor_timeout` must be true in the same cycle as the end of the repetition.  ", "sva_signals": ["clk", "rst_n", "[0:0] sensor_active", "[0:0] sensor_data", "[0:0] sensor_timeout"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (sensor_active && !sensor_data)[*8:20] |-> sensor_timeout;", "sva_name": "p_sensor_timeout_on_inactive_data_window", "full_property": "property p_var_rep_50;\n@(posedge clk)     (sensor_active && !sensor_data)[*8:20] |-> sensor_timeout;\nendproperty\nassert_p_var_rep_50:assert property (p_var_rep_50) else $error(\"\");", "task_id": "2_1844", "predict_sva": "@(posedge clk)         (sensor_active && !sensor_data) [*8:20] |-> sensor_timeout"}
{"id": "10_9_0474", "name": "p_past_parity_error_persists", "sva": "@(posedge clk)     $past(parity_err, 3) |-> parity_err", "ori_sva": "property p_past_parity_error_persists;\n@(posedge clk)     $past(parity_err, 3) |-> parity_err;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_parity_error_persists  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(parity_err, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `parity_err`  ", "sva_signals": ["clk", "rst_n", "[0:0] parity_err"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(parity_err, 3) |-> parity_err;", "sva_name": "p_parity_err_sticky_3cycles", "full_property": "property p_past_parity_error_persists;\n@(posedge clk)         $past(parity_err, 3) |-> parity_err;\nendproperty\nassert_p_past_parity_error_persists:assert property (p_past_parity_error_persists) else $error(\"\");", "task_id": "2_2034", "predict_sva": "@(posedge clk)         $past(parity_err, 3) |-> parity_err"}
{"id": "11_26_0544", "name": "p_and_26", "sva": "@(posedge clk)     (dma_request && !bus_hold) && (fifo_ready) |-> dma_ack", "ori_sva": "property p_and_26;\n@(posedge clk)     (dma_request && !bus_hold) && (fifo_ready) |-> dma_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(dma_request && !bus_hold) && (fifo_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `dma_ack`", "sva_signals": ["clk", "rst_n", "[0:0] dma_request", "[0:0] bus_hold", "[0:0] fifo_ready", "[0:0] dma_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (dma_request && !bus_hold) && fifo_ready |-> dma_ack;", "sva_name": "p_dma_ack_on_request_and_ready", "full_property": "property p_and_26;\n@(posedge clk)         (dma_request && !bus_hold) && fifo_ready |-> dma_ack;\nendproperty\nassert_p_and_26:assert property (p_and_26) else $error(\"\");", "task_id": "2_2053", "predict_sva": "@(posedge clk)         (dma_request == 1 && bus_hold == 0 && fifo_ready == 1) |-> (dma_ack == 1)"}
{"id": "11_31_0529", "name": "p_and_31", "sva": "@(posedge clk)     (burst_end && !error_flag) && (next_buff_ready) |-> next_burst_start", "ori_sva": "property p_and_31;\n@(posedge clk)     (burst_end && !error_flag) && (next_buff_ready) |-> next_burst_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_31  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(burst_end && !error_flag) && (next_buff_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `next_burst_start`", "sva_signals": ["clk", "rst_n", "[0:0] burst_end", "[0:0] error_flag", "[0:0] next_buff_ready", "[0:0] next_burst_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (burst_end && !error_flag) && next_buff_ready |-> next_burst_start;", "sva_name": "p_next_burst_start_on_burst_end_and_ready", "full_property": "property p_and_31;\n@(posedge clk)         (burst_end && !error_flag) && next_buff_ready |-> next_burst_start;\nendproperty\nassert_p_and_31:assert property (p_and_31) else $error(\"\");", "task_id": "2_2058", "predict_sva": "@(posedge clk)         (burst_end == 1 && error_flag == 0 && next_buff_ready == 1) |-> (next_burst_start == 1)"}
{"id": "11_32_0549", "name": "p_and_32", "sva": "@(posedge clk)     (phase_error && !ignore_phase) && (lock_window_open) |-> phase_adjust", "ori_sva": "property p_and_32;\n@(posedge clk)     (phase_error && !ignore_phase) && (lock_window_open) |-> phase_adjust\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_32  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(phase_error && !ignore_phase) && (lock_window_open)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `phase_adjust`", "sva_signals": ["clk", "rst_n", "[0:0] phase_error", "[0:0] ignore_phase", "[0:0] lock_window_open", "[0:0] phase_adjust"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (phase_error && !ignore_phase) && lock_window_open |-> phase_adjust;", "sva_name": "p_phase_adjust_on_phase_error_and_lock_window", "full_property": "property p_and_32;\n@(posedge clk)         (phase_error && !ignore_phase) && lock_window_open |-> phase_adjust;\nendproperty\nassert_p_and_32:assert property (p_and_32) else $error(\"\");", "task_id": "2_2060", "predict_sva": "@(posedge clk)         (phase_error == 1 && ignore_phase == 0 && lock_window_open == 1) |-> (phase_adjust == 1)"}
{"id": "11_42_0560", "name": "p_and_42", "sva": "@(posedge clk)     (clock_divider == 0) && (high_speed_mode) |-> full_speed_clock", "ori_sva": "property p_and_42;\n@(posedge clk)     (clock_divider == 0) && (high_speed_mode) |-> full_speed_clock\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_42  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(clock_divider == 0) && (high_speed_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `full_speed_clock`", "sva_signals": ["clk", "rst_n", "[0:0] clock_divider", "[0:0] high_speed_mode", "[0:0] full_speed_clock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (clock_divider == 0) && (high_speed_mode) |-> full_speed_clock;", "sva_name": "p_full_speed_clock_assertion", "full_property": "property p_and_42;\n@(posedge clk)         (clock_divider == 0) && (high_speed_mode) |-> full_speed_clock;\nendproperty\nassert_p_and_42:assert property (p_and_42) else $error(\"\");", "task_id": "2_2074", "predict_sva": "@(posedge clk)         (clock_divider == 0 && high_speed_mode == 1) |-> (full_speed_clock == 1)"}
{"id": "12_22_0594", "name": "p_or_22", "sva": "@(posedge clk)     config_err || runtime_err |-> system_halt", "ori_sva": "property p_or_22;\n@(posedge clk)     config_err || runtime_err |-> system_halt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_22  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `config_err || runtime_err`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `system_halt`", "sva_signals": ["clk", "rst_n", "[0:0] config_err", "[0:0] runtime_err", "[0:0] system_halt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (config_err || runtime_err) |-> system_halt;", "sva_name": "p_system_halt_on_error", "full_property": "property p_or_22;\n@(posedge clk)         (config_err || runtime_err) |-> system_halt;\nendproperty\nassert_p_or_22:assert property (p_or_22) else $error(\"\");", "task_id": "2_2096", "predict_sva": "@(posedge clk)         (config_err == 1 || runtime_err == 1) |-> system_halt == 1"}
{"id": "12_36_0581", "name": "p_or_36", "sva": "@(posedge clk)     (low_batt || over_temp) |-> shutdown", "ori_sva": "property p_or_36;\n@(posedge clk)     (low_batt || over_temp) |-> shutdown;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_36  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(low_batt || over_temp)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `shutdown`", "sva_signals": ["clk", "rst_n", "[0:0] low_batt", "[0:0] over_temp", "[0:0] shutdown"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (low_batt || over_temp) |-> shutdown;", "sva_name": "p_shutdown_on_low_batt_or_over_temp", "full_property": "property p_or_36;\n@(posedge clk)         (low_batt || over_temp) |-> shutdown;\nendproperty\nassert_p_or_36:assert property (p_or_36) else $error(\"\");", "task_id": "2_2111", "predict_sva": "@(posedge clk)         (low_batt == 1 || over_temp == 1) |-> shutdown == 1"}
{"id": "12_9_0557", "name": "p_or_9", "sva": "@(posedge clk)     $past(valid,2) || $past(ready,2) |-> curr_state == next_state", "ori_sva": "property p_or_9;\n@(posedge clk)     $past(valid,2) || $past(ready,2) |-> curr_state == next_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_9  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(valid, 2) || $past(ready, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `curr_state == next_state`  ", "sva_signals": ["clk", "rst_n", "[0:0] valid", "[0:0] ready", "[0:0] curr_state", "[0:0] next_state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ($past(valid, 2) || $past(ready, 2)) |-> (curr_state == next_state);", "sva_name": "p_curr_state_matches_next_state_after_valid_or_ready", "full_property": "property p_or_9;\n@(posedge clk)     ($past(valid, 2) || $past(ready, 2)) |-> (curr_state == next_state);\nendproperty\nassert_p_or_9:assert property (p_or_9) else $error(\"\");", "task_id": "2_2135", "predict_sva": "@(posedge clk)         ($past(valid, 2) == 1 || $past(ready, 2) == 1) |-> curr_state == next_state"}
{"id": "13_2_0603", "name": "p_not_2", "sva": "@(negedge clk)     !(!enable && reset) |-> ready", "ori_sva": "property p_not_2;\n@(negedge clk)     !(!enable && reset) |-> ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_2  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(!enable && reset)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ready`", "sva_signals": ["clk", "reset", "[0:0] enable", "[0:0] ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)         !(!enable && reset) |-> ready;", "sva_name": "p_ready_asserted_when_not_enable_and_reset", "full_property": "property p_not_2;\n@(negedge clk)         !(!enable && reset) |-> ready;\nendproperty\nassert_p_not_2:assert property (p_not_2) else $error(\"\");", "task_id": "2_2156", "predict_sva": "@(negedge clk)         !(!enable && reset) |-> ready == 1"}
{"id": "15_18_0709", "name": "p18", "sva": "@(posedge clk) disable iff(force_error)     error_inject |-> ##2 error_detect", "ori_sva": "property p18;\n@(posedge clk) disable iff(force_error)     error_inject |-> ##2 error_detect\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p18  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (force_error)`  \n**Antecedent (LHS of Implication)**: `error_inject == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 error_detect == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] force_error", "[0:0] error_inject", "[0:0] error_detect"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (force_error)     error_inject == 1'b1 |-> ##2 error_detect == 1'b1;", "sva_name": "p_error_inject_to_error_detect", "full_property": "property p18;\n@(posedge clk) disable iff (force_error)     error_inject == 1'b1 |-> ##2 error_detect == 1'b1;\nendproperty\nassert_p18:assert property (p18) else $error(\"\");", "task_id": "2_2218", "predict_sva": "@(posedge clk) disable iff (force_error)         (force_error == 0 && error_inject == 1'b1) |-> ##2 (error_detect == 1'b1)"}
{"id": "15_8_0699", "name": "p8", "sva": "@(negedge clk) disable iff(bypass_mode)     $changed(addr) |-> ##1 $stable(addr)", "ori_sva": "property p8;\n@(negedge clk) disable iff(bypass_mode)     $changed(addr) |-> ##1 $stable(addr)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p8  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: disable iff (bypass_mode)  \n**Antecedent (LHS of Implication)**: `$changed(addr)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(addr)`  ", "sva_signals": ["clk", "rst_n", "bypass_mode", "addr"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk) disable iff (bypass_mode)     $changed(addr) |-> ##1 $stable(addr);", "sva_name": "p_addr_stable_after_change", "full_property": "property p8;\n@(negedge clk) disable iff (bypass_mode)     $changed(addr) |-> ##1 $stable(addr);\nendproperty\nassert_p8:assert property (p8) else $error(\"\");", "task_id": "2_2257", "predict_sva": "@(negedge clk) disable iff (bypass_mode)         (bypass_mode == 0 && $changed(addr)) |-> ##1 addr == $past(addr)"}
{"id": "1_19_0062", "name": "p_fixed_delay_19", "sva": "@(posedge clk) (phase_align && pll_locked) |-> ##7 clock_stable", "ori_sva": "property p_fixed_delay_19;\n@(posedge clk) (phase_align && pll_locked) |-> ##7 clock_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_19  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phase_align && pll_locked`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##7 clock_stable`  ", "sva_signals": ["clk", "rst_n", "[0:0] phase_align", "[0:0] pll_locked", "[0:0] clock_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (phase_align && pll_locked) |-> ##7 clock_stable;", "sva_name": "p_clock_stable_after_phase_align_and_pll_locked", "full_property": "property p_fixed_delay_19;\n@(posedge clk)         (phase_align && pll_locked) |-> ##7 clock_stable;\nendproperty\nassert_p_fixed_delay_19:assert property (p_fixed_delay_19) else $error(\"\");", "task_id": "2_2267", "predict_sva": "@(posedge clk)         (phase_align == 1 && pll_locked == 1) |-> ##7 (clock_stable == 1)"}
{"id": "1_35_0073", "name": "p_fixed_delay_35", "sva": "@(posedge clk) (pattern_match && !mask_match) |-> ##1 match_interrupt", "ori_sva": "property p_fixed_delay_35;\n@(posedge clk) (pattern_match && !mask_match) |-> ##1 match_interrupt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_35  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pattern_match && !mask_match`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 match_interrupt`", "sva_signals": ["clk", "rst_n", "[0:0] pattern_match", "[0:0] mask_match", "[0:0] match_interrupt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (pattern_match && !mask_match) |-> ##1 match_interrupt;", "sva_name": "p_match_interrupt_on_pattern_match", "full_property": "property p_fixed_delay_35;\n@(posedge clk)         (pattern_match && !mask_match) |-> ##1 match_interrupt;\nendproperty\nassert_p_fixed_delay_35:assert property (p_fixed_delay_35) else $error(\"\");", "task_id": "2_2284", "predict_sva": "@(posedge clk)         (pattern_match == 1 && mask_match == 0) |-> ##1 (match_interrupt == 1)"}
{"id": "1_41_0075", "name": "p_fixed_delay_41", "sva": "@(posedge clk) (packet_received && crc_check) |-> ##3 packet_valid", "ori_sva": "property p_fixed_delay_41;\n@(posedge clk) (packet_received && crc_check) |-> ##3 packet_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_41  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_received && crc_check`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 packet_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] packet_received", "[0:0] crc_check", "[0:0] packet_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (packet_received && crc_check) |-> ##3 packet_valid;", "sva_name": "p_packet_valid_after_packet_received_and_crc_check", "full_property": "property p_fixed_delay_41;\n@(posedge clk)         (packet_received && crc_check) |-> ##3 packet_valid;\nendproperty\nassert_p_fixed_delay_41:assert property (p_fixed_delay_41) else $error(\"\");", "task_id": "2_2291", "predict_sva": "@(posedge clk)         (packet_received == 1 && crc_check == 1) |-> ##3 (packet_valid == 1)"}
{"id": "1_44_0008", "name": "p_fixed_delay_44", "sva": "@(posedge clk) (phase_error && phase_adjust) |-> ##5 phase_locked", "ori_sva": "property p_fixed_delay_44;\n@(posedge clk) (phase_error && phase_adjust) |-> ##5 phase_locked;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_44  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phase_error && phase_adjust`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 phase_locked`  \n\n(Explanation: The assertion checks that if both `phase_error` and `phase_adjust` are true at a rising clock edge, then after exactly 5 clock cycles, `phase_locked` must be true.)", "sva_signals": ["clk", "rst_n", "[0:0] phase_error", "[0:0] phase_adjust", "[0:0] phase_locked"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (phase_error && phase_adjust) |-> ##5 phase_locked;", "sva_name": "p_phase_locked_after_phase_error_and_phase_adjust", "full_property": "property p_fixed_delay_44;\n@(posedge clk)         (phase_error && phase_adjust) |-> ##5 phase_locked;\nendproperty\nassert_p_fixed_delay_44:assert property (p_fixed_delay_44) else $error(\"\");", "task_id": "2_2294", "predict_sva": "@(posedge clk)         (phase_error == 1 && phase_adjust == 1) |-> ##5 (phase_locked == 1)"}
{"id": "2_11_0047", "name": "prop_11", "sva": "@(posedge clk)     sync_pulse |-> ##[4:9] sync_ack", "ori_sva": "property prop_11;\n@(posedge clk)     sync_pulse |-> ##[4:9] sync_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_11  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:9] sync_ack` (sync_ack must be asserted between 4 to 9 clock cycles after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] sync_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     sync_pulse == 1'b1 |-> ##[4:9] sync_ack;", "sva_name": "p_sync_ack_delay_after_sync_pulse", "full_property": "property prop_11;\n@(posedge clk)     sync_pulse == 1'b1 |-> ##[4:9] sync_ack;\nendproperty\nassert_prop_11:assert property (prop_11) else $error(\"\");", "task_id": "2_2307", "predict_sva": "@(posedge clk)         sync_pulse == 1'b1 |-> ##[4:9] sync_ack == 1'b1"}
{"id": "2_13_0010", "name": "prop_13", "sva": "@(posedge clk)     timer_expired |-> ##[2:6] timer_reset", "ori_sva": "property prop_13;\n@(posedge clk)     timer_expired |-> ##[2:6] timer_reset;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_13  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timer_expired == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:6] timer_reset == 1'b1`  \n\n(Note: The consequent specifies that `timer_reset` must become true within 2 to 6 clock cycles after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] timer_expired", "[0:0] timer_reset"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         timer_expired == 1'b1 |-> ##[2:6] timer_reset == 1'b1;", "sva_name": "p_timer_reset_after_expiry", "full_property": "property prop_13;\n@(posedge clk)         timer_expired == 1'b1 |-> ##[2:6] timer_reset == 1'b1;\nendproperty\nassert_prop_13:assert property (prop_13) else $error(\"\");", "task_id": "2_2309", "predict_sva": "@(posedge clk)         timer_expired == 1'b1 |-> ##[2:6] timer_reset == 1'b1"}
{"id": "2_26_0036", "name": "prop_26", "sva": "@(posedge clk)     clock_switch |-> ##[2:4] clock_stable", "ori_sva": "property prop_26;\n@(posedge clk)     clock_switch |-> ##[2:4] clock_stable;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_26  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `clock_switch == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] clock_stable` (The signal `clock_stable` must be true within 2 to 4 clock cycles after the antecedent is true)", "sva_signals": ["clk", "rst_n", "[0:0] clock_switch", "[0:0] clock_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         clock_switch == 1'b1 |-> ##[2:4] clock_stable;", "sva_name": "p_clock_stable_after_switch", "full_property": "property prop_26;\n@(posedge clk)         clock_switch == 1'b1 |-> ##[2:4] clock_stable;\nendproperty\nassert_prop_26:assert property (prop_26) else $error(\"\");", "task_id": "2_2324", "predict_sva": "@(posedge clk)         clock_switch |-> ##[2:4] clock_stable"}
{"id": "2_48_0087", "name": "prop_48", "sva": "@(posedge clk)     signal_loss |-> ##[3:6] signal_recovery", "ori_sva": "property prop_48;\n@(posedge clk)     signal_loss |-> ##[3:6] signal_recovery;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_48  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `signal_loss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] signal_recovery == 1'b1`  \n\n(Note: The consequent specifies that `signal_recovery` must become true within 3 to 6 clock cycles after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] signal_loss", "[0:0] signal_recovery"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     signal_loss == 1'b1 |-> ##[3:6] signal_recovery == 1'b1;", "sva_name": "p_signal_recovery_after_loss", "full_property": "property prop_48;\n@(posedge clk)     signal_loss == 1'b1 |-> ##[3:6] signal_recovery == 1'b1;\nendproperty\nassert_prop_48:assert property (prop_48) else $error(\"\");", "task_id": "2_2347", "predict_sva": "@(posedge clk)         signal_loss == 1'b1 |-> ##[3:6] signal_recovery == 1'b1"}
{"id": "3_31_0105", "name": "p_overlap_31", "sva": "@(posedge clk)     (debug_halt && debug_en) |-> debug_ack", "ori_sva": "property p_overlap_31;\n@(posedge clk)     (debug_halt && debug_en) |-> debug_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overlap_31  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `debug_halt && debug_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `debug_ack`", "sva_signals": ["clk", "rst_n", "[0:0] debug_halt", "[0:0] debug_en", "[0:0] debug_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (debug_halt && debug_en) |-> debug_ack;", "sva_name": "p_debug_ack_on_halt_and_en", "full_property": "property p_overlap_31;\n@(posedge clk)         (debug_halt && debug_en) |-> debug_ack;\nendproperty\nassert_p_overlap_31:assert property (p_overlap_31) else $error(\"\");", "task_id": "2_2378", "predict_sva": "@(posedge clk)         (debug_halt == 1 && debug_en == 1) |-> (debug_ack == 1)"}
{"id": "5_11_0228", "name": "prop_11", "sva": "@(posedge clk) $fell(interrupt_line)[*3] |-> interrupt_handled", "ori_sva": "property prop_11;\n@(posedge clk) $fell(interrupt_line)[*3] |-> interrupt_handled;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_11  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(interrupt_line)[*3]` (The `interrupt_line` signal falls 3 consecutive times)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `interrupt_handled` (The `interrupt_handled` signal must be asserted)  ", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_line", "[0:0] interrupt_handled"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(interrupt_line)[*3] |-> interrupt_handled;", "sva_name": "p_interrupt_handled_on_three_consecutive_falls", "full_property": "property prop_11;\n@(posedge clk)     $fell(interrupt_line)[*3] |-> interrupt_handled;\nendproperty\nassert_prop_11:assert property (prop_11) else $error(\"\");", "task_id": "2_2455", "predict_sva": "@(posedge clk)         $fell(interrupt_line) [*3] |-> interrupt_handled"}
{"id": "5_21_0231", "name": "prop_21", "sva": "@(posedge clk) (fifo_write_en && !fifo_full)[*2] |-> fifo_write_ptr_changed[*2]", "ori_sva": "property prop_21;\n@(posedge clk) (fifo_write_en && !fifo_full)[*2] |-> fifo_write_ptr_changed[*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_21  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(fifo_write_en && !fifo_full)[*2]` (two consecutive cycles where `fifo_write_en` is active and `fifo_full` is inactive)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fifo_write_ptr_changed[*2]` (two consecutive cycles where `fifo_write_ptr_changed` is active)  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_write_en", "[0:0] fifo_full", "[0:0] fifo_write_ptr_changed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (fifo_write_en && !fifo_full)[*2] |-> fifo_write_ptr_changed[*2];", "sva_name": "p_fifo_write_ptr_changed_on_valid_write", "full_property": "property prop_21;\n@(posedge clk)     (fifo_write_en && !fifo_full)[*2] |-> fifo_write_ptr_changed[*2];\nendproperty\nassert_prop_21:assert property (prop_21) else $error(\"\");", "task_id": "2_2465", "predict_sva": "@(posedge clk)         (fifo_write_en == 1 && fifo_full == 0) [*2] |-> (fifo_write_ptr_changed == 1) [*2]"}
{"id": "5_25_0210", "name": "prop_25", "sva": "@(posedge clk) (encryption_active && !encryption_error)[*2] |-> cipher_text_valid[*2]", "ori_sva": "property prop_25;\n@(posedge clk) (encryption_active && !encryption_error)[*2] |-> cipher_text_valid[*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_25  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(encryption_active && !encryption_error)[*2]` (The condition `encryption_active` is high and `encryption_error` is low for two consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cipher_text_valid[*2]` (The signal `cipher_text_valid` must be high for the next two consecutive clock cycles after the antecedent is satisfied)", "sva_signals": ["clk", "rst_n", "[0:0] encryption_active", "[0:0] encryption_error", "[0:0] cipher_text_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (encryption_active && !encryption_error)[*2] |-> cipher_text_valid[*2];", "sva_name": "p_cipher_text_valid_after_encryption_active_no_error", "full_property": "property prop_25;\n@(posedge clk)     (encryption_active && !encryption_error)[*2] |-> cipher_text_valid[*2];\nendproperty\nassert_prop_25:assert property (prop_25) else $error(\"\");", "task_id": "2_2469", "predict_sva": "@(posedge clk)         (encryption_active == 1 && encryption_error == 0) [*2] |-> cipher_text_valid == 1 [*2]"}
{"id": "5_47_0250", "name": "prop_47", "sva": "@(posedge clk) (branch_prediction_active && !branch_mispredict)[*2] |-> prediction_valid[*2]", "ori_sva": "property prop_47;\n@(posedge clk) (branch_prediction_active && !branch_mispredict)[*2] |-> prediction_valid[*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_47  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(branch_prediction_active && !branch_mispredict)[*2]`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `prediction_valid[*2]`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] branch_prediction_active", "[0:0] branch_mispredict", "[0:0] prediction_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (branch_prediction_active && !branch_mispredict)[*2] |-> prediction_valid[*2];", "sva_name": "p_prediction_valid_on_active_no_mispredict", "full_property": "property prop_47;\n@(posedge clk)         (branch_prediction_active && !branch_mispredict)[*2] |-> prediction_valid[*2];\nendproperty\nassert_prop_47:assert property (prop_47) else $error(\"\");", "task_id": "2_2538", "predict_sva": "@(posedge clk)         (branch_prediction_active == 1 && branch_mispredict == 0) [*2] |-> (prediction_valid == 1) [*2]"}
{"id": "6_5_0276", "name": "p_var_rep_5", "sva": "@(posedge clk)     (frame_start && sync_ok) |-> payload[*8:12] ##1 frame_end", "ori_sva": "property p_var_rep_5;\n@(posedge clk)     (frame_start && sync_ok) |-> payload[*8:12] ##1 frame_end;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_start && sync_ok`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `payload` repeats 8 to 12 times (`payload[*8:12]`) followed by `frame_end` in the next clock cycle (`##1 frame_end`)  ", "sva_signals": ["clk", "rst_n", "[0:0] frame_start", "[0:0] sync_ok", "[0:0] payload", "[0:0] frame_end"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (frame_start && sync_ok) |-> payload[*8:12] ##1 frame_end;", "sva_name": "p_frame_start_payload_sequence", "full_property": "property p_var_rep_5;\n@(posedge clk)     (frame_start && sync_ok) |-> payload[*8:12] ##1 frame_end;\nendproperty\nassert_p_var_rep_5:assert property (p_var_rep_5) else $error(\"\");", "task_id": "2_2542", "predict_sva": "@(posedge clk)     (frame_start && sync_ok) |=>      (payload [*8:12]) ##1 frame_end"}
{"id": "6_7_0247", "name": "p_var_rep_7", "sva": "@(posedge clk)     !fifo_empty[*2:4] |-> rd_en", "ori_sva": "property p_var_rep_7;\n@(posedge clk)     !fifo_empty[*2:4] |-> rd_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_var_rep_7  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!fifo_empty` holds true consecutively for 2 to 4 clock cycles (`[*2:4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `rd_en` must be asserted (high) in the same cycle where the antecedent sequence completes.  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] rd_en"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (!fifo_empty [*2:4]) |-> rd_en;", "sva_name": "p_rd_en_after_fifo_empty_sequence", "full_property": "property p_var_rep_7;\n@(posedge clk)     (!fifo_empty [*2:4]) |-> rd_en;\nendproperty\nassert_p_var_rep_7:assert property (p_var_rep_7) else $error(\"\");", "task_id": "2_2544", "predict_sva": "@(posedge clk)         (fifo_empty == 0 [*2:4]) |-> rd_en == 1"}
{"id": "7_5_0311", "name": "p_rose_req_grant", "sva": "@(posedge clk) $rose(req) |-> grant", "ori_sva": "property p_rose_req_grant;\n@(posedge clk) $rose(req) |-> grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_req_grant  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(req)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant`", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(req) |-> grant;", "sva_name": "p_grant_on_req_rise", "full_property": "property p_rose_req_grant;\n@(posedge clk)         $rose(req) |-> grant;\nendproperty\nassert_p_rose_req_grant:assert property (p_rose_req_grant) else $error(\"\");", "task_id": "2_2592", "predict_sva": "@(posedge clk)         $rose(req) |-> grant == 1"}
{"id": "8_19_0375", "name": "p_fell_19", "sva": "@(posedge clk) $fell(update) |-> ##2 !dirty_bit", "ori_sva": "property p_fell_19;\n@(posedge clk) $fell(update) |-> ##2 !dirty_bit;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_19  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(update)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 !dirty_bit`  ", "sva_signals": ["clk", "rst_n", "[0:0] update", "[0:0] dirty_bit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(update) |-> ##2 !dirty_bit;", "sva_name": "p_dirty_bit_deassert_after_update_fall", "full_property": "property p_fell_19;\n@(posedge clk)     $fell(update) |-> ##2 !dirty_bit;\nendproperty\nassert_p_fell_19:assert property (p_fell_19) else $error(\"\");", "task_id": "2_2607", "predict_sva": "@(posedge clk)         $fell(update) |-> ##2 dirty_bit == 0"}
{"id": "10_21_0490", "name": "p_past_burst_counter", "sva": "@(posedge clk)     $past(burst_en, 1) |-> burst_cnt == ($past(burst_cnt, 1) + 1) % 8", "ori_sva": "property p_past_burst_counter;\n@(posedge clk)     $past(burst_en, 1) |-> burst_cnt == ($past(burst_cnt, 1) + 1) % 8;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_burst_counter  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(burst_en, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `burst_cnt == ($past(burst_cnt, 1) + 1) % 8`", "sva_signals": ["clk", "rst_n", "[0:0] burst_en", "[2:0] burst_cnt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(burst_en, 1) |-> burst_cnt == (($past(burst_cnt, 1) + 1) % 8);", "sva_name": "p_burst_cnt_increment_on_burst_en", "full_property": "property p_past_burst_counter;\n@(posedge clk)         $past(burst_en, 1) |-> burst_cnt == (($past(burst_cnt, 1) + 1) % 8);\nendproperty\nassert_p_past_burst_counter:assert property (p_past_burst_counter) else $error(\"\");", "task_id": "2_2699", "predict_sva": "@(posedge clk)         $past(burst_en) == 1 |-> burst_cnt % 8 == 1"}
{"id": "10_29_0451", "name": "p_past_serial_to_parallel", "sva": "@(posedge clk)     $past(ser_valid, 8) |-> par_valid", "ori_sva": "property p_past_serial_to_parallel;\n@(posedge clk)     $past(ser_valid, 8) |-> par_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_serial_to_parallel  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(ser_valid, 8)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `par_valid`  ", "sva_signals": ["clk", "rst_n", "[0:0] ser_valid", "[0:0] par_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(ser_valid, 8) |-> par_valid;", "sva_name": "p_ser_valid_to_par_valid_8cycle", "full_property": "property p_past_serial_to_parallel;\n@(posedge clk)         $past(ser_valid, 8) |-> par_valid;\nendproperty\nassert_p_past_serial_to_parallel:assert property (p_past_serial_to_parallel) else $error(\"\");", "task_id": "2_2707", "predict_sva": "@(posedge clk)         $past(ser_valid, 8) |-> par_valid"}
{"id": "10_44_0500", "name": "p_past_scan_chain", "sva": "@(posedge clk)     $past(scan_en, 5) |-> scan_out == $past(scan_in, 5)", "ori_sva": "property p_past_scan_chain;\n@(posedge clk)     $past(scan_en, 5) |-> scan_out == $past(scan_in, 5);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_scan_chain  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(scan_en, 5)` (scan_en was high 5 clock cycles ago)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `scan_out == $past(scan_in, 5)` (scan_out must equal the value of scan_in from 5 clock cycles ago)", "sva_signals": ["clk", "rst_n", "[0:0] scan_en", "[0:0] scan_out", "[0:0] scan_in"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $past(scan_en, 5) |-> scan_out == $past(scan_in, 5);", "sva_name": "p_scan_out_matches_scan_in_5cycles_ago", "full_property": "property p_past_scan_chain;\n@(posedge clk)     $past(scan_en, 5) |-> scan_out == $past(scan_in, 5);\nendproperty\nassert_p_past_scan_chain:assert property (p_past_scan_chain) else $error(\"\");", "task_id": "2_2720", "predict_sva": "@(posedge clk)         $past(scan_en, 5) |-> scan_out == $past(scan_in, 5)"}
{"id": "10_42_0503", "name": "p_past_irq_latency", "sva": "@(posedge clk)     $past(irq, 3) && !$past(irq_ack, 2) |-> irq_handler_active", "ori_sva": "property p_past_irq_latency;\n@(posedge clk)     $past(irq, 3) && !$past(irq_ack, 2) |-> irq_handler_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_irq_latency  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(irq, 3) && !$past(irq_ack, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `irq_handler_active`  ", "sva_signals": ["clk", "rst_n", "[0:0] irq", "[0:0] irq_ack", "[0:0] irq_handler_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ($past(irq, 3) && !$past(irq_ack, 2)) |-> irq_handler_active;", "sva_name": "p_irq_handler_activation_on_irq_and_ack", "full_property": "property p_past_irq_latency;\n@(posedge clk)         ($past(irq, 3) && !$past(irq_ack, 2)) |-> irq_handler_active;\nendproperty\nassert_p_past_irq_latency:assert property (p_past_irq_latency) else $error(\"\");", "task_id": "2_2723", "predict_sva": "@(posedge clk)         ($past(irq, 3) == 1 && $past(irq_ack, 2) == 0) |-> irq_handler_active == 1"}
{"id": "10_4_0441", "name": "p_past_error_persists", "sva": "@(posedge clk)     $past(err_flag, 2) && $past(err_flag, 1) |-> err_flag", "ori_sva": "property p_past_error_persists;\n@(posedge clk)     $past(err_flag, 2) && $past(err_flag, 1) |-> err_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_error_persists  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(err_flag, 2) && $past(err_flag, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `err_flag`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] err_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ($past(err_flag, 2) && $past(err_flag, 1)) |-> err_flag;", "sva_name": "p_err_flag_sticky_2cycles", "full_property": "property p_past_error_persists;\n@(posedge clk)     ($past(err_flag, 2) && $past(err_flag, 1)) |-> err_flag;\nendproperty\nassert_p_past_error_persists:assert property (p_past_error_persists) else $error(\"\");", "task_id": "2_2727", "predict_sva": "@(posedge clk)         ($past(err_flag, 2) == 1 && $past(err_flag, 1) == 1) |-> (err_flag == 1)"}
{"id": "11_15_0504", "name": "p_and_15", "sva": "@(posedge clk)     (sync_pulse && locked) |-> sync_ack", "ori_sva": "property p_and_15;\n@(posedge clk)     (sync_pulse && locked) |-> sync_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_15  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse && locked`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `sync_ack`", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] locked", "[0:0] sync_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sync_pulse && locked) |-> sync_ack;", "sva_name": "p_sync_ack_on_pulse_and_locked", "full_property": "property p_and_15;\n@(posedge clk)         (sync_pulse && locked) |-> sync_ack;\nendproperty\nassert_p_and_15:assert property (p_and_15) else $error(\"\");", "task_id": "2_2739", "predict_sva": "@(posedge clk)         (sync_pulse == 1 && locked == 1) |-> (sync_ack == 1)"}
{"id": "11_39_0553", "name": "p_and_39", "sva": "@(posedge clk)     (sop && eop) && valid |-> single_packet", "ori_sva": "property p_and_39;\n@(posedge clk)     (sop && eop) && valid |-> single_packet\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_39  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(sop && eop) && valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `single_packet`", "sva_signals": ["clk", "rst_n", "[0:0] sop", "[0:0] eop", "[0:0] valid", "[0:0] single_packet"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         ((sop && eop) && valid) |-> single_packet;", "sva_name": "p_single_packet_on_sop_eop_valid", "full_property": "property p_and_39;\n@(posedge clk)         ((sop && eop) && valid) |-> single_packet;\nendproperty\nassert_p_and_39:assert property (p_and_39) else $error(\"\");", "task_id": "2_2764", "predict_sva": "@(posedge clk)         (sop == 1 && eop == 1 && valid == 1) |-> (single_packet == 1)"}
{"id": "11_42_0732", "name": "p_and_42", "sva": "@(posedge clk)     (encrypt_en && key_ready) |-> cipher_start", "ori_sva": "property p_and_42;\n@(posedge clk)     (encrypt_en && key_ready) |-> cipher_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_and_42  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encrypt_en && key_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cipher_start`", "sva_signals": ["clk", "rst_n", "[0:0] encrypt_en", "[0:0] key_ready", "[0:0] cipher_start"], "clock": "clk", "attempts_left": 9, "sva_result": "@(posedge clk)         (encrypt_en && key_ready) |-> cipher_start;", "sva_name": "p_cipher_start_when_encrypt_and_key_ready", "full_property": "property p_and_42;\n@(posedge clk)         (encrypt_en && key_ready) |-> cipher_start;\nendproperty\nassert_p_and_42:assert property (p_and_42) else $error(\"\");", "task_id": "2_2768", "predict_sva": "@(posedge clk)         (encrypt_en == 1 && key_ready == 1) |-> (cipher_start == 1)"}
{"id": "11_4_0511", "name": "p_and_4", "sva": "@(posedge clk)     enable && (count > threshold) |-> overflow", "ori_sva": "property p_and_4;\n@(posedge clk)     enable && (count > threshold) |-> overflow\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_and_4  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `enable && (count > threshold)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `overflow`", "sva_signals": ["clk", "rst_n", "[0:0] enable", "[0:0] overflow", "[0:0] count", "[0:0] threshold"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (enable && (count > threshold)) |-> overflow;", "sva_name": "p_overflow_on_threshold_exceed", "full_property": "property p_and_4;\n@(posedge clk)         (enable && (count > threshold)) |-> overflow;\nendproperty\nassert_p_and_4:assert property (p_and_4) else $error(\"\");", "task_id": "2_2775", "predict_sva": "@(posedge clk)         (enable == 1 && count > threshold) |-> (overflow == 1)"}
{"id": "12_11_0537", "name": "p_or_11", "sva": "@(posedge clk)     (config_error || parity_error) |-> error_status", "ori_sva": "property p_or_11;\n@(posedge clk)     (config_error || parity_error) |-> error_status\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_11  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(config_error || parity_error)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `error_status`", "sva_signals": ["clk", "rst_n", "[0:0] config_error", "[0:0] parity_error", "[0:0] error_status"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (config_error || parity_error) |-> error_status;", "sva_name": "p_error_status_on_error", "full_property": "property p_or_11;\n@(posedge clk)         (config_error || parity_error) |-> error_status;\nendproperty\nassert_p_or_11:assert property (p_or_11) else $error(\"\");", "task_id": "2_2784", "predict_sva": "@(posedge clk)         (config_error == 1 || parity_error == 1) |-> error_status == 1"}
{"id": "12_21_0546", "name": "p_or_21", "sva": "@(posedge clk)     (sync_pulse || async_pulse) |-> ##1 pulse_ack", "ori_sva": "property p_or_21;\n@(posedge clk)     (sync_pulse || async_pulse) |-> ##1 pulse_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_or_21  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse || async_pulse`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 pulse_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] async_pulse", "[0:0] pulse_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (sync_pulse || async_pulse) |-> ##1 pulse_ack;", "sva_name": "p_pulse_ack_on_pulse", "full_property": "property p_or_21;\n@(posedge clk)         (sync_pulse || async_pulse) |-> ##1 pulse_ack;\nendproperty\nassert_p_or_21:assert property (p_or_21) else $error(\"\");", "task_id": "2_2795", "predict_sva": "@(posedge clk)         (sync_pulse == 1 || async_pulse == 1) |-> ##1 pulse_ack == 1"}
{"id": "13_11_0593", "name": "p_not_11", "sva": "@(negedge clk) !(full || empty) |-> can_write", "ori_sva": "property p_not_11;\n@(negedge clk) !(full || empty) |-> can_write\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_11  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(full || empty)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `can_write`", "sva_signals": ["clk", "rst_n", "[0:0] full", "[0:0] empty", "[0:0] can_write"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)         !(full || empty) |-> can_write;", "sva_name": "p_can_write_when_not_full_and_not_empty", "full_property": "property p_not_11;\n@(negedge clk)         !(full || empty) |-> can_write;\nendproperty\nassert_p_not_11:assert property (p_not_11) else $error(\"\");", "task_id": "2_2832", "predict_sva": "@(negedge clk)         (full == 0 && empty == 0) |-> (can_write == 1)"}
{"id": "13_22_0599", "name": "p_not_22", "sva": "@(posedge clk) !(fifo_empty && fifo_full) |-> fifo_ok", "ori_sva": "property p_not_22;\n@(posedge clk) !(fifo_empty && fifo_full) |-> fifo_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_22  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(fifo_empty && fifo_full)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `fifo_ok`", "sva_signals": ["clk", "rst_n", "[0:0] fifo_empty", "[0:0] fifo_full", "[0:0] fifo_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(fifo_empty && fifo_full) |-> fifo_ok;", "sva_name": "p_fifo_ok_when_not_both_empty_and_full", "full_property": "property p_not_22;\n@(posedge clk)         !(fifo_empty && fifo_full) |-> fifo_ok;\nendproperty\nassert_p_not_22:assert property (p_not_22) else $error(\"\");", "task_id": "2_2841", "predict_sva": "@(posedge clk)         !(fifo_empty && fifo_full) |-> fifo_ok"}
{"id": "13_32_0618", "name": "p_not_32", "sva": "@(negedge clk) !(low_power && high_power) |-> mid_power", "ori_sva": "property p_not_32;\n@(negedge clk) !(low_power && high_power) |-> mid_power\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_32  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(low_power && high_power)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `mid_power`", "sva_signals": ["clk", "rst_n", "[0:0] low_power", "[0:0] high_power", "[0:0] mid_power"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)         !(low_power && high_power) |-> mid_power;", "sva_name": "p_mid_power_assertion_when_not_both_powers", "full_property": "property p_not_32;\n@(negedge clk)         !(low_power && high_power) |-> mid_power;\nendproperty\nassert_p_not_32:assert property (p_not_32) else $error(\"\");", "task_id": "2_2851", "predict_sva": "@(negedge clk)         !(low_power && high_power) |-> mid_power == 1"}
{"id": "13_36_0627", "name": "p_not_36", "sva": "@(posedge clk) !(early_term && late_term) |-> on_time", "ori_sva": "property p_not_36;\n@(posedge clk) !(early_term && late_term) |-> on_time\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_36  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!(early_term && late_term)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `on_time`", "sva_signals": ["clk", "rst_n", "[0:0] early_term", "[0:0] late_term", "[0:0] on_time"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         !(early_term && late_term) |-> on_time;", "sva_name": "p_on_time_assertion", "full_property": "property p_not_36;\n@(posedge clk)         !(early_term && late_term) |-> on_time;\nendproperty\nassert_p_not_36:assert property (p_not_36) else $error(\"\");", "task_id": "2_2855", "predict_sva": "@(posedge clk)         !(early_term && late_term) |-> on_time == 1"}
{"id": "1_12_0063", "name": "p_fixed_delay_12", "sva": "@(posedge clk) (timeout_start && !timeout_clear) |-> ##8 timeout_event", "ori_sva": "property p_fixed_delay_12;\n@(posedge clk) (timeout_start && !timeout_clear) |-> ##8 timeout_event;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_12  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timeout_start && !timeout_clear`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 timeout_event`  \n\n(Note: The consequent specifies that exactly 8 clock cycles after the antecedent is true, `timeout_event` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] timeout_start", "[0:0] timeout_clear", "[0:0] timeout_event"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (timeout_start && !timeout_clear) |-> ##8 timeout_event;", "sva_name": "p_timeout_event_after_8_cycles", "full_property": "property p_fixed_delay_12;\n@(posedge clk)         (timeout_start && !timeout_clear) |-> ##8 timeout_event;\nendproperty\nassert_p_fixed_delay_12:assert property (p_fixed_delay_12) else $error(\"\");", "task_id": "2_2946", "predict_sva": "@(posedge clk)         (timeout_start == 1 && timeout_clear == 0) |-> ##8 (timeout_event == 1)"}
{"id": "1_37_0014", "name": "p_fixed_delay_37", "sva": "@(posedge clk) (jtag_reset && tck_stable) |-> ##3 jtag_ready", "ori_sva": "property p_fixed_delay_37;\n@(posedge clk) (jtag_reset && tck_stable) |-> ##3 jtag_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_37  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `jtag_reset && tck_stable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 jtag_ready`  \n\n(Explanation: The assertion checks that if both `jtag_reset` and `tck_stable` are true at a rising clock edge, then after exactly 3 clock cycles (`##3`), `jtag_ready` must be asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] jtag_reset", "[0:0] tck_stable", "[0:0] jtag_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (jtag_reset && tck_stable) |-> ##3 jtag_ready;", "sva_name": "p_jtag_ready_after_reset_and_tck_stable", "full_property": "property p_fixed_delay_37;\n@(posedge clk)     (jtag_reset && tck_stable) |-> ##3 jtag_ready;\nendproperty\nassert_p_fixed_delay_37:assert property (p_fixed_delay_37) else $error(\"\");", "task_id": "2_2973", "predict_sva": "@(posedge clk)         (jtag_reset == 1 && tck_stable == 1) |-> ##3 (jtag_ready == 1)"}
{"id": "1_5_0010", "name": "p_fixed_delay_5", "sva": "@(posedge clk) (wr_en && full) |-> ##3 overflow_flag", "ori_sva": "property p_fixed_delay_5;\n@(posedge clk) (wr_en && full) |-> ##3 overflow_flag;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fixed_delay_5  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wr_en && full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 overflow_flag`  \n\n(Note: The assertion states that whenever `wr_en` and `full` are both true at a rising clock edge, the `overflow_flag` must be true exactly 3 clock cycles later.)", "sva_signals": ["clk", "rst_n", "[0:0] wr_en", "[0:0] full", "[0:0] overflow_flag"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (wr_en && full) |-> ##3 overflow_flag;", "sva_name": "p_overflow_flag_after_wr_en_full", "full_property": "property p_fixed_delay_5;\n@(posedge clk)     (wr_en && full) |-> ##3 overflow_flag;\nendproperty\nassert_p_fixed_delay_5:assert property (p_fixed_delay_5) else $error(\"\");", "task_id": "2_2989", "predict_sva": "@(posedge clk)         (wr_en == 1 && full == 1) |-> ##3 (overflow_flag == 1)"}
{"id": "2_26_0055", "name": "prop_26", "sva": "@(negedge clk)     sensor_trigger |-> ##[3:9] sensor_data_ready", "ori_sva": "property prop_26;\n@(negedge clk)     sensor_trigger |-> ##[3:9] sensor_data_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_26  \n**Trigger Condition**: At every falling edge of the `clk`;  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_trigger == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:9] sensor_data_ready == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] sensor_trigger", "[0:0] sensor_data_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     sensor_trigger == 1'b1 |-> ##[3:9] sensor_data_ready == 1'b1;", "sva_name": "p_sensor_data_ready_after_trigger", "full_property": "property prop_26;\n@(negedge clk)     sensor_trigger == 1'b1 |-> ##[3:9] sensor_data_ready == 1'b1;\nendproperty\nassert_prop_26:assert property (prop_26) else $error(\"\");", "task_id": "2_3011", "predict_sva": "@(negedge clk)         sensor_trigger == 1'b1 |-> ##[3:9] sensor_data_ready == 1'b1"}
{"id": "3_16_0097", "name": "p_config_implies_ready", "sva": "@(posedge clk) config_done |-> module_ready", "ori_sva": "property p_config_implies_ready;\n@(posedge clk) config_done |-> module_ready;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_config_implies_ready  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `config_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `module_ready == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] config_done", "[0:0] module_ready"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         config_done == 1'b1 |-> module_ready == 1'b1;", "sva_name": "p_config_done_module_ready", "full_property": "property p_config_implies_ready;\n@(posedge clk)         config_done == 1'b1 |-> module_ready == 1'b1;\nendproperty\nassert_p_config_implies_ready:assert property (p_config_implies_ready) else $error(\"\");", "task_id": "2_3049", "predict_sva": "@(posedge clk)         config_done == 1'b1 |-> module_ready == 1'b1"}
{"id": "2_9_0008", "name": "prop_9", "sva": "@(posedge clk)     dma_request |-> ##[10:20] dma_complete", "ori_sva": "property prop_9;\n@(posedge clk)     dma_request |-> ##[10:20] dma_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: prop_9  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] dma_complete == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] dma_request", "[0:0] dma_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     dma_request == 1'b1 |-> ##[10:20] dma_complete == 1'b1;", "sva_name": "p_dma_complete_within_10_to_20_cycles_after_request", "full_property": "property prop_9;\n@(posedge clk)     dma_request == 1'b1 |-> ##[10:20] dma_complete == 1'b1;\nendproperty\nassert_prop_9:assert property (prop_9) else $error(\"\");", "task_id": "2_3042", "predict_sva": "@(posedge clk)         dma_request == 1'b1 |-> ##[10:20] dma_complete == 1'b1"}
{"id": "3_29_0093", "name": "p_initialized_implies_go", "sva": "@(posedge clk) initialized |-> go_signal", "ori_sva": "property p_initialized_implies_go;\n@(posedge clk) initialized |-> go_signal;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_initialized_implies_go  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `initialized`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `go_signal`", "sva_signals": ["clk", "rst_n", "[0:0] go_signal", "[0:0] initialized"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         initialized |-> go_signal;", "sva_name": "p_initialized_go_signal", "full_property": "property p_initialized_implies_go;\n@(posedge clk)         initialized |-> go_signal;\nendproperty\nassert_p_initialized_implies_go:assert property (p_initialized_implies_go) else $error(\"\");", "task_id": "2_3063", "predict_sva": "@(posedge clk)         initialized == 1 |-> go_signal == 1"}
{"id": "3_49_0745", "name": "p_voltage_drop_implies_alert", "sva": "@(posedge clk) voltage_drop |-> power_alert", "ori_sva": "property p_voltage_drop_implies_alert;\n@(posedge clk) voltage_drop |-> power_alert;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_drop_implies_alert  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_drop == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `power_alert == 1'b1`", "sva_signals": ["clk", "rst_n", "[0:0] voltage_drop", "[0:0] power_alert"], "clock": "clk", "attempts_left": 9, "sva_result": "@(posedge clk)         voltage_drop == 1'b1 |-> power_alert == 1'b1;", "sva_name": "p_voltage_drop_power_alert", "full_property": "property p_voltage_drop_implies_alert;\n@(posedge clk)         voltage_drop == 1'b1 |-> power_alert == 1'b1;\nendproperty\nassert_p_voltage_drop_implies_alert:assert property (p_voltage_drop_implies_alert) else $error(\"\");", "task_id": "2_3084", "predict_sva": "@(posedge clk)         voltage_drop == 1'b1 |-> power_alert == 1'b1"}
{"id": "5_17_0204", "name": "p_17", "sva": "@(posedge clk)     (init_start[*4]) |-> ##4 init_complete", "ori_sva": "property p_17;\n@(posedge clk)     (init_start[*4]) |-> ##4 init_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_17  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `init_start` is high for 4 consecutive cycles (`init_start[*4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `init_complete` must be high 4 cycles after the last occurrence of `init_start` (`##4 init_complete`)", "sva_signals": ["clk", "rst_n", "[0:0] init_start", "[0:0] init_complete"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     init_start[*4] |-> ##4 init_complete;", "sva_name": "p_init_complete_after_4_consecutive_init_start", "full_property": "property p_17;\n@(posedge clk)     init_start[*4] |-> ##4 init_complete;\nendproperty\nassert_p_17:assert property (p_17) else $error(\"\");", "task_id": "2_3149", "predict_sva": "@(posedge clk)         init_start [*4] |-> ##4 init_complete"}
{"id": "5_31_0234", "name": "p_31", "sva": "@(posedge clk)     (spi_cs_low[*4]) |-> ##4 spi_cs_high", "ori_sva": "property p_31;\n@(posedge clk)     (spi_cs_low[*4]) |-> ##4 spi_cs_high\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_31  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `spi_cs_low` holds true for 4 consecutive clock cycles (`spi_cs_low[*4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After exactly 4 clock cycles (`##4`), `spi_cs_high` must be true  ", "sva_signals": ["clk", "rst_n", "[0:0] spi_cs_low", "[0:0] spi_cs_high"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     spi_cs_low[*4] |-> ##4 spi_cs_high;", "sva_name": "p_spi_cs_low_to_high_4cycle_delay", "full_property": "property p_31;\n@(posedge clk)     spi_cs_low[*4] |-> ##4 spi_cs_high;\nendproperty\nassert_p_31:assert property (p_31) else $error(\"\");", "task_id": "2_3165", "predict_sva": "@(posedge clk)         spi_cs_low [*4] |-> ##4 spi_cs_high"}
{"id": "7_47_0367", "name": "p_rose_monitor_log", "sva": "@(posedge clk) $rose(monitor) |-> log", "ori_sva": "property p_rose_monitor_log;\n@(posedge clk) $rose(monitor) |-> log;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rose_monitor_log  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(monitor)` (monitor transitions from low to high)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `log` (log must be high)", "sva_signals": ["clk", "rst_n", "[0:0] monitor", "[0:0] log"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(monitor) |-> log;", "sva_name": "p_log_asserted_on_monitor_rise", "full_property": "property p_rose_monitor_log;\n@(posedge clk)     $rose(monitor) |-> log;\nendproperty\nassert_p_rose_monitor_log:assert property (p_rose_monitor_log) else $error(\"\");", "task_id": "2_3279", "predict_sva": "@(posedge clk)         $rose(monitor) |-> log == 1"}
{"id": "8_18_0360", "name": "p_fell_calibrate_done", "sva": "@(posedge clk)     $fell(calibrate) |-> ##5 calibration_done", "ori_sva": "property p_fell_calibrate_done;\n@(posedge clk)     $fell(calibrate) |-> ##5 calibration_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_calibrate_done  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(calibrate)` (a falling edge detected on the signal `calibrate`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 calibration_done` (5 clock cycles after the antecedent, the signal `calibration_done` must be asserted)", "sva_signals": ["clk", "rst_n", "[0:0] calibrate", "[0:0] calibration_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(calibrate) |-> ##5 calibration_done;", "sva_name": "p_calibration_done_after_calibrate_fall", "full_property": "property p_fell_calibrate_done;\n@(posedge clk)         $fell(calibrate) |-> ##5 calibration_done;\nendproperty\nassert_p_fell_calibrate_done:assert property (p_fell_calibrate_done) else $error(\"\");", "task_id": "2_3296", "predict_sva": "@(posedge clk)         $fell(calibrate) |-> ##5 calibration_done"}
{"id": "8_35_0362", "name": "p_fell_clock_div_change", "sva": "@(posedge clk)     $fell(clock_div) |-> ##2 clock_changed", "ori_sva": "property p_fell_clock_div_change;\n@(posedge clk)     $fell(clock_div) |-> ##2 clock_changed;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fell_clock_div_change  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clock_div)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 clock_changed`  ", "sva_signals": ["clk", "rst_n", "[0:0] clock_div", "[0:0] clock_changed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(clock_div) |-> ##2 clock_changed;", "sva_name": "p_clock_div_fall_clock_changed", "full_property": "property p_fell_clock_div_change;\n@(posedge clk)         $fell(clock_div) |-> ##2 clock_changed;\nendproperty\nassert_p_fell_clock_div_change:assert property (p_fell_clock_div_change) else $error(\"\");", "task_id": "2_3316", "predict_sva": "@(posedge clk)         $fell(clock_div) |-> ##2 clock_changed"}
{"id": "8_5_0345", "name": "p_fell_req_ack_follows", "sva": "@(posedge clk)     $fell(req) |=> ack", "ori_sva": "property p_fell_req_ack_follows;\n@(posedge clk)     $fell(req) |=> ack;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_fell_req_ack_follows  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(req)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `ack`  \n\n(Note: The `|=>` operator means the consequent is checked in the next clock cycle after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] req", "[0:0] ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(req) |=> ack;", "sva_name": "p_ack_on_req_fall", "full_property": "property p_fell_req_ack_follows;\n@(posedge clk)         $fell(req) |=> ack;\nendproperty\nassert_p_fell_req_ack_follows:assert property (p_fell_req_ack_follows) else $error(\"\");", "task_id": "2_3334", "predict_sva": "@(posedge clk)         $fell(req) |-> ##1 ack == 1"}
{"id": "10_48_0493", "name": "p_pwm_deadtime_check", "sva": "@(posedge pwm_clk)     $fell(pwm_a) |-> ##[2:4] ($past(pwm_b,1) == 1'b0) ##0 deadtime_ok", "ori_sva": "property p_pwm_deadtime_check;\n@(posedge pwm_clk)     $fell(pwm_a) |-> ##[2:4] ($past(pwm_b,1) == 1'b0) ##0 deadtime_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pwm_deadtime_check  \n**Trigger Condition**: At every rising edge of the `pwm_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(pwm_a)` (a falling edge is detected on `pwm_a`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] ($past(pwm_b,1) == 1'b0) ##0 deadtime_ok`  \n- The consequent checks that within 2 to 4 clock cycles after the antecedent, the following two conditions must hold:  \n  1. The past value of `pwm_b` (1 clock cycle before) was `1'b0`.  \n  2. The signal `deadtime_ok` is asserted (evaluates to true) at the same time as the check on `pwm_b`.  \n\nThis assertion verifies that after a falling edge on `pwm_a`, `pwm_b` was low in the previous cycle, and a valid deadtime (`deadtime_ok`) is observed within 2 to 4 clock cycles.", "sva_signals": ["pwm_clk", "[0:0] pwm_a", "[0:0] pwm_b", "[0:0] deadtime_ok"], "clock": "pwm_clk", "attempts_left": 10, "sva_result": "@(posedge pwm_clk)     $fell(pwm_a) |-> ##[2:4] ($past(pwm_b,1) == 1'b0) ##0 deadtime_ok;", "sva_name": "p_pwm_a_falling_edge_deadtime_check", "full_property": "property p_pwm_deadtime_check;\n@(posedge pwm_clk)     $fell(pwm_a) |-> ##[2:4] ($past(pwm_b,1) == 1'b0) ##0 deadtime_ok;\nendproperty\nassert_p_pwm_deadtime_check:assert property (p_pwm_deadtime_check) else $error(\"\");", "task_id": "2_3431", "predict_sva": "@(posedge pwm_clk)         $fell(pwm_a) |-> ##[2:4] ($past(pwm_b,1) == 0 && deadtime_ok == 1)"}
{"id": "11_14_0521", "name": "uart_break_condition_detection", "sva": "@(posedge clk_uart)     rx_low && !tx_active |-> ##[12:16] break_detected && !framing_error", "ori_sva": "property uart_break_condition_detection;\n@(posedge clk_uart)     rx_low && !tx_active |-> ##[12:16] break_detected && !framing_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: uart_break_condition_detection  \n**Trigger Condition**: At every rising edge of the `clk_uart`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rx_low && !tx_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[12:16] break_detected && !framing_error`  ", "sva_signals": ["clk_uart", "tx_active", "[0:0] rx_low", "[0:0] break_detected", "[0:0] framing_error"], "clock": "clk_uart", "attempts_left": 10, "sva_result": "@(posedge clk_uart)     (rx_low && !tx_active) |-> ##[12:16] (break_detected && !framing_error);", "sva_name": "p_break_detected_framing_error_window", "full_property": "property uart_break_condition_detection;\n@(posedge clk_uart)     (rx_low && !tx_active) |-> ##[12:16] (break_detected && !framing_error);\nendproperty\nassert_uart_break_condition_detection:assert property (uart_break_condition_detection) else $error(\"\");", "task_id": "2_3442", "predict_sva": "@(posedge clk_uart)         (rx_low == 1 && tx_active == 0) |-> ##[12:16] (break_detected == 1 && framing_error == 0)"}
{"id": "11_16_0498", "name": "sdio_cmd_response_timeout", "sva": "@(posedge clk_sdio)     cmd_sent && !cmd_busy |-> ##[8:64] response_received || timeout_error", "ori_sva": "property sdio_cmd_response_timeout;\n@(posedge clk_sdio)     cmd_sent && !cmd_busy |-> ##[8:64] response_received || timeout_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sdio_cmd_response_timeout  \n**Trigger Condition**: At every rising edge of the `clk_sdio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_sent && !cmd_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:64] response_received || timeout_error`  \n\n", "sva_signals": ["clk_sdio", "cmd_sent", "cmd_busy", "response_received", "timeout_error"], "clock": "clk_sdio", "attempts_left": 10, "sva_result": "@(posedge clk_sdio)     (cmd_sent && !cmd_busy) |-> ##[8:64] (response_received || timeout_error);", "sva_name": "p_cmd_response_or_timeout_within_8_to_64_cycles", "full_property": "property sdio_cmd_response_timeout;\n@(posedge clk_sdio)     (cmd_sent && !cmd_busy) |-> ##[8:64] (response_received || timeout_error);\nendproperty\nassert_sdio_cmd_response_timeout:assert property (sdio_cmd_response_timeout) else $error(\"\");", "task_id": "2_3445", "predict_sva": "@(posedge clk_sdio)         (cmd_sent == 1 && cmd_busy == 0) |-> ##[8:64] (response_received == 1 || timeout_error == 1)"}
{"id": "11_38_0538", "name": "secure_boot_signature_verify", "sva": "@(posedge clk_boot)     auth_start && !crypto_busy |-> ##[32:64] auth_pass && !tamper_detected", "ori_sva": "property secure_boot_signature_verify;\n@(posedge clk_boot)     auth_start && !crypto_busy |-> ##[32:64] auth_pass && !tamper_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: secure_boot_signature_verify  \n**Trigger Condition**: At every rising edge of the `clk_boot`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `auth_start && !crypto_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[32:64] auth_pass && !tamper_detected`  ", "sva_signals": ["clk_boot", "[0:0] auth_start", "[0:0] crypto_busy", "[0:0] auth_pass", "[0:0] tamper_detected"], "clock": "clk_boot", "attempts_left": 10, "sva_result": "@(posedge clk_boot)         (auth_start && !crypto_busy) |-> ##[32:64] (auth_pass && !tamper_detected);", "sva_name": "p_auth_pass_within_32_64_cycles_no_tamper", "full_property": "property secure_boot_signature_verify;\n@(posedge clk_boot)         (auth_start && !crypto_busy) |-> ##[32:64] (auth_pass && !tamper_detected);\nendproperty\nassert_secure_boot_signature_verify:assert property (secure_boot_signature_verify) else $error(\"\");", "task_id": "2_3466", "predict_sva": "@(posedge clk_boot)         (auth_start == 1 && crypto_busy == 0) |-> ##[32:64] (auth_pass == 1 && tamper_detected == 0)"}
{"id": "12_30_0559", "name": "crc32_match_or_ignore_check_30", "sva": "@(posedge clk_pcie)      (rx_crc32 == comp_crc32) || crc_check_disable |-> ##1 $fell(bad_tlp_status)", "ori_sva": "property crc32_match_or_ignore_check_30;\n@(posedge clk_pcie)      (rx_crc32 == comp_crc32) || crc_check_disable |-> ##1 $fell(bad_tlp_status)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: crc32_match_or_ignore_check_30  \n**Trigger Condition**: At every rising edge of the `clk_pcie`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(rx_crc32 == comp_crc32) || crc_check_disable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(bad_tlp_status)`", "sva_signals": ["clk_pcie", "[0:0] rx_crc32", "[0:0] comp_crc32", "[0:0] crc_check_disable", "[0:0] bad_tlp_status"], "clock": "clk_pcie", "attempts_left": 10, "sva_result": "@(posedge clk_pcie)         ((rx_crc32 == comp_crc32) || crc_check_disable) |-> ##1 $fell(bad_tlp_status);", "sva_name": "p_bad_tlp_status_fall_on_crc_check", "full_property": "property crc32_match_or_ignore_check_30;\n@(posedge clk_pcie)         ((rx_crc32 == comp_crc32) || crc_check_disable) |-> ##1 $fell(bad_tlp_status);\nendproperty\nassert_crc32_match_or_ignore_check_30:assert property (crc32_match_or_ignore_check_30) else $error(\"\");", "task_id": "2_3498", "predict_sva": "@(posedge clk_pcie)         (rx_crc32 == comp_crc32) || (crc_check_disable == 1) |-> ##1 $fell(bad_tlp_status)"}
{"id": "15_15_0724", "name": "packet_sequence_check_15", "sva": "@(posedge clk_net) disable iff(net_reset)     packet_start |-> ##1 header_valid ##[2:3] payload_valid ##2 crc_match", "ori_sva": "property packet_sequence_check_15;\n@(posedge clk_net) disable iff(net_reset)     packet_start |-> ##1 header_valid ##[2:3] payload_valid ##2 crc_match\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: packet_sequence_check_15  \n**Trigger Condition**: At every rising edge of the `clk_net`  \n**Disable Condition**: `disable iff (net_reset)`  \n**Antecedent (LHS of Implication)**: `packet_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 header_valid ##[2:3] payload_valid ##2 crc_match`  ", "sva_signals": ["clk_net", "net_reset", "[0:0] packet_start", "[0:0] header_valid", "[0:0] payload_valid", "[0:0] crc_match"], "clock": "clk_net", "attempts_left": 10, "sva_result": "@(posedge clk_net) disable iff (net_reset)     packet_start |-> ##1 header_valid ##[2:3] payload_valid ##2 crc_match;", "sva_name": "p_packet_sequence_check", "full_property": "property packet_sequence_check_15;\n@(posedge clk_net) disable iff (net_reset)     packet_start |-> ##1 header_valid ##[2:3] payload_valid ##2 crc_match;\nendproperty\nassert_packet_sequence_check_15:assert property (packet_sequence_check_15) else $error(\"\");", "task_id": "2_3573", "predict_sva": "@(posedge clk_net) disable iff (net_reset)         (net_reset == 0 && packet_start == 1) |-> ##1 (header_valid == 1) ##[2:3] (payload_valid == 1) ##2 (crc_match == 1)"}
{"id": "1_22_0027", "name": "sd_card_crc_response", "sva": "@(posedge clk_sd)      cmd_sent |-> ##6 crc7_ok ##1 response_timeout", "ori_sva": "property sd_card_crc_response;\n@(posedge clk_sd)      cmd_sent |-> ##6 crc7_ok ##1 response_timeout\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sd_card_crc_response  \n**Trigger Condition**: At every rising edge of the `clk_sd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_sent == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 crc7_ok ##1 response_timeout`  ", "sva_signals": ["clk_sd", "rst_n", "[0:0] cmd_sent", "[0:0] crc7_ok", "[0:0] response_timeout"], "clock": "clk_sd", "attempts_left": 10, "sva_result": "@(posedge clk_sd)     cmd_sent == 1'b1 |-> ##6 crc7_ok ##1 response_timeout;", "sva_name": "p_cmd_sent_crc7_response_timeout", "full_property": "property sd_card_crc_response;\n@(posedge clk_sd)     cmd_sent == 1'b1 |-> ##6 crc7_ok ##1 response_timeout;\nendproperty\nassert_sd_card_crc_response:assert property (sd_card_crc_response) else $error(\"\");", "task_id": "2_3619", "predict_sva": "@(posedge clk_sd)         cmd_sent == 1'b1 |-> ##6 crc7_ok == 1'b1 ##1 response_timeout == 1'b1"}
{"id": "1_31_0028", "name": "battery_voltage_monitor", "sva": "@(posedge clk_batt)      voltage_low |-> ##[4:6] charge_enable ##1 !battery_dead", "ori_sva": "property battery_voltage_monitor;\n@(posedge clk_batt)      voltage_low |-> ##[4:6] charge_enable ##1 !battery_dead\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: battery_voltage_monitor  \n**Trigger Condition**: At every rising edge of the `clk_batt`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_low == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:6] charge_enable ##1 !battery_dead`  ", "sva_signals": ["clk_batt", "voltage_low", "[0:0] charge_enable", "[0:0] battery_dead"], "clock": "clk_batt", "attempts_left": 10, "sva_result": "@(posedge clk_batt)     voltage_low == 1'b1 |-> ##[4:6] charge_enable ##1 !battery_dead;", "sva_name": "p_voltage_low_charge_enable_battery_dead", "full_property": "property battery_voltage_monitor;\n@(posedge clk_batt)     voltage_low == 1'b1 |-> ##[4:6] charge_enable ##1 !battery_dead;\nendproperty\nassert_battery_voltage_monitor:assert property (battery_voltage_monitor) else $error(\"\");", "task_id": "2_3627", "predict_sva": "@(posedge clk_batt)         voltage_low == 1'b1 |-> ##[4:6] charge_enable == 1'b1 ##1 battery_dead == 1'b0"}
{"id": "2_25_0072", "name": "i2c_start_check_25", "sva": "@(posedge clk_i2c)      i2c_start_cond |-> ##[1:3] i2c_stop_cond || i2c_restart", "ori_sva": "property i2c_start_check_25;\n@(posedge clk_i2c)      i2c_start_cond |-> ##[1:3] i2c_stop_cond || i2c_restart\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: i2c_start_check_25  \n**Trigger Condition**: At every rising edge of the `clk_i2c`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `i2c_start_cond == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] i2c_stop_cond || i2c_restart`  ", "sva_signals": ["clk_i2c", "rst_n", "[0:0] i2c_start_cond", "[0:0] i2c_stop_cond", "[0:0] i2c_restart"], "clock": "clk_i2c", "attempts_left": 10, "sva_result": "@(posedge clk_i2c)     i2c_start_cond == 1'b1 |-> ##[1:3] (i2c_stop_cond || i2c_restart);", "sva_name": "p_i2c_start_condition_check", "full_property": "property i2c_start_check_25;\n@(posedge clk_i2c)     i2c_start_cond == 1'b1 |-> ##[1:3] (i2c_stop_cond || i2c_restart);\nendproperty\nassert_i2c_start_check_25:assert property (i2c_start_check_25) else $error(\"\");", "task_id": "2_3663", "predict_sva": "@(posedge clk_i2c)     i2c_start_cond == 1'b1 |-> ##[1:3] (i2c_stop_cond == 1'b1 || i2c_restart == 1'b1)"}
{"id": "2_3_0044", "name": "irq_pending_clear_check_3", "sva": "@(posedge clk_core)      (irq_pending && irq_enable) |-> ##[2:4] !irq_pending || irq_serviced", "ori_sva": "property irq_pending_clear_check_3;\n@(posedge clk_core)      (irq_pending && irq_enable) |-> ##[2:4] !irq_pending || irq_serviced\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: irq_pending_clear_check_3  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(irq_pending && irq_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] !irq_pending || irq_serviced`  ", "sva_signals": ["clk_core", "[0:0] irq_pending", "[0:0] irq_enable", "[0:0] irq_serviced"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     (irq_pending && irq_enable) |-> ##[2:4] (!irq_pending || irq_serviced);", "sva_name": "p_irq_service_within_2_to_4_cycles", "full_property": "property irq_pending_clear_check_3;\n@(posedge clk_core)     (irq_pending && irq_enable) |-> ##[2:4] (!irq_pending || irq_serviced);\nendproperty\nassert_irq_pending_clear_check_3:assert property (irq_pending_clear_check_3) else $error(\"\");", "task_id": "2_3673", "predict_sva": "@(posedge clk_core)         (irq_pending == 1 && irq_enable == 1) |-> ##[2:4] (irq_pending == 0 || irq_serviced == 1)"}
{"id": "2_36_0082", "name": "can_frame_check_36", "sva": "@(posedge clk_can)      can_frame_start |-> ##[5:20] can_frame_end || can_error", "ori_sva": "property can_frame_check_36;\n@(posedge clk_can)      can_frame_start |-> ##[5:20] can_frame_end || can_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_frame_check_36  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_frame_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:20] can_frame_end || can_error`  ", "sva_signals": ["clk_can", "rst_n", "[0:0] can_frame_start", "[0:0] can_frame_end", "[0:0] can_error"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     can_frame_start == 1'b1 |-> ##[5:20] (can_frame_end || can_error);", "sva_name": "p_can_frame_end_or_error_within_5_to_20_cycles_after_start", "full_property": "property can_frame_check_36;\n@(posedge clk_can)     can_frame_start == 1'b1 |-> ##[5:20] (can_frame_end || can_error);\nendproperty\nassert_can_frame_check_36:assert property (can_frame_check_36) else $error(\"\");", "task_id": "2_3676", "predict_sva": "@(posedge clk_can)         can_frame_start == 1'b1 |-> ##[5:20] (can_frame_end == 1'b1 || can_error == 1'b1)"}
{"id": "3_13_0128", "name": "adc_conv_start_done_check", "sva": "@(posedge clk_adc)     adc_conv_start |-> ##[10:15] adc_conv_done || adc_conv_timeout", "ori_sva": "property adc_conv_start_done_check;\n@(posedge clk_adc)     adc_conv_start |-> ##[10:15] adc_conv_done || adc_conv_timeout\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: adc_conv_start_done_check  \n**Trigger Condition**: At every rising edge of the `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `adc_conv_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:15] (adc_conv_done || adc_conv_timeout)`  ", "sva_signals": ["clk_adc", "[0:0] adc_conv_start", "[0:0] adc_conv_done", "[0:0] adc_conv_timeout"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     adc_conv_start == 1'b1 |-> ##[10:15] (adc_conv_done || adc_conv_timeout);", "sva_name": "p_adc_conv_done_or_timeout_within_10_15_cycles", "full_property": "property adc_conv_start_done_check;\n@(posedge clk_adc)     adc_conv_start == 1'b1 |-> ##[10:15] (adc_conv_done || adc_conv_timeout);\nendproperty\nassert_adc_conv_start_done_check:assert property (adc_conv_start_done_check) else $error(\"\");", "task_id": "2_3695", "predict_sva": "@(posedge clk_adc)         adc_conv_start == 1'b1 |-> ##[10:15] (adc_conv_done == 1'b1 || adc_conv_timeout == 1'b1)"}
{"id": "3_16_0109", "name": "sata_phy_ready_check", "sva": "@(posedge clk_sata)     sata_phy_init |-> ##[100:200] sata_phy_ready ##0 !sata_phy_err", "ori_sva": "property sata_phy_ready_check;\n@(posedge clk_sata)     sata_phy_init |-> ##[100:200] sata_phy_ready ##0 !sata_phy_err\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sata_phy_ready_check  \n**Trigger Condition**: At every rising edge of the `clk_sata`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sata_phy_init == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:200] sata_phy_ready ##0 !sata_phy_err`  ", "sva_signals": ["clk_sata", "sata_phy_init", "sata_phy_ready", "sata_phy_err"], "clock": "clk_sata", "attempts_left": 10, "sva_result": "@(posedge clk_sata)     sata_phy_init == 1'b1 |-> ##[100:200] (sata_phy_ready ##0 !sata_phy_err);", "sva_name": "p_sata_phy_ready_and_err_after_init", "full_property": "property sata_phy_ready_check;\n@(posedge clk_sata)     sata_phy_init == 1'b1 |-> ##[100:200] (sata_phy_ready ##0 !sata_phy_err);\nendproperty\nassert_sata_phy_ready_check:assert property (sata_phy_ready_check) else $error(\"\");", "task_id": "2_3697", "predict_sva": "@(posedge clk_sata)         sata_phy_init == 1'b1 |-> ##[100:200] (sata_phy_ready == 1'b1 && sata_phy_err == 1'b0)"}
{"id": "5_20_0233", "name": "temp_sensor_alarm_check", "sva": "@(posedge clk_sensor)     (temp_rising[*10] ##1 over_temp[*5]) |-> temp_alarm[*3]", "ori_sva": "property temp_sensor_alarm_check;\n@(posedge clk_sensor)     (temp_rising[*10] ##1 over_temp[*5]) |-> temp_alarm[*3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: temp_sensor_alarm_check  \n**Trigger Condition**: At every rising edge of the `clk_sensor`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(temp_rising[*10] ##1 over_temp[*5])`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `temp_alarm[*3]`  ", "sva_signals": ["clk_sensor", "[0:0] temp_rising", "[0:0] over_temp", "[0:0] temp_alarm"], "clock": "clk_sensor", "attempts_left": 10, "sva_result": "@(posedge clk_sensor)     (temp_rising[*10] ##1 over_temp[*5]) |-> temp_alarm[*3];", "sva_name": "p_temp_alarm_after_temp_rising_and_over_temp", "full_property": "property temp_sensor_alarm_check;\n@(posedge clk_sensor)     (temp_rising[*10] ##1 over_temp[*5]) |-> temp_alarm[*3];\nendproperty\nassert_temp_sensor_alarm_check:assert property (temp_sensor_alarm_check) else $error(\"\");", "task_id": "2_3782", "predict_sva": "@(posedge clk_sensor)         (temp_rising [*10]) ##1 (over_temp [*5]) |-> (temp_alarm [*3])"}
{"id": "6_11_0251", "name": "thermal_throttling_check", "sva": "@(posedge clk_temp)      temp_high[*4:8] |-> ##[1:3] throttle_en[*1:4]", "ori_sva": "property thermal_throttling_check;\n@(posedge clk_temp)      temp_high[*4:8] |-> ##[1:3] throttle_en[*1:4]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_throttling_check  \n**Trigger Condition**: At every rising edge of the `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_high` is true for 4 to 8 consecutive clock cycles (`temp_high[*4:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 1 to 3 clock cycles (`##[1:3]`), `throttle_en` is true for 1 to 4 consecutive clock cycles (`throttle_en[*1:4]`)", "sva_signals": ["clk", "rst_n", "[0:0] temp_high", "[0:0] throttle_en", "clk_temp"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     temp_high[*4:8] |-> ##[1:3] throttle_en[*1:4];", "sva_name": "p_temp_high_throttle_en_sequence", "full_property": "property thermal_throttling_check;\n@(posedge clk_temp)     temp_high[*4:8] |-> ##[1:3] throttle_en[*1:4];\nendproperty\nassert_thermal_throttling_check:assert property (thermal_throttling_check) else $error(\"\");", "task_id": "2_3813", "predict_sva": "@(posedge clk_temp)         (temp_high [*4:8]) |-> ##[1:3] throttle_en [*1:4]"}
{"id": "6_22_0289", "name": "dma_transfer_size_check", "sva": "@(posedge clk_dma)      dma_req[*8:16] |-> ##[2:4] transfer_done[*1:2]", "ori_sva": "property dma_transfer_size_check;\n@(posedge clk_dma)      dma_req[*8:16] |-> ##[2:4] transfer_done[*1:2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dma_transfer_size_check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_req` is continuously high for 8 to 16 clock cycles (`dma_req[*8:16]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 2 to 4 clock cycles (`##[2:4]`), `transfer_done` occurs for 1 to 2 clock cycles (`transfer_done[*1:2]`)", "sva_signals": ["clk_dma", "[0:0] dma_req", "[0:0] transfer_done"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma)     dma_req[*8:16] |-> ##[2:4] transfer_done[*1:2];", "sva_name": "p_transfer_done_after_dma_req_burst", "full_property": "property dma_transfer_size_check;\n@(posedge clk_dma)     dma_req[*8:16] |-> ##[2:4] transfer_done[*1:2];\nendproperty\nassert_dma_transfer_size_check:assert property (dma_transfer_size_check) else $error(\"\");", "task_id": "2_3823", "predict_sva": "@(posedge clk_dma)         dma_req [*8:16] |-> ##[2:4] transfer_done [*1:2]"}
{"id": "6_38_0302", "name": "ethernet_mii_rx_check", "sva": "@(posedge clk_mii_rx)      rx_dv[*4:8] |-> ##[3:5] crc_valid[*1:2]", "ori_sva": "property ethernet_mii_rx_check;\n@(posedge clk_mii_rx)      rx_dv[*4:8] |-> ##[3:5] crc_valid[*1:2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ethernet_mii_rx_check  \n**Trigger Condition**: At every rising edge of `clk_mii_rx`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rx_dv` is continuously high for 4 to 8 clock cycles (`rx_dv[*4:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After a delay of 3 to 5 clock cycles (`##[3:5]`), `crc_valid` is high for 1 to 2 clock cycles (`crc_valid[*1:2]`)", "sva_signals": ["clk_mii_rx", "[0:0] rx_dv", "[0:0] crc_valid"], "clock": "clk_mii_rx", "attempts_left": 10, "sva_result": "@(posedge clk_mii_rx)     rx_dv[*4:8] |-> ##[3:5] crc_valid[*1:2];", "sva_name": "p_crc_valid_after_rx_dv_burst", "full_property": "property ethernet_mii_rx_check;\n@(posedge clk_mii_rx)     rx_dv[*4:8] |-> ##[3:5] crc_valid[*1:2];\nendproperty\nassert_ethernet_mii_rx_check:assert property (ethernet_mii_rx_check) else $error(\"\");", "task_id": "2_3839", "predict_sva": "@(posedge clk_mii_rx)         (rx_dv [*4:8]) |-> ##[3:5] crc_valid [*1:2]"}
{"id": "10_30_0514", "name": "delayed_reset_sequence_check", "sva": "@(posedge reset_clk)     $fell(reset_assert) |-> $past(reset_counter,4) == 8'hFF", "ori_sva": "property delayed_reset_sequence_check;\n@(posedge reset_clk)     $fell(reset_assert) |-> $past(reset_counter,4) == 8'hFF\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: delayed_reset_sequence_check  \n**Trigger Condition**: At every rising edge of the `reset_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(reset_assert)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(reset_counter, 4) == 8'hFF`  \n\nThe assertion checks that whenever there is a falling edge on `reset_assert` (indicating the de-assertion of reset), the value of `reset_counter` four clock cycles prior to this event must be equal to `8'hFF`. This ensures that the reset sequence was properly maintained before being de-asserted.", "sva_signals": ["reset_clk", "[0:0] reset_assert", "[7:0] reset_counter"], "clock": "reset_clk", "attempts_left": 10, "sva_result": "@(posedge reset_clk)     $fell(reset_assert) |-> $past(reset_counter, 4) == 8'hFF;", "sva_name": "p_reset_assert_deassertion_sequence", "full_property": "property delayed_reset_sequence_check;\n@(posedge reset_clk)     $fell(reset_assert) |-> $past(reset_counter, 4) == 8'hFF;\nendproperty\nassert_delayed_reset_sequence_check:assert property (delayed_reset_sequence_check) else $error(\"\");", "task_id": "2_3969", "predict_sva": "@(posedge reset_clk) disable iff (1'b0)         $fell(reset_assert) |-> $past(reset_counter, 4) == 8'hFF"}
{"id": "11_4_0517", "name": "irq_priority_ack_check", "sva": "@(posedge clk_irq_ctrl)     (irq_pending[3] && irq_mask[3]) && highest_priority |-> ##1 irq_ack[3]", "ori_sva": "property irq_priority_ack_check;\n@(posedge clk_irq_ctrl)     (irq_pending[3] && irq_mask[3]) && highest_priority |-> ##1 irq_ack[3]\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: irq_priority_ack_check  \n**Trigger Condition**: At every rising edge of the `clk_irq_ctrl`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(irq_pending[3] && irq_mask[3]) && highest_priority`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 irq_ack[3]`", "sva_signals": ["clk_irq_ctrl", "rst_n", "[3:0] irq_pending", "[3:0] irq_mask", "[0:0] highest_priority", "[3:0] irq_ack"], "clock": "clk_irq_ctrl", "attempts_left": 10, "sva_result": "@(posedge clk_irq_ctrl)         (irq_pending[3] && irq_mask[3] && highest_priority) |-> ##1 irq_ack[3];", "sva_name": "p_irq_ack3_on_highest_priority_pending_unmasked", "full_property": "property irq_priority_ack_check;\n@(posedge clk_irq_ctrl)         (irq_pending[3] && irq_mask[3] && highest_priority) |-> ##1 irq_ack[3];\nendproperty\nassert_irq_priority_ack_check:assert property (irq_priority_ack_check) else $error(\"\");", "task_id": "2_4028", "predict_sva": "@(posedge clk_irq_ctrl)         (irq_pending[3] == 1 && irq_mask[3] == 1 && highest_priority == 1) |-> ##1 (irq_ack[3] == 1)"}
{"id": "1_23_0001", "name": "crypto_hash_start_check", "sva": "@(posedge crypto_clk)     $rose(hash_start) && !hash_busy |-> ##15 hash_done && $stable(hash_input_data)", "ori_sva": "property crypto_hash_start_check;\n@(posedge crypto_clk)     $rose(hash_start) && !hash_busy |-> ##15 hash_done && $stable(hash_input_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: crypto_hash_start_check  \n**Trigger Condition**: At every rising edge of the `crypto_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(hash_start) && !hash_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##15 hash_done && $stable(hash_input_data)`  ", "sva_signals": ["crypto_clk", "hash_start", "hash_busy", "hash_done", "hash_input_data"], "clock": "crypto_clk", "attempts_left": 10, "sva_result": "@(posedge crypto_clk)     ($rose(hash_start) && !hash_busy) |-> ##15 (hash_done && $stable(hash_input_data));", "sva_name": "p_hash_done_after_start_and_input_stable", "full_property": "property crypto_hash_start_check;\n@(posedge crypto_clk)     ($rose(hash_start) && !hash_busy) |-> ##15 (hash_done && $stable(hash_input_data));\nendproperty\nassert_crypto_hash_start_check:assert property (crypto_hash_start_check) else $error(\"\");", "task_id": "2_4138", "predict_sva": "@(posedge crypto_clk)         ($rose(hash_start) && hash_busy == 0) |-> ##15 (hash_done == 1 && hash_input_data == $past(hash_input_data))"}
{"id": "1_40_0028", "name": "mipi_dsi_hs_mode_check", "sva": "@(posedge mipi_dsi_clk)     $rose(mipi_hs_mode_en) && mipi_lp_mode_active |-> ##8 mipi_hs_mode_active && $stable(mipi_lane_state)", "ori_sva": "property mipi_dsi_hs_mode_check;\n@(posedge mipi_dsi_clk)     $rose(mipi_hs_mode_en) && mipi_lp_mode_active |-> ##8 mipi_hs_mode_active && $stable(mipi_lane_state)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mipi_dsi_hs_mode_check  \n**Trigger Condition**: At every rising edge of the `mipi_dsi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(mipi_hs_mode_en) && mipi_lp_mode_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 mipi_hs_mode_active && $stable(mipi_lane_state)`  ", "sva_signals": ["mipi_dsi_clk", "mipi_hs_mode_en", "mipi_lp_mode_active", "mipi_hs_mode_active", "[3:0] mipi_lane_state"], "clock": "mipi_dsi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_dsi_clk)     ($rose(mipi_hs_mode_en) && mipi_lp_mode_active) |-> ##8 (mipi_hs_mode_active && $stable(mipi_lane_state));", "sva_name": "p_mipi_hs_mode_activation_and_lane_stability", "full_property": "property mipi_dsi_hs_mode_check;\n@(posedge mipi_dsi_clk)     ($rose(mipi_hs_mode_en) && mipi_lp_mode_active) |-> ##8 (mipi_hs_mode_active && $stable(mipi_lane_state));\nendproperty\nassert_mipi_dsi_hs_mode_check:assert property (mipi_dsi_hs_mode_check) else $error(\"\");", "task_id": "2_4153", "predict_sva": "@(posedge mipi_dsi_clk)         ($rose(mipi_hs_mode_en) && mipi_lp_mode_active == 1) |-> ##8 (mipi_hs_mode_active == 1 && mipi_lane_state == $past(mipi_lane_state))"}
{"id": "2_21_0025", "name": "pll_lock_check", "sva": "@(posedge clk_ref)      pll_enable |-> ##[8:32] pll_locked", "ori_sva": "property pll_lock_check;\n@(posedge clk_ref)      pll_enable |-> ##[8:32] pll_locked\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pll_lock_check  \n**Trigger Condition**: At every rising edge of the `clk_ref`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pll_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:32] pll_locked == 1'b1`  ", "sva_signals": ["clk_ref", "[0:0] pll_enable", "[0:0] pll_locked"], "clock": "clk_ref", "attempts_left": 10, "sva_result": "@(posedge clk_ref)     pll_enable == 1'b1 |-> ##[8:32] pll_locked == 1'b1;", "sva_name": "p_pll_locked_within_8_to_32_cycles", "full_property": "property pll_lock_check;\n@(posedge clk_ref)     pll_enable == 1'b1 |-> ##[8:32] pll_locked == 1'b1;\nendproperty\nassert_pll_lock_check:assert property (pll_lock_check) else $error(\"\");", "task_id": "2_4180", "predict_sva": "@(posedge clk_ref)         pll_enable == 1'b1 |-> ##[8:32] pll_locked == 1'b1"}
{"id": "2_33_0103", "name": "audio_sample_check", "sva": "@(posedge clk_audio)      audio_sample_req |-> ##[1:4] audio_sample_ack", "ori_sva": "property audio_sample_check;\n@(posedge clk_audio)      audio_sample_req |-> ##[1:4] audio_sample_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: audio_sample_check  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `audio_sample_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] audio_sample_ack` (The `audio_sample_ack` signal must be asserted within 1 to 4 clock cycles after the antecedent is true)", "sva_signals": ["clk_audio", "[0:0] audio_sample_req", "[0:0] audio_sample_ack"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     audio_sample_req == 1'b1 |-> ##[1:4] audio_sample_ack;", "sva_name": "p_audio_sample_ack_within_4_cycles", "full_property": "property audio_sample_check;\n@(posedge clk_audio)     audio_sample_req == 1'b1 |-> ##[1:4] audio_sample_ack;\nendproperty\nassert_audio_sample_check:assert property (audio_sample_check) else $error(\"\");", "task_id": "2_4193", "predict_sva": "@(posedge clk_audio)         audio_sample_req == 1'b1 |-> ##[1:4] audio_sample_ack == 1'b1"}
{"id": "2_35_0084", "name": "voltage_monitor_check", "sva": "@(posedge clk_vmon)      vmon_enable |-> ##[3:7] vmon_ready", "ori_sva": "property voltage_monitor_check;\n@(posedge clk_vmon)      vmon_enable |-> ##[3:7] vmon_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: voltage_monitor_check  \n**Trigger Condition**: At every rising edge of the `clk_vmon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vmon_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] vmon_ready == 1'b1`  \n\n(Note: The consequent specifies that within 3 to 7 clock cycles after the antecedent is true, `vmon_ready` must be asserted (`1'b1`).)", "sva_signals": ["clk", "rst_n", "[0:0] vmon_enable", "[0:0] vmon_ready", "clk_vmon"], "clock": "clk_vmon", "attempts_left": 10, "sva_result": "@(posedge clk_vmon)     vmon_enable == 1'b1 |-> ##[3:7] vmon_ready == 1'b1;", "sva_name": "p_vmon_ready_within_3_to_7_cycles_after_enable", "full_property": "property voltage_monitor_check;\n@(posedge clk_vmon)     vmon_enable == 1'b1 |-> ##[3:7] vmon_ready == 1'b1;\nendproperty\nassert_voltage_monitor_check:assert property (voltage_monitor_check) else $error(\"\");", "task_id": "2_4195", "predict_sva": "@(posedge clk_vmon)         vmon_enable == 1'b1 |-> ##[3:7] vmon_ready == 1'b1"}
{"id": "2_6_0015", "name": "cache_invalidate_check", "sva": "@(posedge clk_cache)      cache_inv_req |-> ##[7:25] cache_inv_ack", "ori_sva": "property cache_invalidate_check;\n@(posedge clk_cache)      cache_inv_req |-> ##[7:25] cache_inv_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cache_invalidate_check  \n**Trigger Condition**: At every rising edge of the `clk_cache`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_inv_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[7:25] cache_inv_ack == 1'b1`  ", "sva_signals": ["clk_cache", "[0:0] cache_inv_req", "[0:0] cache_inv_ack"], "clock": "clk_cache", "attempts_left": 10, "sva_result": "@(posedge clk_cache)         cache_inv_req == 1'b1 |-> ##[7:25] cache_inv_ack == 1'b1;", "sva_name": "p_cache_invalidate_ack_within_7_to_25_cycles", "full_property": "property cache_invalidate_check;\n@(posedge clk_cache)         cache_inv_req == 1'b1 |-> ##[7:25] cache_inv_ack == 1'b1;\nendproperty\nassert_cache_invalidate_check:assert property (cache_invalidate_check) else $error(\"\");", "task_id": "2_4213", "predict_sva": "@(posedge clk_cache)         cache_inv_req == 1'b1 |-> ##[7:25] cache_inv_ack == 1'b1"}
{"id": "3_35_0114", "name": "ddr_init_35", "sva": "@(posedge clk_ddr)      init_start |-> ##[200:400] (calib_done || init_fail)", "ori_sva": "property ddr_init_35;\n@(posedge clk_ddr)      init_start |-> ##[200:400] (calib_done || init_fail)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ddr_init_35  \n**Trigger Condition**: At every rising edge of the `clk_ddr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `init_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[200:400] (calib_done || init_fail)`  ", "sva_signals": ["clk_ddr", "init_start", "calib_done", "init_fail"], "clock": "clk_ddr", "attempts_left": 10, "sva_result": "@(posedge clk_ddr)     init_start == 1'b1 |-> ##[200:400] (calib_done || init_fail);", "sva_name": "p_init_start_completion_window", "full_property": "property ddr_init_35;\n@(posedge clk_ddr)     init_start == 1'b1 |-> ##[200:400] (calib_done || init_fail);\nendproperty\nassert_ddr_init_35:assert property (ddr_init_35) else $error(\"\");", "task_id": "2_4239", "predict_sva": "@(posedge clk_ddr)         init_start == 1'b1 |-> ##[200:400] (calib_done == 1'b1 || init_fail == 1'b1)"}
{"id": "3_41_0142", "name": "rf_sync_41", "sva": "@(posedge clk_rf)      sync_pulse |-> ##[3:6] (iq_aligned || phase_error)", "ori_sva": "property rf_sync_41;\n@(posedge clk_rf)      sync_pulse |-> ##[3:6] (iq_aligned || phase_error)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: rf_sync_41  \n**Trigger Condition**: At every rising edge of the `clk_rf`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] (iq_aligned || phase_error)`  ", "sva_signals": ["clk_rf", "sync_pulse", "[0:0] iq_aligned", "[0:0] phase_error"], "clock": "clk_rf", "attempts_left": 10, "sva_result": "@(posedge clk_rf)     sync_pulse |-> ##[3:6] (iq_aligned || phase_error);", "sva_name": "p_sync_pulse_alignment_or_phase_error", "full_property": "property rf_sync_41;\n@(posedge clk_rf)     sync_pulse |-> ##[3:6] (iq_aligned || phase_error);\nendproperty\nassert_rf_sync_41:assert property (rf_sync_41) else $error(\"\");", "task_id": "2_4246", "predict_sva": "@(posedge clk_rf)         sync_pulse == 1 |-> ##[3:6] (iq_aligned == 1 || phase_error == 1)"}
{"id": "3_42_0158", "name": "hdmi_link_42", "sva": "@(posedge clk_hdmi)      link_train |-> ##[100:200] (link_ok || equalization_fail)", "ori_sva": "property hdmi_link_42;\n@(posedge clk_hdmi)      link_train |-> ##[100:200] (link_ok || equalization_fail)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: hdmi_link_42  \n**Trigger Condition**: At every rising edge of `clk_hdmi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `link_train == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:200] (link_ok || equalization_fail)`  ", "sva_signals": ["clk_hdmi", "[0:0] link_train", "[0:0] link_ok", "[0:0] equalization_fail"], "clock": "clk_hdmi", "attempts_left": 10, "sva_result": "@(posedge clk_hdmi)     link_train == 1'b1 |-> ##[100:200] (link_ok || equalization_fail);", "sva_name": "p_link_train_completion_window", "full_property": "property hdmi_link_42;\n@(posedge clk_hdmi)     link_train == 1'b1 |-> ##[100:200] (link_ok || equalization_fail);\nendproperty\nassert_hdmi_link_42:assert property (hdmi_link_42) else $error(\"\");", "task_id": "2_4247", "predict_sva": "@(posedge clk_hdmi)         link_train == 1'b1 |-> ##[100:200] (link_ok == 1'b1 || equalization_fail == 1'b1)"}
{"id": "3_45_0136", "name": "nand_program_45", "sva": "@(posedge clk_nand)      prog_cmd |-> ##[200:400] (prog_done || write_error)", "ori_sva": "property nand_program_45;\n@(posedge clk_nand)      prog_cmd |-> ##[200:400] (prog_done || write_error)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: nand_program_45  \n**Trigger Condition**: At every rising edge of the `clk_nand`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `prog_cmd == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[200:400] (prog_done || write_error)`  ", "sva_signals": ["clk_nand", "prog_cmd", "prog_done", "write_error"], "clock": "clk_nand", "attempts_left": 10, "sva_result": "@(posedge clk_nand)     prog_cmd == 1'b1 |-> ##[200:400] (prog_done || write_error);", "sva_name": "p_prog_done_or_write_error_within_200_400_cycles_after_prog_cmd", "full_property": "property nand_program_45;\n@(posedge clk_nand)     prog_cmd == 1'b1 |-> ##[200:400] (prog_done || write_error);\nendproperty\nassert_nand_program_45:assert property (nand_program_45) else $error(\"\");", "task_id": "2_4250", "predict_sva": "@(posedge clk_nand)         prog_cmd == 1'b1 |-> ##[200:400] (prog_done == 1'b1 || write_error == 1'b1)"}
{"id": "3_50_0124", "name": "zigbee_ack_50", "sva": "@(posedge clk_zigbee)      tx_complete |-> ##[2:5] (ack_received || csma_fail)", "ori_sva": "property zigbee_ack_50;\n@(posedge clk_zigbee)      tx_complete |-> ##[2:5] (ack_received || csma_fail)\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: zigbee_ack_50  \n**Trigger Condition**: At every rising edge of the `clk_zigbee`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 2 to 5 clock cycles after the antecedent is true, either `ack_received` or `csma_fail` must be asserted (`ack_received || csma_fail`)", "sva_signals": ["clk_zigbee", "[0:0] tx_complete", "[0:0] ack_received", "[0:0] csma_fail"], "clock": "clk_zigbee", "attempts_left": 10, "sva_result": "@(posedge clk_zigbee)     tx_complete == 1'b1 |-> ##[2:5] (ack_received || csma_fail);", "sva_name": "p_tx_complete_ack_or_csma_within_2_to_5_cycles", "full_property": "property zigbee_ack_50;\n@(posedge clk_zigbee)     tx_complete == 1'b1 |-> ##[2:5] (ack_received || csma_fail);\nendproperty\nassert_zigbee_ack_50:assert property (zigbee_ack_50) else $error(\"\");", "task_id": "2_4255", "predict_sva": "@(posedge clk_zigbee)         tx_complete == 1'b1 |-> ##[2:5] (ack_received == 1'b1 || csma_fail == 1'b1)"}
{"id": "7_16_0323", "name": "p15_usb_reset_end_check", "sva": "@(posedge clk_usb)      $rose(usb_reset_n) |-> ##[2:5] $stable(usb_speed) ##0 $onehot0(usb_state)", "ori_sva": "property p15_usb_reset_end_check;\n@(posedge clk_usb)      $rose(usb_reset_n) |-> ##[2:5] $stable(usb_speed) ##0 $onehot0(usb_state)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p15_usb_reset_end_check  \n**Trigger Condition**: At every rising edge of `clk_usb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(usb_reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] $stable(usb_speed) ##0 $onehot0(usb_state)`  ", "sva_signals": ["clk_usb", "usb_reset_n", "[0:0] usb_speed", "[0:0] usb_state"], "clock": "clk_usb", "attempts_left": 10, "sva_result": "@(posedge clk_usb)     $rose(usb_reset_n) |-> ##[2:5] $stable(usb_speed) ##0 $onehot0(usb_state);", "sva_name": "p_usb_speed_stable_and_state_onehot0_after_reset", "full_property": "property p15_usb_reset_end_check;\n@(posedge clk_usb)     $rose(usb_reset_n) |-> ##[2:5] $stable(usb_speed) ##0 $onehot0(usb_state);\nendproperty\nassert_p15_usb_reset_end_check:assert property (p15_usb_reset_end_check) else $error(\"\");", "task_id": "2_4350", "predict_sva": "@(posedge clk_usb)         $rose(usb_reset_n) |-> ##[2:5] ($stable(usb_speed) ##1 $onehot0(usb_state))"}
{"id": "174_7_1397", "name": "clk_hold_time", "sva": "@(posedge clk_signal)     $fell(clk_out) |-> ##1 $stable(data_out)[*2]", "ori_sva": "property clk_hold_time;\n@(posedge clk_signal)     $fell(clk_out) |-> ##1 $stable(data_out)[*2];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Data_After_Falling_Clock  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clk_out)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(data_out)[*2]`  \n\n### Explanation:  \n- The property checks that whenever there is a falling edge on `clk_out` (detected at the rising edge of `clk_signal`), the `data_out` signal must remain stable for the next two consecutive clock cycles (starting from the cycle after the falling edge).  \n- `$fell(clk_out)` detects the falling edge of `clk_out`.  \n- `##1 $stable(data_out)[*2]` ensures that `data_out` does not change its value for two consecutive cycles after the falling edge of `clk_out`.  \n- The assertion has no disable condition (`disable iff`).", "sva_signals": ["clk_signal", "clk_out", "data_out", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $fell(clk_out) |-> ##1 $stable(data_out)[*2]", "sva_name": "p_Stable_Data_After_Fell", "full_property": "property p_Stable_Data_After_Falling_Clock;\n@(posedge clk_signal)    $fell(clk_out) |-> ##1 $stable(data_out)[*2]\nendproperty\nassert_p_Stable_Data_After_Falling_Clock:assert property (p_Stable_Data_After_Falling_Clock) else $error(\"\");", "task_id": "3_342", "predict_sva": "@(posedge clk_signal)     $fell(clk_out) |-> $stable(data_out)[*2]"}
{"id": "165_5_1316", "name": "power_sequence", "sva": "@(posedge pmu_clk)     disable iff (deep_sleep)     $rose(pwr_good_vcore) |=> ##[2:10] $rose(pwr_good_io)", "ori_sva": "property power_sequence;\n@(posedge pmu_clk)     disable iff (deep_sleep)     $rose(pwr_good_vcore) |=> ##[2:10] $rose(pwr_good_io);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pwr_good_sequence  \n**Trigger Condition**: At every rising edge of the `pmu_clk`  \n**Disable Condition**: `disable iff (deep_sleep)`  \n**Antecedent (LHS of Implication)**: `$rose(pwr_good_vcore)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[2:10] $rose(pwr_good_io)`  \n\n**Explanation**:  \nThis property checks that whenever there is a rising edge on `pwr_good_vcore` (indicating the core power becomes good), then within **2 to 10 clock cycles** of the `pmu_clk`, there must be a rising edge on `pwr_good_io` (indicating the I/O power becomes good). The assertion is **disabled** if `deep_sleep` is active.  \n\n- **`|=>`** (non-overlapping implication) means the consequent is evaluated **one clock cycle after** the antecedent succeeds.  \n- **`##[2:10]`** specifies a **time window** of 2 to 10 clock cycles for the consequent to occur.  \n- **`$rose()`** detects the transition from 0 to 1 (rising edge) of the signal.  \n\nThe assertion ensures a **timely power-up sequence** between core and I/O power domains.", "sva_signals": ["pmu_clk", "deep_sleep", "[0:0] pwr_good_vcore", "[0:0] pwr_good_io"], "clock": "pmu_clk", "attempts_left": 10, "sva_result": "@(posedge pmu_clk) disable iff (deep_sleep)    $rose(pwr_good_vcore) |=> ##[2:10] $rose(pwr_good_io)", "sva_name": "p_pwr_good_io_rise_within_2_to_10_cycles_after_vcore", "full_property": "property p_pwr_good_sequence;\n@(posedge pmu_clk) disable iff (deep_sleep)    $rose(pwr_good_vcore) |=> ##[2:10] $rose(pwr_good_io)\nendproperty\nassert_p_pwr_good_sequence:assert property (p_pwr_good_sequence) else $error(\"\");", "task_id": "3_272", "predict_sva": "@(posedge pmu_clk) disable iff (deep_sleep)         (deep_sleep == 0 && $rose(pwr_good_vcore)) |-> ##[2:10] $rose(pwr_good_io)"}
{"id": "176_8_1430", "name": "memory_access_protocol", "sva": "@(posedge mem_clk)     mem_req |-> ##1 (mem_gnt && !mem_error) throughout (##[1:8] mem_rdy)", "ori_sva": "property memory_access_protocol;\n@(posedge mem_clk)     mem_req |-> ##1 (mem_gnt && !mem_error) throughout (##[1:8] mem_rdy);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_request_grant  \n**Trigger Condition**: At every rising edge of the `mem_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mem_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`##1 (mem_gnt && !mem_error) throughout (##[1:8] mem_rdy)`  \n\n**Explanation of Consequent**:  \nThe consequent asserts that:  \n1. One clock cycle after `mem_req` is high (`##1`), both `mem_gnt` must be high and `mem_error` must remain low (`mem_gnt && !mem_error`).  \n2. The condition (`mem_gnt && !mem_error`) must hold **continuously** (`throughout`) during the entire window of 1 to 8 clock cycles (`##[1:8]`) until `mem_rdy` eventually becomes true within that window.  \n\n**Key Notes**:  \n- The `throughout` operator ensures the stability of `mem_gnt && !mem_error` while waiting for `mem_rdy` to occur within the specified range.  \n- The assertion fails if either `mem_gnt` is not asserted, `mem_error` goes high, or `mem_rdy` does not occur within 1 to 8 cycles after `mem_req`.", "sva_signals": ["mem_clk", "[0:0] mem_req", "[0:0] mem_gnt", "[0:0] mem_error", "[0:0] mem_rdy"], "clock": "mem_clk", "attempts_left": 10, "sva_result": "@(posedge mem_clk)    mem_req == 1'b1 |-> ##1 ((mem_gnt && !mem_error) throughout (##[1:8] mem_rdy))", "sva_name": "p_mem_req_grant_and_ready", "full_property": "property p_mem_request_grant;\n@(posedge mem_clk)    mem_req == 1'b1 |-> ##1 ((mem_gnt && !mem_error) throughout (##[1:8] mem_rdy))\nendproperty\nassert_p_mem_request_grant:assert property (p_mem_request_grant) else $error(\"\");", "task_id": "3_357", "predict_sva": "@(posedge mem_clk)    mem_req == 1'b1 |-> ##1 (mem_gnt == 1'b1 && mem_error == 1'b0) throughout (##[1:8] mem_rdy == 1'b1)"}
{"id": "190_5_1551", "name": "lo_pri_req_persistence", "sva": "@(posedge clk_arb)     lo_pri_req |-> lo_pri_req until lo_pri_grant", "ori_sva": "property lo_pri_req_persistence;\n@(posedge clk_arb)     lo_pri_req |-> lo_pri_req until lo_pri_grant;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_lo_pri_req_grant  \n**Trigger Condition**: At every rising edge of the `clk_arb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lo_pri_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `lo_pri_req until lo_pri_grant`  \n\n**Explanation of Consequent**:  \nThe `until` operator ensures that `lo_pri_req` remains asserted continuously (from the current clock cycle) until `lo_pri_grant` is asserted. Once `lo_pri_grant` is asserted, the property check completes successfully. If `lo_pri_req` deasserts before `lo_pri_grant` is asserted, the property will fail.  \n\n**Note**: The `until` operator here is a strong variant (default in SVA), meaning the sequence must eventually satisfy `lo_pri_grant` within the simulation bounds.", "sva_signals": ["clk_arb", "lo_pri_req", "lo_pri_grant"], "clock": "clk_arb", "attempts_left": 10, "sva_result": "@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req until lo_pri_grant", "sva_name": "p_lo_pri_req_until_grant", "full_property": "property p_lo_pri_req_grant;\n@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req until lo_pri_grant\nendproperty\nassert_p_lo_pri_req_grant:assert property (p_lo_pri_req_grant) else $error(\"\");", "task_id": "3_470", "predict_sva": "@(posedge clk_arb)    lo_pri_req == 1'b1 |-> lo_pri_req throughout lo_pri_grant[->1]"}
{"id": "200_8_1639", "name": "no_clk_glitch_after_stable", "sva": "@(posedge ref_clk)     $stable(clk_out) |-> ##1 $stable(clk_out)[*5]", "ori_sva": "property no_clk_glitch_after_stable;\n@(posedge ref_clk)     $stable(clk_out) |-> ##1 $stable(clk_out)[*5];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_clk_out  \n**Trigger Condition**: At every posedge of the `ref_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(clk_out)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(clk_out)[*5]`  \n\n### Explanation:  \n- The property checks that if `clk_out` is stable (i.e., does not change) at a rising edge of `ref_clk`, then in the next clock cycle (`##1`), `clk_out` must remain stable for the next 5 consecutive clock cycles (`[*5]`).  \n- The assertion does not have a disable condition (`disable iff`).  \n- The implication (`|->`) ensures that the consequent is checked only when the antecedent (`$stable(clk_out)`) is true.", "sva_signals": ["ref_clk", "[0:0] clk_out"], "clock": "ref_clk", "attempts_left": 10, "sva_result": "@(posedge ref_clk)    $stable(clk_out) |-> ##1 $stable(clk_out)[*5]", "sva_name": "p_clk_out_stable_5cycles", "full_property": "property p_stable_clk_out;\n@(posedge ref_clk)    $stable(clk_out) |-> ##1 $stable(clk_out)[*5]\nendproperty\nassert_p_stable_clk_out:assert property (p_stable_clk_out) else $error(\"\");", "task_id": "3_537", "predict_sva": "@(posedge ref_clk)         $stable(clk_out) |-> ##1 $stable(clk_out)[*5]"}
{"id": "204_8_1675", "name": "state_transition", "sva": "@(posedge clk)     $rose(idle_state) |->      ##[1:3] $rose(active_state)", "ori_sva": "property state_transition;\n@(posedge clk)     $rose(idle_state) |->      ##[1:3] $rose(active_state);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Idle_To_Active_Transition  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(idle_state)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $rose(active_state)`  \n\n### Explanation:  \nThe property checks that when the `idle_state` signal transitions from low to high (detected by `$rose`), the `active_state` signal must transition from low to high (`$rose`) within 1 to 3 clock cycles (`##[1:3]`). The assertion is evaluated at every rising edge of `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] idle_state", "[0:0] active_state"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)    $rose(idle_state) |-> ##[1:3] $rose(active_state)", "sva_name": "p_idle_to_active_state_transition", "full_property": "property p_Idle_To_Active_Transition;\n@(posedge clk)    $rose(idle_state) |-> ##[1:3] $rose(active_state)\nendproperty\nassert_p_Idle_To_Active_Transition:assert property (p_Idle_To_Active_Transition) else $error(\"\");", "task_id": "3_568", "predict_sva": "@(posedge clk)         $rose(idle_state) |-> ##[1:3] $rose(active_state)"}
{"id": "239_4_2040", "name": "cmd_ack_timeout", "sva": "@(posedge clk_core)     $rose(cmd_sent) |-> ##[1:8] $rose(cmd_ack) or ##20 $rose(cmd_timeout)", "ori_sva": "property cmd_ack_timeout;\n@(posedge clk_core)     $rose(cmd_sent) |-> ##[1:8] $rose(cmd_ack) or ##20 $rose(cmd_timeout);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cmd_ack_or_timeout  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cmd_sent)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] $rose(cmd_ack) or ##20 $rose(cmd_timeout)`  \n\n### Explanation:  \n- The property checks that whenever `cmd_sent` rises (`$rose(cmd_sent)`), either:  \n  - `cmd_ack` rises within 1 to 8 clock cycles (`##[1:8] $rose(cmd_ack)`), **or**  \n  - `cmd_timeout` rises after exactly 20 clock cycles (`##20 $rose(cmd_timeout)`).  \n- The assertion is evaluated at every rising edge of `clk_core` and has no disable condition.  \n- The `or` operator in the consequent means either of the two conditions must hold for the assertion to pass.", "sva_signals": ["clk_core", "cmd_sent", "cmd_ack", "cmd_timeout"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)    $rose(cmd_sent) |-> (##[1:8] $rose(cmd_ack)) or (##20 $rose(cmd_timeout))", "sva_name": "p_cmd_ack_or_timeout_after_cmd_sent", "full_property": "property p_cmd_ack_or_timeout;\n@(posedge clk_core)    $rose(cmd_sent) |-> (##[1:8] $rose(cmd_ack)) or (##20 $rose(cmd_timeout))\nendproperty\nassert_p_cmd_ack_or_timeout:assert property (p_cmd_ack_or_timeout) else $error(\"\");", "task_id": "3_804", "predict_sva": "@(posedge clk_core)         $rose(cmd_sent) |-> (##[1:8] $rose(cmd_ack)) or (##20 $rose(cmd_timeout))"}
{"id": "248_4_2125", "name": "fifo_full_protection", "sva": "@(posedge wr_clk) (fifo_full_status && $rose(wr_enable)) |-> ##1 $fell(wr_enable)", "ori_sva": "property fifo_full_protection;\n@(posedge wr_clk) (fifo_full_status && $rose(wr_enable)) |-> ##1 $fell(wr_enable);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_FifoFull_WrEnable  \n**Trigger Condition**: At every rising edge of the `wr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_full_status && $rose(wr_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(wr_enable)`  \n\n**Explanation**:  \nThis assertion checks that whenever the FIFO is full (`fifo_full_status` is true) and there is a rising edge on `wr_enable`, then in the next clock cycle (`##1`), the `wr_enable` signal must fall (`$fell(wr_enable)`). This ensures that the write enable is deasserted in the cycle following an attempted write to a full FIFO.", "sva_signals": ["wr_clk", "wr_enable", "[0:0] fifo_full_status"], "clock": "wr_clk", "attempts_left": 10, "sva_result": "@(posedge wr_clk)    (fifo_full_status && $rose(wr_enable)) |-> ##1 $fell(wr_enable)", "sva_name": "p_fifo_full_wr_enable_fall", "full_property": "property p_FifoFull_WrEnable;\n@(posedge wr_clk)    (fifo_full_status && $rose(wr_enable)) |-> ##1 $fell(wr_enable)\nendproperty\nassert_p_FifoFull_WrEnable:assert property (p_FifoFull_WrEnable) else $error(\"\");", "task_id": "3_865", "predict_sva": "@(posedge wr_clk)         (fifo_full_status && $rose(wr_enable)) |-> ##1 $fell(wr_enable)"}
{"id": "263_2_2232", "name": "usb_eop_se0_duration_max", "sva": "@(posedge usb_clk)     $rose(usb_se0) |-> ##18 $fell(usb_se0)", "ori_sva": "property usb_eop_se0_duration_max;\n@(posedge usb_clk)     $rose(usb_se0) |-> ##18 $fell(usb_se0);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_usb_se0_transition  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(usb_se0)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##18 $fell(usb_se0)`  \n\n**Explanation**:  \nThis property checks that whenever a rising edge is detected on the `usb_se0` signal (indicating the start of a USB single-ended zero condition), then exactly 18 clock cycles later, there must be a falling edge on `usb_se0` (indicating the end of the condition). The check is performed at every rising edge of `usb_clk`.", "sva_signals": ["usb_clk", "usb_se0", "[0:0] usb_se0_rose", "[0:0] usb_se0_fell"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)        $rose(usb_se0) |-> ##18 $fell(usb_se0)", "sva_name": "p_usb_se0_fall_after_rose_18cycles", "full_property": "property p_usb_se0_transition;\n@(posedge usb_clk)        $rose(usb_se0) |-> ##18 $fell(usb_se0)\nendproperty\nassert_p_usb_se0_transition:assert property (p_usb_se0_transition) else $error(\"\");", "task_id": "3_963", "predict_sva": "@(posedge usb_clk)    $rose(usb_se0) |-> ##18 $fell(usb_se0)"}
{"id": "26_1_0177", "name": "addr_hs_to_rvalid_within_3_cycles", "sva": "@(posedge clk) disable iff (!rst_n)     $rose(arvalid && arready) |-> ##[1:3] rvalid", "ori_sva": "property addr_hs_to_rvalid_within_3_cycles;\n\n    @(posedge clk) disable iff (!rst_n)\n    $rose(arvalid && arready) |-> ##[1:3] rvalid;\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_arvalid_arready_to_rvalid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (!rst_n)`  \n**Antecedent (LHS of Implication)**: `$rose(arvalid && arready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] rvalid`  \n\n### Explanation:  \n1. **Property Name**: The assertion is named `p_arvalid_arready_to_rvalid` to reflect its purpose of checking the relationship between `arvalid`, `arready`, and `rvalid`.  \n2. **Trigger Condition**: The property is evaluated at every positive edge of the clock signal `clk`.  \n3. **Disable Condition**: The property is disabled (not evaluated) when the reset signal `rst_n` is low (`!rst_n`), indicating an active-low reset condition.  \n4. **Antecedent**: The antecedent checks for a rising edge (`$rose`) of the logical AND of `arvalid` and `arready`. This means the condition is true when `arvalid` and `arready` transition from low to high.  \n5. **Implication Operator**: The `|->` operator ensures that if the antecedent is true, the consequent must hold.  \n6. **Consequent**: The consequent requires that `rvalid` must become true within 1 to 3 clock cycles (`##[1:3]`) after the antecedent is satisfied.  \n\nThis assertion ensures that after a valid handshake (`arvalid && arready` rising), the `rvalid` signal is asserted within the specified clock cycles, unless the system is in reset.", "sva_signals": ["clk", "rst_n", "[0:0] arvalid", "[0:0] arready", "[0:0] rvalid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)    $rose(arvalid && arready) |-> ##[1:3] rvalid", "sva_name": "p_rvalid_after_handshake", "full_property": "property p_arvalid_arready_to_rvalid;\n@(posedge clk) disable iff (!rst_n)    $rose(arvalid && arready) |-> ##[1:3] rvalid\nendproperty\nassert_p_arvalid_arready_to_rvalid:assert property (p_arvalid_arready_to_rvalid) else $error(\"\");", "task_id": "3_981", "predict_sva": "@(posedge clk) disable iff (!rst_n)     $rose(arvalid && arready) |-> ##[1:3] rvalid"}
{"id": "27_6_0208", "name": "wlast_wstrb_nonzero_after_valid", "sva": "@(posedge clk) $rose(wlast) |-> $past(wvalid) && ($countones(wstrb) > 0)", "ori_sva": "property wlast_wstrb_nonzero_after_valid;\n\n    @(posedge clk) $rose(wlast) |-> $past(wvalid) && ($countones(wstrb) > 0);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wlast_rose_check  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(wlast)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(wvalid) && ($countones(wstrb) > 0)`  \n\n**Explanation**:  \nThe assertion checks that whenever `wlast` rises (`$rose(wlast)`), the following conditions must hold:  \n1. In the previous cycle (`$past(wvalid)`), `wvalid` must have been asserted.  \n2. In the current cycle, at least one bit of `wstrb` must be set (`$countones(wstrb) > 0`).  \n\nThe assertion is evaluated at every rising edge of `clk` and has no disable condition.", "sva_signals": ["clk", "rst_n", "[0:0] wlast", "[0:0] wvalid", "[0:0] wstrb"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        $rose(wlast) |-> ($past(wvalid) && ($countones(wstrb) > 0))", "sva_name": "p_wlast_rise_requires_prev_wvalid_and_wstrb_nonzero", "full_property": "property p_wlast_rose_check;\n@(posedge clk)        $rose(wlast) |-> ($past(wvalid) && ($countones(wstrb) > 0))\nendproperty\nassert_p_wlast_rose_check:assert property (p_wlast_rose_check) else $error(\"\");", "task_id": "3_1022", "predict_sva": "@(posedge clk)         $rose(wlast) |-> ($past(wvalid) == 1) && ($countones(wstrb) > 0)"}
{"id": "281_10_2385", "name": "p_data_island_end_sequence", "sva": "@(posedge hdmi_clk)     $fell(data_island_period) |-> ##1 (end_sequence_byte == 8'hFF)", "ori_sva": "property p_data_island_end_sequence;\n@(posedge hdmi_clk)     $fell(data_island_period) |-> ##1 (end_sequence_byte == 8'hFF);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_EndSequenceAfterDataIsland  \n**Trigger Condition**: At every posedge of the `hdmi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(data_island_period)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (end_sequence_byte == 8'hFF)`  \n\n**Explanation**:  \nThis property checks that whenever there is a falling edge on `data_island_period` signal (indicating the end of a data island period), then in the next clock cycle (`##1`), the `end_sequence_byte` must equal `8'hFF`. The check occurs at every rising edge of `hdmi_clk` and has no disable condition.", "sva_signals": ["hdmi_clk", "[0:0] data_island_period", "[7:0] end_sequence_byte"], "clock": "hdmi_clk", "attempts_left": 10, "sva_result": "@(posedge hdmi_clk)    $fell(data_island_period) |-> ##1 (end_sequence_byte == 8'hFF)", "sva_name": "p_end_sequence_on_data_island_period_fall", "full_property": "property p_EndSequenceAfterDataIsland;\n@(posedge hdmi_clk)    $fell(data_island_period) |-> ##1 (end_sequence_byte == 8'hFF)\nendproperty\nassert_p_EndSequenceAfterDataIsland:assert property (p_EndSequenceAfterDataIsland) else $error(\"\");", "task_id": "3_1026", "predict_sva": "@(posedge hdmi_clk)         $fell(data_island_period) |-> ##1 end_sequence_byte == 8'hFF"}
{"id": "293_9_2481", "name": "p_ecc_error_no_false_positive_status", "sva": "@(posedge nfc_clk)     nfc_status_reg_ecc_err |-> $past(nfc_read_op && nfc_ecc_uncorrectable, 1)", "ori_sva": "property p_ecc_error_no_false_positive_status;\n@(posedge nfc_clk)     nfc_status_reg_ecc_err |-> $past(nfc_read_op && nfc_ecc_uncorrectable, 1);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_nfc_ecc_err_check  \n**Trigger Condition**: At every rising edge of the `nfc_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `nfc_status_reg_ecc_err == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(nfc_read_op && nfc_ecc_uncorrectable, 1)`  \n\nExplanation:  \nThis assertion checks that whenever the NFC status register indicates an ECC error (`nfc_status_reg_ecc_err` is high), it must be true that in the previous clock cycle, there was both an NFC read operation (`nfc_read_op`) and an uncorrectable ECC error (`nfc_ecc_uncorrectable`). The check occurs at every rising edge of the NFC clock (`nfc_clk`).", "sva_signals": ["nfc_clk", "[0:0] nfc_status_reg_ecc_err", "[0:0] nfc_read_op", "[0:0] nfc_ecc_uncorrectable"], "clock": "nfc_clk", "attempts_left": 10, "sva_result": "@(posedge nfc_clk)    nfc_status_reg_ecc_err == 1'b1 |-> $past(nfc_read_op && nfc_ecc_uncorrectable, 1)", "sva_name": "p_ecc_err_status_check", "full_property": "property p_nfc_ecc_err_check;\n@(posedge nfc_clk)    nfc_status_reg_ecc_err == 1'b1 |-> $past(nfc_read_op && nfc_ecc_uncorrectable, 1)\nendproperty\nassert_p_nfc_ecc_err_check:assert property (p_nfc_ecc_err_check) else $error(\"\");", "task_id": "3_1107", "predict_sva": "@(posedge nfc_clk)     nfc_status_reg_ecc_err == 1'b1 |-> $past(nfc_read_op & nfc_ecc_uncorrectable, 1)"}
{"id": "297_1_2519", "name": "odd_even_bank_activation_spacing_1", "sva": "@(posedge hbm_clk)     $rose(hbm_pseudo_ch_mode_enable) |->      (hbm_odd_bank_activate ##2 hbm_even_bank_activate) or      (hbm_even_bank_activate ##2 hbm_odd_bank_activate)", "ori_sva": "property odd_even_bank_activation_spacing_1;\n@(posedge hbm_clk)     $rose(hbm_pseudo_ch_mode_enable) |->      (hbm_odd_bank_activate ##2 hbm_even_bank_activate) or      (hbm_even_bank_activate ##2 hbm_odd_bank_activate);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hbm_bank_activation_order  \n**Trigger Condition**: At every rising edge of the `hbm_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(hbm_pseudo_ch_mode_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(hbm_odd_bank_activate ##2 hbm_even_bank_activate) or (hbm_even_bank_activate ##2 hbm_odd_bank_activate)`  \n\n**Explanation of Consequent**:  \nThe consequent requires that either:  \n1. `hbm_odd_bank_activate` occurs first, followed by `hbm_even_bank_activate` after 2 clock cycles, **or**  \n2. `hbm_even_bank_activate` occurs first, followed by `hbm_odd_bank_activate` after 2 clock cycles.  \n\nThe property checks that the activation of odd and even HBM banks follows one of these two ordered patterns whenever `hbm_pseudo_ch_mode_enable` transitions from low to high.", "sva_signals": ["hbm_clk", "hbm_pseudo_ch_mode_enable", "hbm_odd_bank_activate", "hbm_even_bank_activate"], "clock": "hbm_clk", "attempts_left": 10, "sva_result": "@(posedge hbm_clk)    $rose(hbm_pseudo_ch_mode_enable) |->         ((hbm_odd_bank_activate ##2 hbm_even_bank_activate) or          (hbm_even_bank_activate ##2 hbm_odd_bank_activate))", "sva_name": "p_hbm_bank_activation_sequence", "full_property": "property p_hbm_bank_activation_order;\n@(posedge hbm_clk)    $rose(hbm_pseudo_ch_mode_enable) |->         ((hbm_odd_bank_activate ##2 hbm_even_bank_activate) or          (hbm_even_bank_activate ##2 hbm_odd_bank_activate))\nendproperty\nassert_p_hbm_bank_activation_order:assert property (p_hbm_bank_activation_order) else $error(\"\");", "task_id": "3_1121", "predict_sva": "@(posedge hbm_clk)         $rose(hbm_pseudo_ch_mode_enable) |->          (hbm_odd_bank_activate ##2 hbm_even_bank_activate) or          (hbm_even_bank_activate ##2 hbm_odd_bank_activate)"}
{"id": "58_1_0410", "name": "cmd_response_timeout", "sva": "@(posedge clk_signal)     $rose(cmd_start) |-> ##[1:8] resp_start", "ori_sva": "property cmd_response_timeout;\n@(posedge clk_signal)\n    $rose(cmd_start) |-> ##[1:8] resp_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cmd_start_to_resp_start  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cmd_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] resp_start`  \n\n**Explanation**:  \nThis property checks that whenever there is a rising edge on `cmd_start` (indicating the start of a command), the signal `resp_start` must occur within 1 to 8 clock cycles after the rising edge of `clk_signal`. The assertion is evaluated at every positive edge of `clk_signal` and has no disable condition. The antecedent (`$rose(cmd_start)`) triggers the check, and the consequent (`##[1:8] resp_start`) ensures the response starts within the specified delay window.", "sva_signals": ["clk_signal", "[0:0] cmd_start", "[0:0] resp_start"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)        $rose(cmd_start) |-> ##[1:8] resp_start", "sva_name": "p_resp_start_within_8_cycles_after_cmd_start", "full_property": "property p_cmd_start_to_resp_start;\n@(posedge clk_signal)        $rose(cmd_start) |-> ##[1:8] resp_start\nendproperty\nassert_p_cmd_start_to_resp_start:assert property (p_cmd_start_to_resp_start) else $error(\"\");", "task_id": "3_1283", "predict_sva": "@(posedge clk_signal)         $rose(cmd_start) |-> ##[1:8] resp_start"}
{"id": "32_6_0237", "name": "p_wvalid_must_come_after_awvalid", "sva": "@(posedge clk)     wvalid |-> $past(awvalid,1) || $past(awvalid,2) || $past(awvalid,3)", "ori_sva": "property p_wvalid_must_come_after_awvalid;\n@(posedge clk)\n    wvalid |-> $past(awvalid,1) || $past(awvalid,2) || $past(awvalid,3);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_wvalid_awvalid_check  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wvalid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(awvalid,1) || $past(awvalid,2) || $past(awvalid,3)`  \n\n### Explanation:  \nThe property checks that whenever `wvalid` is high (`1'b1`) at a rising clock edge, at least one of the following must be true:  \n- `awvalid` was high 1 clock cycle ago (`$past(awvalid,1)`),  \n- `awvalid` was high 2 clock cycles ago (`$past(awvalid,2)`), or  \n- `awvalid` was high 3 clock cycles ago (`$past(awvalid,3)`).  \n\nThis ensures that `wvalid` is only asserted if `awvalid` was asserted in one of the preceding 3 clock cycles.", "sva_signals": ["clk", "rst_n", "[0:0] wvalid", "[0:0] awvalid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        wvalid == 1'b1 |-> ($past(awvalid,1) || $past(awvalid,2) || $past(awvalid,3))", "sva_name": "p_wvalid_awvalid_sequence", "full_property": "property p_wvalid_awvalid_check;\n@(posedge clk)        wvalid == 1'b1 |-> ($past(awvalid,1) || $past(awvalid,2) || $past(awvalid,3))\nendproperty\nassert_p_wvalid_awvalid_check:assert property (p_wvalid_awvalid_check) else $error(\"\");", "task_id": "3_1155", "predict_sva": "@(posedge clk)         wvalid == 1'b1 |-> ($past(awvalid, 1) == 1'b1) || ($past(awvalid, 2) == 1'b1) || ($past(awvalid, 3) == 1'b1)"}
{"id": "86_3_0640", "name": "p_signature_stable_after_match", "sva": "@(posedge clk_signal)     $rose(start_signal) ##1 (signature == $past(golden_sig)) |=> $stable(signature)", "ori_sva": "property p_signature_stable_after_match;\n@(posedge clk_signal)\n    $rose(start_signal) ##1 (signature == $past(golden_sig)) |=> $stable(signature);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_signature_stability_after_start  \n**Trigger Condition**: At every posedge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(start_signal) ##1 (signature == $past(golden_sig))`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(signature)`  \n\n### Explanation:  \n1. The property checks the behavior of `signature` after a rising edge of `start_signal`.  \n2. **Antecedent**:  \n   - `$rose(start_signal)` detects the rising edge of `start_signal`.  \n   - `##1 (signature == $past(golden_sig))` ensures that in the next clock cycle, `signature` matches the previous value of `golden_sig`.  \n3. **Implication**: `|=>` (non-overlapping implication) means the consequent is checked one clock cycle after the antecedent completes.  \n4. **Consequent**: `$stable(signature)` asserts that `signature` must remain stable (unchanged) after the antecedent condition is met.  \n\n### Summary:  \nThe assertion verifies that once `start_signal` rises and `signature` matches the previous `golden_sig` in the next cycle, `signature` must remain stable in subsequent cycles.", "sva_signals": ["clk_signal", "start_signal", "signature", "golden_sig"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)    $rose(start_signal) ##1 (signature == $past(golden_sig)) |=> $stable(signature)", "sva_name": "p_Stable_Signature_After_Start", "full_property": "property p_signature_stability_after_start;\n@(posedge clk_signal)    $rose(start_signal) ##1 (signature == $past(golden_sig)) |=> $stable(signature)\nendproperty\nassert_p_signature_stability_after_start:assert property (p_signature_stability_after_start) else $error(\"\");", "task_id": "3_1413", "predict_sva": "@(posedge clk_signal)     $rose(start_signal) ##1 (signature == $past(golden_sig)) |=> $stable(signature)"}
{"id": "9_3_0047", "name": "cnt_change_implies_ones_check", "sva": "@(posedge clk)      cnt != $past(cnt) |=> $countones(cnt) >= $past($countones(cnt), 1)", "ori_sva": "property cnt_change_implies_ones_check;\n@(posedge clk) \n    cnt != $past(cnt) |=> $countones(cnt) >= $past($countones(cnt), 1);\n\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cnt_countones_increase  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cnt != $past(cnt)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$countones(cnt) >= $past($countones(cnt), 1)`  \n\n**Explanation**:  \nThis property checks that whenever the value of `cnt` changes from its previous value (`cnt != $past(cnt)`), then in the next clock cycle (`|=>`), the number of ones in the current `cnt` must be greater than or equal to the number of ones in `cnt` from the previous cycle. The `$countones` function counts the number of set bits (ones) in `cnt`.  \n\n**Key Points**:  \n1. The check is triggered at every rising edge of `clk`.  \n2. If `cnt` changes, the next cycle must not have fewer ones than before.  \n3. No reset/disabling condition is applied.", "sva_signals": ["clk", "rst_n", "[0:0] cnt"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)        cnt != $past(cnt) |=> $countones(cnt) >= $past($countones(cnt), 1)", "sva_name": "p_cnt_ones_non_decreasing_on_change", "full_property": "property p_cnt_countones_increase;\n@(posedge clk)        cnt != $past(cnt) |=> $countones(cnt) >= $past($countones(cnt), 1)\nendproperty\nassert_p_cnt_countones_increase:assert property (p_cnt_countones_increase) else $error(\"\");", "task_id": "3_1458", "predict_sva": "@(posedge clk)         cnt != $past(cnt) |-> ##1 $countones(cnt) >= $past($countones(cnt), 1)"}
{"id": "1_12_0056", "name": "p12", "sva": "@(posedge clk)     $rose(dma_request) |-> ##3 dma_grant", "ori_sva": "property p12;\n@(posedge clk)     $rose(dma_request) |-> ##3 dma_grant\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Dma_Grant_After_Request  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(dma_request)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 dma_grant`  ", "sva_signals": ["clk", "rst_n", "[0:0] dma_request", "[0:0] dma_grant"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(dma_request) |-> ##3 dma_grant;", "sva_name": "p_dma_grant_after_dma_request_rise", "full_property": "property p_Dma_Grant_After_Request;\n@(posedge clk)         $rose(dma_request) |-> ##3 dma_grant;\nendproperty\nassert_p_Dma_Grant_After_Request:assert property (p_Dma_Grant_After_Request) else $error(\"\");", "task_id": "3_1487", "predict_sva": "@(posedge clk)         $rose(dma_request) |-> ##3 dma_grant"}
{"id": "1_20_0012", "name": "p20", "sva": "@(posedge clk)     $fell(enable_signal) |-> ##1 outputs_disabled", "ori_sva": "property p20;\n@(posedge clk)     $fell(enable_signal) |-> ##1 outputs_disabled\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Outputs_Disabled_After_Fell  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(enable_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 outputs_disabled`", "sva_signals": ["clk", "rst_n", "[0:0] enable_signal", "[0:0] outputs_disabled"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(enable_signal) |-> ##1 outputs_disabled;", "sva_name": "p_outputs_disabled_on_enable_fall", "full_property": "property p_Outputs_Disabled_After_Fell;\n@(posedge clk)     $fell(enable_signal) |-> ##1 outputs_disabled;\nendproperty\nassert_p_Outputs_Disabled_After_Fell:assert property (p_Outputs_Disabled_After_Fell) else $error(\"\");", "task_id": "3_1496", "predict_sva": "@(posedge clk)     $fell(enable_signal) |-> ##1 outputs_disabled"}
{"id": "1_24_0030", "name": "p24", "sva": "@(posedge clk)     $fell(clock_valid) |-> ##1 !data_processing", "ori_sva": "property p24;\n@(posedge clk)     $fell(clock_valid) |-> ##1 !data_processing\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fell_Clock_Valid_Stop_Processing  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clock_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !data_processing`  \n\n(Note: The property checks that if `clock_valid` has a falling edge, then in the next clock cycle, `data_processing` must be deasserted (`!data_processing`).)", "sva_signals": ["clk", "rst_n", "[0:0] clock_valid", "[0:0] data_processing"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(clock_valid) |-> ##1 !data_processing;", "sva_name": "p_data_processing_deassert_on_clock_valid_fall", "full_property": "property p_Fell_Clock_Valid_Stop_Processing;\n@(posedge clk)     $fell(clock_valid) |-> ##1 !data_processing;\nendproperty\nassert_p_Fell_Clock_Valid_Stop_Processing:assert property (p_Fell_Clock_Valid_Stop_Processing) else $error(\"\");", "task_id": "3_1500", "predict_sva": "@(posedge clk)         $fell(clock_valid) |-> ##1 data_processing == 0"}
{"id": "1_6_0040", "name": "p6", "sva": "@(posedge clk)     $changed(addr_bus) |-> ##2 data_stable", "ori_sva": "property p6;\n@(posedge clk)     $changed(addr_bus) |-> ##2 data_stable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Addr_Change_Data_Stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(addr_bus)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 data_stable`  ", "sva_signals": ["clk", "rst_n", "[15:0] addr_bus", "[0:0] data_stable"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $changed(addr_bus) |-> ##2 data_stable;", "sva_name": "p_data_stable_after_addr_bus_change", "full_property": "property p_Addr_Change_Data_Stable;\n@(posedge clk)     $changed(addr_bus) |-> ##2 data_stable;\nendproperty\nassert_p_Addr_Change_Data_Stable:assert property (p_Addr_Change_Data_Stable) else $error(\"\");", "task_id": "3_1510", "predict_sva": "@(posedge clk)         $changed(addr_bus) |-> ##2 data_stable == 1"}
{"id": "3_40_0119", "name": "p_non_overlap_10", "sva": "@(posedge clk)     (power_down_req && !critical_operation) |=> ##2 power_off_ack", "ori_sva": "property p_non_overlap_10;\n@(posedge clk)     (power_down_req && !critical_operation) |=> ##2 power_off_ack;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Off_Ack_After_Req  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_down_req && !critical_operation`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##2 power_off_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] power_down_req", "[0:0] critical_operation", "[0:0] power_off_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (power_down_req && !critical_operation) |=> ##2 power_off_ack;", "sva_name": "p_power_off_ack_after_power_down_req", "full_property": "property p_Power_Off_Ack_After_Req;\n@(posedge clk)         (power_down_req && !critical_operation) |=> ##2 power_off_ack;\nendproperty\nassert_p_Power_Off_Ack_After_Req:assert property (p_Power_Off_Ack_After_Req) else $error(\"\");", "task_id": "3_1577", "predict_sva": "@(posedge clk)         (power_down_req == 1 && critical_operation == 0) |-> ##2 (power_off_ack == 1)"}
{"id": "4_23_0148", "name": "p_frame_sync", "sva": "@(posedge clk)     vsync[*2] |-> frame_start", "ori_sva": "property p_frame_sync;\n@(posedge clk)     vsync[*2] |-> frame_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_vsync_frame_start  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vsync` is high for two consecutive clock cycles (`vsync[*2]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `frame_start` is high in the same cycle as the second occurrence of `vsync`  \n\n(Note: The assertion checks that whenever `vsync` remains high for two consecutive clock cycles, `frame_start` must also be high in the second cycle.)", "sva_signals": ["clk", "rst_n", "[0:0] vsync", "[0:0] frame_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         vsync[*2] |-> frame_start;", "sva_name": "p_frame_start_on_second_consecutive_vsync_high", "full_property": "property p_vsync_frame_start;\n@(posedge clk)         vsync[*2] |-> frame_start;\nendproperty\nassert_p_vsync_frame_start:assert property (p_vsync_frame_start) else $error(\"\");", "task_id": "3_1612", "predict_sva": "@(posedge clk)         vsync [*2] |-> frame_start"}
{"id": "4_7_0129", "name": "p_packet_sync", "sva": "@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start", "ori_sva": "property p_packet_sync;\n@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Pulse_To_Packet_Start  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_pulse` occurs consecutively for 2 clock cycles (`sync_pulse[*2]`)  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `##2 packet_start` (2 clock cycles after the antecedent sequence completes, `packet_start` must be asserted)", "sva_signals": ["clk", "rst_n", "[0:0] sync_pulse", "[0:0] packet_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start;", "sva_name": "p_sync_pulse_to_packet_start", "full_property": "property p_Sync_Pulse_To_Packet_Start;\n@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start;\nendproperty\nassert_p_Sync_Pulse_To_Packet_Start:assert property (p_Sync_Pulse_To_Packet_Start) else $error(\"\");", "task_id": "3_1619", "predict_sva": "@(posedge clk)     sync_pulse[*2] |=> ##2 packet_start"}
{"id": "5_12_0181", "name": "p12", "sva": "@(posedge clk)     (($fell(clock_enable) && !low_power_mode) || reset) |-> ##1 clock_gate", "ori_sva": "property p12;\n@(posedge clk)     (($fell(clock_enable) && !low_power_mode) || reset) |-> ##1 clock_gate\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_clock_gate_control  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `($fell(clock_enable) && !low_power_mode) || reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 clock_gate`  ", "sva_signals": ["clk", "rst_n", "[0:0] clock_enable", "[0:0] low_power_mode", "[0:0] reset", "[0:0] clock_gate"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     ($fell(clock_enable) && !low_power_mode) || reset |-> ##1 clock_gate;", "sva_name": "p_clock_gate_assertion_on_enable_or_reset", "full_property": "property p_clock_gate_control;\n@(posedge clk)     ($fell(clock_enable) && !low_power_mode) || reset |-> ##1 clock_gate;\nendproperty\nassert_p_clock_gate_control:assert property (p_clock_gate_control) else $error(\"\");", "task_id": "3_1624", "predict_sva": "@(posedge clk)         ($fell(clock_enable) && !low_power_mode) || reset == 1 |-> ##1 clock_gate == 1"}
{"id": "6_22_0192", "name": "p_fell_fifo_pop", "sva": "@(posedge clk)     $fell(fifo_pop) |-> ##1 fifo_empty", "ori_sva": "property p_fell_fifo_pop;\n@(posedge clk)     $fell(fifo_pop) |-> ##1 fifo_empty\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_FifoEmpty_After_Fell  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(fifo_pop)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 fifo_empty`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_pop", "[0:0] fifo_empty"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $fell(fifo_pop) |-> ##1 fifo_empty;", "sva_name": "p_Fifo_Empty_After_Fell", "full_property": "property p_FifoEmpty_After_Fell;\n@(posedge clk)         $fell(fifo_pop) |-> ##1 fifo_empty;\nendproperty\nassert_p_FifoEmpty_After_Fell:assert property (p_FifoEmpty_After_Fell) else $error(\"\");", "task_id": "3_1663", "predict_sva": "@(posedge clk)     $fell(fifo_pop) |-> ##1 fifo_empty"}
{"id": "8_16_0264", "name": "p_power_sequence", "sva": "@(posedge clk)     $past(pwr_up, 1) |-> ##[1:5] $past(pwr_ok, 2)", "ori_sva": "property p_power_sequence;\n@(posedge clk)     $past(pwr_up, 1) |-> ##[1:5] $past(pwr_ok, 2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PwrOk_After_PwrUp  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(pwr_up, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $past(pwr_ok, 2)`  ", "sva_signals": ["clk", "rst_n", "[0:0] pwr_up", "[0:0] pwr_ok"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $past(pwr_up, 1) |-> ##[1:5] $past(pwr_ok, 2);", "sva_name": "p_pwr_ok_within_5_cycles_after_pwr_up", "full_property": "property p_PwrOk_After_PwrUp;\n@(posedge clk)         $past(pwr_up, 1) |-> ##[1:5] $past(pwr_ok, 2);\nendproperty\nassert_p_PwrOk_After_PwrUp:assert property (p_PwrOk_After_PwrUp) else $error(\"\");", "task_id": "3_1712", "predict_sva": "@(posedge clk)         $past(pwr_up) |-> ##[1:5] $past(pwr_ok, 2)"}
{"id": "1_22_0047", "name": "p_weak_power_sequence", "sva": "@(posedge clk)     always (power_on |-> ##1 voltage_stable[->1] ##1 clock_stable[->1] ##1 reset_release)", "ori_sva": "property p_weak_power_sequence;\n@(posedge clk)     always (power_on |-> ##1 voltage_stable[->1] ##1 clock_stable[->1] ##1 reset_release);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_on_sequence  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_on`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 voltage_stable[->1] ##1 clock_stable[->1] ##1 reset_release`  ", "sva_signals": ["clk", "rst_n", "[0:0] power_on", "[0:0] voltage_stable", "[0:0] clock_stable", "[0:0] reset_release"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         power_on |-> ##1 voltage_stable[->1] ##1 clock_stable[->1] ##1 reset_release;", "sva_name": "p_power_on_sequence_check", "full_property": "property p_power_on_sequence;\n@(posedge clk)         power_on |-> ##1 voltage_stable[->1] ##1 clock_stable[->1] ##1 reset_release;\nendproperty\nassert_p_power_on_sequence:assert property (p_power_on_sequence) else $error(\"\");", "task_id": "3_1753", "predict_sva": "@(posedge clk)         power_on == 1 |-> ##1 voltage_stable == 1 ##1 clock_stable == 1 ##1 reset_release == 1"}
{"id": "2_20_0023", "name": "p_not_nested_sequence", "sva": "@(posedge clk)     not (level1 |-> (level2 |-> level3))", "ori_sva": "property p_not_nested_sequence;\n@(posedge clk)     not (level1 |-> (level2 |-> level3));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: Not_Nested_Implications  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (entire property is negated)  \n**Implication Operator**: Not applicable (property is negated)  \n**Consequent (RHS of Implication)**: Not applicable (property is negated)  \n**Property Behavior**: The property asserts that the nested implication sequence `(level1 |-> (level2 |-> level3))` must never evaluate to true at any clock edge. In other words, it is illegal for `level1` to imply that `level2` implies `level3` at any point in time.  \n\n### Key Observations:  \n1. The entire property is wrapped in `not`, meaning it passes only if the inner implication sequence fails.  \n2. The nested implication checks that:  \n   - If `level1` is true, then in the same cycle, `level2` must imply `level3` (i.e., if `level2` is true, `level3` must also be true).  \n3. No disable condition is specified, so the assertion is always active.  \n\n### Equivalent Logical Meaning:  \nThe assertion is equivalent to: \"There must never exist a clock edge where `level1` is true and either:  \n- `level2` is false, or  \n- `level2` is true but `level3` is false.\"  \n\n### Note:  \nThis is a *cover property* in disguise (checks for existence of a condition) rather than a typical assertion (which checks for absence of violations).", "sva_signals": ["clk", "rst_n", "[0:0] level1", "[0:0] level2", "[0:0] level3"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     not (level1 |-> (level2 |-> level3));", "sva_name": "p_no_illegal_level_sequence", "full_property": "property Not_Nested_Implications;\n@(posedge clk)     not (level1 |-> (level2 |-> level3));\nendproperty\nassert_Not_Nested_Implications:assert property (Not_Nested_Implications) else $error(\"\");", "task_id": "3_1767", "predict_sva": "@(posedge clk)         level1 == 1 |-> !(level2 == 1 && level3 == 0)"}
{"id": "13_22_0561", "name": "p_repeat_22", "sva": "@(posedge clk)     $rose(interrupt_line) |-> (int_ack[*2] ##1 int_service)", "ori_sva": "property p_repeat_22;\n@(posedge clk)     $rose(interrupt_line) |-> (int_ack[*2] ##1 int_service);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Interrupt_Handling  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(interrupt_line)` (a rising edge on the `interrupt_line` signal)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `int_ack[*2] ##1 int_service` (two consecutive cycles where `int_ack` is high, followed by `int_service` being high in the next cycle)", "sva_signals": ["clk", "rst_n", "[0:0] interrupt_line", "[0:0] int_ack", "[0:0] int_service"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(interrupt_line) |-> int_ack[*2] ##1 int_service;", "sva_name": "p_int_ack_and_service_after_interrupt", "full_property": "property p_Interrupt_Handling;\n@(posedge clk)         $rose(interrupt_line) |-> int_ack[*2] ##1 int_service;\nendproperty\nassert_p_Interrupt_Handling:assert property (p_Interrupt_Handling) else $error(\"\");", "task_id": "3_1852", "predict_sva": "@(posedge clk)         $rose(interrupt_line) |-> ##1 int_ack ##1 int_ack ##1 int_service"}
{"id": "13_8_0551", "name": "p_repeat_8", "sva": "@(posedge clk)     $stable(config_reg)[*3] |-> config_valid", "ori_sva": "property p_repeat_8;\n@(posedge clk)     $stable(config_reg)[*3] |-> config_valid;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Config_Valid  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(config_reg)[*3]` (the value of `config_reg` remains stable for 3 consecutive clock cycles)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `config_valid` (the signal `config_valid` must be asserted)", "sva_signals": ["clk", "rst_n", "[0:0] config_reg", "[0:0] config_valid"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(config_reg)[*3] |-> config_valid;", "sva_name": "p_config_valid_after_stable_config_reg", "full_property": "property p_Stable_Config_Valid;\n@(posedge clk)     $stable(config_reg)[*3] |-> config_valid;\nendproperty\nassert_p_Stable_Config_Valid:assert property (p_Stable_Config_Valid) else $error(\"\");", "task_id": "3_1862", "predict_sva": "@(posedge clk)         $stable(config_reg)[*3] |-> config_valid == 1"}
{"id": "14_27_0594", "name": "p_fifo_almost_full", "sva": "@(posedge clk)     fifo_wr_en && fifo_almost_full |=> fifo_full[*1:3]", "ori_sva": "property p_fifo_almost_full;\n@(posedge clk)     fifo_wr_en && fifo_almost_full |=> fifo_full[*1:3];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_full_after_almost_full  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_wr_en && fifo_almost_full`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `fifo_full[*1:3]`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_wr_en", "[0:0] fifo_almost_full", "[0:0] fifo_full"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         (fifo_wr_en && fifo_almost_full) |=> fifo_full[*1:3];", "sva_name": "p_fifo_full_after_almost_full_write", "full_property": "property p_fifo_full_after_almost_full;\n@(posedge clk)         (fifo_wr_en && fifo_almost_full) |=> fifo_full[*1:3];\nendproperty\nassert_p_fifo_full_after_almost_full:assert property (p_fifo_full_after_almost_full) else $error(\"\");", "task_id": "3_1866", "predict_sva": "@(posedge clk)         (fifo_wr_en == 1 && fifo_almost_full == 1) |-> ##1 (fifo_full == 1 [*1:3])"}
{"id": "3_13_0053", "name": "p_throughout_13", "sva": "@(posedge clk)     (security_mode[1:0] == 2'b11) throughout ($fell(secure_access) ##1 secure_ack)", "ori_sva": "property p_throughout_13;\n@(posedge clk)     (security_mode[1:0] == 2'b11) throughout ($fell(secure_access) ##1 secure_ack);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_SecurityModeDuringSecureAccess  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple property without implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: `(security_mode[1:0] == 2'b11) throughout ($fell(secure_access) ##1 secure_ack)`  \n\n**Detailed Behavior**:  \nThe property checks that during the sequence where `secure_access` falls (`$fell(secure_access)`) and is followed by `secure_ack` in the next cycle (`##1 secure_ack`), the `security_mode` signal must continuously maintain the value `2'b11` throughout this entire sequence.  \n\n**Key Points**:  \n1. The check starts when `secure_access` has a falling edge (`$fell`).  \n2. The sequence spans from the falling edge of `secure_access` to the cycle where `secure_ack` is high.  \n3. Throughout this entire sequence, `security_mode` must remain `2'b11`.  \n4. The check is evaluated at every rising edge of `clk`.  \n\nNote: This is a temporal property using the `throughout` operator rather than an implication-based assertion.", "sva_signals": ["clk", "rst_n", "[1:0] security_mode", "[0:0] secure_access", "[0:0] secure_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (security_mode[1:0] == 2'b11) throughout ($fell(secure_access) ##1 secure_ack);", "sva_name": "p_Secure_Access_Check", "full_property": "property p_SecurityModeDuringSecureAccess;\n@(posedge clk)     (security_mode[1:0] == 2'b11) throughout ($fell(secure_access) ##1 secure_ack);\nendproperty\nassert_p_SecurityModeDuringSecureAccess:assert property (p_SecurityModeDuringSecureAccess) else $error(\"\");", "task_id": "3_1941", "predict_sva": "@(posedge clk)     $fell(secure_access) |->      (security_mode[1:0] == 2'b11) throughout (         ##1 $rose(secure_ack)     )"}
{"id": "3_29_0112", "name": "p_throughout_29", "sva": "@(posedge clk)     (burst_count == 4'b1000) throughout (##1 burst_start ##[1:4] burst_done)", "ori_sva": "property p_throughout_29;\n@(posedge clk)     (burst_count == 4'b1000) throughout (##1 burst_start ##[1:4] burst_done);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Burst_Sequence  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(burst_count == 4'b1000)`  \n**Implication Operator**: `throughout`  \n**Consequent (RHS of Implication)**: `##1 burst_start ##[1:4] burst_done`  ", "sva_signals": ["clk", "rst_n", "[3:0] burst_count", "[0:0] burst_start", "[0:0] burst_done"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (burst_count == 4'b1000) throughout ##1 burst_start ##[1:4] burst_done;", "sva_name": "p_burst_start_done_sequence", "full_property": "property p_Burst_Sequence;\n@(posedge clk)     (burst_count == 4'b1000) throughout ##1 burst_start ##[1:4] burst_done;\nendproperty\nassert_p_Burst_Sequence:assert property (p_Burst_Sequence) else $error(\"\");", "task_id": "3_1974", "predict_sva": "@(posedge clk)         burst_count == 4'b1000 |-> ##1 burst_start == 1 ##[1:4] burst_done == 1"}
{"id": "4_14_0295", "name": "p_non_overlap_7", "sva": "@(posedge clk)     temperature_high |=> ##[1:5] cooling_active", "ori_sva": "property p_non_overlap_7;\n@(posedge clk)     temperature_high |=> ##[1:5] cooling_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temperature_high_to_cooling  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temperature_high == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:5] cooling_active == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] temperature_high", "[0:0] cooling_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     temperature_high == 1'b1 |=> ##[1:5] cooling_active == 1'b1;", "sva_name": "p_cooling_active_within_5_cycles_after_temperature_high", "full_property": "property p_temperature_high_to_cooling;\n@(posedge clk)     temperature_high == 1'b1 |=> ##[1:5] cooling_active == 1'b1;\nendproperty\nassert_p_temperature_high_to_cooling:assert property (p_temperature_high_to_cooling) else $error(\"\");", "task_id": "3_1993", "predict_sva": "@(posedge clk)         temperature_high == 1'b1 |-> ##[1:5] cooling_active == 1'b1"}
{"id": "4_16_0293", "name": "p_non_overlap_8", "sva": "@(posedge clk)     voltage_low |=> ##2 power_save_mode", "ori_sva": "property p_non_overlap_8;\n@(posedge clk)     voltage_low |=> ##2 power_save_mode\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_low_power_save  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_low == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##2 power_save_mode == 1'b1`  \n\n(Note: The `|=>` operator indicates that the consequent is checked starting from the next clock cycle after the antecedent is true. Here, it means `power_save_mode` must be high **two clock cycles** after `voltage_low` is detected.)", "sva_signals": ["clk", "rst_n", "[0:0] voltage_low", "[0:0] power_save_mode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     voltage_low == 1'b1 |=> ##2 power_save_mode == 1'b1;", "sva_name": "p_power_save_mode_after_voltage_low", "full_property": "property p_voltage_low_power_save;\n@(posedge clk)     voltage_low == 1'b1 |=> ##2 power_save_mode == 1'b1;\nendproperty\nassert_p_voltage_low_power_save:assert property (p_voltage_low_power_save) else $error(\"\");", "task_id": "3_1995", "predict_sva": "@(posedge clk)         voltage_low == 1'b1 |-> ##2 power_save_mode == 1'b1"}
{"id": "8_24_0400", "name": "p_stable_decrypt_ready", "sva": "@(posedge clk) decrypt_ready |-> $stable(cipher_text)", "ori_sva": "property p_stable_decrypt_ready;\n@(posedge clk) decrypt_ready |-> $stable(cipher_text);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_decrypt_ready_stable_cipher  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `decrypt_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(cipher_text)`  ", "sva_signals": ["clk", "rst_n", "[0:0] decrypt_ready", "[0:0] cipher_text"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         decrypt_ready == 1'b1 |-> $stable(cipher_text);", "sva_name": "p_cipher_text_stable_on_decrypt_ready", "full_property": "property p_decrypt_ready_stable_cipher;\n@(posedge clk)         decrypt_ready == 1'b1 |-> $stable(cipher_text);\nendproperty\nassert_p_decrypt_ready_stable_cipher:assert property (p_decrypt_ready_stable_cipher) else $error(\"\");", "task_id": "3_2123", "predict_sva": "@(posedge clk)         decrypt_ready == 1'b1 |-> cipher_text == $past(cipher_text)"}
{"id": "7_16_0375", "name": "p_fell_interrupt_clear", "sva": "@(posedge clk) disable iff (!rst_n)     $fell(int_pending) |-> ##1 !int_service", "ori_sva": "property p_fell_interrupt_clear;\n@(posedge clk) disable iff (!rst_n)     $fell(int_pending) |-> ##1 !int_service;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Int_Pending_Fell_No_Service  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (!rst_n)  \n**Antecedent (LHS of Implication)**: `$fell(int_pending)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !int_service`  ", "sva_signals": ["clk", "rst_n", "[0:0] int_pending", "[0:0] int_service"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!rst_n)     $fell(int_pending) |-> ##1 !int_service;", "sva_name": "p_Int_Service_After_Fell", "full_property": "property p_Int_Pending_Fell_No_Service;\n@(posedge clk) disable iff (!rst_n)     $fell(int_pending) |-> ##1 !int_service;\nendproperty\nassert_p_Int_Pending_Fell_No_Service:assert property (p_Int_Pending_Fell_No_Service) else $error(\"\");", "task_id": "3_2154", "predict_sva": "@(posedge clk) disable iff (!rst_n)     $fell(int_pending) |-> ##1 !int_service"}
{"id": "11_19_0887", "name": "p_no_x_in_serial_tx", "sva": "@(posedge clk)      uart_tx_enable |-> !$isunknown(uart_tx_data);", "sva_description": "### Assertion description:\n**Property Name**: p_UartTxDataValid  \n**Trigger Condition**: At every evaluation point (implicitly always active, no clock specified)  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `uart_tx_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(uart_tx_data)`  \n\nNote: This assertion checks that whenever `uart_tx_enable` is high, the `uart_tx_data` signal must not contain any unknown ('x' or 'z') bits. The assertion is continuously monitored rather than being clock-edge triggered.", "sva_signals": ["clk", "rst_n", "[0:0] uart_tx_enable", "[7:0] uart_tx_data"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) uart_tx_enable == 1'b1 |-> !$isunknown(uart_tx_data)", "sva_name": "p_uart_tx_data_no_x_when_enabled", "full_property": "property p_UartTxDataValid;\n@(posedge clk) uart_tx_enable == 1'b1 |-> !$isunknown(uart_tx_data)\nendproperty\nassert_p_UartTxDataValid:assert property (p_UartTxDataValid) else $error(\"\");", "task_id": "3_2345", "predict_sva": "@(posedge clk)         uart_tx_enable == 1'b1 |-> !$isunknown(uart_tx_data)"}
{"id": "22_24_1871", "name": "p_intersect_24", "sva": "@(posedge clk)      (handshake_req ##2 handshake_ack) intersect (protocol_init ##2 protocol_term);", "sva_description": "### Assertion description:\n**Property Name**: p_handshake_protocol_intersect  \n**Trigger Condition**: The property is evaluated continuously (not clock-edge triggered)  \n**Disable Condition**: None  \n**Sequence 1**: `(handshake_req ##2 handshake_ack)` - A handshake sequence where `handshake_req` is asserted, followed two cycles later by `handshake_ack`  \n**Sequence 2**: `(protocol_init ##2 protocol_term)` - A protocol sequence where `protocol_init` is asserted, followed two cycles later by `protocol_term`  \n**Operator**: `intersect` - Requires both sequences to start and end at exactly the same time  \n\n**Property Behavior**: The assertion checks that the handshake sequence (req followed by ack after 2 cycles) occurs simultaneously with the protocol sequence (init followed by term after 2 cycles), meaning both sequences must begin and end at precisely the same time.", "sva_signals": ["clk", "rst_n", "[0:0] handshake_req", "[0:0] handshake_ack", "[0:0] protocol_init", "[0:0] protocol_term"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) (handshake_req ##2 handshake_ack) intersect (protocol_init ##2 protocol_term)", "sva_name": "p_handshake_protocol_temporal_alignment", "full_property": "property p_handshake_protocol_intersect;\n@(posedge clk) (handshake_req ##2 handshake_ack) intersect (protocol_init ##2 protocol_term)\nendproperty\nassert_p_handshake_protocol_intersect:assert property (p_handshake_protocol_intersect) else $error(\"\");", "task_id": "3_2813", "predict_sva": "@(posedge clk)         (handshake_req == 1 && protocol_init == 1) |-> ##2 (handshake_ack == 1 && protocol_term == 1)"}
{"id": "22_96_1942", "name": "p_intersect_96", "sva": "@(posedge clk)      (clock_accuracy_check ##2 clock_accuracy_adjust) intersect (time_reference_set ##2 time_reference_update);", "sva_description": "### Assertion description:  \n**Property Name**: clock_and_time_check  \n**Trigger Condition**: The property is evaluated continuously, not tied to a specific clock edge.  \n**Disable Condition**: None  \n**Property Expression**:  \nThe property checks that two sequences occur simultaneously (intersect):  \n1. `clock_accuracy_check` occurs, followed by `clock_accuracy_adjust` two cycles later.  \n2. `time_reference_set` occurs, followed by `time_reference_update` two cycles later.  \n\n**Sequence 1**: `clock_accuracy_check ##2 clock_accuracy_adjust`  \n- **Description**: After `clock_accuracy_check` is true, `clock_accuracy_adjust` must be true exactly two cycles later.  \n\n**Sequence 2**: `time_reference_set ##2 time_reference_update`  \n- **Description**: After `time_reference_set` is true, `time_reference_update` must be true exactly two cycles later.  \n\n**Intersection**: The two sequences must align in time, meaning both sequences must start and end at the same cycles.  \n\n**Note**: This is a sequence property, not an implication-based property. It does not have an antecedent or consequent but instead verifies concurrent behavior of two sequences.  \n\n### Key Observations:  \n- No clock edge is specified (`@(posedge clk)` is absent), so the property is evaluated continuously.  \n- The `intersect` operator ensures both sequences start and end simultaneously.  \n- The `##2` delay operator enforces a two-cycle gap between the start and end of each sequence.", "sva_signals": ["clk", "rst_n", "[0:0] clock_accuracy_check", "[0:0] clock_accuracy_adjust", "[0:0] time_reference_set", "[0:0] time_reference_update"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) (clock_accuracy_check ##2 clock_accuracy_adjust) intersect      (time_reference_set ##2 time_reference_update)", "sva_name": "p_clock_accuracy_time_reference_alignment", "full_property": "property clock_and_time_check;\n@(posedge clk) (clock_accuracy_check ##2 clock_accuracy_adjust) intersect      (time_reference_set ##2 time_reference_update)\nendproperty\nassert_clock_and_time_check:assert property (clock_and_time_check) else $error(\"\");", "task_id": "3_2862", "predict_sva": "@(posedge clk)         (clock_accuracy_check == 1 && time_reference_set == 1) |-> ##2 (clock_accuracy_adjust == 1 && time_reference_update == 1)"}
{"sva": "@(posedge sensor_fusion_clk) disable iff(calibration_drift) perception_system |-> (confidence_threshold[7:0] > 8'd200 ? trust_detection : request_confirmation)", "sva_description": "### Assertion description:\n**Property Name**: p_Perception_System_Check  \n**Trigger Condition**: At every rising edge of the `sensor_fusion_clk`  \n**Disable Condition**: disable iff (calibration_drift)  \n**Antecedent (LHS of Implication)**: `perception_system`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(confidence_threshold[7:0] > 8'd200 ? trust_detection : request_confirmation)`  \n\n### Explanation:\n- The property checks the behavior of the perception system when it is active (`perception_system` is true).  \n- If the perception system is active, then on the next clock cycle:  \n  - If the `confidence_threshold` (8-bit value) is greater than 200, the system should output `trust_detection`.  \n  - Otherwise, it should output `request_confirmation`.  \n- The check is disabled if `calibration_drift` is asserted.", "sva_signals": ["sensor_fusion_clk", "[0:0] calibration_drift", "[0:0] perception_system", "[7:0] confidence_threshold", "[0:0] trust_detection", "[0:0] request_confirmation"], "clock": "sensor_fusion_clk", "attempts_left": 10, "sva_result": "@(posedge sensor_fusion_clk)    disable iff (calibration_drift)    perception_system |-> (confidence_threshold[7:0] > 8'd200 ? trust_detection : request_confirmation)", "sva_name": "p_Perception_System_Check", "id": "0231", "full_property": "property p_Perception_System_Check;\n@(posedge sensor_fusion_clk)    disable iff (calibration_drift)    perception_system |-> (confidence_threshold[7:0] > 8'd200 ? trust_detection : request_confirmation)\nendproperty\nassert_p_Perception_System_Check:assert property (p_Perception_System_Check) else $error(\"\");", "task_id": "3_3095", "predict_sva": "@(posedge sensor_fusion_clk) disable iff (calibration_drift)    perception_system |->         if (confidence_threshold[7:0] > 8'd200)             trust_detection        else            request_confirmation"}
{"sva": "@(posedge analytics_clk) disable iff(privacy_mode) data_pipeline |-> (anonymization_required ? mask_identifiers : preserve_original)", "sva_description": "### Assertion description:  \n**Property Name**: p_data_pipeline_anonymization  \n**Trigger Condition**: At every rising edge of the `analytics_clk`  \n**Disable Condition**: disable iff (`privacy_mode`)  \n**Antecedent (LHS of Implication)**: `data_pipeline`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`anonymization_required ? mask_identifiers : preserve_original`)  \n\n### Explanation:  \nThe property checks that whenever `data_pipeline` is active (antecedent), the system must ensure the correct data handling based on `anonymization_required`:  \n- If `anonymization_required` is true, the output must be `mask_identifiers`.  \n- If `anonymization_required` is false, the output must be `preserve_original`.  \nThe assertion is evaluated at every rising edge of `analytics_clk` but is disabled when `privacy_mode` is active.", "sva_signals": ["analytics_clk", "[0:0] privacy_mode", "[0:0] data_pipeline", "[0:0] anonymization_required", "[0:0] mask_identifiers", "[0:0] preserve_original"], "clock": "analytics_clk", "attempts_left": 10, "sva_result": "@(posedge analytics_clk) disable iff (privacy_mode)    data_pipeline |-> (anonymization_required ? mask_identifiers : preserve_original)", "sva_name": "p_data_pipeline_anonymization_output", "id": "0249", "full_property": "property p_data_pipeline_anonymization;\n@(posedge analytics_clk) disable iff (privacy_mode)    data_pipeline |-> (anonymization_required ? mask_identifiers : preserve_original)\nendproperty\nassert_p_data_pipeline_anonymization:assert property (p_data_pipeline_anonymization) else $error(\"\");", "task_id": "3_3113", "predict_sva": "@(posedge analytics_clk) disable iff (privacy_mode)         (privacy_mode == 0 && data_pipeline == 1) |->          (anonymization_required == 1 ? mask_identifiers : preserve_original)"}
{"sva": "@(posedge neural_clk) disable iff(!brain_signal_clean) direct_neural_interface |-> (thought_pattern_recognized ? execute_command : ignore_noise)", "sva_description": "### Assertion description:  \n**Property Name**: p_Direct_Neural_Interface  \n**Trigger Condition**: At every rising edge of `neural_clk`  \n**Disable Condition**: `disable iff (!brain_signal_clean)`  \n**Antecedent (LHS of Implication)**: `direct_neural_interface`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(thought_pattern_recognized ? execute_command : ignore_noise)`  \n\n### Explanation:  \n1. The property checks behavior related to a direct neural interface.  \n2. It triggers on every positive edge of `neural_clk` and is disabled if `brain_signal_clean` is low (asynchronous reset condition).  \n3. If `direct_neural_interface` is active (antecedent), the consequent requires:  \n   - If `thought_pattern_recognized` is true, `execute_command` must hold.  \n   - Otherwise (`thought_pattern_recognized` is false), `ignore_noise` must hold.  \n4. The ternary operator (`? :`) encodes a conditional outcome in the consequent.", "sva_signals": ["neural_clk", "brain_signal_clean", "[0:0] direct_neural_interface", "[2:0] thought_pattern_recognized", "[0:0] execute_command", "[0:0] ignore_noise"], "clock": "neural_clk", "attempts_left": 10, "sva_result": "@(posedge neural_clk) disable iff (!brain_signal_clean)    direct_neural_interface |-> (thought_pattern_recognized ? execute_command : ignore_noise)", "sva_name": "p_DNI_Thought_Pattern_Recognition", "id": "0360", "full_property": "property p_Direct_Neural_Interface;\n@(posedge neural_clk) disable iff (!brain_signal_clean)    direct_neural_interface |-> (thought_pattern_recognized ? execute_command : ignore_noise)\nendproperty\nassert_p_Direct_Neural_Interface:assert property (p_Direct_Neural_Interface) else $error(\"\");", "task_id": "3_3223", "predict_sva": "@(posedge neural_clk) disable iff (!brain_signal_clean)    direct_neural_interface |->         if (thought_pattern_recognized)             execute_command        else            ignore_noise"}
{"sva": "@(negedge inspection_clk) disable iff(measurement_system_down) quality_control |-> (dimensional_check_passed ? (surface_defect_absent ? accept_part : rework_required) : reject_part)", "sva_description": "### Assertion description:  \n**Property Name**: p_Quality_Control_Check  \n**Trigger Condition**: At every negedge of the `inspection_clk`  \n**Disable Condition**: disable iff (`measurement_system_down`)  \n**Antecedent (LHS of Implication)**: `quality_control == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(dimensional_check_passed ? (surface_defect_absent ? accept_part : rework_required) : reject_part)`  \n\n### Explanation:  \nThe property evaluates the quality control decision logic when `quality_control` is active (LHS). On the falling edge of `inspection_clk` (unless disabled by `measurement_system_down`), it checks:  \n1. If `dimensional_check_passed` is true:  \n   - Further checks if `surface_defect_absent` is true:  \n     - If true, the part is `accept_part`.  \n     - If false, `rework_required` is triggered.  \n2. If `dimensional_check_passed` is false, the part is `reject_part`.  \n\nThe ternary operator (`?:`) hierarchically encodes the decision tree for part disposition.", "sva_signals": ["inspection_clk", "[0:0] measurement_system_down", "[0:0] quality_control", "[0:0] dimensional_check_passed", "[0:0] surface_defect_absent", "[0:0] accept_part", "[0:0] rework_required", "[0:0] reject_part"], "clock": "inspection_clk", "attempts_left": 10, "sva_result": "@(negedge inspection_clk) disable iff (measurement_system_down)    quality_control == 1'b1 |->     (dimensional_check_passed ? (surface_defect_absent ? accept_part : rework_required) : reject_part)", "sva_name": "p_quality_control_decision", "id": "0520", "full_property": "property p_Quality_Control_Check;\n@(negedge inspection_clk) disable iff (measurement_system_down)    quality_control == 1'b1 |->     (dimensional_check_passed ? (surface_defect_absent ? accept_part : rework_required) : reject_part)\nendproperty\nassert_p_Quality_Control_Check:assert property (p_Quality_Control_Check) else $error(\"\");", "task_id": "3_3380", "predict_sva": "@(negedge inspection_clk) disable iff (measurement_system_down)    quality_control |->         if (dimensional_check_passed)             if (surface_defect_absent)                 accept_part            else                rework_required        else            reject_part"}
{"sva": "@(negedge compliance_clk) disable iff(regulatory_approval_pending) quality_assurance |-> (documentation_complete ? (audit_trail_verified ? release_batch : complete_records) : gather_missing_data)", "sva_description": "### Assertion description:  \n**Property Name**: p_Quality_Assurance_Release  \n**Trigger Condition**: At every falling edge of the `compliance_clk`  \n**Disable Condition**: `disable iff (regulatory_approval_pending)`  \n**Antecedent (LHS of Implication)**: `quality_assurance`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(documentation_complete ? (audit_trail_verified ? release_batch : complete_records) : gather_missing_data)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested ternary conditional expression:  \n1. If `documentation_complete` is true:  \n   - Further checks if `audit_trail_verified` is true:  \n     - If true, the result is `release_batch`.  \n     - If false, the result is `complete_records`.  \n2. If `documentation_complete` is false:  \n   - The result is `gather_missing_data`.  \n\nThis property ensures that when `quality_assurance` is active, the system follows the specified conditional logic for batch release or corrective actions based on documentation and audit status. The check is disabled if `regulatory_approval_pending` is asserted.", "sva_signals": ["compliance_clk", "[0:0] regulatory_approval_pending", "[0:0] quality_assurance", "[0:0] documentation_complete", "[0:0] audit_trail_verified", "[0:0] release_batch", "[0:0] complete_records", "[0:0] gather_missing_data"], "clock": "compliance_clk", "attempts_left": 10, "sva_result": "@(negedge compliance_clk) disable iff (regulatory_approval_pending)    quality_assurance |-> (documentation_complete ? (audit_trail_verified ? release_batch : complete_records) : gather_missing_data)", "sva_name": "p_quality_assurance_release_logic", "id": "0552", "full_property": "property p_Quality_Assurance_Release;\n@(negedge compliance_clk) disable iff (regulatory_approval_pending)    quality_assurance |-> (documentation_complete ? (audit_trail_verified ? release_batch : complete_records) : gather_missing_data)\nendproperty\nassert_p_Quality_Assurance_Release:assert property (p_Quality_Assurance_Release) else $error(\"\");", "task_id": "3_3411", "predict_sva": "@(negedge compliance_clk) disable iff (regulatory_approval_pending)         quality_assurance == 1 |->          if (documentation_complete == 1)              if (audit_trail_verified == 1)                  release_batch == 1              else                  complete_records == 1          else              gather_missing_data == 1"}
{"sva": "@(negedge spintronic_clk) disable iff(magnetic_field_unstable) spin_based_electronics |-> (spin_polarization[11:0] ? (magnetoresistance_high ? spin_valve_operation : magnetic_tunnel_junction) : spin_injection)", "sva_description": "### Assertion description:  \n**Property Name**: p_spin_based_electronics_check  \n**Trigger Condition**: At every negedge of the `spintronic_clk`  \n**Disable Condition**: disable iff (`magnetic_field_unstable`)  \n**Antecedent (LHS of Implication)**: `spin_based_electronics`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(spin_polarization[11:0] ? (magnetoresistance_high ? spin_valve_operation : magnetic_tunnel_junction) : spin_injection)`  \n\n### Explanation of the Consequent:  \nThe consequent is a ternary conditional expression that evaluates as follows:  \n1. If `spin_polarization[11:0]` is non-zero (true), then:  \n   - If `magnetoresistance_high` is true, the result is `spin_valve_operation`.  \n   - Else, the result is `magnetic_tunnel_junction`.  \n2. If `spin_polarization[11:0]` is zero (false), the result is `spin_injection`.  \n\n### Summary:  \nThe property asserts that whenever `spin_based_electronics` is true at the falling edge of `spintronic_clk` (and `magnetic_field_unstable` is not active), the expression involving `spin_polarization`, `magnetoresistance_high`, and the corresponding spin-based operation must hold true.", "sva_signals": ["spintronic_clk", "magnetic_field_unstable", "[0:0] spin_based_electronics", "[11:0] spin_polarization", "[0:0] magnetoresistance_high", "[0:0] spin_valve_operation", "[0:0] magnetic_tunnel_junction", "[0:0] spin_injection"], "clock": "spintronic_clk", "attempts_left": 10, "sva_result": "disable iff (magnetic_field_unstable)    @(negedge spintronic_clk)    spin_based_electronics |->         (spin_polarization[11:0] ?             (magnetoresistance_high ? spin_valve_operation : magnetic_tunnel_junction) :             spin_injection)", "sva_name": "p_spin_based_electronics_operation_selection", "id": "0642", "full_property": "property p_spin_based_electronics_check;\ndisable iff (magnetic_field_unstable)    @(negedge spintronic_clk)    spin_based_electronics |->         (spin_polarization[11:0] ?             (magnetoresistance_high ? spin_valve_operation : magnetic_tunnel_junction) :             spin_injection)\nendproperty\nassert_p_spin_based_electronics_check:assert property (p_spin_based_electronics_check) else $error(\"\");", "task_id": "3_3500", "predict_sva": "@(negedge spintronic_clk) disable iff (magnetic_field_unstable)         (magnetic_field_unstable == 0 && spin_based_electronics == 1) |->          (spin_polarization[11:0] != 0) ?              (magnetoresistance_high == 1 ? spin_valve_operation == 1 :               magnetic_tunnel_junction == 1) :              spin_injection == 1"}
{"sva": "@(negedge intention_clock) disable iff(goal_system_offline) autonomous_agent |-> (goal_hierarchy[7:0] ? (plan_execution_successful ? goal_achievement : (replanning_needed ? strategy_revision : goal_abandonment)) : reactive_behavior)", "sva_description": "### Assertion description:  \n**Property Name**: p_Autonomous_Agent_Goal_Handling  \n**Trigger Condition**: At every negedge of the `intention_clock`  \n**Disable Condition**: disable iff (`goal_system_offline`)  \n**Antecedent (LHS of Implication)**: `autonomous_agent`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(goal_hierarchy[7:0] ? (plan_execution_successful ? goal_achievement : (replanning_needed ? strategy_revision : goal_abandonment)) : reactive_behavior)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested conditional expression that describes the expected behavior based on the following logic:  \n1. If `goal_hierarchy[7:0]` is true (non-zero), then:  \n   - If `plan_execution_successful` is true, the outcome is `goal_achievement`.  \n   - Else, if `replanning_needed` is true, the outcome is `strategy_revision`.  \n   - Else, the outcome is `goal_abandonment`.  \n2. If `goal_hierarchy[7:0]` is false (zero), the outcome is `reactive_behavior`.  \n\nThis property ensures that the autonomous agent follows the specified goal-handling logic when triggered, while being disabled if the system goes offline.", "sva_signals": ["intention_clock", "goal_system_offline", "[0:0] autonomous_agent", "[7:0] goal_hierarchy", "[0:0] plan_execution_successful", "[0:0] goal_achievement", "[0:0] replanning_needed", "[0:0] strategy_revision", "[0:0] goal_abandonment", "[0:0] reactive_behavior"], "clock": "intention_clock", "attempts_left": 10, "sva_result": "@(negedge intention_clock) disable iff (goal_system_offline)    autonomous_agent |->         (goal_hierarchy[7:0] ?             (plan_execution_successful ? goal_achievement :                 (replanning_needed ? strategy_revision : goal_abandonment))             : reactive_behavior)", "sva_name": "p_Autonomous_Agent_Goal_Behavior", "id": "0727", "full_property": "property p_Autonomous_Agent_Goal_Handling;\n@(negedge intention_clock) disable iff (goal_system_offline)    autonomous_agent |->         (goal_hierarchy[7:0] ?             (plan_execution_successful ? goal_achievement :                 (replanning_needed ? strategy_revision : goal_abandonment))             : reactive_behavior)\nendproperty\nassert_p_Autonomous_Agent_Goal_Handling:assert property (p_Autonomous_Agent_Goal_Handling) else $error(\"\");", "task_id": "3_3582", "predict_sva": "@(negedge intention_clock) disable iff (goal_system_offline)    autonomous_agent |->         if (goal_hierarchy[7:0] != 8'b0)             if (plan_execution_successful)                 goal_achievement            else if (replanning_needed)                 strategy_revision            else                goal_abandonment        else            reactive_behavior"}
{"sva": "@(negedge unity_clock) disable iff(separation_illusion_strong) integration_processor |-> (wholeness_recognition[11:0] ? (transcendent_unity ? cosmic_consciousness : (harmonious_integration ? balanced_system : fragmented_existence)) : isolated_components)", "sva_description": "### Assertion description:\n**Property Name**: p_Integration_Processor_Check  \n**Trigger Condition**: At every negedge of the `unity_clock`  \n**Disable Condition**: disable iff (`separation_illusion_strong`)  \n**Antecedent (LHS of Implication)**: `integration_processor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(wholeness_recognition[11:0] ? (transcendent_unity ? cosmic_consciousness : (harmonious_integration ? balanced_system : fragmented_existence)) : isolated_components)`  \n\n**Consequent Explanation**:  \nThe consequent is a nested ternary conditional expression that evaluates as follows:  \n1. If `wholeness_recognition[11:0]` is non-zero (true), then:  \n   - If `transcendent_unity` is true, the result is `cosmic_consciousness`  \n   - Else, if `harmonious_integration` is true, the result is `balanced_system`  \n   - Else, the result is `fragmented_existence`  \n2. If `wholeness_recognition[11:0]` is zero (false), the result is `isolated_components`  \n\n**Behavior**:  \nWhenever `integration_processor` is true at the falling edge of `unity_clock` (and `separation_illusion_strong` is not asserted), the nested condition based on `wholeness_recognition`, `transcendent_unity`, and `harmonious_integration` must evaluate to the expected output signal.", "sva_signals": ["unity_clock", "separation_illusion_strong", "integration_processor", "[11:0] wholeness_recognition", "[0:0] transcendent_unity", "[0:0] cosmic_consciousness", "[0:0] harmonious_integration", "[0:0] balanced_system", "[0:0] fragmented_existence", "[0:0] isolated_components"], "clock": "unity_clock", "attempts_left": 10, "sva_result": "@(negedge unity_clock) disable iff (separation_illusion_strong)    integration_processor |->     (wholeness_recognition[11:0] ?         (transcendent_unity ? cosmic_consciousness :             (harmonious_integration ? balanced_system : fragmented_existence))         : isolated_components)", "sva_name": "p_integration_processor_output_logic", "id": "0751", "full_property": "property p_Integration_Processor_Check;\n@(negedge unity_clock) disable iff (separation_illusion_strong)    integration_processor |->     (wholeness_recognition[11:0] ?         (transcendent_unity ? cosmic_consciousness :             (harmonious_integration ? balanced_system : fragmented_existence))         : isolated_components)\nendproperty\nassert_p_Integration_Processor_Check:assert property (p_Integration_Processor_Check) else $error(\"\");", "task_id": "3_3604", "predict_sva": "@(negedge unity_clock) disable iff (separation_illusion_strong)         (separation_illusion_strong == 0 && integration_processor == 1) |->          (wholeness_recognition[11:0] != 0) ?              (transcendent_unity == 1 ? cosmic_consciousness :               harmonious_integration == 1 ? balanced_system :               fragmented_existence) :              isolated_components"}
{"sva": "@(negedge lfsr_clk) disable iff(!feedback_polynomial) linear_feedback |-> (shift_register[31:0] && tap_configuration ? (maximum_length ? ml_sequence : shorter_period) : all_zeros_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_linear_feedback_check  \n**Trigger Condition**: At every negedge of the `lfsr_clk`  \n**Disable Condition**: disable iff (!feedback_polynomial)  \n**Antecedent (LHS of Implication)**: `linear_feedback`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(shift_register[31:0] && tap_configuration) ? (maximum_length ? ml_sequence : shorter_period) : all_zeros_state`  \n\n### Explanation:  \n1. The property evaluates the linear feedback behavior of an LFSR (Linear Feedback Shift Register) on the falling edge of `lfsr_clk`.  \n2. The check is **disabled** if `feedback_polynomial` is low (`!feedback_polynomial`).  \n3. The **antecedent** (`linear_feedback`) triggers the implication. If true, the **consequent** is evaluated:  \n   - If `shift_register[31:0]` has a nonzero value **and** `tap_configuration` is true, then:  \n     - If `maximum_length` is true, the output must match `ml_sequence` (max-length sequence).  \n     - Else, it must match `shorter_period` (custom shorter sequence).  \n   - If either `shift_register[31:0]` is zero **or** `tap_configuration` is false, the output must be `all_zeros_state`.  \n\nThis assertion ensures correct LFSR operation under specified conditions, including handling of max-length sequences, shorter periods, and reset-like states.", "sva_signals": ["lfsr_clk", "feedback_polynomial", "[31:0] shift_register", "[31:0] tap_configuration", "[0:0] maximum_length", "[31:0] ml_sequence", "[31:0] shorter_period", "[31:0] all_zeros_state", "[0:0] linear_feedback"], "clock": "lfsr_clk", "attempts_left": 10, "sva_result": "@(negedge lfsr_clk) disable iff (!feedback_polynomial)    linear_feedback |->         ((shift_register[31:0] && tap_configuration) ?             (maximum_length ? ml_sequence : shorter_period) :             all_zeros_state)", "sva_name": "p_lfsr_output_behavior", "id": "0959", "full_property": "property p_linear_feedback_check;\n@(negedge lfsr_clk) disable iff (!feedback_polynomial)    linear_feedback |->         ((shift_register[31:0] && tap_configuration) ?             (maximum_length ? ml_sequence : shorter_period) :             all_zeros_state)\nendproperty\nassert_p_linear_feedback_check:assert property (p_linear_feedback_check) else $error(\"\");", "task_id": "3_3791", "predict_sva": "@(negedge lfsr_clk) disable iff (!feedback_polynomial)         linear_feedback == 1 |->          ((shift_register[31:0] != 0) && tap_configuration) ?              (maximum_length ? ml_sequence : shorter_period) :              all_zeros_state"}
{"sva": "@(posedge hope_clock) disable iff(!future_vision_enabled) possibility_engine |-> (optimism_level[11:0] ? (unwavering_hope ? faith_based_confidence : (realistic_optimism ? grounded_hope : cautious_pessimism)) : despair_state)", "sva_description": "### Assertion description:  \n**Property Name**: p_Possibility_Engine_Optimism  \n**Trigger Condition**: At every rising edge of the `hope_clock`  \n**Disable Condition**: `disable iff (!future_vision_enabled)`  \n**Antecedent (LHS of Implication)**: `possibility_engine`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`(optimism_level[11:0] ? (unwavering_hope ? faith_based_confidence : (realistic_optimism ? grounded_hope : cautious_pessimism)) : despair_state)`  \n\n### Explanation of the Consequent:  \nThe consequent is a nested conditional expression:  \n1. If `optimism_level[11:0]` is non-zero:  \n   - If `unwavering_hope` is true, the result is `faith_based_confidence`.  \n   - Else, if `realistic_optimism` is true, the result is `grounded_hope`.  \n   - Otherwise, the result is `cautious_pessimism`.  \n2. If `optimism_level[11:0]` is zero, the result is `despair_state`.  \n\nThis property asserts that when `possibility_engine` is active, the output must follow the above conditional logic based on the values of `optimism_level`, `unwavering_hope`, and `realistic_optimism`. The check is disabled if `future_vision_enabled` is low.", "sva_signals": ["hope_clock", "future_vision_enabled", "[0:0] possibility_engine", "[11:0] optimism_level", "[0:0] unwavering_hope", "[0:0] faith_based_confidence", "[0:0] realistic_optimism", "[0:0] grounded_hope", "[0:0] cautious_pessimism", "[0:0] despair_state"], "clock": "hope_clock", "attempts_left": 10, "sva_result": "@(posedge hope_clock) disable iff (!future_vision_enabled)    possibility_engine |-> (        optimism_level[11:0] ? (            unwavering_hope ? faith_based_confidence :             (realistic_optimism ? grounded_hope : cautious_pessimism)        ) : despair_state    )", "sva_name": "p_optimism_result_conditional_output", "id": "0764", "full_property": "property p_Possibility_Engine_Optimism;\n@(posedge hope_clock) disable iff (!future_vision_enabled)    possibility_engine |-> (        optimism_level[11:0] ? (            unwavering_hope ? faith_based_confidence :             (realistic_optimism ? grounded_hope : cautious_pessimism)        ) : despair_state    )\nendproperty\nassert_p_Possibility_Engine_Optimism:assert property (p_Possibility_Engine_Optimism) else $error(\"\");", "task_id": "3_3616", "predict_sva": "@(posedge hope_clock) disable iff (!future_vision_enabled)         possibility_engine == 1 |->          if (optimism_level[11:0] != 0)              if (unwavering_hope)                  faith_based_confidence == 1             else if (realistic_optimism)                  grounded_hope == 1             else                  cautious_pessimism == 1         else              despair_state == 1"}
{"sva": "@(negedge calibration_clk) disable iff(!reference_stable) offset_calibration |-> ((calibration_sample[11:0] - reference_value[11:0]) > tolerance_band[11:0] ? (auto_calibration ? adjust_offset : (manual_mode ? user_adjustment : calibration_failure)) : calibration_complete)", "sva_description": "### Assertion description:  \n**Property Name**: p_offset_calibration_check  \n**Trigger Condition**: At every negedge of the `calibration_clk`  \n**Disable Condition**: disable iff (!reference_stable)  \n**Antecedent (LHS of Implication)**: `offset_calibration`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`((calibration_sample[11:0] - reference_value[11:0]) > tolerance_band[11:0]) ?`  \n&nbsp;&nbsp;&nbsp;&nbsp;`(auto_calibration ? adjust_offset : (manual_mode ? user_adjustment : calibration_failure))`  \n&nbsp;&nbsp;&nbsp;&nbsp;`: calibration_complete`  \n\n**Explanation of Consequent**:  \nIf the difference between `calibration_sample[11:0]` and `reference_value[11:0]` exceeds `tolerance_band[11:0]`, then:  \n- If `auto_calibration` is true, the result is `adjust_offset`.  \n- Else, if `manual_mode` is true, the result is `user_adjustment`.  \n- Otherwise, the result is `calibration_failure`.  \nIf the difference does not exceed the tolerance band, the result is `calibration_complete`.  \n\n**Note**: The consequent is a conditional (ternary) expression that selects an outcome based on multiple nested conditions.", "sva_signals": ["calibration_clk", "reference_stable", "[0:0] offset_calibration", "[11:0] calibration_sample", "[11:0] reference_value", "[11:0] tolerance_band", "[0:0] auto_calibration", "[0:0] adjust_offset", "[0:0] manual_mode", "[0:0] user_adjustment", "[0:0] calibration_failure", "[0:0] calibration_complete"], "clock": "calibration_clk", "attempts_left": 10, "sva_result": "@(negedge calibration_clk) disable iff (!reference_stable)    offset_calibration |->         ((calibration_sample[11:0] - reference_value[11:0]) > tolerance_band[11:0]) ?            (auto_calibration ? adjust_offset : (manual_mode ? user_adjustment : calibration_failure))            : calibration_complete", "sva_name": "p_calibration_output_correctness", "id": "0994", "full_property": "property p_offset_calibration_check;\n@(negedge calibration_clk) disable iff (!reference_stable)    offset_calibration |->         ((calibration_sample[11:0] - reference_value[11:0]) > tolerance_band[11:0]) ?            (auto_calibration ? adjust_offset : (manual_mode ? user_adjustment : calibration_failure))            : calibration_complete\nendproperty\nassert_p_offset_calibration_check:assert property (p_offset_calibration_check) else $error(\"\");", "task_id": "3_3820", "predict_sva": "@(negedge calibration_clk) disable iff (!reference_stable)         (reference_stable == 1 && offset_calibration == 1) |->          (calibration_sample[11:0] - reference_value[11:0]) > tolerance_band[11:0] ?              (auto_calibration == 1 ? adjust_offset == 1 :               manual_mode == 1 ? user_adjustment == 1 :               calibration_failure == 1) :              calibration_complete == 1"}
{"sva": "@(posedge clk) disable iff(test_mode) uart_transmit |-> $past(tx_buffer_full, 1) |=> !$past(collision_detect)", "sva_description": "### Assertion description:  \n**Property Name**: p_uart_transmit_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (test_mode)`  \n**Antecedent (LHS of Implication)**: `uart_transmit == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tx_buffer_full, 1) |=> !$past(collision_detect)`  ", "sva_signals": ["clk", "[0:0] test_mode", "[0:0] uart_transmit", "[0:0] tx_buffer_full", "[0:0] collision_detect"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (test_mode)     uart_transmit == 1'b1 |-> $past(tx_buffer_full, 1) |=> !$past(collision_detect)", "sva_name": "p_uart_transmit_no_collision_on_buffer_full", "id": "0034", "full_property": "property p_uart_transmit_check;\n@(posedge clk)     disable iff (test_mode)     uart_transmit == 1'b1 |-> $past(tx_buffer_full, 1) |=> !$past(collision_detect)\nendproperty\nassert_p_uart_transmit_check:assert property (p_uart_transmit_check) else $error(\"\");", "task_id": "3_3866", "predict_sva": "@(posedge clk) disable iff (test_mode)         (test_mode == 0 && uart_transmit == 1 && $past(tx_buffer_full) == 1) |-> ##1 $past(collision_detect) == 0"}
{"sva": "@(negedge thermal_clk) disable iff(!temperature_valid) thermal_protection |-> ((junction_temp[11:0] > warning_threshold[11:0]) & (junction_temp[11:0] < shutdown_threshold[11:0]) ? (thermal_throttling ? reduce_performance : (fan_control ? increase_cooling : thermal_warning)) : normal_operation)", "sva_description": "### Assertion description:  \n**Property Name**: p_thermal_protection_check  \n**Trigger Condition**: At every negedge of the `thermal_clk`  \n**Disable Condition**: disable iff (!temperature_valid)  \n**Antecedent (LHS of Implication)**: `thermal_protection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`((junction_temp[11:0] > warning_threshold[11:0]) & (junction_temp[11:0] < shutdown_threshold[11:0])) ?`  \n`(thermal_throttling ? reduce_performance : (fan_control ? increase_cooling : thermal_warning)) : normal_operation)`  \n\n### Explanation of the Consequent:  \nThe consequent is a conditional (ternary) expression that checks:  \n1. If `junction_temp` is between `warning_threshold` and `shutdown_threshold`, then:  \n   - If `thermal_throttling` is active, trigger `reduce_performance`.  \n   - Else, if `fan_control` is active, trigger `increase_cooling`.  \n   - Else, trigger `thermal_warning`.  \n2. If `junction_temp` is outside the specified range, trigger `normal_operation`.  \n\nThis property ensures that the thermal protection logic responds appropriately to temperature conditions when `thermal_protection` is active.", "sva_signals": ["thermal_clk", "temperature_valid", "[11:0] junction_temp", "[11:0] warning_threshold", "[11:0] shutdown_threshold", "[0:0] thermal_protection", "[0:0] thermal_throttling", "[0:0] reduce_performance", "[0:0] fan_control", "[0:0] increase_cooling", "[0:0] thermal_warning", "[0:0] normal_operation"], "clock": "thermal_clk", "attempts_left": 10, "sva_result": "@(negedge thermal_clk) disable iff (!temperature_valid)    thermal_protection |->         ((junction_temp[11:0] > warning_threshold[11:0]) && (junction_temp[11:0] < shutdown_threshold[11:0])) ?             (thermal_throttling ? reduce_performance :                 (fan_control ? increase_cooling : thermal_warning)) :             normal_operation", "sva_name": "p_thermal_protection_output_response", "id": "1000", "full_property": "property p_thermal_protection_check;\n@(negedge thermal_clk) disable iff (!temperature_valid)    thermal_protection |->         ((junction_temp[11:0] > warning_threshold[11:0]) && (junction_temp[11:0] < shutdown_threshold[11:0])) ?             (thermal_throttling ? reduce_performance :                 (fan_control ? increase_cooling : thermal_warning)) :             normal_operation\nendproperty\nassert_p_thermal_protection_check:assert property (p_thermal_protection_check) else $error(\"\");", "task_id": "3_3824", "predict_sva": "@(negedge thermal_clk) disable iff (!temperature_valid)         (temperature_valid == 1 && thermal_protection == 1) |->          (junction_temp[11:0] > warning_threshold[11:0] && junction_temp[11:0] < shutdown_threshold[11:0]) ?              (thermal_throttling == 1 ? reduce_performance == 1 :               fan_control == 1 ? increase_cooling == 1 :               thermal_warning == 1) :              normal_operation == 1"}
{"sva": "@(posedge clk_100m) disable iff(!hard_reset) cache_hit |-> $past(tag_match) && ($past(cache_enable, 1) || $past(bypass_mode))", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_hit_check  \n**Trigger Condition**: At every rising edge of the `clk_100m`  \n**Disable Condition**: `disable iff (!hard_reset)`  \n**Antecedent (LHS of Implication)**: `cache_hit == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(tag_match) && ($past(cache_enable, 1) || $past(bypass_mode))`  ", "sva_signals": ["clk_100m", "hard_reset", "[0:0] cache_hit", "[0:0] tag_match", "[0:0] cache_enable", "[0:0] bypass_mode"], "clock": "clk_100m", "attempts_left": 10, "sva_result": "@(posedge clk_100m) disable iff (!hard_reset)         cache_hit == 1'b1 |-> $past(tag_match) && ($past(cache_enable, 1) || $past(bypass_mode))", "sva_name": "p_cache_hit_requires_prior_tag_and_enable_or_bypass", "id": "0035", "full_property": "property p_cache_hit_check;\n@(posedge clk_100m) disable iff (!hard_reset)         cache_hit == 1'b1 |-> $past(tag_match) && ($past(cache_enable, 1) || $past(bypass_mode))\nendproperty\nassert_p_cache_hit_check:assert property (p_cache_hit_check) else $error(\"\");", "task_id": "3_3867", "predict_sva": "@(posedge clk_100m) disable iff (!hard_reset)         cache_hit == 1'b1 |-> $past(tag_match) == 1'b1 && ($past(cache_enable, 1) == 1'b1 || $past(bypass_mode, 1) == 1'b1)"}
{"sva": "@(negedge clk_i2c) disable iff(bus_error) i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_i2c_start_condition_check  \n**Trigger Condition**: At every falling edge of `clk_i2c`  \n**Disable Condition**: `disable iff (bus_error)`  \n**Antecedent (LHS of Implication)**: `i2c_start_condition`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))`  ", "sva_signals": ["clk_i2c", "[0:0] bus_error", "[0:0] i2c_start_condition", "[0:0] bus_busy", "[0:0] scl_high", "[0:0] sda_high"], "clock": "clk_i2c", "attempts_left": 10, "sva_result": "@(negedge clk_i2c) disable iff (bus_error)     i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))", "sva_name": "p_i2c_start_condition_validity", "id": "0079", "full_property": "property p_i2c_start_condition_check;\n@(negedge clk_i2c) disable iff (bus_error)     i2c_start_condition |-> !$past(bus_busy) && ($past(scl_high, 1) && $past(sda_high, 1))\nendproperty\nassert_p_i2c_start_condition_check:assert property (p_i2c_start_condition_check) else $error(\"\");", "task_id": "3_3908", "predict_sva": "@(negedge clk_i2c) disable iff (bus_error)         (bus_error == 0 && i2c_start_condition == 1) |->          ($past(bus_busy) == 0 && $past(scl_high) == 1 && $past(sda_high) == 1)"}
{"sva": "@(posedge clk_pcie) disable iff(!pcie_reset_n) packet_layer |-> $past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Layer_Flow_Control  \n**Trigger Condition**: At every rising edge of `clk_pcie`  \n**Disable Condition**: `disable iff (!pcie_reset_n)`  \n**Antecedent (LHS of Implication)**: `packet_layer`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2))`  ", "sva_signals": ["clk_pcie", "pcie_reset_n", "[0:0] packet_layer", "[0:0] flow_control", "[0:0] link_layer_ready", "[0:0] credits_available"], "clock": "clk_pcie", "attempts_left": 10, "sva_result": "@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2)))", "sva_name": "p_packet_layer_flow_control_link_credit_check", "id": "0242", "full_property": "property p_Packet_Layer_Flow_Control;\n@(posedge clk_pcie) disable iff (!pcie_reset_n)     packet_layer |-> ($past(flow_control, 1) && ($past(link_layer_ready) && $past(credits_available, 2)))\nendproperty\nassert_p_Packet_Layer_Flow_Control:assert property (p_Packet_Layer_Flow_Control) else $error(\"\");", "task_id": "3_4061", "predict_sva": "@(posedge clk_pcie) disable iff (!pcie_reset_n)         (pcie_reset_n == 1 && packet_layer == 1) |->          ($past(flow_control, 1) == 1) &&          ($past(link_layer_ready, 2) == 1 && $past(credits_available, 2) == 1)"}
{"sva": "@(posedge clk) disable iff(recovery_mode) fault_detector |-> $past(health_monitor, 2) |=> ($past(diagnostic_complete) && ($past(system_recovery) || $past(safe_shutdown)))", "sva_description": "### Assertion description:  \n**Property Name**: p_Fault_Detector_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`recovery_mode`)  \n**Antecedent (LHS of Implication)**: `fault_detector == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(health_monitor, 2) |=> ($past(diagnostic_complete) && ($past(system_recovery) || $past(safe_shutdown)))`  \n\n**Detailed Explanation of Consequent**:  \n- The consequent checks that **two clock cycles after** `health_monitor` was active (sampled 2 cycles ago), the following must hold:  \n  1. `diagnostic_complete` was active in the **previous cycle**, **and**  \n  2. Either `system_recovery` **or** `safe_shutdown` was active in the **previous cycle**.  \n- The `|=>` operator ensures the check occurs **one cycle after** the evaluation of `$past(health_monitor, 2)`.  \n\n**Key Temporal Relationships**:  \n- `$past(health_monitor, 2)`: Samples `health_monitor` from **2 cycles before** the current cycle.  \n- `$past(diagnostic_complete)`, `$past(system_recovery)`, `$past(safe_shutdown)`: Sample signals from **1 cycle before** the current cycle.  \n- The assertion enforces that a fault detection (`fault_detector`) implies prior health monitoring and subsequent diagnostic/recovery actions.  \n\n**Note**: If `recovery_mode` is active, the assertion is disabled entirely.", "sva_signals": ["clk", "recovery_mode", "[0:0] fault_detector", "[0:0] health_monitor", "[0:0] diagnostic_complete", "[0:0] system_recovery", "[0:0] safe_shutdown"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (recovery_mode)     fault_detector == 1'b1 |->      $past(health_monitor, 2) |=> ($past(diagnostic_complete) && ($past(system_recovery) || $past(safe_shutdown)))", "sva_name": "p_fault_detector_check", "id": "0326", "full_property": "property p_Fault_Detector_Check;\n@(posedge clk) disable iff (recovery_mode)     fault_detector == 1'b1 |->      $past(health_monitor, 2) |=> ($past(diagnostic_complete) && ($past(system_recovery) || $past(safe_shutdown)))\nendproperty\nassert_p_Fault_Detector_Check:assert property (p_Fault_Detector_Check) else $error(\"\");", "task_id": "3_4140", "predict_sva": "@(posedge clk) disable iff (recovery_mode)     fault_detector == 1'b1 |->      $past(health_monitor, 2) |=> ($past(diagnostic_complete) && ($past(system_recovery) || $past(safe_shutdown)))"}
{"sva": "@(posedge clk) disable iff(debug_exception) instruction_complete |-> $past(execution_unit, 1) |=> (!$past(privilege_violation, 2) && $past(result_writeback))", "sva_description": "### Assertion description:  \n**Property Name**: p_Instruction_Complete_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (debug_exception)`  \n**Antecedent (LHS of Implication)**: `instruction_complete == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(execution_unit, 1) |=> (!$past(privilege_violation, 2) && $past(result_writeback))`  \n\n**Explanation of Consequent**:  \n1. The `$past(execution_unit, 1)` checks the value of `execution_unit` at the previous clock cycle.  \n2. The `|=>` operator ensures that in the **next clock cycle** after `execution_unit` was valid, the following must hold:  \n   - `!$past(privilege_violation, 2)`: The `privilege_violation` signal must have been **low** two cycles before the current clock edge.  \n   - `$past(result_writeback)`: The `result_writeback` signal must have been **high** one cycle before the current clock edge.  \n\n**Summary**:  \nWhen `instruction_complete` is high, the assertion checks that:  \n- One cycle earlier, `execution_unit` was active, and  \n- In the following cycle, there was no privilege violation two cycles prior **and** a writeback occurred one cycle prior.", "sva_signals": ["clk", "rst_n", "[0:0] debug_exception", "[0:0] instruction_complete", "[0:0] execution_unit", "[0:0] privilege_violation", "[0:0] result_writeback"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (debug_exception)     instruction_complete == 1'b1 |->      $past(execution_unit, 1) |=>      (!$past(privilege_violation, 2) && $past(result_writeback))", "sva_name": "p_instruction_complete_sequence_check", "id": "0300", "full_property": "property p_Instruction_Complete_Check;\n@(posedge clk) disable iff (debug_exception)     instruction_complete == 1'b1 |->      $past(execution_unit, 1) |=>      (!$past(privilege_violation, 2) && $past(result_writeback))\nendproperty\nassert_p_Instruction_Complete_Check:assert property (p_Instruction_Complete_Check) else $error(\"\");", "task_id": "3_4116", "predict_sva": "@(posedge clk) disable iff (debug_exception)         (debug_exception == 0 && instruction_complete == 1) |->          ($past(execution_unit) == 1) ##1          ($past(privilege_violation, 2) == 0) ##1          ($past(result_writeback, 1) == 1)"}
{"sva": "@(negedge clk_carriers) disable iff(!multicarrier_on) subband_processing |-> $past(carrier_allocation, 2) |=> ($past(power_distribution) && $past(spectral_efficiency))", "sva_description": "### Assertion description:  \n**Property Name**: p_Subband_Processing_Check  \n**Trigger Condition**: At every falling edge of `clk_carriers`  \n**Disable Condition**: `disable iff (!multicarrier_on)`  \n**Antecedent (LHS of Implication)**: `subband_processing == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(carrier_allocation, 2) |=> ($past(power_distribution) && $past(spectral_efficiency))`  ", "sva_signals": ["clk_carriers", "multicarrier_on", "[0:0] subband_processing", "carrier_allocation", "power_distribution", "spectral_efficiency"], "clock": "clk_carriers", "attempts_left": 10, "sva_result": "@(negedge clk_carriers) disable iff (!multicarrier_on)     subband_processing == 1'b1 |->      $past(carrier_allocation, 2) |=> ($past(power_distribution) && $past(spectral_efficiency))", "sva_name": "p_subband_processing_check", "id": "0403", "full_property": "property p_Subband_Processing_Check;\n@(negedge clk_carriers) disable iff (!multicarrier_on)     subband_processing == 1'b1 |->      $past(carrier_allocation, 2) |=> ($past(power_distribution) && $past(spectral_efficiency))\nendproperty\nassert_p_Subband_Processing_Check:assert property (p_Subband_Processing_Check) else $error(\"\");", "task_id": "3_4215", "predict_sva": "@(negedge clk_carriers) disable iff (!multicarrier_on)     subband_processing == 1'b1 |->      $past(carrier_allocation, 2) |=> ($past(power_distribution) && $past(spectral_efficiency))"}
{"sva": "@(posedge clk) disable iff(saturation_flag) digital_predistortion |-> $past(nonlinearity_model, 1) && ($past(adaptation_coefficient, 3) && $past(convergence_monitor))", "sva_description": "### Assertion description:  \n**Property Name**: p_Digital_Predistortion_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`saturation_flag`)  \n**Antecedent (LHS of Implication)**: `digital_predistortion == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(nonlinearity_model, 1) && ($past(adaptation_coefficient, 3) && $past(convergence_monitor))`  ", "sva_signals": ["clk", "[0:0] saturation_flag", "[0:0] digital_predistortion", "[0:0] nonlinearity_model", "[0:0] adaptation_coefficient", "[0:0] convergence_monitor"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (saturation_flag)     digital_predistortion == 1'b1 |->          $past(nonlinearity_model, 1) &&          ($past(adaptation_coefficient, 3) && $past(convergence_monitor, 1))", "sva_name": "p_digital_predistortion_past_conditions", "id": "0369", "full_property": "property p_Digital_Predistortion_Check;\n@(posedge clk) disable iff (saturation_flag)     digital_predistortion == 1'b1 |->          $past(nonlinearity_model, 1) &&          ($past(adaptation_coefficient, 3) && $past(convergence_monitor, 1))\nendproperty\nassert_p_Digital_Predistortion_Check:assert property (p_Digital_Predistortion_Check) else $error(\"\");", "task_id": "3_4182", "predict_sva": "@(posedge clk) disable iff (saturation_flag)         (saturation_flag == 0 && digital_predistortion == 1'b1) |->          ($past(nonlinearity_model, 1) == 1'b1) &&          ($past(adaptation_coefficient, 3) == 1'b1) &&          ($past(convergence_monitor, 3) == 1'b1)"}
{"sva": "@(posedge clk) disable iff(!optical_tweezers_on) particle_manipulation |-> $past(laser_trapping, 1) |=> ($past(force_measurement, 2) && $past(position_control))", "sva_description": "### Assertion description:  \n**Property Name**: p_Particle_Manipulation_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`!optical_tweezers_on`)  \n**Antecedent (LHS of Implication)**: `particle_manipulation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(laser_trapping, 1) |=> ($past(force_measurement, 2) && $past(position_control))`  \n\n", "sva_signals": ["clk", "optical_tweezers_on", "[0:0] particle_manipulation", "[0:0] laser_trapping", "[0:0] force_measurement", "[0:0] position_control"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!optical_tweezers_on)     particle_manipulation == 1'b1 |->      $past(laser_trapping, 1) |=> ($past(force_measurement, 2) && $past(position_control))", "sva_name": "p_particle_manipulation_sequence_check", "id": "0414", "full_property": "property p_Particle_Manipulation_Check;\n@(posedge clk) disable iff (!optical_tweezers_on)     particle_manipulation == 1'b1 |->      $past(laser_trapping, 1) |=> ($past(force_measurement, 2) && $past(position_control))\nendproperty\nassert_p_Particle_Manipulation_Check:assert property (p_Particle_Manipulation_Check) else $error(\"\");", "task_id": "3_4226", "predict_sva": "@(posedge clk) disable iff (!optical_tweezers_on)         (optical_tweezers_on == 1 && particle_manipulation == 1) |->          ($past(laser_trapping) == 1) |-> ##1 ($past(force_measurement, 2) == 1 && $past(position_control, 1) == 1)"}
{"sva": "@(posedge clk) disable iff(homomorphic_computation_error) privacy_preserving_analytics |-> $past(encrypted_data_processing, 1) |=> ($past(computation_verification, 2) && !$past(plaintext_leakage))", "sva_description": "### Assertion description:  \n**Property Name**: p_privacy_preserving_analytics  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (homomorphic_computation_error)`  \n**Antecedent (LHS of Implication)**: `privacy_preserving_analytics`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(encrypted_data_processing, 1) |=> ($past(computation_verification, 2) && !$past(plaintext_leakage))`  ", "sva_signals": ["clk", "homomorphic_computation_error", "privacy_preserving_analytics", "encrypted_data_processing", "computation_verification", "plaintext_leakage"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (homomorphic_computation_error)     privacy_preserving_analytics |->      $past(encrypted_data_processing, 1) |=>      ($past(computation_verification, 2) && !$past(plaintext_leakage))", "sva_name": "p_privacy_preserving_analytics_check", "id": "0546", "full_property": "property p_privacy_preserving_analytics;\n@(posedge clk) disable iff (homomorphic_computation_error)     privacy_preserving_analytics |->      $past(encrypted_data_processing, 1) |=>      ($past(computation_verification, 2) && !$past(plaintext_leakage))\nendproperty\nassert_p_privacy_preserving_analytics:assert property (p_privacy_preserving_analytics) else $error(\"\");", "task_id": "3_4350", "predict_sva": "@(posedge clk) disable iff (homomorphic_computation_error)     privacy_preserving_analytics |->          $past(encrypted_data_processing, 1) |=>          ($past(computation_verification, 2) && !$past(plaintext_leakage))"}
{"sva": "@(posedge clk_machine_listening) disable iff(environmental_noise_interference) computational_auditory_scene_analysis |-> ($past(source_separation_algorithm, 2) && $past(auditory_object_formation)) |=> !$past(cocktail_party_problem)", "sva_description": "### Assertion description:  \n**Property Name**: p_Computational_Auditory_Scene_Analysis  \n**Trigger Condition**: At every rising edge of the `clk_machine_listening`  \n**Disable Condition**: `disable iff (environmental_noise_interference)`  \n**Antecedent (LHS of Implication)**: `computational_auditory_scene_analysis`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(source_separation_algorithm, 2) && $past(auditory_object_formation)) |=> !$past(cocktail_party_problem)`  ", "sva_signals": ["clk_machine_listening", "environmental_noise_interference", "computational_auditory_scene_analysis", "[0:0] source_separation_algorithm", "[0:0] auditory_object_formation", "[0:0] cocktail_party_problem"], "clock": "clk_machine_listening", "attempts_left": 10, "sva_result": "@(posedge clk_machine_listening) disable iff (environmental_noise_interference)     computational_auditory_scene_analysis |->      ($past(source_separation_algorithm, 2) && $past(auditory_object_formation)) |=> !$past(cocktail_party_problem)", "sva_name": "p_computational_auditory_scene_analysis", "id": "0845", "full_property": "property p_Computational_Auditory_Scene_Analysis;\n@(posedge clk_machine_listening) disable iff (environmental_noise_interference)     computational_auditory_scene_analysis |->      ($past(source_separation_algorithm, 2) && $past(auditory_object_formation)) |=> !$past(cocktail_party_problem)\nendproperty\nassert_p_Computational_Auditory_Scene_Analysis:assert property (p_Computational_Auditory_Scene_Analysis) else $error(\"\");", "task_id": "3_4631", "predict_sva": "@(posedge clk_machine_listening) disable iff (environmental_noise_interference)     computational_auditory_scene_analysis |->          ($past(source_separation_algorithm, 2) && $past(auditory_object_formation)) |=>          !$past(cocktail_party_problem)"}
{"sva": "@(posedge clk_technical_embroidery) disable iff(thread_tension_instability) decorative_stitching |-> ($past(stitch_density_optimization, 1) && $past(design_registration_accuracy, 2)) && $past(thread_break_minimization, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_Decorative_Stitching_Check  \n**Trigger Condition**: At every rising edge of the `clk_technical_embroidery`  \n**Disable Condition**: `disable iff (thread_tension_instability)`  \n**Antecedent (LHS of Implication)**: `decorative_stitching`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(stitch_density_optimization, 1) && $past(design_registration_accuracy, 2)) && $past(thread_break_minimization, 3)`  ", "sva_signals": ["clk_technical_embroidery", "thread_tension_instability", "[0:0] decorative_stitching", "[0:0] stitch_density_optimization", "[0:0] design_registration_accuracy", "[0:0] thread_break_minimization"], "clock": "clk_technical_embroidery", "attempts_left": 10, "sva_result": "@(posedge clk_technical_embroidery) disable iff (thread_tension_instability)     decorative_stitching |-> ($past(stitch_density_optimization, 1) && $past(design_registration_accuracy, 2)) && $past(thread_break_minimization, 3)", "sva_name": "p_Decorative_Stitching_Check", "id": "0933", "full_property": "property p_Decorative_Stitching_Check;\n@(posedge clk_technical_embroidery) disable iff (thread_tension_instability)     decorative_stitching |-> ($past(stitch_density_optimization, 1) && $past(design_registration_accuracy, 2)) && $past(thread_break_minimization, 3)\nendproperty\nassert_p_Decorative_Stitching_Check:assert property (p_Decorative_Stitching_Check) else $error(\"\");", "task_id": "3_4711", "predict_sva": "@(posedge clk_technical_embroidery) disable iff (thread_tension_instability)     decorative_stitching |->          ($past(stitch_density_optimization, 1) &&           $past(design_registration_accuracy, 2) &&           $past(thread_break_minimization, 3))"}
{"sva": "@(negedge clk) fifo_read && $past(fifo_not_empty, 1) |-> read_data_valid ##1 read_ack", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Read_Valid_Ack  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_read && $past(fifo_not_empty, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `read_data_valid ##1 read_ack`  ", "sva_signals": ["clk", "rst_n", "[0:0] fifo_read", "[0:0] fifo_not_empty", "[0:0] read_data_valid", "[0:0] read_ack"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     (fifo_read && $past(fifo_not_empty, 1)) |-> (read_data_valid ##1 read_ack)", "sva_name": "p_fifo_read_data_valid_ack", "id": "1000", "full_property": "property p_Fifo_Read_Valid_Ack;\n@(negedge clk)     (fifo_read && $past(fifo_not_empty, 1)) |-> (read_data_valid ##1 read_ack)\nendproperty\nassert_p_Fifo_Read_Valid_Ack:assert property (p_Fifo_Read_Valid_Ack) else $error(\"\");", "task_id": "3_4771", "predict_sva": "@(negedge clk)         (fifo_read == 1 && $past(fifo_not_empty) == 1) |-> (read_data_valid == 1) ##1 (read_ack == 1)"}
{"sva": "@(posedge clk) instruction_fetch && $past(pc_valid) |-> $past(instruction_cache_hit) || memory_access", "sva_description": "### Assertion description:  \n**Property Name**: p_Instruction_Fetch_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `instruction_fetch && $past(pc_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(instruction_cache_hit) || memory_access`  ", "sva_signals": ["clk", "rst_n", "[0:0] instruction_fetch", "[0:0] pc_valid", "[0:0] instruction_cache_hit", "[0:0] memory_access"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (instruction_fetch && $past(pc_valid)) |-> ($past(instruction_cache_hit) || memory_access)", "sva_name": "p_instruction_fetch_pc_valid_cache_hit_or_memory_access", "id": "1051", "full_property": "property p_Instruction_Fetch_Check;\n@(posedge clk)     (instruction_fetch && $past(pc_valid)) |-> ($past(instruction_cache_hit) || memory_access)\nendproperty\nassert_p_Instruction_Fetch_Check:assert property (p_Instruction_Fetch_Check) else $error(\"\");", "task_id": "3_4818", "predict_sva": "@(posedge clk)         (instruction_fetch == 1 && $past(pc_valid) == 1) |-> ($past(instruction_cache_hit) == 1 || memory_access == 1)"}
{"sva": "@(posedge clk_industrial_archaeology) disable iff(technological_context_overlooked) industrial_heritage_study |-> ($past(machinery_operation_reconstruction, 1) && $past(production_process_documentation, 2)) && $past(social_impact_assessment, 3)", "sva_description": "### Assertion description:  \n**Property Name**: p_industrial_heritage_study  \n**Trigger Condition**: At every rising edge of the `clk_industrial_archaeology`  \n**Disable Condition**: disable iff (`technological_context_overlooked`)  \n**Antecedent (LHS of Implication)**: `industrial_heritage_study == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- `$past(machinery_operation_reconstruction, 1)` must be true (1 clock cycle ago),  \n- `$past(production_process_documentation, 2)` must be true (2 clock cycles ago),  \n- `$past(social_impact_assessment, 3)` must be true (3 clock cycles ago).  \nAll three past conditions must hold simultaneously for the assertion to pass.", "sva_signals": ["clk_industrial_archaeology", "technological_context_overlooked", "[0:0] industrial_heritage_study", "[0:0] machinery_operation_reconstruction", "[0:0] production_process_documentation", "[0:0] social_impact_assessment"], "clock": "clk_industrial_archaeology", "attempts_left": 10, "sva_result": "@(posedge clk_industrial_archaeology) disable iff (technological_context_overlooked)     industrial_heritage_study == 1'b1 |->     $past(machinery_operation_reconstruction, 1) &&     $past(production_process_documentation, 2) &&     $past(social_impact_assessment, 3)", "sva_name": "p_industrial_heritage_study_past_dependencies", "id": "1014", "full_property": "property p_industrial_heritage_study;\n@(posedge clk_industrial_archaeology) disable iff (technological_context_overlooked)     industrial_heritage_study == 1'b1 |->     $past(machinery_operation_reconstruction, 1) &&     $past(production_process_documentation, 2) &&     $past(social_impact_assessment, 3)\nendproperty\nassert_p_industrial_heritage_study:assert property (p_industrial_heritage_study) else $error(\"\");", "task_id": "3_4783", "predict_sva": "@(posedge clk_industrial_archaeology) disable iff (technological_context_overlooked)         (technological_context_overlooked == 0 && industrial_heritage_study == 1) |->          ($past(machinery_operation_reconstruction, 1) == 1) &&          ($past(production_process_documentation, 2) == 1) &&          ($past(social_impact_assessment, 3) == 1)"}
{"sva": "@(negedge clk_bluetooth) disable iff(rst_radio) frequency_hopping_sequence && $past(master_clock_synchronization) |-> channel_selection_update", "sva_description": "### Assertion description:  \n**Property Name**: p_channel_selection_update  \n**Trigger Condition**: At every falling edge of the `clk_bluetooth`  \n**Disable Condition**: disable iff (rst_radio)  \n**Antecedent (LHS of Implication)**: `frequency_hopping_sequence && $past(master_clock_synchronization)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `channel_selection_update`", "sva_signals": ["clk_bluetooth", "rst_radio", "[0:0] frequency_hopping_sequence", "[0:0] master_clock_synchronization", "[0:0] channel_selection_update"], "clock": "clk_bluetooth", "attempts_left": 10, "sva_result": "@(negedge clk_bluetooth) disable iff (rst_radio)         frequency_hopping_sequence && $past(master_clock_synchronization) |-> channel_selection_update", "sva_name": "p_channel_selection_update_on_freq_hop_and_prev_sync", "id": "1207", "full_property": "property p_channel_selection_update;\n@(negedge clk_bluetooth) disable iff (rst_radio)         frequency_hopping_sequence && $past(master_clock_synchronization) |-> channel_selection_update\nendproperty\nassert_p_channel_selection_update:assert property (p_channel_selection_update) else $error(\"\");", "task_id": "3_4969", "predict_sva": "@(negedge clk_bluetooth) disable iff (rst_radio)         (rst_radio == 0 && frequency_hopping_sequence == 1 && $past(master_clock_synchronization) == 1) |-> channel_selection_update == 1"}
{"sva": "@(posedge clk_satellite_navigation) disable iff(!gnss_reset_n) carrier_phase_ambiguity_resolution |-> $past(integer_least_squares_solution, 17) && precise_positioning_output", "sva_description": "### Assertion description:  \n**Property Name**: p_carrier_phase_ambiguity_resolution  \n**Trigger Condition**: At every rising edge of `clk_satellite_navigation`  \n**Disable Condition**: `disable iff (!gnss_reset_n)`  \n**Antecedent (LHS of Implication)**: `carrier_phase_ambiguity_resolution == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(integer_least_squares_solution, 17) && precise_positioning_output`  ", "sva_signals": ["clk_satellite_navigation", "gnss_reset_n", "[0:0] carrier_phase_ambiguity_resolution", "[0:0] integer_least_squares_solution", "[0:0] precise_positioning_output"], "clock": "clk_satellite_navigation", "attempts_left": 10, "sva_result": "@(posedge clk_satellite_navigation) disable iff (!gnss_reset_n)     carrier_phase_ambiguity_resolution == 1'b1 |->      $past(integer_least_squares_solution, 17) && precise_positioning_output", "sva_name": "p_carrier_phase_ambiguity_resolution", "id": "1286", "full_property": "property p_carrier_phase_ambiguity_resolution;\n@(posedge clk_satellite_navigation) disable iff (!gnss_reset_n)     carrier_phase_ambiguity_resolution == 1'b1 |->      $past(integer_least_squares_solution, 17) && precise_positioning_output\nendproperty\nassert_p_carrier_phase_ambiguity_resolution:assert property (p_carrier_phase_ambiguity_resolution) else $error(\"\");", "task_id": "3_5046", "predict_sva": "@(posedge clk_satellite_navigation) disable iff (!gnss_reset_n)     carrier_phase_ambiguity_resolution == 1'b1 |->      $past(integer_least_squares_solution, 17) && precise_positioning_output"}
{"sva": "@(posedge clk_exception_handling) disable iff(rst_trap_handler == 1'b1) precise_interrupt_delivery |-> $past(instruction_completion_checkpoint, 6) && architectural_state_preservation", "sva_description": "### Assertion description:  \n**Property Name**: p_precise_interrupt_delivery  \n**Trigger Condition**: At every rising edge of `clk_exception_handling`  \n**Disable Condition**: `disable iff (rst_trap_handler == 1'b1)`  \n**Antecedent (LHS of Implication)**: `precise_interrupt_delivery`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(instruction_completion_checkpoint, 6) && architectural_state_preservation`  ", "sva_signals": ["clk_exception_handling", "rst_trap_handler", "[0:0] precise_interrupt_delivery", "[0:0] instruction_completion_checkpoint", "[0:0] architectural_state_preservation"], "clock": "clk_exception_handling", "attempts_left": 10, "sva_result": "@(posedge clk_exception_handling) disable iff (rst_trap_handler == 1'b1)     precise_interrupt_delivery |-> $past(instruction_completion_checkpoint, 6) && architectural_state_preservation", "sva_name": "p_precise_interrupt_delivery", "id": "1310", "full_property": "property p_precise_interrupt_delivery;\n@(posedge clk_exception_handling) disable iff (rst_trap_handler == 1'b1)     precise_interrupt_delivery |-> $past(instruction_completion_checkpoint, 6) && architectural_state_preservation\nendproperty\nassert_p_precise_interrupt_delivery:assert property (p_precise_interrupt_delivery) else $error(\"\");", "task_id": "3_5070", "predict_sva": "@(posedge clk_exception_handling) disable iff (rst_trap_handler == 1'b1)     precise_interrupt_delivery |->          ($past(instruction_completion_checkpoint, 6) && architectural_state_preservation)"}
{"sva": "@(negedge clk_voltage_control) disable iff(rst_automatic_voltage_regulator == 1'b1) excitation_system_control |-> $past(field_current_adjustment, 8) && terminal_voltage_regulation", "sva_description": "### Assertion description:  \n**Property Name**: p_excitation_system_control  \n**Trigger Condition**: At every falling edge of `clk_voltage_control`  \n**Disable Condition**: `disable iff (rst_automatic_voltage_regulator == 1'b1)`  \n**Antecedent (LHS of Implication)**: `excitation_system_control`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(field_current_adjustment, 8) && terminal_voltage_regulation`", "sva_signals": ["clk_voltage_control", "rst_automatic_voltage_regulator", "[0:0] excitation_system_control", "[0:0] field_current_adjustment", "[0:0] terminal_voltage_regulation"], "clock": "clk_voltage_control", "attempts_left": 10, "sva_result": "@(negedge clk_voltage_control) disable iff (rst_automatic_voltage_regulator == 1'b1)     excitation_system_control |-> $past(field_current_adjustment, 8) && terminal_voltage_regulation", "sva_name": "p_excitation_system_control", "id": "1446", "full_property": "property p_excitation_system_control;\n@(negedge clk_voltage_control) disable iff (rst_automatic_voltage_regulator == 1'b1)     excitation_system_control |-> $past(field_current_adjustment, 8) && terminal_voltage_regulation\nendproperty\nassert_p_excitation_system_control:assert property (p_excitation_system_control) else $error(\"\");", "task_id": "3_5204", "predict_sva": "@(negedge clk_voltage_control) disable iff (rst_automatic_voltage_regulator == 1'b1)     excitation_system_control |->          ($past(field_current_adjustment, 8) && terminal_voltage_regulation)"}
{"sva": "@(negedge clk_weather_station) disable iff(rst_meteorological == 1'b1) barometric_pressure_trend |-> $past(temperature_humidity_correlation, 7) && storm_prediction_algorithm", "sva_description": "### Assertion description:  \n**Property Name**: p_barometric_pressure_trend  \n**Trigger Condition**: At every falling edge of the `clk_weather_station`  \n**Disable Condition**: `disable iff (rst_meteorological == 1'b1)`  \n**Antecedent (LHS of Implication)**: `barometric_pressure_trend`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(temperature_humidity_correlation, 7) && storm_prediction_algorithm`", "sva_signals": ["clk_weather_station", "rst_meteorological", "[0:0] barometric_pressure_trend", "[0:0] temperature_humidity_correlation", "[0:0] storm_prediction_algorithm"], "clock": "clk_weather_station", "attempts_left": 10, "sva_result": "@(negedge clk_weather_station) disable iff (rst_meteorological == 1'b1)     barometric_pressure_trend |-> $past(temperature_humidity_correlation, 7) && storm_prediction_algorithm", "sva_name": "p_barometric_pressure_trend_dependency", "id": "1467", "full_property": "property p_barometric_pressure_trend;\n@(negedge clk_weather_station) disable iff (rst_meteorological == 1'b1)     barometric_pressure_trend |-> $past(temperature_humidity_correlation, 7) && storm_prediction_algorithm\nendproperty\nassert_p_barometric_pressure_trend:assert property (p_barometric_pressure_trend) else $error(\"\");", "task_id": "3_5225", "predict_sva": "@(negedge clk_weather_station) disable iff (rst_meteorological)         (rst_meteorological == 0 && barometric_pressure_trend == 1) |->          (storm_prediction_algorithm == 1 && $past(temperature_humidity_correlation, 7) == 1)"}
{"sva": "@(posedge clk_islamic_finance) disable iff(rst_sharia_compliance == 1'b1) profit_sharing_mechanism |-> $past(asset_backing_verification, 8) && ethical_investment_screening", "sva_description": "### Assertion description:  \n**Property Name**: p_Profit_Sharing_Mechanism  \n**Trigger Condition**: At every rising edge of the `clk_islamic_finance`  \n**Disable Condition**: `disable iff (rst_sharia_compliance == 1'b1)`  \n**Antecedent (LHS of Implication)**: `profit_sharing_mechanism`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(asset_backing_verification, 8) && ethical_investment_screening`  ", "sva_signals": ["clk_islamic_finance", "rst_sharia_compliance", "[0:0] profit_sharing_mechanism", "[7:0] asset_backing_verification", "[0:0] ethical_investment_screening"], "clock": "clk_islamic_finance", "attempts_left": 10, "sva_result": "@(posedge clk_islamic_finance) disable iff (rst_sharia_compliance == 1'b1)     profit_sharing_mechanism |-> ($past(asset_backing_verification, 8) && ethical_investment_screening)", "sva_name": "p_profit_sharing_mechanism", "id": "1734", "full_property": "property p_Profit_Sharing_Mechanism;\n@(posedge clk_islamic_finance) disable iff (rst_sharia_compliance == 1'b1)     profit_sharing_mechanism |-> ($past(asset_backing_verification, 8) && ethical_investment_screening)\nendproperty\nassert_p_Profit_Sharing_Mechanism:assert property (p_Profit_Sharing_Mechanism) else $error(\"\");", "task_id": "3_5487", "predict_sva": "@(posedge clk_islamic_finance) disable iff (rst_sharia_compliance == 1'b1)     profit_sharing_mechanism |-> $past(asset_backing_verification, 8) && ethical_investment_screening"}
{"sva": "@(negedge clk_dna_computing) disable iff(rst_biocomputation == 1'b1) nucleotide_sequence_processing |-> $past(hybridization_thermodynamics, 12) && biological_information_processing", "sva_description": "### Assertion description:  \n**Property Name**: p_nucleotide_sequence_processing  \n**Trigger Condition**: At every falling edge of the `clk_dna_computing`  \n**Disable Condition**: `disable iff (rst_biocomputation == 1'b1)`  \n**Antecedent (LHS of Implication)**: `nucleotide_sequence_processing`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(hybridization_thermodynamics, 12) && biological_information_processing`", "sva_signals": ["clk_dna_computing", "rst_biocomputation", "[0:0] nucleotide_sequence_processing", "[0:0] hybridization_thermodynamics", "[0:0] biological_information_processing"], "clock": "clk_dna_computing", "attempts_left": 10, "sva_result": "disable iff (rst_biocomputation == 1'b1)     @(negedge clk_dna_computing)         nucleotide_sequence_processing |-> $past(hybridization_thermodynamics, 12) && biological_information_processing", "sva_name": "p_nucleotide_sequence_processing", "id": "1954", "full_property": "property p_nucleotide_sequence_processing;\ndisable iff (rst_biocomputation == 1'b1)     @(negedge clk_dna_computing)         nucleotide_sequence_processing |-> $past(hybridization_thermodynamics, 12) && biological_information_processing\nendproperty\nassert_p_nucleotide_sequence_processing:assert property (p_nucleotide_sequence_processing) else $error(\"\");", "task_id": "3_5704", "predict_sva": "@(negedge clk_dna_computing) disable iff (rst_biocomputation == 1'b1)     nucleotide_sequence_processing |->          $past(hybridization_thermodynamics, 12) && biological_information_processing"}
{"sva": "@(negedge rst_clk) disable iff(soft_reset) bus_grant |-> ($past(bus_request, 1) && $past(priority_high, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_grant_after_request  \n**Trigger Condition**: At every negedge of the `rst_clk`  \n**Disable Condition**: disable iff (`soft_reset`)  \n**Antecedent (LHS of Implication)**: `bus_grant == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(bus_request, 1) && $past(priority_high, 1)`  \n\n(Note: The property checks that whenever `bus_grant` is asserted, the bus request (`bus_request`) and high priority signal (`priority_high`) were both active in the previous cycle of `rst_clk`. The assertion is disabled if `soft_reset` is active.)", "sva_signals": ["rst_clk", "[0:0] soft_reset", "[0:0] bus_grant", "[0:0] bus_request", "[0:0] priority_high"], "clock": "rst_clk", "attempts_left": 10, "sva_result": "@(negedge rst_clk) disable iff (soft_reset)     bus_grant == 1'b1 |-> $past(bus_request, 1) && $past(priority_high, 1)", "sva_name": "p_bus_grant_requires_prev_request_and_priority_high", "id": "2035", "full_property": "property p_bus_grant_after_request;\n@(negedge rst_clk) disable iff (soft_reset)     bus_grant == 1'b1 |-> $past(bus_request, 1) && $past(priority_high, 1)\nendproperty\nassert_p_bus_grant_after_request:assert property (p_bus_grant_after_request) else $error(\"\");", "task_id": "3_5785", "predict_sva": "@(negedge rst_clk) disable iff (soft_reset)         (soft_reset == 0 && bus_grant == 1'b1) |-> ($past(bus_request) == 1'b1 && $past(priority_high) == 1'b1)"}
{"sva": "@(posedge clk_smart_irrigation) disable iff(rst_drip_emitter_control == 1'b1) pressure_compensating_valve |-> $past(flow_rate_uniformity_check, 7) && water_distribution_efficiency", "sva_description": "### Assertion description:  \n**Property Name**: p_pressure_compensating_valve_check  \n**Trigger Condition**: At every rising edge of the `clk_smart_irrigation`  \n**Disable Condition**: disable iff (`rst_drip_emitter_control == 1'b1`)  \n**Antecedent (LHS of Implication)**: `pressure_compensating_valve`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(flow_rate_uniformity_check, 7) && water_distribution_efficiency`", "sva_signals": ["clk_smart_irrigation", "rst_drip_emitter_control", "[0:0] pressure_compensating_valve", "[0:0] flow_rate_uniformity_check", "[0:0] water_distribution_efficiency"], "clock": "clk_smart_irrigation", "attempts_left": 10, "sva_result": "@(posedge clk_smart_irrigation) disable iff (rst_drip_emitter_control == 1'b1)     pressure_compensating_valve |-> $past(flow_rate_uniformity_check, 7) && water_distribution_efficiency", "sva_name": "p_pressure_compensating_valve_flow_uniformity_and_efficiency", "id": "2018", "full_property": "property p_pressure_compensating_valve_check;\n@(posedge clk_smart_irrigation) disable iff (rst_drip_emitter_control == 1'b1)     pressure_compensating_valve |-> $past(flow_rate_uniformity_check, 7) && water_distribution_efficiency\nendproperty\nassert_p_pressure_compensating_valve_check:assert property (p_pressure_compensating_valve_check) else $error(\"\");", "task_id": "3_5768", "predict_sva": "@(posedge clk_smart_irrigation) disable iff (rst_drip_emitter_control)         (rst_drip_emitter_control == 0 && pressure_compensating_valve == 1) |->          ($past(flow_rate_uniformity_check, 7) == 1) &&          (water_distribution_efficiency == 1)"}
{"sva": "@(posedge clk) disable iff(bypass_mode) pipeline_stall |-> $past(resource_busy | dependency_hazard, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Pipeline_Stall_Condition  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (bypass_mode)`  \n**Antecedent (LHS of Implication)**: `pipeline_stall == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(resource_busy | dependency_hazard, 1)`  ", "sva_signals": ["clk", "[0:0] bypass_mode", "[0:0] pipeline_stall", "[0:0] resource_busy", "[0:0] dependency_hazard"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (bypass_mode)     pipeline_stall == 1'b1 |-> $past(resource_busy | dependency_hazard, 1)", "sva_name": "p_pipeline_stall_due_to_resource_or_dependency", "id": "2055", "full_property": "property p_Pipeline_Stall_Condition;\n@(posedge clk) disable iff (bypass_mode)     pipeline_stall == 1'b1 |-> $past(resource_busy | dependency_hazard, 1)\nendproperty\nassert_p_Pipeline_Stall_Condition:assert property (p_Pipeline_Stall_Condition) else $error(\"\");", "task_id": "3_5805", "predict_sva": "@(posedge clk) disable iff (bypass_mode)         (bypass_mode == 0 && pipeline_stall == 1) |-> ($past(resource_busy) == 1 || $past(dependency_hazard) == 1)"}
{"sva": "@(posedge clk) thermal_shutdown |=> $past(temperature_sensor[9:0] >= critical_temp, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Shutdown_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `thermal_shutdown == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(temperature_sensor[9:0] >= critical_temp, 1)`  ", "sva_signals": ["clk", "rst_n", "[9:0] temperature_sensor", "[9:0] critical_temp", "[0:0] thermal_shutdown"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         thermal_shutdown == 1'b1 |=> $past(temperature_sensor[9:0] >= critical_temp, 1)", "sva_name": "p_thermal_shutdown_critical_temp_check", "id": "2061", "full_property": "property p_Thermal_Shutdown_Check;\n@(posedge clk)         thermal_shutdown == 1'b1 |=> $past(temperature_sensor[9:0] >= critical_temp, 1)\nendproperty\nassert_p_Thermal_Shutdown_Check:assert property (p_Thermal_Shutdown_Check) else $error(\"\");", "task_id": "3_5811", "predict_sva": "@(posedge clk)         thermal_shutdown == 1'b1 |-> $past(temperature_sensor[9:0] >= critical_temp, 1)"}
{"sva": "@(posedge clk) watchdog_reset |=> $past(timeout_counter[15:0] == timeout_limit, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_watchdog_reset_timeout  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `watchdog_reset`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(timeout_counter[15:0] == timeout_limit, 1)`  ", "sva_signals": ["clk", "rst_n", "[15:0] watchdog_reset", "[15:0] timeout_counter", "[15:0] timeout_limit"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     watchdog_reset |=> $past(timeout_counter[15:0] == timeout_limit, 1)", "sva_name": "p_watchdog_reset_timeout_limit_check", "id": "2087", "full_property": "property p_watchdog_reset_timeout;\n@(posedge clk)     watchdog_reset |=> $past(timeout_counter[15:0] == timeout_limit, 1)\nendproperty\nassert_p_watchdog_reset_timeout:assert property (p_watchdog_reset_timeout) else $error(\"\");", "task_id": "3_5836", "predict_sva": "@(posedge clk)         watchdog_reset == 1 |-> $past(timeout_counter[15:0] == timeout_limit, 1)"}
{"sva": "@(posedge clk_noc) disable iff(!network_enable) routing_deadlock |-> ($past(all_buffers_full[15:0], 2) == 16'hFFFF)", "sva_description": "### Assertion description:  \n**Property Name**: p_routing_deadlock_check  \n**Trigger Condition**: At every rising edge of the `clk_noc`  \n**Disable Condition**: disable iff `(!network_enable)`  \n**Antecedent (LHS of Implication)**: `routing_deadlock == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(all_buffers_full[15:0], 2) == 16'hFFFF`  \n\n(Note: The assertion checks that whenever a routing deadlock occurs, the network buffers were fully occupied (`16'hFFFF`) two clock cycles prior.)", "sva_signals": ["clk_noc", "network_enable", "[0:0] routing_deadlock", "[15:0] all_buffers_full"], "clock": "clk_noc", "attempts_left": 10, "sva_result": "@(posedge clk_noc) disable iff (!network_enable)     routing_deadlock == 1'b1 |-> $past(all_buffers_full[15:0], 2) == 16'hFFFF", "sva_name": "p_routing_deadlock_check", "id": "2104", "full_property": "property p_routing_deadlock_check;\n@(posedge clk_noc) disable iff (!network_enable)     routing_deadlock == 1'b1 |-> $past(all_buffers_full[15:0], 2) == 16'hFFFF\nendproperty\nassert_p_routing_deadlock_check:assert property (p_routing_deadlock_check) else $error(\"\");", "task_id": "3_5850", "predict_sva": "@(posedge clk_noc) disable iff (!network_enable)     routing_deadlock == 1'b1 |-> $past(all_buffers_full[15:0] == 16'hFFFF, 2)"}
{"sva": "@(posedge clk_aes) disable iff(!aes_enable) advanced_encryption_standard |-> ($past(key_expansion[127:0], 1) && $past(substitute_bytes, 1) && $past(shift_rows, 1))", "sva_description": "### Assertion description:  \n**Property Name**: advanced_encryption_standard  \n**Trigger Condition**: At every rising edge of the `clk_aes`  \n**Disable Condition**: `disable iff (!aes_enable)`  \n**Antecedent (LHS of Implication)**: `advanced_encryption_standard`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(key_expansion[127:0], 1) && $past(substitute_bytes, 1) && $past(shift_rows, 1))`  ", "sva_signals": ["clk_aes", "aes_enable", "[127:0] key_expansion", "[0:0] substitute_bytes", "[0:0] shift_rows", "[0:0] advanced_encryption_standard"], "clock": "clk_aes", "attempts_left": 10, "sva_result": "@(posedge clk_aes) disable iff (!aes_enable)     advanced_encryption_standard |->          ($past(key_expansion[127:0], 1) && $past(substitute_bytes, 1) && $past(shift_rows, 1))", "sva_name": "p_advanced_encryption_standard", "id": "2300", "full_property": "property advanced_encryption_standard;\n@(posedge clk_aes) disable iff (!aes_enable)     advanced_encryption_standard |->          ($past(key_expansion[127:0], 1) && $past(substitute_bytes, 1) && $past(shift_rows, 1))\nendproperty\nassert_advanced_encryption_standard:assert property (advanced_encryption_standard) else $error(\"\");", "task_id": "3_6031", "predict_sva": "@(posedge clk_aes) disable iff (!aes_enable)     advanced_encryption_standard |->          ($past(key_expansion[127:0]) != 0) &&          $past(substitute_bytes) &&          $past(shift_rows)"}
{"sva": "@(posedge clk_firrtl) disable iff(!firrtl_reset) flexible_intermediate_representation |-> ($past(circuit_ir, 1) && $past(transformation_pass, 1) && $past(backend_emission, 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_Flexible_Intermediate_Representation  \n**Trigger Condition**: At every rising edge of `clk_firrtl`  \n**Disable Condition**: `disable iff (!firrtl_reset)`  \n**Antecedent (LHS of Implication)**: `flexible_intermediate_representation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(circuit_ir, 1) && $past(transformation_pass, 1) && $past(backend_emission, 1))`  ", "sva_signals": ["clk_firrtl", "firrtl_reset", "[0:0] flexible_intermediate_representation", "[0:0] circuit_ir", "[0:0] transformation_pass", "[0:0] backend_emission"], "clock": "clk_firrtl", "attempts_left": 10, "sva_result": "@(posedge clk_firrtl) disable iff (!firrtl_reset)     flexible_intermediate_representation |->          ($past(circuit_ir, 1) && $past(transformation_pass, 1) && $past(backend_emission, 1))", "sva_name": "p_firrtl_flex_intermediate_representation", "id": "2318", "full_property": "property p_Flexible_Intermediate_Representation;\n@(posedge clk_firrtl) disable iff (!firrtl_reset)     flexible_intermediate_representation |->          ($past(circuit_ir, 1) && $past(transformation_pass, 1) && $past(backend_emission, 1))\nendproperty\nassert_p_Flexible_Intermediate_Representation:assert property (p_Flexible_Intermediate_Representation) else $error(\"\");", "task_id": "3_6047", "predict_sva": "@(posedge clk_firrtl) disable iff (!firrtl_reset)     flexible_intermediate_representation |->          ($past(circuit_ir) && $past(transformation_pass) && $past(backend_emission))"}
{"sva": "@(negedge clk_gemmini) disable iff(!gemmini_enable) systolic_array_generator |=> $past(gemm_operation & accumulator_memory & dataflow_orchestration, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_systolic_array_generator_operation  \n**Trigger Condition**: At every falling edge of the `clk_gemmini`  \n**Disable Condition**: disable iff (`!gemmini_enable`)  \n**Antecedent (LHS of Implication)**: `systolic_array_generator`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(gemm_operation & accumulator_memory & dataflow_orchestration, 1)`  ", "sva_signals": ["clk_gemmini", "gemmini_enable", "[0:0] systolic_array_generator", "[0:0] gemm_operation", "[0:0] accumulator_memory", "[0:0] dataflow_orchestration"], "clock": "clk_gemmini", "attempts_left": 10, "sva_result": "@(negedge clk_gemmini) disable iff (!gemmini_enable)     systolic_array_generator |=> $past(gemm_operation & accumulator_memory & dataflow_orchestration, 1)", "sva_name": "p_systolic_array_generator", "id": "2327", "full_property": "property p_systolic_array_generator_operation;\n@(negedge clk_gemmini) disable iff (!gemmini_enable)     systolic_array_generator |=> $past(gemm_operation & accumulator_memory & dataflow_orchestration, 1)\nendproperty\nassert_p_systolic_array_generator_operation:assert property (p_systolic_array_generator_operation) else $error(\"\");", "task_id": "3_6055", "predict_sva": "@(negedge clk_gemmini) disable iff (!gemmini_enable)     systolic_array_generator |-> $past(gemm_operation & accumulator_memory & dataflow_orchestration, 1)"}
{"sva": "@(negedge clk_flash_ctrl) disable iff(!flash_controller_enable) flash_memory_controller |-> $past(erase_operation & program_operation & read_operation, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_flash_memory_controller_check  \n**Trigger Condition**: At every falling edge of `clk_flash_ctrl`  \n**Disable Condition**: disable iff `(!flash_controller_enable)`  \n**Antecedent (LHS of Implication)**: `flash_memory_controller`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(erase_operation & program_operation & read_operation, 1)`  ", "sva_signals": ["clk_flash_ctrl", "flash_controller_enable", "flash_memory_controller", "[0:0] erase_operation", "[0:0] program_operation", "[0:0] read_operation"], "clock": "clk_flash_ctrl", "attempts_left": 10, "sva_result": "@(negedge clk_flash_ctrl) disable iff (!flash_controller_enable)     flash_memory_controller |-> $past(erase_operation & program_operation & read_operation, 1)", "sva_name": "p_flash_memory_controller", "id": "2367", "full_property": "property p_flash_memory_controller_check;\n@(negedge clk_flash_ctrl) disable iff (!flash_controller_enable)     flash_memory_controller |-> $past(erase_operation & program_operation & read_operation, 1)\nendproperty\nassert_p_flash_memory_controller_check:assert property (p_flash_memory_controller_check) else $error(\"\");", "task_id": "3_6091", "predict_sva": "@(negedge clk_flash_ctrl) disable iff (!flash_controller_enable)     flash_memory_controller |=> $past(erase_operation & program_operation & read_operation, 1)"}
{"sva": "@(negedge clk_avian_compass) disable iff(!avian_enable) avian_magnetic_compass_mechanism |-> $past(cryptochrome_protein[15:0] & radical_pair_mechanism & geomagnetic_field_sensitivity[11:0], 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Avian_Magnetic_Compass_Mechanism  \n**Trigger Condition**: At every falling edge of the `clk_avian_compass`  \n**Disable Condition**: `disable iff (!avian_enable)`  \n**Antecedent (LHS of Implication)**: `avian_magnetic_compass_mechanism`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(cryptochrome_protein[15:0] & radical_pair_mechanism & geomagnetic_field_sensitivity[11:0], 1)`  ", "sva_signals": ["clk_avian_compass", "avian_enable", "[15:0] avian_magnetic_compass_mechanism", "[15:0] cryptochrome_protein", "[15:0] radical_pair_mechanism", "[11:0] geomagnetic_field_sensitivity"], "clock": "clk_avian_compass", "attempts_left": 10, "sva_result": "@(negedge clk_avian_compass) disable iff (!avian_enable)     avian_magnetic_compass_mechanism |->      $past(cryptochrome_protein[15:0] & radical_pair_mechanism & geomagnetic_field_sensitivity[11:0], 1)", "sva_name": "p_avian_magnetic_compass_mechanism", "id": "2555", "full_property": "property p_Avian_Magnetic_Compass_Mechanism;\n@(negedge clk_avian_compass) disable iff (!avian_enable)     avian_magnetic_compass_mechanism |->      $past(cryptochrome_protein[15:0] & radical_pair_mechanism & geomagnetic_field_sensitivity[11:0], 1)\nendproperty\nassert_p_Avian_Magnetic_Compass_Mechanism:assert property (p_Avian_Magnetic_Compass_Mechanism) else $error(\"\");", "task_id": "3_6241", "predict_sva": "@(negedge clk_avian_compass) disable iff (!avian_enable)     avian_magnetic_compass_mechanism |->          $past(cryptochrome_protein[15:0] & radical_pair_mechanism & geomagnetic_field_sensitivity[11:0], 1)"}
{"sva": "@(negedge clk_trapped_ion) disable iff(!ion_trap_ready) trapped_ion_quantum_gate |-> $past(laser_pulse_sequence[31:0] & vibrational_mode_coupling & phonon_mediated_interaction, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Trapped_Ion_Quantum_Gate  \n**Trigger Condition**: At every falling edge of the `clk_trapped_ion`  \n**Disable Condition**: `disable iff (!ion_trap_ready)`  \n**Antecedent (LHS of Implication)**: `trapped_ion_quantum_gate == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(laser_pulse_sequence[31:0] & vibrational_mode_coupling & phonon_mediated_interaction, 1)`  ", "sva_signals": ["clk_trapped_ion", "ion_trap_ready", "[0:0] trapped_ion_quantum_gate", "[31:0] laser_pulse_sequence", "[31:0] vibrational_mode_coupling", "[31:0] phonon_mediated_interaction"], "clock": "clk_trapped_ion", "attempts_left": 10, "sva_result": "@(negedge clk_trapped_ion) disable iff (!ion_trap_ready)     trapped_ion_quantum_gate == 1'b1 |->      $past(laser_pulse_sequence[31:0] & vibrational_mode_coupling & phonon_mediated_interaction, 1)", "sva_name": "p_Trapped_Ion_Quantum_Gate", "id": "2576", "full_property": "property p_Trapped_Ion_Quantum_Gate;\n@(negedge clk_trapped_ion) disable iff (!ion_trap_ready)     trapped_ion_quantum_gate == 1'b1 |->      $past(laser_pulse_sequence[31:0] & vibrational_mode_coupling & phonon_mediated_interaction, 1)\nendproperty\nassert_p_Trapped_Ion_Quantum_Gate:assert property (p_Trapped_Ion_Quantum_Gate) else $error(\"\");", "task_id": "3_6257", "predict_sva": "@(negedge clk_trapped_ion) disable iff (!ion_trap_ready)     trapped_ion_quantum_gate == 1'b1 |->      $past(laser_pulse_sequence[31:0] & vibrational_mode_coupling & phonon_mediated_interaction, 1)"}
{"sva": "@(posedge clk_exoplanet) disable iff(!exoplanet_rst_n) transit_photometry_detector |=> ($past(stellar_brightness[15:0], 1) && $past(transit_depth[11:0], 1) && $past(orbital_period[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_transit_photometry_detector  \n**Trigger Condition**: At every rising edge of the `clk_exoplanet`  \n**Disable Condition**: `disable iff (!exoplanet_rst_n)`  \n**Antecedent (LHS of Implication)**: `transit_photometry_detector`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**:  \n`($past(stellar_brightness[15:0], 1) && $past(transit_depth[11:0], 1) && $past(orbital_period[31:0], 1))`  ", "sva_signals": ["clk_exoplanet", "exoplanet_rst_n", "[0:0] transit_photometry_detector", "[15:0] stellar_brightness", "[11:0] transit_depth", "[31:0] orbital_period"], "clock": "clk_exoplanet", "attempts_left": 10, "sva_result": "@(posedge clk_exoplanet) disable iff (!exoplanet_rst_n)     transit_photometry_detector |=>          ($past(stellar_brightness[15:0], 1) &&           $past(transit_depth[11:0], 1) &&           $past(orbital_period[31:0], 1))", "sva_name": "p_transit_photometry_detector", "id": "2637", "full_property": "property p_transit_photometry_detector;\n@(posedge clk_exoplanet) disable iff (!exoplanet_rst_n)     transit_photometry_detector |=>          ($past(stellar_brightness[15:0], 1) &&           $past(transit_depth[11:0], 1) &&           $past(orbital_period[31:0], 1))\nendproperty\nassert_p_transit_photometry_detector:assert property (p_transit_photometry_detector) else $error(\"\");", "task_id": "3_6309", "predict_sva": "@(posedge clk_exoplanet) disable iff (!exoplanet_rst_n)     transit_photometry_detector |->          ($past(stellar_brightness[15:0]) != 16'b0) &&          ($past(transit_depth[11:0]) != 12'b0) &&          ($past(orbital_period[31:0]) != 32'b0)"}
{"sva": "@(negedge clk_solar_probe) disable iff(!solar_probe_enable) parker_solar_probe_investigation |-> $past(solar_wind_velocity[15:0] & coronal_heating_mechanism[11:0] & magnetic_field_structure, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_Parker_Solar_Probe_Investigation  \n**Trigger Condition**: At every falling edge of `clk_solar_probe`  \n**Disable Condition**: `disable iff (!solar_probe_enable)`  \n**Antecedent (LHS of Implication)**: `parker_solar_probe_investigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(solar_wind_velocity[15:0] & coronal_heating_mechanism[11:0] & magnetic_field_structure, 1)`  ", "sva_signals": ["clk_solar_probe", "solar_probe_enable", "[0:0] parker_solar_probe_investigation", "[15:0] solar_wind_velocity", "[11:0] coronal_heating_mechanism", "[0:0] magnetic_field_structure"], "clock": "clk_solar_probe", "attempts_left": 10, "sva_result": "@(negedge clk_solar_probe) disable iff (!solar_probe_enable)     parker_solar_probe_investigation |->          $past(solar_wind_velocity[15:0] & coronal_heating_mechanism[11:0] & magnetic_field_structure, 1)", "sva_name": "p_parker_solar_probe_investigation", "id": "2664", "full_property": "property p_Parker_Solar_Probe_Investigation;\n@(negedge clk_solar_probe) disable iff (!solar_probe_enable)     parker_solar_probe_investigation |->          $past(solar_wind_velocity[15:0] & coronal_heating_mechanism[11:0] & magnetic_field_structure, 1)\nendproperty\nassert_p_Parker_Solar_Probe_Investigation:assert property (p_Parker_Solar_Probe_Investigation) else $error(\"\");", "task_id": "3_6330", "predict_sva": "@(negedge clk_solar_probe) disable iff (!solar_probe_enable)     parker_solar_probe_investigation |=>      ($past(solar_wind_velocity[15:0] & coronal_heating_mechanism[11:0] & magnetic_field_structure, 1))"}
{"sva": "@(negedge clk_ceilometer) disable iff(!cloud_height_enable) cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)", "sva_description": "### Assertion description:  \n**Property Name**: p_cloud_base_height_measurement  \n**Trigger Condition**: At every falling edge of the `clk_ceilometer`  \n**Disable Condition**: disable iff (`!cloud_height_enable`)  \n**Antecedent (LHS of Implication)**: `cloud_base_height_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)`  ", "sva_signals": ["clk_ceilometer", "cloud_height_enable", "[15:0] cloud_base_height_measurement", "[15:0] laser_pulse_backscatter", "[11:0] cloud_layer_detection", "[0:0] vertical_visibility"], "clock": "clk_ceilometer", "attempts_left": 10, "sva_result": "@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)", "sva_name": "p_cloud_base_height_measurement", "id": "2707", "full_property": "property p_cloud_base_height_measurement;\n@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |-> $past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1)\nendproperty\nassert_p_cloud_base_height_measurement:assert property (p_cloud_base_height_measurement) else $error(\"\");", "task_id": "3_6367", "predict_sva": "@(negedge clk_ceilometer) disable iff (!cloud_height_enable)     cloud_base_height_measurement |=>      ($past(laser_pulse_backscatter[15:0] & cloud_layer_detection[11:0] & vertical_visibility, 1))"}
{"sva": "@(posedge clk) disable iff(factory_test) ecc_correction_limit |-> $past(single_bit_errors) > max_correctable && $past(ecc_enabled)", "sva_description": "### Assertion description:  \n**Property Name**: p_ecc_correction_limit  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (factory_test)`  \n**Antecedent (LHS of Implication)**: `ecc_correction_limit == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(single_bit_errors) > max_correctable && $past(ecc_enabled)`  ", "sva_signals": ["clk", "rst_n", "[0:0] factory_test", "[0:0] ecc_correction_limit", "[0:0] single_bit_errors", "[0:0] max_correctable", "[0:0] ecc_enabled"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)", "sva_name": "p_ecc_correction_limit_condition", "id": "3129", "full_property": "property p_ecc_correction_limit;\n@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)\nendproperty\nassert_p_ecc_correction_limit:assert property (p_ecc_correction_limit) else $error(\"\");", "task_id": "3_6732", "predict_sva": "@(posedge clk) disable iff (factory_test)     ecc_correction_limit == 1'b1 |->      ($past(single_bit_errors) > max_correctable) && $past(ecc_enabled)"}
{"sva": "@(posedge clk) disable iff(theranostics) theranostic_nanoparticle_system |=> ($past(imaging_contrast_agent[15:0], 1) && $past(therapeutic_payload[11:0], 1) && $past(targeted_delivery[31:0], 1))", "sva_description": "### Assertion description:  \n**Property Name**: p_theranostic_nanoparticle_system  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (theranostics)`  \n**Antecedent (LHS of Implication)**: `theranostic_nanoparticle_system`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `($past(imaging_contrast_agent[15:0], 1) && $past(therapeutic_payload[11:0], 1) && $past(targeted_delivery[31:0], 1))`  \n\n", "sva_signals": ["clk", "theranostics", "[0:0] theranostic_nanoparticle_system", "[15:0] imaging_contrast_agent", "[11:0] therapeutic_payload", "[31:0] targeted_delivery"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (theranostics)     theranostic_nanoparticle_system |=>      ($past(imaging_contrast_agent[15:0], 1) &&       $past(therapeutic_payload[11:0], 1) &&       $past(targeted_delivery[31:0], 1))", "sva_name": "p_theranostic_nanoparticle_system", "id": "2952", "full_property": "property p_theranostic_nanoparticle_system;\n@(posedge clk) disable iff (theranostics)     theranostic_nanoparticle_system |=>      ($past(imaging_contrast_agent[15:0], 1) &&       $past(therapeutic_payload[11:0], 1) &&       $past(targeted_delivery[31:0], 1))\nendproperty\nassert_p_theranostic_nanoparticle_system:assert property (p_theranostic_nanoparticle_system) else $error(\"\");", "task_id": "3_6575", "predict_sva": "@(posedge clk) disable iff (theranostics)     theranostic_nanoparticle_system |->          ($past(imaging_contrast_agent[15:0], 1) &&           $past(therapeutic_payload[11:0], 1) &&           $past(targeted_delivery[31:0], 1))"}
{"sva": "@(posedge clk) disable iff(scan_chain_active) metastability_detection |-> $past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin)", "sva_description": "### Assertion description:  \n**Property Name**: p_metastability_detection  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (scan_chain_active)`  \n**Antecedent (LHS of Implication)**: `metastability_detection`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin)`  ", "sva_signals": ["clk", "scan_chain_active", "async_input_changed", "[0:0] metastability_detection", "setup_time_margin", "min_setup_margin"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (scan_chain_active)     metastability_detection |-> ($past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin))", "sva_name": "p_metastability_detection_trigger", "id": "3220", "full_property": "property p_metastability_detection;\n@(posedge clk) disable iff (scan_chain_active)     metastability_detection |-> ($past(async_input_changed) && ($past(setup_time_margin) < min_setup_margin))\nendproperty\nassert_p_metastability_detection:assert property (p_metastability_detection) else $error(\"\");", "task_id": "3_6814", "predict_sva": "@(posedge clk) disable iff (scan_chain_active)         (scan_chain_active == 0 && metastability_detection == 1) |->          ($past(async_input_changed) == 1 && $past(setup_time_margin) < min_setup_margin)"}
{"sva": "@(posedge clk_routing) disable iff(routing_reset) congestion_control_fail |-> ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)", "sva_description": "### Assertion description:  \n**Property Name**: p_congestion_control_fail  \n**Trigger Condition**: At every rising edge of the `clk_routing`  \n**Disable Condition**: `disable iff (routing_reset)`  \n**Antecedent (LHS of Implication)**: `congestion_control_fail == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)`  ", "sva_signals": ["clk_routing", "routing_reset", "[0:0] congestion_control_fail", "[0:0] packet_queue_depth", "[0:0] congestion_threshold", "[0:0] flow_control_applied"], "clock": "clk_routing", "attempts_left": 10, "sva_result": "@(posedge clk_routing) disable iff (routing_reset)     congestion_control_fail == 1'b1 |->      ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)", "sva_name": "p_congestion_control_fail_allowed_only_on_threshold_and_no_flow_control", "id": "3216", "full_property": "property p_congestion_control_fail;\n@(posedge clk_routing) disable iff (routing_reset)     congestion_control_fail == 1'b1 |->      ($past(packet_queue_depth) > congestion_threshold) && !$past(flow_control_applied)\nendproperty\nassert_p_congestion_control_fail:assert property (p_congestion_control_fail) else $error(\"\");", "task_id": "3_6810", "predict_sva": "@(posedge clk_routing) disable iff (routing_reset)         (congestion_control_fail == 1'b1 && routing_reset == 0) |->          ($past(packet_queue_depth) > congestion_threshold) &&          ($past(flow_control_applied) == 0)"}
{"sva": "@(posedge clk) disable iff(!chip_select_n) spi_clock_polarity_check |-> ($past(sclk_idle) == clock_polarity) && $past(transmission_idle)", "sva_description": "### Assertion description:  \n**Property Name**: spi_clock_polarity_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`!chip_select_n`)  \n**Antecedent (LHS of Implication)**: `spi_clock_polarity_check`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(sclk_idle) == clock_polarity) && $past(transmission_idle)`  ", "sva_signals": ["clk", "[0:0] chip_select_n", "[0:0] spi_clock_polarity_check", "[0:0] sclk_idle", "[0:0] clock_polarity", "[0:0] transmission_idle"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (!chip_select_n)     spi_clock_polarity_check |-> ($past(sclk_idle) == clock_polarity) && $past(transmission_idle)", "sva_name": "p_spi_clock_polarity_check", "id": "3249", "full_property": "property spi_clock_polarity_check;\n@(posedge clk) disable iff (!chip_select_n)     spi_clock_polarity_check |-> ($past(sclk_idle) == clock_polarity) && $past(transmission_idle)\nendproperty\nassert_spi_clock_polarity_check:assert property (spi_clock_polarity_check) else $error(\"\");", "task_id": "3_6840", "predict_sva": "@(posedge clk) disable iff (!chip_select_n)     spi_clock_polarity_check |->          ($past(sclk_idle) == clock_polarity) &&          ($past(transmission_idle) == 1'b1)"}
{"sva": "@(posedge clk_reactor_coolant_pump) disable iff(!rcp_power_available) natural_circulation_establishment |-> $past(forced_circulation_lost) && !$past(natural_circulation_verified, 15)", "sva_description": "### Assertion description:  \n**Property Name**: p_Natural_Circulation_Establishment  \n**Trigger Condition**: At every rising edge of `clk_reactor_coolant_pump`  \n**Disable Condition**: `disable iff (!rcp_power_available)`  \n**Antecedent (LHS of Implication)**: `natural_circulation_establishment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(forced_circulation_lost) && !$past(natural_circulation_verified, 15)`  ", "sva_signals": ["clk_reactor_coolant_pump", "rcp_power_available", "[0:0] natural_circulation_establishment", "[0:0] forced_circulation_lost", "[0:0] natural_circulation_verified"], "clock": "clk_reactor_coolant_pump", "attempts_left": 10, "sva_result": "@(posedge clk_reactor_coolant_pump) disable iff (!rcp_power_available)     natural_circulation_establishment |->          $past(forced_circulation_lost) && !$past(natural_circulation_verified, 15)", "sva_name": "p_natural_circulation_establishment_precondition", "id": "3349", "full_property": "property p_Natural_Circulation_Establishment;\n@(posedge clk_reactor_coolant_pump) disable iff (!rcp_power_available)     natural_circulation_establishment |->          $past(forced_circulation_lost) && !$past(natural_circulation_verified, 15)\nendproperty\nassert_p_Natural_Circulation_Establishment:assert property (p_Natural_Circulation_Establishment) else $error(\"\");", "task_id": "3_6937", "predict_sva": "@(posedge clk_reactor_coolant_pump) disable iff (!rcp_power_available)         (rcp_power_available == 1 && natural_circulation_establishment == 1) |->          ($past(forced_circulation_lost) == 1 && !$past(natural_circulation_verified, 15))"}
{"sva": "@(negedge clk_transponder) disable iff(!ranging_system_operational) spacecraft_range_measurement |-> $past(range_tone_transmitted) && ($past(round_trip_time) > maximum_expected_delay)", "sva_description": "### Assertion description:  \n**Property Name**: p_Spacecraft_Range_Measurement  \n**Trigger Condition**: At every falling edge of `clk_transponder`  \n**Disable Condition**: `disable iff (!ranging_system_operational)`  \n**Antecedent (LHS of Implication)**: `spacecraft_range_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(range_tone_transmitted) && ($past(round_trip_time) > maximum_expected_delay)`  ", "sva_signals": ["clk_transponder", "ranging_system_operational", "[0:0] spacecraft_range_measurement", "[0:0] range_tone_transmitted", "[0:0] round_trip_time", "[0:0] maximum_expected_delay"], "clock": "clk_transponder", "attempts_left": 10, "sva_result": "@(negedge clk_transponder) disable iff (!ranging_system_operational)     spacecraft_range_measurement |->          $past(range_tone_transmitted) && ($past(round_trip_time) > maximum_expected_delay)", "sva_name": "p_spacecraft_range_measurement", "id": "3377", "full_property": "property p_Spacecraft_Range_Measurement;\n@(negedge clk_transponder) disable iff (!ranging_system_operational)     spacecraft_range_measurement |->          $past(range_tone_transmitted) && ($past(round_trip_time) > maximum_expected_delay)\nendproperty\nassert_p_Spacecraft_Range_Measurement:assert property (p_Spacecraft_Range_Measurement) else $error(\"\");", "task_id": "3_6964", "predict_sva": "@(negedge clk_transponder) disable iff (!ranging_system_operational)     spacecraft_range_measurement |->          ($past(range_tone_transmitted) && ($past(round_trip_time) > maximum_expected_delay))"}
{"sva": "@(posedge clk) disable iff(human_factors_analysis) operator_action_reliability |-> $past(stress_level_high) && ($past(procedure_compliance) != expected_performance) && $past(safety_significant_task)", "sva_description": "### Assertion description:  \n**Property Name**: p_Operator_Action_Reliability  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (human_factors_analysis)`  \n**Antecedent (LHS of Implication)**: `operator_action_reliability == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(stress_level_high) && ($past(procedure_compliance) != expected_performance) && $past(safety_significant_task)`  ", "sva_signals": ["clk", "rst_n", "[0:0] human_factors_analysis", "[0:0] operator_action_reliability", "[0:0] stress_level_high", "[0:0] procedure_compliance", "[0:0] expected_performance", "[0:0] safety_significant_task"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (human_factors_analysis)     operator_action_reliability == 1'b1 |->      $past(stress_level_high) &&      ($past(procedure_compliance) != expected_performance) &&      $past(safety_significant_task)", "sva_name": "p_operator_action_reliability_validity", "id": "3354", "full_property": "property p_Operator_Action_Reliability;\n@(posedge clk) disable iff (human_factors_analysis)     operator_action_reliability == 1'b1 |->      $past(stress_level_high) &&      ($past(procedure_compliance) != expected_performance) &&      $past(safety_significant_task)\nendproperty\nassert_p_Operator_Action_Reliability:assert property (p_Operator_Action_Reliability) else $error(\"\");", "task_id": "3_6942", "predict_sva": "@(posedge clk) disable iff (human_factors_analysis)         (human_factors_analysis == 0 && operator_action_reliability == 1) |->          ($past(stress_level_high) == 1 && $past(procedure_compliance) != $past(expected_performance) && $past(safety_significant_task) == 1)"}
{"sva": "@(negedge clk_gyro) disable iff(gyroscope_calibration_mode) angular_rate_measurement_drift |-> ($past(gyro_bias_estimate) - $past(gyro_bias_estimate, 100)) > bias_drift_limit", "sva_description": "### Assertion description:  \n**Property Name**: p_Angular_Rate_Measurement_Drift  \n**Trigger Condition**: At every falling edge of `clk_gyro`  \n**Disable Condition**: `disable iff (gyroscope_calibration_mode)`  \n**Antecedent (LHS of Implication)**: `angular_rate_measurement_drift == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(gyro_bias_estimate) - $past(gyro_bias_estimate, 100)) > bias_drift_limit`  ", "sva_signals": ["clk_gyro", "gyroscope_calibration_mode", "[0:0] angular_rate_measurement_drift", "[15:0] gyro_bias_estimate", "[15:0] bias_drift_limit"], "clock": "clk_gyro", "attempts_left": 10, "sva_result": "@(negedge clk_gyro) disable iff (gyroscope_calibration_mode)     angular_rate_measurement_drift == 1'b1 |->      ($past(gyro_bias_estimate) - $past(gyro_bias_estimate, 100)) > bias_drift_limit", "sva_name": "p_gyro_bias_drift_limit_check", "id": "3378", "full_property": "property p_Angular_Rate_Measurement_Drift;\n@(negedge clk_gyro) disable iff (gyroscope_calibration_mode)     angular_rate_measurement_drift == 1'b1 |->      ($past(gyro_bias_estimate) - $past(gyro_bias_estimate, 100)) > bias_drift_limit\nendproperty\nassert_p_Angular_Rate_Measurement_Drift:assert property (p_Angular_Rate_Measurement_Drift) else $error(\"\");", "task_id": "3_6965", "predict_sva": "@(negedge clk_gyro) disable iff (gyroscope_calibration_mode)         (gyroscope_calibration_mode == 0 && angular_rate_measurement_drift == 1'b1) |->          ($past(gyro_bias_estimate) - $past(gyro_bias_estimate, 100)) > bias_drift_limit"}
{"sva": "@(posedge clk_payload) disable iff(payload_standby) scientific_instrument_calibration |-> $past(calibration_source_exposure_time) && ($past(instrument_response) < expected_signal_level)", "sva_description": "### Assertion description:  \n**Property Name**: p_scientific_instrument_calibration  \n**Trigger Condition**: At every rising edge of the `clk_payload`  \n**Disable Condition**: `disable iff (payload_standby)`  \n**Antecedent (LHS of Implication)**: `scientific_instrument_calibration == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(calibration_source_exposure_time) && ($past(instrument_response) < expected_signal_level)`", "sva_signals": ["clk_payload", "payload_standby", "[0:0] scientific_instrument_calibration", "[0:0] calibration_source_exposure_time", "[0:0] instrument_response", "[0:0] expected_signal_level"], "clock": "clk_payload", "attempts_left": 10, "sva_result": "@(posedge clk_payload) disable iff (payload_standby)     scientific_instrument_calibration == 1'b1 |->      $past(calibration_source_exposure_time) && ($past(instrument_response) < expected_signal_level)", "sva_name": "p_calibration_source_exposure_and_response_check", "id": "3390", "full_property": "property p_scientific_instrument_calibration;\n@(posedge clk_payload) disable iff (payload_standby)     scientific_instrument_calibration == 1'b1 |->      $past(calibration_source_exposure_time) && ($past(instrument_response) < expected_signal_level)\nendproperty\nassert_p_scientific_instrument_calibration:assert property (p_scientific_instrument_calibration) else $error(\"\");", "task_id": "3_6975", "predict_sva": "@(posedge clk_payload) disable iff (payload_standby)         (payload_standby == 0 && scientific_instrument_calibration == 1) |->          ($past(calibration_source_exposure_time) == 1 && $past(instrument_response) < expected_signal_level)"}
{"sva": "@(posedge clk_seismometer) disable iff(!planetary_seismology_experiment) marsquake_detection_sensitivity |-> ($past(ground_motion_amplitude) > detection_threshold) && !$past(event_classification_completed, 18)", "sva_description": "### Assertion description:  \n**Property Name**: p_Marsquake_Detection_Sensitivity  \n**Trigger Condition**: At every rising edge of the `clk_seismometer`  \n**Disable Condition**: disable iff (`!planetary_seismology_experiment`)  \n**Antecedent (LHS of Implication)**: `marsquake_detection_sensitivity`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `ground_motion_amplitude` must be greater than `detection_threshold` (`$past(ground_motion_amplitude) > detection_threshold`)  \n- The event classification must not have been completed 18 cycles ago (`!$past(event_classification_completed, 18)`)  \n\nThe assertion checks that when `marsquake_detection_sensitivity` is active, the ground motion amplitude from the previous cycle exceeds the threshold, and no event classification was completed 18 cycles prior. The property is disabled if the `planetary_seismology_experiment` is inactive.", "sva_signals": ["clk_seismometer", "planetary_seismology_experiment", "[0:0] marsquake_detection_sensitivity", "ground_motion_amplitude", "detection_threshold", "[0:0] event_classification_completed"], "clock": "clk_seismometer", "attempts_left": 10, "sva_result": "@(posedge clk_seismometer) disable iff (!planetary_seismology_experiment)     marsquake_detection_sensitivity |->          ($past(ground_motion_amplitude) > detection_threshold) &&         (!$past(event_classification_completed, 18))", "sva_name": "p_marsquake_detection_sensitivity_response", "id": "3402", "full_property": "property p_Marsquake_Detection_Sensitivity;\n@(posedge clk_seismometer) disable iff (!planetary_seismology_experiment)     marsquake_detection_sensitivity |->          ($past(ground_motion_amplitude) > detection_threshold) &&         (!$past(event_classification_completed, 18))\nendproperty\nassert_p_Marsquake_Detection_Sensitivity:assert property (p_Marsquake_Detection_Sensitivity) else $error(\"\");", "task_id": "3_6987", "predict_sva": "@(posedge clk_seismometer) disable iff (!planetary_seismology_experiment)         (planetary_seismology_experiment == 1 && marsquake_detection_sensitivity == 1) |->          ($past(ground_motion_amplitude) > detection_threshold) &&          ($past(event_classification_completed, 18) == 0)"}
{"sva": "@(posedge clk_electronic_attack) disable iff(!offensive_electronic_warfare) enemy_communication_disruption |-> $past(enemy_frequency_identified) && ($past(jamming_signal_strength) < communication_denial_threshold)", "sva_description": "### Assertion description:  \n**Property Name**: p_enemy_communication_disruption  \n**Trigger Condition**: At every rising edge of the `clk_electronic_attack`  \n**Disable Condition**: `disable iff (!offensive_electronic_warfare)`  \n**Antecedent (LHS of Implication)**: `enemy_communication_disruption == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(enemy_frequency_identified) && ($past(jamming_signal_strength) < communication_denial_threshold)`  ", "sva_signals": ["clk_electronic_attack", "offensive_electronic_warfare", "[0:0] enemy_communication_disruption", "[0:0] enemy_frequency_identified", "[0:0] jamming_signal_strength", "[0:0] communication_denial_threshold"], "clock": "clk_electronic_attack", "attempts_left": 10, "sva_result": "@(posedge clk_electronic_attack) disable iff (!offensive_electronic_warfare)     enemy_communication_disruption == 1'b1 |->          $past(enemy_frequency_identified) && ($past(jamming_signal_strength) < communication_denial_threshold)", "sva_name": "p_enemy_communication_disruption_allowed", "id": "3425", "full_property": "property p_enemy_communication_disruption;\n@(posedge clk_electronic_attack) disable iff (!offensive_electronic_warfare)     enemy_communication_disruption == 1'b1 |->          $past(enemy_frequency_identified) && ($past(jamming_signal_strength) < communication_denial_threshold)\nendproperty\nassert_p_enemy_communication_disruption:assert property (p_enemy_communication_disruption) else $error(\"\");", "task_id": "3_7010", "predict_sva": "@(posedge clk_electronic_attack) disable iff (!offensive_electronic_warfare)         (offensive_electronic_warfare == 1 && enemy_communication_disruption == 1) |->          ($past(enemy_frequency_identified) == 1 && $past(jamming_signal_strength) < communication_denial_threshold)"}
{"sva": "@(negedge clk_peptide_synthesizer) disable iff(amino_acid_coupling_reagent_expired) solid_phase_peptide_synthesis |-> ($past(deprotection_cycle_efficiency) < complete_deprotection_threshold) && $past(synthesis_fidelity_monitoring_active)", "sva_description": "### Assertion description:  \n**Property Name**: p_Solid_Phase_Peptide_Synthesis_Check  \n**Trigger Condition**: At every falling edge of the `clk_peptide_synthesizer`  \n**Disable Condition**: disable iff (`amino_acid_coupling_reagent_expired`)  \n**Antecedent (LHS of Implication)**: `solid_phase_peptide_synthesis`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: (`$past(deprotection_cycle_efficiency) < complete_deprotection_threshold`) && `$past(synthesis_fidelity_monitoring_active)`", "sva_signals": ["clk_peptide_synthesizer", "amino_acid_coupling_reagent_expired", "[0:0] solid_phase_peptide_synthesis", "[0:0] deprotection_cycle_efficiency", "[0:0] complete_deprotection_threshold", "[0:0] synthesis_fidelity_monitoring_active"], "clock": "clk_peptide_synthesizer", "attempts_left": 10, "sva_result": "@(negedge clk_peptide_synthesizer) disable iff (amino_acid_coupling_reagent_expired)     solid_phase_peptide_synthesis |->          ($past(deprotection_cycle_efficiency) < complete_deprotection_threshold) &&          $past(synthesis_fidelity_monitoring_active)", "sva_name": "p_Solid_Phase_Peptide_Synthesis", "id": "3494", "full_property": "property p_Solid_Phase_Peptide_Synthesis_Check;\n@(negedge clk_peptide_synthesizer) disable iff (amino_acid_coupling_reagent_expired)     solid_phase_peptide_synthesis |->          ($past(deprotection_cycle_efficiency) < complete_deprotection_threshold) &&          $past(synthesis_fidelity_monitoring_active)\nendproperty\nassert_p_Solid_Phase_Peptide_Synthesis_Check:assert property (p_Solid_Phase_Peptide_Synthesis_Check) else $error(\"\");", "task_id": "3_7077", "predict_sva": "@(negedge clk_peptide_synthesizer) disable iff (amino_acid_coupling_reagent_expired)     solid_phase_peptide_synthesis |->          ($past(deprotection_cycle_efficiency) < complete_deprotection_threshold) &&         $past(synthesis_fidelity_monitoring_active)"}
{"sva": "@(posedge clk_microbalance) disable iff(vibration_isolation_compromised) quartz_crystal_microbalance_measurement |-> ($past(frequency_shift_detection_sensitivity) && $past(mass_loading_calculation)) && ($past(measurement_precision) < required_detection_limit)", "sva_description": "### Assertion description:  \n**Property Name**: p_Quartz_Crystal_Microbalance_Measurement  \n**Trigger Condition**: At every rising edge of the `clk_microbalance`  \n**Disable Condition**: `disable iff (vibration_isolation_compromised)`  \n**Antecedent (LHS of Implication)**: `quartz_crystal_microbalance_measurement`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(frequency_shift_detection_sensitivity) && $past(mass_loading_calculation)) && ($past(measurement_precision) < required_detection_limit)`  \n\nThe assertion checks that whenever the `quartz_crystal_microbalance_measurement` signal is active (antecedent), the following conditions must hold (consequent):  \n1. The past values of `frequency_shift_detection_sensitivity` and `mass_loading_calculation` must both be true (`$past` of these signals evaluated as logical AND).  \n2. The past value of `measurement_precision` must be less than the `required_detection_limit`.  \nThe assertion is disabled if `vibration_isolation_compromised` is active.", "sva_signals": ["clk_microbalance", "vibration_isolation_compromised", "[0:0] quartz_crystal_microbalance_measurement", "[0:0] frequency_shift_detection_sensitivity", "[0:0] mass_loading_calculation", "[0:0] measurement_precision", "[0:0] required_detection_limit"], "clock": "clk_microbalance", "attempts_left": 10, "sva_result": "@(posedge clk_microbalance) disable iff (vibration_isolation_compromised)     quartz_crystal_microbalance_measurement |->          ($past(frequency_shift_detection_sensitivity) &&           $past(mass_loading_calculation)) &&          ($past(measurement_precision) < required_detection_limit)", "sva_name": "p_quartz_crystal_microbalance_measurement_preconditions", "id": "3506", "full_property": "property p_Quartz_Crystal_Microbalance_Measurement;\n@(posedge clk_microbalance) disable iff (vibration_isolation_compromised)     quartz_crystal_microbalance_measurement |->          ($past(frequency_shift_detection_sensitivity) &&           $past(mass_loading_calculation)) &&          ($past(measurement_precision) < required_detection_limit)\nendproperty\nassert_p_Quartz_Crystal_Microbalance_Measurement:assert property (p_Quartz_Crystal_Microbalance_Measurement) else $error(\"\");", "task_id": "3_7088", "predict_sva": "@(posedge clk_microbalance) disable iff (vibration_isolation_compromised)         (vibration_isolation_compromised == 0 && quartz_crystal_microbalance_measurement == 1) |->          ($past(frequency_shift_detection_sensitivity) == 1 &&           $past(mass_loading_calculation) == 1 &&           $past(measurement_precision) < required_detection_limit)"}
{"sva": "@(posedge clk_slope_stability) disable iff(geotechnical_monitoring_suspended) open_pit_wall_stability |-> ($past(slope_displacement_measurement) > stability_threshold) && !$past(mining_operations_suspended_in_area, 12)", "sva_description": "### Assertion description:  \n**Property Name**: p_open_pit_wall_stability_check  \n**Trigger Condition**: At every rising edge of the `clk_slope_stability`  \n**Disable Condition**: disable iff (`geotechnical_monitoring_suspended`)  \n**Antecedent (LHS of Implication)**: `open_pit_wall_stability`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The past value of `slope_displacement_measurement` must be greater than `stability_threshold` (`$past(slope_displacement_measurement) > stability_threshold`)  \n- Mining operations must not have been suspended in the area for the past 12 cycles (`!$past(mining_operations_suspended_in_area, 12)`)  \n\nThe assertion ensures that if the open pit wall is stable (`open_pit_wall_stability` is true), then:  \n1. The previous slope displacement measurement exceeded the stability threshold, and  \n2. Mining operations were not suspended in the area for the last 12 clock cycles.  \nThe check is disabled if geotechnical monitoring is suspended (`geotechnical_monitoring_suspended` is true).", "sva_signals": ["clk", "geotechnical_monitoring_suspended", "open_pit_wall_stability", "slope_displacement_measurement", "stability_threshold", "mining_operations_suspended_in_area", "clk_slope_stability"], "clock": "clk_slope_stability", "attempts_left": 10, "sva_result": "@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)     open_pit_wall_stability |->          ($past(slope_displacement_measurement) > stability_threshold) &&         (!$past(mining_operations_suspended_in_area, 12))", "sva_name": "p_open_pit_wall_stability_prev_measurement_and_no_suspension", "id": "3528", "full_property": "property p_open_pit_wall_stability_check;\n@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)     open_pit_wall_stability |->          ($past(slope_displacement_measurement) > stability_threshold) &&         (!$past(mining_operations_suspended_in_area, 12))\nendproperty\nassert_p_open_pit_wall_stability_check:assert property (p_open_pit_wall_stability_check) else $error(\"\");", "task_id": "3_7110", "predict_sva": "@(posedge clk_slope_stability) disable iff (geotechnical_monitoring_suspended)         (geotechnical_monitoring_suspended == 0 && open_pit_wall_stability == 1) |->          ($past(slope_displacement_measurement) > stability_threshold) &&          ($past(mining_operations_suspended_in_area, 12) == 0)"}
{"sva": "@(posedge clk) disable iff(salvage_operation_in_progress) marine_casualty_response |-> ($past(vessel_stability_assessment) == critical_stability_condition) && !$past(emergency_response_team_deployment_confirmed, 15)", "sva_description": "### Assertion description:  \n**Property Name**: p_Marine_Casualty_Response  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (salvage_operation_in_progress)`  \n**Antecedent (LHS of Implication)**: `marine_casualty_response`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(vessel_stability_assessment) == critical_stability_condition) && !$past(emergency_response_team_deployment_confirmed, 15)`  \n\n", "sva_signals": ["clk", "salvage_operation_in_progress", "[0:0] marine_casualty_response", "vessel_stability_assessment", "critical_stability_condition", "emergency_response_team_deployment_confirmed"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (salvage_operation_in_progress)     marine_casualty_response |->          ($past(vessel_stability_assessment) == critical_stability_condition) &&          !$past(emergency_response_team_deployment_confirmed, 15)", "sva_name": "p_marine_casualty_response_stability_and_emergency_check", "id": "3568", "full_property": "property p_Marine_Casualty_Response;\n@(posedge clk) disable iff (salvage_operation_in_progress)     marine_casualty_response |->          ($past(vessel_stability_assessment) == critical_stability_condition) &&          !$past(emergency_response_team_deployment_confirmed, 15)\nendproperty\nassert_p_Marine_Casualty_Response:assert property (p_Marine_Casualty_Response) else $error(\"\");", "task_id": "3_7150", "predict_sva": "@(posedge clk) disable iff (salvage_operation_in_progress)         (salvage_operation_in_progress == 0 && marine_casualty_response == 1) |->          ($past(vessel_stability_assessment) == critical_stability_condition) &&          ($past(emergency_response_team_deployment_confirmed, 15) == 0)"}
{"sva": "@(posedge clk) disable iff(underwater_archaeology_site_protection) cultural_heritage_preservation |-> $past(archaeological_artifact_disturbance_sensor_triggered) && ($past(site_access_restriction_enforcement) != unauthorized_access_prevented)", "sva_description": "### Assertion description:  \n**Property Name**: p_Cultural_Heritage_Preservation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (underwater_archaeology_site_protection)`  \n**Antecedent (LHS of Implication)**: `cultural_heritage_preservation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(archaeological_artifact_disturbance_sensor_triggered) && ($past(site_access_restriction_enforcement) != unauthorized_access_prevented)`  ", "sva_signals": ["clk", "rst_n", "[0:0] underwater_archaeology_site_protection", "[0:0] cultural_heritage_preservation", "[0:0] archaeological_artifact_disturbance_sensor_triggered", "[0:0] site_access_restriction_enforcement", "[0:0] unauthorized_access_prevented"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (underwater_archaeology_site_protection)     cultural_heritage_preservation == 1'b1 |->      $past(archaeological_artifact_disturbance_sensor_triggered) &&      ($past(site_access_restriction_enforcement) != unauthorized_access_prevented)", "sva_name": "p_cultural_heritage_preservation_sensor_and_access_check", "id": "3609", "full_property": "property p_Cultural_Heritage_Preservation;\n@(posedge clk) disable iff (underwater_archaeology_site_protection)     cultural_heritage_preservation == 1'b1 |->      $past(archaeological_artifact_disturbance_sensor_triggered) &&      ($past(site_access_restriction_enforcement) != unauthorized_access_prevented)\nendproperty\nassert_p_Cultural_Heritage_Preservation:assert property (p_Cultural_Heritage_Preservation) else $error(\"\");", "task_id": "3_7189", "predict_sva": "@(posedge clk) disable iff (underwater_archaeology_site_protection)         (underwater_archaeology_site_protection == 0 && cultural_heritage_preservation == 1) |->          ($past(archaeological_artifact_disturbance_sensor_triggered) == 1) &&          ($past(site_access_restriction_enforcement) != unauthorized_access_prevented)"}
{"sva": "@(posedge clk) disable iff(agricultural_extension_service_recommendation_update) integrated_crop_management |-> $past(pest_disease_pressure_forecast) && ($past(preventive_treatment_application_timing) > optimal_intervention_window)", "sva_description": "### Assertion description:  \n**Property Name**: p_Integrated_Crop_Management_Check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (agricultural_extension_service_recommendation_update)`  \n**Antecedent (LHS of Implication)**: `integrated_crop_management`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(pest_disease_pressure_forecast) && ($past(preventive_treatment_application_timing) > optimal_intervention_window)`", "sva_signals": ["clk", "rst_n", "[0:0] agricultural_extension_service_recommendation_update", "[0:0] integrated_crop_management", "[0:0] pest_disease_pressure_forecast", "[0:0] preventive_treatment_application_timing", "[0:0] optimal_intervention_window"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (agricultural_extension_service_recommendation_update)     integrated_crop_management |->          ($past(pest_disease_pressure_forecast) &&           ($past(preventive_treatment_application_timing) > optimal_intervention_window))", "sva_name": "p_integrated_crop_management_prev_pressure_and_treatment_check", "id": "3619", "full_property": "property p_Integrated_Crop_Management_Check;\n@(posedge clk)     disable iff (agricultural_extension_service_recommendation_update)     integrated_crop_management |->          ($past(pest_disease_pressure_forecast) &&           ($past(preventive_treatment_application_timing) > optimal_intervention_window))\nendproperty\nassert_p_Integrated_Crop_Management_Check:assert property (p_Integrated_Crop_Management_Check) else $error(\"\");", "task_id": "3_7199", "predict_sva": "@(posedge clk) disable iff (agricultural_extension_service_recommendation_update)         (integrated_crop_management == 1 && agricultural_extension_service_recommendation_update == 0) |->          ($past(pest_disease_pressure_forecast) == 1 && $past(preventive_treatment_application_timing) > optimal_intervention_window)"}
{"sva": "@(posedge clk_harvester) disable iff(combine_header_maintenance_mode) crop_yield_monitoring |-> ($past(grain_flow_sensor_reading) < expected_yield_per_hectare) && $past(harvest_speed_optimization_disabled)", "sva_description": "### Assertion description:  \n**Property Name**: p_Crop_Yield_Monitoring  \n**Trigger Condition**: At every rising edge of the `clk_harvester`  \n**Disable Condition**: `disable iff (combine_header_maintenance_mode)`  \n**Antecedent (LHS of Implication)**: `crop_yield_monitoring == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(grain_flow_sensor_reading) < expected_yield_per_hectare) && $past(harvest_speed_optimization_disabled)`  \n\nThe assertion checks that whenever `crop_yield_monitoring` is active (high), the past value of `grain_flow_sensor_reading` must be less than `expected_yield_per_hectare`, and the past value of `harvest_speed_optimization_disabled` must be true (high). The check is disabled during `combine_header_maintenance_mode`.", "sva_signals": ["clk_harvester", "combine_header_maintenance_mode", "[0:0] crop_yield_monitoring", "[0:0] grain_flow_sensor_reading", "[0:0] expected_yield_per_hectare", "[0:0] harvest_speed_optimization_disabled"], "clock": "clk_harvester", "attempts_left": 10, "sva_result": "@(posedge clk_harvester) disable iff (combine_header_maintenance_mode)     crop_yield_monitoring == 1'b1 |->          ($past(grain_flow_sensor_reading) < expected_yield_per_hectare) &&          $past(harvest_speed_optimization_disabled)", "sva_name": "p_Crop_Yield_Monitoring", "id": "3639", "full_property": "property p_Crop_Yield_Monitoring;\n@(posedge clk_harvester) disable iff (combine_header_maintenance_mode)     crop_yield_monitoring == 1'b1 |->          ($past(grain_flow_sensor_reading) < expected_yield_per_hectare) &&          $past(harvest_speed_optimization_disabled)\nendproperty\nassert_p_Crop_Yield_Monitoring:assert property (p_Crop_Yield_Monitoring) else $error(\"\");", "task_id": "3_7219", "predict_sva": "@(posedge clk_harvester) disable iff (combine_header_maintenance_mode)     crop_yield_monitoring |->          ($past(grain_flow_sensor_reading) < expected_yield_per_hectare) &&         ($past(harvest_speed_optimization_disabled) == 1'b1)"}
{"sva": "@(posedge clk_crop_rotation) disable iff(!sustainable_agriculture_practice_compliance) soil_health_improvement |-> ($past(nitrogen_fixing_crop_establishment) && $past(soil_biology_activity_measurement)) && ($past(organic_matter_accumulation_rate) < soil_health_improvement_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_soil_health_improvement_check  \n**Trigger Condition**: At every rising edge of the `clk_crop_rotation`  \n**Disable Condition**: disable iff (!sustainable_agriculture_practice_compliance)  \n**Antecedent (LHS of Implication)**: `soil_health_improvement == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of two conditions:  \n  1. `$past(nitrogen_fixing_crop_establishment) && $past(soil_biology_activity_measurement)`  \n  2. `$past(organic_matter_accumulation_rate) < soil_health_improvement_target`  \n\nThe assertion checks that whenever `soil_health_improvement` is active (high), the following must hold true at the next clock cycle:  \n1. Both `nitrogen_fixing_crop_establishment` and `soil_biology_activity_measurement` were active in the previous cycle.  \n2. The past value of `organic_matter_accumulation_rate` must be less than the `soil_health_improvement_target`.  \nThe assertion is disabled if `sustainable_agriculture_practice_compliance` is low.", "sva_signals": ["clk_crop_rotation", "sustainable_agriculture_practice_compliance", "[0:0] soil_health_improvement", "[0:0] nitrogen_fixing_crop_establishment", "[0:0] soil_biology_activity_measurement", "[0:0] organic_matter_accumulation_rate", "[0:0] soil_health_improvement_target"], "clock": "clk_crop_rotation", "attempts_left": 10, "sva_result": "@(posedge clk_crop_rotation) disable iff (!sustainable_agriculture_practice_compliance)     soil_health_improvement == 1'b1 |->     ($past(nitrogen_fixing_crop_establishment) && $past(soil_biology_activity_measurement)) &&     ($past(organic_matter_accumulation_rate) < soil_health_improvement_target)", "sva_name": "p_soil_health_improvement_preconditions", "id": "3640", "full_property": "property p_soil_health_improvement_check;\n@(posedge clk_crop_rotation) disable iff (!sustainable_agriculture_practice_compliance)     soil_health_improvement == 1'b1 |->     ($past(nitrogen_fixing_crop_establishment) && $past(soil_biology_activity_measurement)) &&     ($past(organic_matter_accumulation_rate) < soil_health_improvement_target)\nendproperty\nassert_p_soil_health_improvement_check:assert property (p_soil_health_improvement_check) else $error(\"\");", "task_id": "3_7220", "predict_sva": "@(posedge clk_crop_rotation) disable iff (!sustainable_agriculture_practice_compliance)         (sustainable_agriculture_practice_compliance == 1 && soil_health_improvement == 1) |->          ($past(nitrogen_fixing_crop_establishment) == 1 && $past(soil_biology_activity_measurement) == 1) &&          ($past(organic_matter_accumulation_rate) < soil_health_improvement_target)"}
{"sva": "@(posedge clk) disable iff(textile_mill_energy_efficiency_optimization) production_line_power_consumption |-> ($past(machine_utilization_rate) < optimal_efficiency_threshold) && ($past(energy_cost_per_unit_production) == cost_target_exceeded)", "sva_description": "### Assertion description:  \n**Property Name**: p_Production_Line_Power_Consumption  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`textile_mill_energy_efficiency_optimization`)  \n**Antecedent (LHS of Implication)**: `production_line_power_consumption == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(machine_utilization_rate) < optimal_efficiency_threshold) && ($past(energy_cost_per_unit_production) == cost_target_exceeded)`  ", "sva_signals": ["clk", "rst_n", "[0:0] textile_mill_energy_efficiency_optimization", "[0:0] production_line_power_consumption", "[0:0] machine_utilization_rate", "[0:0] optimal_efficiency_threshold", "[0:0] energy_cost_per_unit_production", "[0:0] cost_target_exceeded"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (textile_mill_energy_efficiency_optimization)     production_line_power_consumption == 1'b1 |->          ($past(machine_utilization_rate) < optimal_efficiency_threshold) &&          ($past(energy_cost_per_unit_production) == cost_target_exceeded)", "sva_name": "p_production_line_power_consumption_efficiency_check", "id": "3672", "full_property": "property p_Production_Line_Power_Consumption;\n@(posedge clk) disable iff (textile_mill_energy_efficiency_optimization)     production_line_power_consumption == 1'b1 |->          ($past(machine_utilization_rate) < optimal_efficiency_threshold) &&          ($past(energy_cost_per_unit_production) == cost_target_exceeded)\nendproperty\nassert_p_Production_Line_Power_Consumption:assert property (p_Production_Line_Power_Consumption) else $error(\"\");", "task_id": "3_7250", "predict_sva": "@(posedge clk) disable iff (textile_mill_energy_efficiency_optimization)         (textile_mill_energy_efficiency_optimization == 0 && production_line_power_consumption == 1) |->          ($past(machine_utilization_rate) < optimal_efficiency_threshold) &&          ($past(energy_cost_per_unit_production) == cost_target_exceeded)"}
{"sva": "@(posedge clk_esports_tournament) disable iff(!tournament_infrastructure_monitoring_active) competitive_event_technical_reliability |-> $past(server_performance_stability_verification) && ($past(broadcast_quality_assurance_validation) < professional_esports_standard_requirement)", "sva_description": "### Assertion description:  \n**Property Name**: p_CompetitiveEventTechnicalReliability  \n**Trigger Condition**: At every rising edge of `clk_esports_tournament`  \n**Disable Condition**: `disable iff (!tournament_infrastructure_monitoring_active)`  \n**Antecedent (LHS of Implication)**: `competitive_event_technical_reliability`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(server_performance_stability_verification) && ($past(broadcast_quality_assurance_validation) < professional_esports_standard_requirement)`  ", "sva_signals": ["clk_esports_tournament", "tournament_infrastructure_monitoring_active", "[0:0] competitive_event_technical_reliability", "[0:0] server_performance_stability_verification", "[0:0] broadcast_quality_assurance_validation", "[0:0] professional_esports_standard_requirement"], "clock": "clk_esports_tournament", "attempts_left": 10, "sva_result": "@(posedge clk_esports_tournament) disable iff (!tournament_infrastructure_monitoring_active)     competitive_event_technical_reliability |->          $past(server_performance_stability_verification) &&          ($past(broadcast_quality_assurance_validation) < professional_esports_standard_requirement)", "sva_name": "p_competitive_event_technical_reliability", "id": "3811", "full_property": "property p_CompetitiveEventTechnicalReliability;\n@(posedge clk_esports_tournament) disable iff (!tournament_infrastructure_monitoring_active)     competitive_event_technical_reliability |->          $past(server_performance_stability_verification) &&          ($past(broadcast_quality_assurance_validation) < professional_esports_standard_requirement)\nendproperty\nassert_p_CompetitiveEventTechnicalReliability:assert property (p_CompetitiveEventTechnicalReliability) else $error(\"\");", "task_id": "3_7385", "predict_sva": "@(posedge clk_esports_tournament) disable iff (!tournament_infrastructure_monitoring_active)     competitive_event_technical_reliability |->          $past(server_performance_stability_verification) &&          ($past(broadcast_quality_assurance_validation) < professional_esports_standard_requirement)"}
{"sva": "@(posedge clk) disable iff(cosmic_ray_background_interference_high) dark_matter_detection_experiment |-> ($past(detector_shielding_effectiveness_verification) && $past(background_event_discrimination_capability)) && ($past(dark_matter_signal_sensitivity) != detection_threshold_achievement_confirmation)", "sva_description": "### Assertion description:  \n**Property Name**: p_Dark_Matter_Detection_Experiment  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (cosmic_ray_background_interference_high)`  \n**Antecedent (LHS of Implication)**: `dark_matter_detection_experiment`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($past(detector_shielding_effectiveness_verification) && $past(background_event_discrimination_capability)) && ($past(dark_matter_signal_sensitivity) != detection_threshold_achievement_confirmation)`  ", "sva_signals": ["clk", "cosmic_ray_background_interference_high", "dark_matter_detection_experiment", "detector_shielding_effectiveness_verification", "background_event_discrimination_capability", "dark_matter_signal_sensitivity", "detection_threshold_achievement_confirmation"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (cosmic_ray_background_interference_high)     dark_matter_detection_experiment |->      ($past(detector_shielding_effectiveness_verification) &&       $past(background_event_discrimination_capability)) &&      ($past(dark_matter_signal_sensitivity) != detection_threshold_achievement_confirmation)", "sva_name": "p_Dark_Matter_Detection_Check", "id": "3885", "full_property": "property p_Dark_Matter_Detection_Experiment;\n@(posedge clk) disable iff (cosmic_ray_background_interference_high)     dark_matter_detection_experiment |->      ($past(detector_shielding_effectiveness_verification) &&       $past(background_event_discrimination_capability)) &&      ($past(dark_matter_signal_sensitivity) != detection_threshold_achievement_confirmation)\nendproperty\nassert_p_Dark_Matter_Detection_Experiment:assert property (p_Dark_Matter_Detection_Experiment) else $error(\"\");", "task_id": "3_7457", "predict_sva": "@(posedge clk) disable iff (cosmic_ray_background_interference_high)     dark_matter_detection_experiment |->          ($past(detector_shielding_effectiveness_verification) &&           $past(background_event_discrimination_capability)) &&         ($past(dark_matter_signal_sensitivity) != detection_threshold_achievement_confirmation)"}
{"sva": "@(posedge clk) disable iff(tourism_innovation_ecosystem_collaboration_platform_deployment) destination_competitiveness_enhancement |-> ($past(innovation_capacity_building_initiative_outcome) && $past(tourism_entrepreneur_support_program_effectiveness)) && ($past(destination_innovation_leadership_achievement) == tourism_sector_transformation_competitive_advantage_realization_shortfall)", "sva_description": "### Assertion description:  \n**Property Name**: p_Destination_Competitiveness_Enhancement  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: `disable iff (tourism_innovation_ecosystem_collaboration_platform_deployment)`  \n**Antecedent (LHS of Implication)**: `destination_competitiveness_enhancement == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that both `$past(innovation_capacity_building_initiative_outcome)` and `$past(tourism_entrepreneur_support_program_effectiveness)` are true (logical AND),  \n- AND the past value of `destination_innovation_leadership_achievement` (`$past(destination_innovation_leadership_achievement)`) must equal the current value of `tourism_sector_transformation_competitive_advantage_realization_shortfall`.  \n\n### Notes:  \n1. The consequent combines two conditions with a logical AND (`&&`):  \n   - Historical validity of two initiative outcomes (`innovation_capacity_building_initiative_outcome` and `tourism_entrepreneur_support_program_effectiveness`).  \n   - A comparison between a past leadership achievement and a current shortfall metric.  \n2. The disable condition is triggered if `tourism_innovation_ecosystem_collaboration_platform_deployment` is active.", "sva_signals": ["clk", "[0:0] tourism_innovation_ecosystem_collaboration_platform_deployment", "[0:0] destination_competitiveness_enhancement", "[0:0] innovation_capacity_building_initiative_outcome", "[0:0] tourism_entrepreneur_support_program_effectiveness", "[0:0] destination_innovation_leadership_achievement", "[0:0] tourism_sector_transformation_competitive_advantage_realization_shortfall"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     disable iff (tourism_innovation_ecosystem_collaboration_platform_deployment)     destination_competitiveness_enhancement == 1'b1 |->     ($past(innovation_capacity_building_initiative_outcome) &&       $past(tourism_entrepreneur_support_program_effectiveness)) &&     ($past(destination_innovation_leadership_achievement) ==       tourism_sector_transformation_competitive_advantage_realization_shortfall)", "sva_name": "p_Destination_Competitiveness_Enhancement", "id": "3758", "full_property": "property p_Destination_Competitiveness_Enhancement;\n@(posedge clk)     disable iff (tourism_innovation_ecosystem_collaboration_platform_deployment)     destination_competitiveness_enhancement == 1'b1 |->     ($past(innovation_capacity_building_initiative_outcome) &&       $past(tourism_entrepreneur_support_program_effectiveness)) &&     ($past(destination_innovation_leadership_achievement) ==       tourism_sector_transformation_competitive_advantage_realization_shortfall)\nendproperty\nassert_p_Destination_Competitiveness_Enhancement:assert property (p_Destination_Competitiveness_Enhancement) else $error(\"\");", "task_id": "3_7334", "predict_sva": "@(posedge clk) disable iff (tourism_innovation_ecosystem_collaboration_platform_deployment)     destination_competitiveness_enhancement == 1'b1 |->      ($past(innovation_capacity_building_initiative_outcome) == 1'b1) &&     ($past(tourism_entrepreneur_support_program_effectiveness) == 1'b1) &&     ($past(destination_innovation_leadership_achievement) == tourism_sector_transformation_competitive_advantage_realization_shortfall)"}
{"sva": "@(posedge clk_quantum_dots) disable iff(semiconductor_heterostructure_quality_degraded) artificial_atom_spectroscopy |-> ($past(quantum_confinement_energy_level_calculation_accuracy) && $past(optical_transition_linewidth_measurement_precision)) && ($past(single_photon_emission_purity_verification) < quantum_dot_device_performance_specification)", "sva_description": "### Assertion description:  \n**Property Name**: p_artificial_atom_spectroscopy_quality_check  \n**Trigger Condition**: At every rising edge of the `clk_quantum_dots`  \n**Disable Condition**: `disable iff (semiconductor_heterostructure_quality_degraded)`  \n**Antecedent (LHS of Implication)**: `artificial_atom_spectroscopy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- Requires that both:  \n  1. The past values of `quantum_confinement_energy_level_calculation_accuracy` and `optical_transition_linewidth_measurement_precision` are true (logical AND), **and**  \n  2. The past value of `single_photon_emission_purity_verification` is strictly less than `quantum_dot_device_performance_specification`.  \n\n### Key Notes:  \n1. **Temporal Dependencies**: The assertion evaluates past values (`$past`) of three signals and compares one against a specification threshold.  \n2. **Disable Condition**: The check is aborted if `semiconductor_heterostructure_quality_degraded` is active (e.g., during fault conditions).  \n3. **Consequent Logic**: Combines a logical AND with a numerical inequality, ensuring both accuracy metrics and purity standards are met.  \n\n*(Formatted for clarity in verification documentation.)*", "sva_signals": ["clk", "semiconductor_heterostructure_quality_degraded", "artificial_atom_spectroscopy", "quantum_confinement_energy_level_calculation_accuracy", "optical_transition_linewidth_measurement_precision", "single_photon_emission_purity_verification", "quantum_dot_device_performance_specification", "clk_quantum_dots"], "clock": "clk_quantum_dots", "attempts_left": 10, "sva_result": "@(posedge clk_quantum_dots) disable iff (semiconductor_heterostructure_quality_degraded)     artificial_atom_spectroscopy == 1'b1 |->      ($past(quantum_confinement_energy_level_calculation_accuracy) &&       $past(optical_transition_linewidth_measurement_precision)) &&     ($past(single_photon_emission_purity_verification) < quantum_dot_device_performance_specification)", "sva_name": "p_Artificial_Atom_Spectroscopy_Check", "id": "3916", "full_property": "property p_artificial_atom_spectroscopy_quality_check;\n@(posedge clk_quantum_dots) disable iff (semiconductor_heterostructure_quality_degraded)     artificial_atom_spectroscopy == 1'b1 |->      ($past(quantum_confinement_energy_level_calculation_accuracy) &&       $past(optical_transition_linewidth_measurement_precision)) &&     ($past(single_photon_emission_purity_verification) < quantum_dot_device_performance_specification)\nendproperty\nassert_p_artificial_atom_spectroscopy_quality_check:assert property (p_artificial_atom_spectroscopy_quality_check) else $error(\"\");", "task_id": "3_7487", "predict_sva": "@(posedge clk_quantum_dots) disable iff (semiconductor_heterostructure_quality_degraded)     artificial_atom_spectroscopy == 1'b1 |->      ($past(quantum_confinement_energy_level_calculation_accuracy) &&       $past(optical_transition_linewidth_measurement_precision)) &&     ($past(single_photon_emission_purity_verification) < quantum_dot_device_performance_specification)"}
{"sva": "@(posedge clk_financial_technology_regulation) disable iff(!regulatory_technology_implementation_assessment_complete) regtech_compliance_automation |-> $past(regulatory_change_management_effectiveness) && ($past(compliance_cost_reduction_quantification) < regulatory_technology_efficiency_improvement_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_regtech_compliance_automation  \n**Trigger Condition**: At every rising edge of the `clk_financial_technology_regulation`  \n**Disable Condition**: `disable iff (!regulatory_technology_implementation_assessment_complete)`  \n**Antecedent (LHS of Implication)**: `regtech_compliance_automation == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(regulatory_change_management_effectiveness) && ($past(compliance_cost_reduction_quantification) < regulatory_technology_efficiency_improvement_target)`  ", "sva_signals": ["clk_financial_technology_regulation", "regulatory_technology_implementation_assessment_complete", "[0:0] regtech_compliance_automation", "[0:0] regulatory_change_management_effectiveness", "[0:0] compliance_cost_reduction_quantification", "[0:0] regulatory_technology_efficiency_improvement_target"], "clock": "clk_financial_technology_regulation", "attempts_left": 10, "sva_result": "@(posedge clk_financial_technology_regulation) disable iff (!regulatory_technology_implementation_assessment_complete)     regtech_compliance_automation == 1'b1 |->      $past(regulatory_change_management_effectiveness) &&      ($past(compliance_cost_reduction_quantification) < regulatory_technology_efficiency_improvement_target)", "sva_name": "p_regtech_compliance_automation_effectiveness_and_cost_reduction", "id": "3924", "full_property": "property p_regtech_compliance_automation;\n@(posedge clk_financial_technology_regulation) disable iff (!regulatory_technology_implementation_assessment_complete)     regtech_compliance_automation == 1'b1 |->      $past(regulatory_change_management_effectiveness) &&      ($past(compliance_cost_reduction_quantification) < regulatory_technology_efficiency_improvement_target)\nendproperty\nassert_p_regtech_compliance_automation:assert property (p_regtech_compliance_automation) else $error(\"\");", "task_id": "3_7495", "predict_sva": "@(posedge clk_financial_technology_regulation) disable iff (!regulatory_technology_implementation_assessment_complete)         (regulatory_technology_implementation_assessment_complete == 1 && regtech_compliance_automation == 1) |->          ($past(regulatory_change_management_effectiveness) == 1 &&           $past(compliance_cost_reduction_quantification) < regulatory_technology_efficiency_improvement_target)"}
{"sva": "@(posedge clk_cavity_quantum_electrodynamics) disable iff(!optical_cavity_finesse_optimization_complete) strong_coupling_regime_investigation |-> $past(atom_cavity_coupling_strength_measurement) && ($past(vacuum_rabi_splitting_observation_clarity) < quantum_optics_phenomena_demonstration_threshold)", "sva_description": "### Assertion description:  \n**Property Name**: p_Strong_Coupling_Regime_Investigation  \n**Trigger Condition**: At every rising edge of the `clk_cavity_quantum_electrodynamics`  \n**Disable Condition**: `disable iff (!optical_cavity_finesse_optimization_complete)`  \n**Antecedent (LHS of Implication)**: `strong_coupling_regime_investigation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(atom_cavity_coupling_strength_measurement) && ($past(vacuum_rabi_splitting_observation_clarity) < quantum_optics_phenomena_demonstration_threshold)`  \n\n", "sva_signals": ["clk_cavity_quantum_electrodynamics", "optical_cavity_finesse_optimization_complete", "[0:0] strong_coupling_regime_investigation", "[0:0] atom_cavity_coupling_strength_measurement", "[0:0] vacuum_rabi_splitting_observation_clarity", "[0:0] quantum_optics_phenomena_demonstration_threshold"], "clock": "clk_cavity_quantum_electrodynamics", "attempts_left": 10, "sva_result": "@(posedge clk_cavity_quantum_electrodynamics) disable iff (!optical_cavity_finesse_optimization_complete)     strong_coupling_regime_investigation |->      $past(atom_cavity_coupling_strength_measurement) &&      ($past(vacuum_rabi_splitting_observation_clarity) < quantum_optics_phenomena_demonstration_threshold)", "sva_name": "p_strong_coupling_regime_investigation", "id": "3934", "full_property": "property p_Strong_Coupling_Regime_Investigation;\n@(posedge clk_cavity_quantum_electrodynamics) disable iff (!optical_cavity_finesse_optimization_complete)     strong_coupling_regime_investigation |->      $past(atom_cavity_coupling_strength_measurement) &&      ($past(vacuum_rabi_splitting_observation_clarity) < quantum_optics_phenomena_demonstration_threshold)\nendproperty\nassert_p_Strong_Coupling_Regime_Investigation:assert property (p_Strong_Coupling_Regime_Investigation) else $error(\"\");", "task_id": "3_7505", "predict_sva": "@(posedge clk_cavity_quantum_electrodynamics) disable iff (!optical_cavity_finesse_optimization_complete)     strong_coupling_regime_investigation |->          ($past(atom_cavity_coupling_strength_measurement) &&           ($past(vacuum_rabi_splitting_observation_clarity) < quantum_optics_phenomena_demonstration_threshold))"}
{"sva": "@(posedge clk_sample_collection) disable iff(!planetary_protection_protocol_compliance_verified) extraterrestrial_sample_acquisition |-> $past(contamination_prevention_procedure_implementation) && ($past(sample_integrity_preservation_effectiveness) < scientific_analysis_validity_standard)", "sva_description": "### Assertion description:  \n**Property Name**: p_Extraterrestrial_Sample_Acquisition_Check  \n**Trigger Condition**: At every rising edge of `clk_sample_collection`  \n**Disable Condition**: `disable iff (!planetary_protection_protocol_compliance_verified)`  \n**Antecedent (LHS of Implication)**: `extraterrestrial_sample_acquisition == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(contamination_prevention_procedure_implementation) && ($past(sample_integrity_preservation_effectiveness) < scientific_analysis_validity_standard)`  ", "sva_signals": ["clk", "rst_n", "[0:0] extraterrestrial_sample_acquisition", "[0:0] planetary_protection_protocol_compliance_verified", "[0:0] contamination_prevention_procedure_implementation", "[0:0] sample_integrity_preservation_effectiveness", "[0:0] scientific_analysis_validity_standard", "clk_sample_collection"], "clock": "clk_sample_collection", "attempts_left": 10, "sva_result": "@(posedge clk_sample_collection) disable iff (!planetary_protection_protocol_compliance_verified)     extraterrestrial_sample_acquisition == 1'b1 |->     $past(contamination_prevention_procedure_implementation) &&      ($past(sample_integrity_preservation_effectiveness) < scientific_analysis_validity_standard)", "sva_name": "p_extraterrestrial_sample_acquisition_precondition", "id": "3959", "full_property": "property p_Extraterrestrial_Sample_Acquisition_Check;\n@(posedge clk_sample_collection) disable iff (!planetary_protection_protocol_compliance_verified)     extraterrestrial_sample_acquisition == 1'b1 |->     $past(contamination_prevention_procedure_implementation) &&      ($past(sample_integrity_preservation_effectiveness) < scientific_analysis_validity_standard)\nendproperty\nassert_p_Extraterrestrial_Sample_Acquisition_Check:assert property (p_Extraterrestrial_Sample_Acquisition_Check) else $error(\"\");", "task_id": "3_7530", "predict_sva": "@(posedge clk_sample_collection) disable iff (!planetary_protection_protocol_compliance_verified)         (planetary_protection_protocol_compliance_verified == 1 && extraterrestrial_sample_acquisition == 1) |->          ($past(contamination_prevention_procedure_implementation) == 1 &&           $past(sample_integrity_preservation_effectiveness) < scientific_analysis_validity_standard)"}
{"sva": "@(negedge clk_rehabilitation) disable iff(patient_fatigue_level_excessive) physical_therapy_progress_monitoring |-> ($past(range_of_motion_improvement_measurement) && $past(muscle_strength_recovery_assessment)) && ($past(functional_independence_achievement_rate) < rehabilitation_outcome_target_expectation)", "sva_description": "### Assertion description:  \n**Property Name**: p_Rehabilitation_Progress_Monitoring  \n**Trigger Condition**: At every falling edge of the `clk_rehabilitation`;  \n**Disable Condition**: disable iff (`patient_fatigue_level_excessive`)  \n**Antecedent (LHS of Implication)**: `physical_therapy_progress_monitoring`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- The logical AND of:  \n  1. `$past(range_of_motion_improvement_measurement)`  \n  2. `$past(muscle_strength_recovery_assessment)`  \n- AND the condition:  \n  `$past(functional_independence_achievement_rate) < rehabilitation_outcome_target_expectation`  ", "sva_signals": ["clk_rehabilitation", "patient_fatigue_level_excessive", "physical_therapy_progress_monitoring", "range_of_motion_improvement_measurement", "muscle_strength_recovery_assessment", "functional_independence_achievement_rate", "rehabilitation_outcome_target_expectation"], "clock": "clk_rehabilitation", "attempts_left": 10, "sva_result": "@(negedge clk_rehabilitation) disable iff (patient_fatigue_level_excessive)     physical_therapy_progress_monitoring |->      ($past(range_of_motion_improvement_measurement) &&       $past(muscle_strength_recovery_assessment)) &&     ($past(functional_independence_achievement_rate) < rehabilitation_outcome_target_expectation)", "sva_name": "p_physical_therapy_progress_monitoring", "id": "4014", "full_property": "property p_Rehabilitation_Progress_Monitoring;\n@(negedge clk_rehabilitation) disable iff (patient_fatigue_level_excessive)     physical_therapy_progress_monitoring |->      ($past(range_of_motion_improvement_measurement) &&       $past(muscle_strength_recovery_assessment)) &&     ($past(functional_independence_achievement_rate) < rehabilitation_outcome_target_expectation)\nendproperty\nassert_p_Rehabilitation_Progress_Monitoring:assert property (p_Rehabilitation_Progress_Monitoring) else $error(\"\");", "task_id": "3_7583", "predict_sva": "@(negedge clk_rehabilitation) disable iff (patient_fatigue_level_excessive)     physical_therapy_progress_monitoring |->          ($past(range_of_motion_improvement_measurement) &&           $past(muscle_strength_recovery_assessment) &&           ($past(functional_independence_achievement_rate) < rehabilitation_outcome_target_expectation))"}
{"id": "312_6_0103", "name": "p_err_flag_clearing", "sva": "@(posedge clk_signal)     $fell(global_err_int) |-> !(parity_err || timeout_err || protocol_err)", "ori_sva": "property p_err_flag_clearing;\n@(posedge clk_signal)     $fell(global_err_int) |-> !(parity_err || timeout_err || protocol_err)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_No_Error_After_Fell  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(global_err_int)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(parity_err || timeout_err || protocol_err)`", "sva_signals": ["clk_signal", "[0:0] global_err_int", "[0:0] parity_err", "[0:0] timeout_err", "[0:0] protocol_err"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(global_err_int) |-> !(parity_err || timeout_err || protocol_err)", "sva_name": "p_no_error_asserted_on_global_err_int_fall", "full_property": "property p_No_Error_After_Fell;\n@(posedge clk_signal)     $fell(global_err_int) |-> !(parity_err || timeout_err || protocol_err)\nendproperty\nassert_p_No_Error_After_Fell:assert property (p_No_Error_After_Fell) else $error(\"\");", "task_id": "3_7694", "predict_sva": "@(posedge clk_signal)         $fell(global_err_int) |-> (parity_err == 0 && timeout_err == 0 && protocol_err == 0)"}
{"id": "315_1_0143", "name": "pwr_seq_control_1", "sva": "@(posedge clk_sys)     $rose(pwr_en) |-> (vdd_ok || bypass_mode)", "ori_sva": "property pwr_seq_control_1;\n@(posedge clk_sys)     $rose(pwr_en) |-> (vdd_ok || bypass_mode);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pwr_Enable_Check  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pwr_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(vdd_ok || bypass_mode)`  ", "sva_signals": ["clk_sys", "[0:0] pwr_en", "[0:0] vdd_ok", "[0:0] bypass_mode"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(pwr_en) |-> (vdd_ok || bypass_mode)", "sva_name": "pwr_en_rise_requires_vdd_or_bypass", "full_property": "property p_Pwr_Enable_Check;\n@(posedge clk_sys)         $rose(pwr_en) |-> (vdd_ok || bypass_mode)\nendproperty\nassert_p_Pwr_Enable_Check:assert property (p_Pwr_Enable_Check) else $error(\"\");", "task_id": "3_7710", "predict_sva": "@(posedge clk_sys)         $rose(pwr_en) |-> (vdd_ok == 1 || bypass_mode == 1)"}
{"id": "316_2_0119", "name": "p_temp_not_ready_no_adc_start_2", "sva": "@(negedge clk_sys)     $fell(temp_ready) |=> !adc_start", "ori_sva": "property p_temp_not_ready_no_adc_start_2;\n@(negedge clk_sys)     $fell(temp_ready) |=> !adc_start;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_start_after_temp_ready_fall  \n**Trigger Condition**: At every negedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(temp_ready)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!adc_start`", "sva_signals": ["clk_sys", "[0:0] temp_ready", "[0:0] adc_start"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(negedge clk_sys)     $fell(temp_ready) |=> !adc_start", "sva_name": "p_adc_start_not_after_temp_ready_fall", "full_property": "property p_adc_start_after_temp_ready_fall;\n@(negedge clk_sys)     $fell(temp_ready) |=> !adc_start\nendproperty\nassert_p_adc_start_after_temp_ready_fall:assert property (p_adc_start_after_temp_ready_fall) else $error(\"\");", "task_id": "3_7717", "predict_sva": "@(negedge clk_sys)         $fell(temp_ready) |-> adc_start == 0"}
{"sva": "@(posedge clk_healthcare_sustainability) disable iff(!environmental_health_impact_assessment_methodology_validated) green_healthcare_system_transformation |-> $past(healthcare_carbon_footprint_reduction_strategy_implementation) && ($past(sustainable_healthcare_practice_adoption_effectiveness) < environmental_stewardship_healthcare_sector_leadership_target)", "sva_description": "### Assertion description:  \n**Property Name**: p_Green_Healthcare_System_Transformation  \n**Trigger Condition**: At every rising edge of the `clk_healthcare_sustainability`  \n**Disable Condition**: `disable iff (!environmental_health_impact_assessment_methodology_validated)`  \n**Antecedent (LHS of Implication)**: `green_healthcare_system_transformation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(healthcare_carbon_footprint_reduction_strategy_implementation) && ($past(sustainable_healthcare_practice_adoption_effectiveness) < environmental_stewardship_healthcare_sector_leadership_target)`  ", "sva_signals": ["clk_healthcare_sustainability", "environmental_health_impact_assessment_methodology_validated", "[0:0] green_healthcare_system_transformation", "[0:0] healthcare_carbon_footprint_reduction_strategy_implementation", "[0:0] sustainable_healthcare_practice_adoption_effectiveness", "[0:0] environmental_stewardship_healthcare_sector_leadership_target"], "clock": "clk_healthcare_sustainability", "attempts_left": 10, "sva_result": "@(posedge clk_healthcare_sustainability) disable iff (!environmental_health_impact_assessment_methodology_validated)     green_healthcare_system_transformation |->      ($past(healthcare_carbon_footprint_reduction_strategy_implementation) &&       ($past(sustainable_healthcare_practice_adoption_effectiveness) < environmental_stewardship_healthcare_sector_leadership_target))", "sva_name": "p_green_healthcare_transformation_dependency", "id": "4030", "full_property": "property p_Green_Healthcare_System_Transformation;\n@(posedge clk_healthcare_sustainability) disable iff (!environmental_health_impact_assessment_methodology_validated)     green_healthcare_system_transformation |->      ($past(healthcare_carbon_footprint_reduction_strategy_implementation) &&       ($past(sustainable_healthcare_practice_adoption_effectiveness) < environmental_stewardship_healthcare_sector_leadership_target))\nendproperty\nassert_p_Green_Healthcare_System_Transformation:assert property (p_Green_Healthcare_System_Transformation) else $error(\"\");", "task_id": "3_7599", "predict_sva": "@(posedge clk_healthcare_sustainability) disable iff (!environmental_health_impact_assessment_methodology_validated)         (environmental_health_impact_assessment_methodology_validated == 1 && green_healthcare_system_transformation == 1) |->          ($past(healthcare_carbon_footprint_reduction_strategy_implementation) == 1) &&          ($past(sustainable_healthcare_practice_adoption_effectiveness) < environmental_stewardship_healthcare_sector_leadership_target)"}
{"id": "317_2_0130", "name": "key_integrity_check_2", "sva": "@(posedge clk_signal)     key_valid |=> (key_reg ^ ~key_check) == 0", "ori_sva": "property key_integrity_check_2;\n@(posedge clk_signal)     key_valid |=> (key_reg ^ ~key_check) == 0;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_key_valid_check  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `key_valid == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `(key_reg ^ ~key_check) == 0`  ", "sva_signals": ["clk_signal", "[0:0] key_valid", "[0:0] key_reg", "[0:0] key_check"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     key_valid == 1'b1 |=> (key_reg ^ ~key_check) == 0", "sva_name": "p_key_reg_xor_key_check_not", "full_property": "property p_key_valid_check;\n@(posedge clk_signal)     key_valid == 1'b1 |=> (key_reg ^ ~key_check) == 0\nendproperty\nassert_p_key_valid_check:assert property (p_key_valid_check) else $error(\"\");", "task_id": "3_7725", "predict_sva": "@(posedge clk_signal)         key_valid == 1'b1 |-> (key_reg ^ ~key_check) == 0"}
{"id": "318_3_0153", "name": "wakeup_rtc_only", "sva": "@(posedge clk_sys)     $rose(rtc_wakeup) && !gpio_wakeup && !comm_wakeup |-> ##2 sys_wakeup", "ori_sva": "property wakeup_rtc_only;\n@(posedge clk_sys)     $rose(rtc_wakeup) && !gpio_wakeup && !comm_wakeup |-> ##2 sys_wakeup;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sys_wakeup_trigger  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(rtc_wakeup) && !gpio_wakeup && !comm_wakeup`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 sys_wakeup`  ", "sva_signals": ["clk_sys", "rtc_wakeup", "gpio_wakeup", "comm_wakeup", "sys_wakeup"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($rose(rtc_wakeup) && !gpio_wakeup && !comm_wakeup) |-> ##2 sys_wakeup", "sva_name": "p_sys_wakeup_after_rtc_wakeup", "full_property": "property p_sys_wakeup_trigger;\n@(posedge clk_sys)     ($rose(rtc_wakeup) && !gpio_wakeup && !comm_wakeup) |-> ##2 sys_wakeup\nendproperty\nassert_p_sys_wakeup_trigger:assert property (p_sys_wakeup_trigger) else $error(\"\");", "task_id": "3_7733", "predict_sva": "@(posedge clk_sys)         ($rose(rtc_wakeup) && gpio_wakeup == 0 && comm_wakeup == 0) |-> ##2 sys_wakeup == 1"}
{"id": "336_4_0291", "name": "boot_mode_sel_p4", "sva": "@(posedge clk_sys)     boot_sel[0] |-> (direct_boot || secure_boot) throughout boot_sel[0][*1:$]", "ori_sva": "property boot_mode_sel_p4;\n@(posedge clk_sys)     boot_sel[0] |-> (direct_boot || secure_boot) throughout boot_sel[0][*1:$];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_boot_sel_condition  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `boot_sel[0] == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(direct_boot || secure_boot) throughout boot_sel[0][*1:$]`  ", "sva_signals": ["clk_sys", "[0:0] boot_sel", "direct_boot", "secure_boot"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     boot_sel[0] == 1'b1 |-> (direct_boot || secure_boot) throughout boot_sel[0][*1:$]", "sva_name": "p_boot_sel_boot_mode_exclusion", "full_property": "property p_boot_sel_condition;\n@(posedge clk_sys)     boot_sel[0] == 1'b1 |-> (direct_boot || secure_boot) throughout boot_sel[0][*1:$]\nendproperty\nassert_p_boot_sel_condition:assert property (p_boot_sel_condition) else $error(\"\");", "task_id": "3_7845", "predict_sva": "@(posedge clk_sys)         boot_sel[0] == 1'b1 |-> (direct_boot == 1'b1) or (secure_boot == 1'b1) throughout boot_sel[0] == 1'b1"}
{"id": "337_6_0281", "name": "data_stable_when_clock_stops_posedge", "sva": "@(posedge clk_signal)     $fell(clk_running) |-> $stable(data_out) until $rose(clk_running)", "ori_sva": "property data_stable_when_clock_stops_posedge;\n@(posedge clk_signal)     $fell(clk_running) |-> $stable(data_out) until $rose(clk_running);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Stable_Data_When_Clk_Fell  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(clk_running)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(data_out) until $rose(clk_running)`  ", "sva_signals": ["clk_signal", "[0:0] clk_running", "data_out", "[0:0] error", "[7:0] code", "[7:0] is_fatal"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(clk_running) |-> $stable(data_out) until $rose(clk_running)", "sva_name": "p_Stable_Data_After_Fell", "full_property": "property p_Stable_Data_When_Clk_Fell;\n@(posedge clk_signal)     $fell(clk_running) |-> $stable(data_out) until $rose(clk_running)\nendproperty\nassert_p_Stable_Data_When_Clk_Fell:assert property (p_Stable_Data_When_Clk_Fell) else $error(\"\");", "task_id": "3_7852", "predict_sva": "@(posedge clk_signal)     $fell(clk_running) |-> $stable(data_out) until $rose(clk_running)"}
{"id": "346_8_0371", "name": "p_low_pwr_clk_gating_8", "sva": "@(negedge clk_sys)     !active_mode && !$past(clock_en) |-> !clock_en", "ori_sva": "property p_low_pwr_clk_gating_8;\n@(negedge clk_sys)     !active_mode && !$past(clock_en) |-> !clock_en\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Clock_Enable_Check  \n**Trigger Condition**: At every falling edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!active_mode && !$past(clock_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!clock_en`  ", "sva_signals": ["clk_sys", "active_mode", "[0:0] clock_en"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(negedge clk_sys)     (!active_mode && !$past(clock_en)) |-> !clock_en", "sva_name": "p_clock_en_deassertion_when_inactive", "full_property": "property p_Clock_Enable_Check;\n@(negedge clk_sys)     (!active_mode && !$past(clock_en)) |-> !clock_en\nendproperty\nassert_p_Clock_Enable_Check:assert property (p_Clock_Enable_Check) else $error(\"\");", "task_id": "3_7919", "predict_sva": "@(negedge clk_sys)         (active_mode == 0 && $past(clock_en) == 0) |-> (clock_en == 0)"}
{"id": "349_5_0404", "name": "p_multi_trigger_no_glitch", "sva": "@(posedge clk)     $fell(trigger_A && trigger_B && threshold_exceed) |-> ##1 !interrupt_pending", "ori_sva": "property p_multi_trigger_no_glitch;\n@(posedge clk)     $fell(trigger_A && trigger_B && threshold_exceed) |-> ##1 !interrupt_pending;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Interrupt_After_Trigger_Fall  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(trigger_A && trigger_B && threshold_exceed)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !interrupt_pending`  ", "sva_signals": ["clk", "rst_n", "[0:0] trigger_A", "[0:0] trigger_B", "[0:0] threshold_exceed", "[0:0] interrupt_pending"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(trigger_A && trigger_B && threshold_exceed) |-> ##1 !interrupt_pending", "sva_name": "p_interrupt_pending_deassert_after_falling_edge", "full_property": "property p_Interrupt_After_Trigger_Fall;\n@(posedge clk)     $fell(trigger_A && trigger_B && threshold_exceed) |-> ##1 !interrupt_pending\nendproperty\nassert_p_Interrupt_After_Trigger_Fall:assert property (p_Interrupt_After_Trigger_Fall) else $error(\"\");", "task_id": "3_7938", "predict_sva": "@(posedge clk)         $fell(trigger_A && trigger_B && threshold_exceed) |-> ##1 interrupt_pending == 0"}
{"id": "381_4_0656", "name": "auth_pass_no_glitch", "sva": "@(posedge clk_signal)     $stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3) |-> auth_granted", "ori_sva": "property auth_pass_no_glitch;\n@(posedge clk_signal)     $stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3) |-> auth_granted;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_auth_granted_stable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `auth_granted`  ", "sva_signals": ["clk_signal", "[0:0] auth_pass_phase1", "[0:0] auth_pass_phase2", "[0:0] auth_pass_phase3", "[0:0] auth_granted"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ($stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3)) |-> auth_granted", "sva_name": "p_auth_granted_on_stable_phases", "full_property": "property p_auth_granted_stable;\n@(posedge clk_signal)     ($stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3)) |-> auth_granted\nendproperty\nassert_p_auth_granted_stable:assert property (p_auth_granted_stable) else $error(\"\");", "task_id": "3_8138", "predict_sva": "@(posedge clk_signal)         ($stable(auth_pass_phase1) && $stable(auth_pass_phase2) && $stable(auth_pass_phase3)) |-> (auth_granted == 1)"}
{"id": "386_1_0715", "name": "boot_mode_sel_p1", "sva": "@(posedge clk_sys)     $rose(boot_sel[0]) |-> (direct_boot || secure_boot)", "ori_sva": "property boot_mode_sel_p1;\n@(posedge clk_sys)     $rose(boot_sel[0]) |-> (direct_boot || secure_boot);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Boot_Selection  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(boot_sel[0])`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(direct_boot || secure_boot)`", "sva_signals": ["clk_sys", "[0:0] boot_sel", "direct_boot", "secure_boot"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(boot_sel[0]) |-> (direct_boot || secure_boot)", "sva_name": "p_boot_sel_rise_boot_mode_asserted", "full_property": "property p_Boot_Selection;\n@(posedge clk_sys)         $rose(boot_sel[0]) |-> (direct_boot || secure_boot)\nendproperty\nassert_p_Boot_Selection:assert property (p_Boot_Selection) else $error(\"\");", "task_id": "3_8173", "predict_sva": "@(posedge clk_sys)         $rose(boot_sel[0]) |-> (direct_boot == 1 || secure_boot == 1)"}
{"id": "389_2_0737", "name": "p_reset_source_valid_2", "sva": "@(posedge clk)     (ext_reset || wdt_reset || !power_good) |=> $past(reset_active, 1)", "ori_sva": "property p_reset_source_valid_2;\n@(posedge clk)     (ext_reset || wdt_reset || !power_good) |=> $past(reset_active, 1);\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_Reset_Activation  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(ext_reset || wdt_reset || !power_good)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$past(reset_active, 1)`  ", "sva_signals": ["clk", "rst_n", "[0:0] ext_reset", "[0:0] wdt_reset", "[0:0] power_good", "[0:0] reset_active"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (ext_reset || wdt_reset || !power_good) |=> $past(reset_active, 1)", "sva_name": "p_reset_active_on_reset_condition", "full_property": "property p_Reset_Activation;\n@(posedge clk)     (ext_reset || wdt_reset || !power_good) |=> $past(reset_active, 1)\nendproperty\nassert_p_Reset_Activation:assert property (p_Reset_Activation) else $error(\"\");", "task_id": "3_8187", "predict_sva": "@(posedge clk)         (ext_reset == 1 || wdt_reset == 1 || power_good == 0) |-> $past(reset_active) == 1"}
{"id": "389_5_0727", "name": "p_reset_source_valid_5", "sva": "@(posedge clk)     $fell(reset_active) |-> $past(!ext_reset && !wdt_reset && power_good, 1)", "ori_sva": "property p_reset_source_valid_5;\n@(posedge clk)     $fell(reset_active) |-> $past(!ext_reset && !wdt_reset && power_good, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Reset_Deassertion_Conditions  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(reset_active)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(!ext_reset && !wdt_reset && power_good, 1)`  ", "sva_signals": ["clk", "reset_active", "[0:0] ext_reset", "[0:0] wdt_reset", "[0:0] power_good"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(reset_active) |-> $past(!ext_reset && !wdt_reset && power_good, 1)", "sva_name": "p_reset_deassert_prev_state_check", "full_property": "property p_Reset_Deassertion_Conditions;\n@(posedge clk)     $fell(reset_active) |-> $past(!ext_reset && !wdt_reset && power_good, 1)\nendproperty\nassert_p_Reset_Deassertion_Conditions:assert property (p_Reset_Deassertion_Conditions) else $error(\"\");", "task_id": "3_8190", "predict_sva": "@(posedge clk)         $fell(reset_active) |-> ($past(ext_reset) == 0 && $past(wdt_reset) == 0 && $past(power_good) == 1)"}
{"id": "394_9_0788", "name": "core_results_consistent_9", "sva": "@(posedge clk_sys)     core_1_result != core_2_result |-> $fell(core_sync)", "ori_sva": "property core_results_consistent_9;\n@(posedge clk_sys)     core_1_result != core_2_result |-> $fell(core_sync);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Core_Result_Mismatch  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `core_1_result != core_2_result`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$fell(core_sync)`  ", "sva_signals": ["clk_sys", "[0:0] core_sync", "core_1_result", "core_2_result"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (core_1_result != core_2_result) |-> $fell(core_sync)", "sva_name": "p_core_sync_fall_on_core_mismatch", "full_property": "property p_Core_Result_Mismatch;\n@(posedge clk_sys)     (core_1_result != core_2_result) |-> $fell(core_sync)\nendproperty\nassert_p_Core_Result_Mismatch:assert property (p_Core_Result_Mismatch) else $error(\"\");", "task_id": "3_8229", "predict_sva": "@(posedge clk_sys)         (core_1_result != core_2_result) |-> (core_sync == 1'b0 && $past(core_sync) == 1'b1)"}
{"id": "449_6_1257", "name": "p_freq_change_acknowledge", "sva": "@(posedge gpu_clk)     $rose(gpu_freq_change) |-> ##[1:5] $fell(gpu_freq_busy)", "ori_sva": "property p_freq_change_acknowledge;\n@(posedge gpu_clk)     $rose(gpu_freq_change) |-> ##[1:5] $fell(gpu_freq_busy);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gpu_freq_busy_fall_after_change  \n**Trigger Condition**: At every rising edge of the `gpu_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(gpu_freq_change)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] $fell(gpu_freq_busy)`  ", "sva_signals": ["gpu_clk", "gpu_freq_change", "gpu_freq_busy"], "clock": "gpu_clk", "attempts_left": 10, "sva_result": "@(posedge gpu_clk)         $rose(gpu_freq_change) |-> ##[1:5] $fell(gpu_freq_busy)", "sva_name": "p_gpu_freq_busy_fall_after_freq_change", "full_property": "property p_gpu_freq_busy_fall_after_change;\n@(posedge gpu_clk)         $rose(gpu_freq_change) |-> ##[1:5] $fell(gpu_freq_busy)\nendproperty\nassert_p_gpu_freq_busy_fall_after_change:assert property (p_gpu_freq_busy_fall_after_change) else $error(\"\");", "task_id": "3_8322", "predict_sva": "@(posedge gpu_clk)    $rose(gpu_freq_change) |-> ##[1:5] $fell(gpu_freq_busy)"}
{"id": "451_2_1255", "name": "p_hash_stable_until_boot", "sva": "@(posedge clk_sys)     $rose(boot_enable) |=> $stable(bootloader_hash) throughout boot_done", "ori_sva": "property p_hash_stable_until_boot;\n@(posedge clk_sys)     $rose(boot_enable) |=> $stable(bootloader_hash) throughout boot_done;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Bootloader_Hash_Stable  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(boot_enable)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `$stable(bootloader_hash) throughout boot_done`  ", "sva_signals": ["clk_sys", "boot_enable", "bootloader_hash", "boot_done"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(boot_enable) |=> $stable(bootloader_hash) throughout boot_done", "sva_name": "p_boot_enable_stable_hash", "full_property": "property p_Bootloader_Hash_Stable;\n@(posedge clk_sys)         $rose(boot_enable) |=> $stable(bootloader_hash) throughout boot_done\nendproperty\nassert_p_Bootloader_Hash_Stable:assert property (p_Bootloader_Hash_Stable) else $error(\"\");", "task_id": "3_8325", "predict_sva": "@(posedge clk_sys)     $rose(boot_enable) |-> $stable(bootloader_hash) throughout boot_done"}
{"id": "454_2_1283", "name": "dma_xfer_integrity_p2", "sva": "@(posedge clk_sys)     $fell(dma_start) |=> (dma_busy throughout (##[0:2] $stable(dma_addr) ##1 dma_data_valid[->4] ##1 $fell(dma_done)))", "ori_sva": "property dma_xfer_integrity_p2;\n@(posedge clk_sys)     $fell(dma_start) |=> (dma_busy throughout (##[0:2] $stable(dma_addr) ##1 dma_data_valid[->4] ##1 $fell(dma_done)));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_sequence_after_fell  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(dma_start)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**:  \n`dma_busy` must hold continuously (`throughout`) the following sequence:  \n1. Within 0 to 2 clock cycles (`##[0:2]`), `dma_addr` must remain stable (`$stable(dma_addr)`), followed by  \n2. Exactly 1 clock cycle later (`##1`), `dma_data_valid` must occur 4 times (`dma_data_valid[->4]`), followed by  \n3. Exactly 1 clock cycle later (`##1`), `dma_done` must fall (`$fell(dma_done)`)  ", "sva_signals": ["clk_sys", "dma_start", "dma_busy", "dma_addr", "dma_data_valid", "dma_done"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(dma_start) |=>      dma_busy throughout (         ##[0:2] $stable(dma_addr) ##1         dma_data_valid[->4] ##1         $fell(dma_done)     )", "sva_name": "p_Dma_Sequence_After_Start_Fall", "full_property": "property p_dma_sequence_after_fell;\n@(posedge clk_sys)     $fell(dma_start) |=>      dma_busy throughout (         ##[0:2] $stable(dma_addr) ##1         dma_data_valid[->4] ##1         $fell(dma_done)     )\nendproperty\nassert_p_dma_sequence_after_fell:assert property (p_dma_sequence_after_fell) else $error(\"\");", "task_id": "3_8336", "predict_sva": "@(posedge clk_sys)     $fell(dma_start) |->      (##[0:2] $stable(dma_addr)) ##1 (dma_data_valid[->4]) ##1 $fell(dma_done) throughout dma_busy"}
{"id": "457_8_1280", "name": "pcie_training_duration_check", "sva": "@(posedge pcie_clk)     $rose(ltssm_training) |-> (training_active until $rose(ltssm_l0))", "ori_sva": "property pcie_training_duration_check;\n@(posedge pcie_clk)     $rose(ltssm_training) |-> (training_active until $rose(ltssm_l0));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Training_Active_Until_L0  \n**Trigger Condition**: At every rising edge of the `pcie_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ltssm_training)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `training_active until $rose(ltssm_l0)`  ", "sva_signals": ["pcie_clk", "ltssm_training", "ltssm_l0", "training_active"], "clock": "pcie_clk", "attempts_left": 10, "sva_result": "@(posedge pcie_clk)     $rose(ltssm_training) |-> (training_active) until $rose(ltssm_l0)", "sva_name": "p_training_active_during_ltssm_training", "full_property": "property p_Training_Active_Until_L0;\n@(posedge pcie_clk)     $rose(ltssm_training) |-> (training_active) until $rose(ltssm_l0)\nendproperty\nassert_p_Training_Active_Until_L0:assert property (p_Training_Active_Until_L0) else $error(\"\");", "task_id": "3_8357", "predict_sva": "@(posedge pcie_clk)    $rose(ltssm_training) |->     (training_active throughout $rose(ltssm_l0))"}
{"id": "459_4_1329", "name": "ddr_phy_init_dll_lock_stable", "sva": "@(posedge clk)     (zq_cal[->3] ##1 phy_init) |-> ##[10:20] $stable(dll_lock)", "ori_sva": "property ddr_phy_init_dll_lock_stable;\n@(posedge clk)     (zq_cal[->3] ##1 phy_init) |-> ##[10:20] $stable(dll_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dll_lock_stable_after_zq_cal_and_phy_init  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(zq_cal[->3] ##1 phy_init)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] $stable(dll_lock)`  ", "sva_signals": ["clk", "rst_n", "[0:0] zq_cal", "[0:0] phy_init", "[0:0] dll_lock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (zq_cal[->3] ##1 phy_init) |-> ##[10:20] $stable(dll_lock)", "sva_name": "p_dll_lock_stability_after_zq_cal_phy_init", "full_property": "property p_dll_lock_stable_after_zq_cal_and_phy_init;\n@(posedge clk)     (zq_cal[->3] ##1 phy_init) |-> ##[10:20] $stable(dll_lock)\nendproperty\nassert_p_dll_lock_stable_after_zq_cal_and_phy_init:assert property (p_dll_lock_stable_after_zq_cal_and_phy_init) else $error(\"\");", "task_id": "3_8360", "predict_sva": "@(posedge clk)         (zq_cal [*3]) ##1 phy_init |-> ##10 (dll_lock == $past(dll_lock)) [*10:20]"}
{"id": "459_7_1322", "name": "ddr_phy_init_zq_cal_before_dll_lock", "sva": "@(posedge clk)     zq_cal[->3] |-> ##[10:20] $stable(dll_lock)", "ori_sva": "property ddr_phy_init_zq_cal_before_dll_lock;\n@(posedge clk)     zq_cal[->3] |-> ##[10:20] $stable(dll_lock);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_zq_cal_to_dll_lock_stable  \n**Trigger Condition**: At every posedge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `zq_cal[->3]` (third occurrence of `zq_cal` signal)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] $stable(dll_lock)` (within 10 to 20 clock cycles after the antecedent, `dll_lock` signal remains stable)", "sva_signals": ["clk", "rst_n", "[0:0] zq_cal", "[0:0] dll_lock"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     zq_cal[->3] |-> ##[10:20] $stable(dll_lock)", "sva_name": "p_dll_lock_stable_after_zq_cal_third_rise", "full_property": "property p_zq_cal_to_dll_lock_stable;\n@(posedge clk)     zq_cal[->3] |-> ##[10:20] $stable(dll_lock)\nendproperty\nassert_p_zq_cal_to_dll_lock_stable:assert property (p_zq_cal_to_dll_lock_stable) else $error(\"\");", "task_id": "3_8362", "predict_sva": "@(posedge clk)         zq_cal[->3] |-> ##[10:20] $stable(dll_lock)"}
{"id": "468_7_1360", "name": "p_vertex_count_check", "sva": "@(posedge clk_core)     $fell(prim_assembler_start) |-> (##1 vertex_valid[->6])", "ori_sva": "property p_vertex_count_check;\n@(posedge clk_core)     $fell(prim_assembler_start) |-> (##1 vertex_valid[->6]);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_vertex_valid_after_prim_assembler_start_fall  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(prim_assembler_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 vertex_valid[->6]`  ", "sva_signals": ["clk_core", "rst_n", "[0:0] prim_assembler_start", "[0:0] vertex_valid"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $fell(prim_assembler_start) |-> ##1 vertex_valid[->6]", "sva_name": "p_vertex_valid_after_prim_assembler_start_fall", "full_property": "property p_vertex_valid_after_prim_assembler_start_fall;\n@(posedge clk_core)         $fell(prim_assembler_start) |-> ##1 vertex_valid[->6]\nendproperty\nassert_p_vertex_valid_after_prim_assembler_start_fall:assert property (p_vertex_valid_after_prim_assembler_start_fall) else $error(\"\");", "task_id": "3_8405", "predict_sva": "@(posedge clk_core)         $fell(prim_assembler_start) |-> ##1 vertex_valid [*6]"}
{"id": "462_1_1332", "name": "p_sync_fall_to_stable_gmtime", "sva": "@(posedge clk_sys)     $fell(sync_request) |-> ##1 !clock_adjust throughout      (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset))", "ori_sva": "property p_sync_fall_to_stable_gmtime;\n@(posedge clk_sys)     $fell(sync_request) |-> ##1 !clock_adjust throughout      (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_request_fall  \n**Trigger Condition**: At every posedge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(sync_request)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`##1 !clock_adjust throughout (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##0 $stable(clock_offset))`  \n\n**Explanation of Consequent**:  \n1. **Initial Delay**: After the antecedent is true (`$fell(sync_request)`), the consequent starts **1 clock cycle later (`##1`)** with the condition `!clock_adjust` (clock adjustment must be disabled).  \n2. **Temporal Sequence**:  \n   - **Stable GM Time**: Within **1 to 5 clock cycles** (`##[1:5]`), the global time (`gm_time[63:0]`) must remain stable (`$stable`).  \n   - **Sync Acknowledge**: After the stable GM time, within **10 to 100 clock cycles** (`##[10:100]`), a rising edge on `sync_ack` must occur (`$rose(sync_ack)`).  \n   - **Stable Clock Offset**: **Immediately** after `sync_ack` rises (`##0`), the `clock_offset` must remain stable (`$stable`).  \n3. **Throughout Constraint**: The condition `!clock_adjust` must hold **continuously** from **1 cycle after the antecedent** until the **entire temporal sequence completes**.  \n\n**Key Notes**:  \n- The assertion ensures that when `sync_request` falls, clock adjustment is disabled, followed by a specific sequence of events (stable time, acknowledgment, and stable offset).  \n- The `throughout` operator enforces that `!clock_adjust` remains true during the entire sequence.", "sva_signals": ["clk_sys", "sync_request", "clock_adjust", "gm_time[63:0]", "sync_ack", "clock_offset"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(sync_request) |->      ##1 (!clock_adjust) throughout (         ##[1:5] $stable(gm_time[63:0])          ##[10:100] $rose(sync_ack)          ##0 $stable(clock_offset)     )", "sva_name": "p_sync_request_fall_clock_adjust_sequence", "full_property": "property p_sync_request_fall;\n@(posedge clk_sys)     $fell(sync_request) |->      ##1 (!clock_adjust) throughout (         ##[1:5] $stable(gm_time[63:0])          ##[10:100] $rose(sync_ack)          ##0 $stable(clock_offset)     )\nendproperty\nassert_p_sync_request_fall:assert property (p_sync_request_fall) else $error(\"\");", "task_id": "3_8373", "predict_sva": "@(posedge clk_sys)         $fell(sync_request) |-> ##1 (clock_adjust == 0 throughout (##[1:5] $stable(gm_time[63:0]) ##[10:100] $rose(sync_ack) ##1 $stable(clock_offset)))"}
{"id": "473_6_1417", "name": "p_chirp_phase_stable_until_valid", "sva": "@(posedge clk_signal)     $fell(adc_capture) && $stable(chirp_phase) |->      ($stable(chirp_phase) until $rose(range_fft_valid))", "ori_sva": "property p_chirp_phase_stable_until_valid;\n@(posedge clk_signal)     $fell(adc_capture) && $stable(chirp_phase) |->      ($stable(chirp_phase) until $rose(range_fft_valid));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_StableChirpPhaseUntilFFTValid  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(adc_capture) && $stable(chirp_phase)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `($stable(chirp_phase) until $rose(range_fft_valid))`  ", "sva_signals": ["clk_signal", "adc_capture", "chirp_phase", "range_fft_valid"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     ($fell(adc_capture) && $stable(chirp_phase)) |-> ($stable(chirp_phase) until $rose(range_fft_valid))", "sva_name": "p_Stable_Chirp_Phase_After_Capture_Fall", "full_property": "property p_StableChirpPhaseUntilFFTValid;\n@(posedge clk_signal)     ($fell(adc_capture) && $stable(chirp_phase)) |-> ($stable(chirp_phase) until $rose(range_fft_valid))\nendproperty\nassert_p_StableChirpPhaseUntilFFTValid:assert property (p_StableChirpPhaseUntilFFTValid) else $error(\"\");", "task_id": "3_8432", "predict_sva": "@(posedge clk_signal)     ($fell(adc_capture) && $stable(chirp_phase)) |-> $stable(chirp_phase) until $rose(range_fft_valid)"}
{"id": "484_3_1477", "name": "p_hbm2e_refresh_addr_stable", "sva": "@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[1:8] $stable(refresh_addr)", "ori_sva": "property p_hbm2e_refresh_addr_stable;\n@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[1:8] $stable(refresh_addr);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Refresh_Addr_Stable_After_Fell  \n**Trigger Condition**: At every rising edge of `clk_hbm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(auto_refresh)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] $stable(refresh_addr)`  ", "sva_signals": ["clk_hbm", "auto_refresh", "refresh_addr"], "clock": "clk_hbm", "attempts_left": 10, "sva_result": "@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[1:8] $stable(refresh_addr)", "sva_name": "p_refresh_addr_stable_after_auto_refresh_fall", "full_property": "property p_Refresh_Addr_Stable_After_Fell;\n@(posedge clk_hbm)     $fell(auto_refresh) |-> ##[1:8] $stable(refresh_addr)\nendproperty\nassert_p_Refresh_Addr_Stable_After_Fell:assert property (p_Refresh_Addr_Stable_After_Fell) else $error(\"\");", "task_id": "3_8470", "predict_sva": "@(posedge clk_hbm)         $fell(auto_refresh) |-> ##[1:8] $stable(refresh_addr)"}
{"id": "498_3_1590", "name": "p_link_width_stable_after_linkdown", "sva": "@(posedge clk_signal)     $fell(ucie_linkup) |-> ##1 $stable(link_width)", "ori_sva": "property p_link_width_stable_after_linkdown;\n@(posedge clk_signal)     $fell(ucie_linkup) |-> ##1 $stable(link_width);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Link_Width_Stable_After_Linkup_Fall  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(ucie_linkup)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(link_width)`  ", "sva_signals": ["clk_signal", "[0:0] ucie_linkup", "link_width"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(ucie_linkup) |-> ##1 $stable(link_width)", "sva_name": "p_link_width_stable_after_ucie_linkup_fall", "full_property": "property p_Link_Width_Stable_After_Linkup_Fall;\n@(posedge clk_signal)     $fell(ucie_linkup) |-> ##1 $stable(link_width)\nendproperty\nassert_p_Link_Width_Stable_After_Linkup_Fall:assert property (p_Link_Width_Stable_After_Linkup_Fall) else $error(\"\");", "task_id": "3_8542", "predict_sva": "@(posedge clk_signal)         $fell(ucie_linkup) |-> ##1 link_width == $past(link_width)"}
{"id": "498_5_1581", "name": "p_protocol_handshake_fall_after_ready", "sva": "@(posedge clk_signal)     $rose(phy_ready) |-> ##1 $fell(protocol_handshake)", "ori_sva": "property p_protocol_handshake_fall_after_ready;\n@(posedge clk_signal)     $rose(phy_ready) |-> ##1 $fell(protocol_handshake);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PhyReady_ProtocolHandshake  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(phy_ready)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(protocol_handshake)`  ", "sva_signals": ["clk_signal", "phy_ready", "protocol_handshake"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(phy_ready) |-> ##1 $fell(protocol_handshake)", "sva_name": "p_phy_ready_protocol_handshake_fall", "full_property": "property p_PhyReady_ProtocolHandshake;\n@(posedge clk_signal)     $rose(phy_ready) |-> ##1 $fell(protocol_handshake)\nendproperty\nassert_p_PhyReady_ProtocolHandshake:assert property (p_PhyReady_ProtocolHandshake) else $error(\"\");", "task_id": "3_8544", "predict_sva": "@(posedge clk_signal)         $rose(phy_ready) |-> ##1 $fell(protocol_handshake)"}
{"id": "503_9_0044", "name": "pcie_tlp_packet_gap", "sva": "@(posedge clk)     crc_valid ##1 header_valid |-> $fell(tlp_start) || $past($fell(tlp_start))", "ori_sva": "property pcie_tlp_packet_gap;\n@(posedge clk)     crc_valid ##1 header_valid |-> $fell(tlp_start) || $past($fell(tlp_start));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_tlp_packet_gap  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_valid ##1 header_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$fell(tlp_start) || $past($fell(tlp_start))`  ", "sva_signals": ["clk", "rst_n", "[0:0] crc_valid", "[0:0] header_valid", "[0:0] tlp_start"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     crc_valid ##1 header_valid |-> ($fell(tlp_start) || $past($fell(tlp_start)))", "sva_name": "pcie_tlp_sequence_integrity", "full_property": "property pcie_tlp_packet_gap;\n@(posedge clk)     crc_valid ##1 header_valid |-> ($fell(tlp_start) || $past($fell(tlp_start)))\nendproperty\nassert_pcie_tlp_packet_gap:assert property (pcie_tlp_packet_gap) else $error(\"\");", "task_id": "3_8581", "predict_sva": "@(posedge clk)     crc_valid ##1 header_valid |-> $fell(tlp_start) or $past($fell(tlp_start), 1)"}
{"id": "507_1_0014", "name": "dma_desc_chain_p1", "sva": "@(posedge clk)     $fell(dma_start) |-> ##2 ((desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen)", "ori_sva": "property dma_desc_chain_p1;\n@(posedge clk)     $fell(dma_start) |-> ##2 ((desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dma_desc_chain_p1  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(dma_start)` (a falling edge on `dma_start`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 ((desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen)`  \n   - After 2 clock cycles (`##2`), the following sequence must occur:  \n      - A sequence of `desc_fetch` followed by `data_xfer` within 1 to 3 clock cycles (`##[1:3]`), repeated exactly 4 times (`[*4]`),  \n      - Followed by `irq_gen` occurring exactly 1 clock cycle later (`##1`).", "sva_signals": ["clk", "rst_n", "[0:0] dma_start", "[0:0] desc_fetch", "[0:0] data_xfer", "[0:0] irq_gen"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(dma_start) |-> ##2 ((desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen)", "sva_name": "dma_desc_chain_p2", "full_property": "property dma_desc_chain_p1;\n@(posedge clk)     $fell(dma_start) |-> ##2 ((desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen)\nendproperty\nassert_dma_desc_chain_p1:assert property (dma_desc_chain_p1) else $error(\"\");", "task_id": "3_8585", "predict_sva": "@(posedge clk)     $fell(dma_start) |-> ##2 (desc_fetch ##[1:3] data_xfer)[*4] ##1 irq_gen"}
{"id": "515_5_0112", "name": "p_no_result_valid_without_fir_enable", "sva": "@(posedge clk_signal)     $rose(result_valid) |-> $past(fir_enable, 2 + (17*4) + (3*16))", "ori_sva": "property p_no_result_valid_without_fir_enable;\n@(posedge clk_signal)     $rose(result_valid) |-> $past(fir_enable, 2 + (17*4) + (3*16));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_result_valid_without_fir_enable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(result_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(fir_enable, 2 + (17*4) + (3*16))`  ", "sva_signals": ["clk_signal", "[0:0] result_valid", "[0:0] fir_enable"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)         $rose(result_valid) |-> $past(fir_enable, 2 + (17*4) + (3*16))", "sva_name": "p_result_valid_rise_fir_enable_118_cycles_ago", "full_property": "property p_no_result_valid_without_fir_enable;\n@(posedge clk_signal)         $rose(result_valid) |-> $past(fir_enable, 2 + (17*4) + (3*16))\nendproperty\nassert_p_no_result_valid_without_fir_enable:assert property (p_no_result_valid_without_fir_enable) else $error(\"\");", "task_id": "3_8614", "predict_sva": "@(posedge clk_signal)         $rose(result_valid) |-> $past(fir_enable, 118)"}
{"id": "573_1_0536", "name": "p_simd_add_no_overflow_posedge", "sva": "@(posedge clk)     $rose(simd_add) |-> (simd_sum <= VMAX && simd_sum >= VMIN)", "ori_sva": "property p_simd_add_no_overflow_posedge;\n@(posedge clk)     $rose(simd_add) |-> (simd_sum <= VMAX && simd_sum >= VMIN);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_add_no_overflow_posedge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_add)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(simd_sum <= VMAX && simd_sum >= VMIN)`  \n\n", "sva_signals": ["clk", "rst_n", "[0:0] simd_add", "[0:0] simd_sum", "[0:0] VMAX", "[0:0] VMIN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_add) |-> (simd_sum <= VMAX && simd_sum >= VMIN)", "sva_name": "p_simd_add_no_overflow_with_enable", "full_property": "property p_simd_add_no_overflow_posedge;\n@(posedge clk)     $rose(simd_add) |-> (simd_sum <= VMAX && simd_sum >= VMIN)\nendproperty\nassert_p_simd_add_no_overflow_posedge:assert property (p_simd_add_no_overflow_posedge) else $error(\"\");", "task_id": "3_8667", "predict_sva": "@(posedge clk)         $rose(simd_add) |-> (simd_sum <= VMAX && simd_sum >= VMIN)"}
{"id": "581_2_0573", "name": "p_simd_store_alignment_negedge", "sva": "@(negedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0)", "ori_sva": "property p_simd_store_alignment_negedge;\n@(negedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_store_alignment_negedge  \n**Trigger Condition**: At every falling edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_store)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mem_addr % VLEN == 0)`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_store", "[31:0] mem_addr", "[31:0] VLEN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(negedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0)", "sva_name": "p_simd_store_alignment_check", "full_property": "property p_simd_store_alignment_negedge;\n@(negedge clk)     $rose(simd_store) |-> (mem_addr % VLEN == 0)\nendproperty\nassert_p_simd_store_alignment_negedge:assert property (p_simd_store_alignment_negedge) else $error(\"\");", "task_id": "3_8705", "predict_sva": "@(negedge clk)     $rose(simd_store) |-> mem_addr % VLEN == 0"}
{"id": "581_4_0584", "name": "p_simd_store_alignment_async", "sva": "@(posedge clk) @(posedge clk or posedge async_rst)     $rose(simd_store) |-> (mem_addr % VLEN == 0)", "ori_sva": "property p_simd_store_alignment_async;\n@(posedge clk) @(posedge clk or posedge async_rst)     $rose(simd_store) |-> (mem_addr % VLEN == 0);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_store_alignment_async  \n**Trigger Condition**: At every rising edge of `clk` or rising edge of `async_rst`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_store)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(mem_addr % VLEN == 0)`  \n\n(Note: The assertion checks that whenever `simd_store` rises, the memory address `mem_addr` must be aligned to the vector length `VLEN` (i.e., `mem_addr` is a multiple of `VLEN`). The check is triggered on either a clock edge or an asynchronous reset edge.)", "sva_signals": ["clk", "async_rst", "[0:0] simd_store", "[0:0] mem_addr", "[0:0] VLEN"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk or posedge async_rst)         $rose(simd_store) |-> (mem_addr % VLEN == 0)", "sva_name": "p_simd_store_mem_addr_alignment", "full_property": "property p_simd_store_alignment_async;\n@(posedge clk or posedge async_rst)         $rose(simd_store) |-> (mem_addr % VLEN == 0)\nendproperty\nassert_p_simd_store_alignment_async:assert property (p_simd_store_alignment_async) else $error(\"\");", "task_id": "3_8707", "predict_sva": "@(posedge clk or posedge async_rst)         $rose(simd_store) |-> (mem_addr % VLEN == 0)"}
{"id": "592_3_0661", "name": "simd_hazard_delay_check", "sva": "@(posedge clk)     $rose(simd_issue) |=> !simd_hazard", "ori_sva": "property simd_hazard_delay_check;\n@(posedge clk)     $rose(simd_issue) |=> !simd_hazard;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_hazard_delay_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!simd_hazard`  \n\n(Note: The `|=>` operator indicates that the consequent is checked one clock cycle after the antecedent is true.)", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] simd_hazard"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(simd_issue) |=> !simd_hazard", "sva_name": "simd_hazard_check", "full_property": "property simd_hazard_delay_check;\n@(posedge clk)     $rose(simd_issue) |=> !simd_hazard\nendproperty\nassert_simd_hazard_delay_check:assert property (simd_hazard_delay_check) else $error(\"\");", "task_id": "3_8765", "predict_sva": "@(posedge clk)         $rose(simd_issue) |-> ##1 !simd_hazard"}
{"id": "592_6_0679", "name": "simd_hazard_future_check", "sva": "@(posedge clk)     $rose(simd_issue) |-> ##[0:2] !simd_hazard", "ori_sva": "property simd_hazard_future_check;\n@(posedge clk)     $rose(simd_issue) |-> ##[0:2] !simd_hazard;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_hazard_future_check  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] !simd_hazard`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] simd_hazard"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_issue) |-> ##[0:2] !simd_hazard", "sva_name": "simd_hazard_window_check", "full_property": "property simd_hazard_future_check;\n@(posedge clk)         $rose(simd_issue) |-> ##[0:2] !simd_hazard\nendproperty\nassert_simd_hazard_future_check:assert property (simd_hazard_future_check) else $error(\"\");", "task_id": "3_8768", "predict_sva": "@(posedge clk)         $rose(simd_issue) |-> !simd_hazard throughout (1 ##1 1)"}
{"id": "594_8_0693", "name": "p_simd_dec_onehot_window", "sva": "@(posedge clk_core)     $rose(simd_issue_i) |-> ##[1:3] $onehot(simd_decoded_o)", "ori_sva": "property p_simd_dec_onehot_window;\n@(posedge clk_core)     $rose(simd_issue_i) |-> ##[1:3] $onehot(simd_decoded_o)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_dec_onehot_window  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue_i)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $onehot(simd_decoded_o)`  ", "sva_signals": ["clk_core", "rst_n", "[0:0] simd_issue_i", "[0:0] simd_decoded_o"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(simd_issue_i) |-> ##[1:3] $onehot(simd_decoded_o)", "sva_name": "p_simd_dec_onehot_after_issue", "full_property": "property p_simd_dec_onehot_window;\n@(posedge clk_core)     $rose(simd_issue_i) |-> ##[1:3] $onehot(simd_decoded_o)\nendproperty\nassert_p_simd_dec_onehot_window:assert property (p_simd_dec_onehot_window) else $error(\"\");", "task_id": "3_8778", "predict_sva": "@(posedge clk_core)     $rose(simd_issue_i) |=> ##[1:3] $onehot(simd_decoded_o)"}
{"id": "596_3_0684", "name": "vreg_rw_mutex_3", "sva": "@(posedge clk_signal)     $rose(vreg_write) |=>      !($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx))", "ori_sva": "property vreg_rw_mutex_3;\n@(posedge clk_signal)     $rose(vreg_write) |=>      !($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: vreg_rw_mutex_3  \n**Trigger Condition**: At every rising edge of `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(vreg_write)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx))`  ", "sva_signals": ["clk_signal", "[0:0] vreg_write", "[0:0] vreg_read", "[0:0] vreg_idx_read", "[0:0] vreg_idx"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $rose(vreg_write) |=> !($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx))", "sva_name": "p_vreg_rw_mutex_1", "full_property": "property vreg_rw_mutex_3;\n@(posedge clk_signal)     $rose(vreg_write) |=> !($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx))\nendproperty\nassert_vreg_rw_mutex_3:assert property (vreg_rw_mutex_3) else $error(\"\");", "task_id": "3_8787", "predict_sva": "@(posedge clk_signal)         $rose(vreg_write) |-> !( ($past(vreg_read) && vreg_write && ($past(vreg_idx_read) == vreg_idx))"}
{"id": "602_8_0784", "name": "p_simd_illegal_opcode_until_posedge", "sva": "@(posedge clk)     $rose(simd_issue) |-> !(illegal_opcode) until !simd_issue", "ori_sva": "property p_simd_illegal_opcode_until_posedge;\n@(posedge clk)     $rose(simd_issue) |-> !(illegal_opcode) until !simd_issue;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_simd_illegal_opcode_until_posedge  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_issue)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!(illegal_opcode) until !simd_issue`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_issue", "[0:0] illegal_opcode"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(simd_issue) |-> !(illegal_opcode) until !simd_issue", "sva_name": "p_simd_issue_illegal_opcode_check", "full_property": "property p_simd_illegal_opcode_until_posedge;\n@(posedge clk)         $rose(simd_issue) |-> !(illegal_opcode) until !simd_issue\nendproperty\nassert_p_simd_illegal_opcode_until_posedge:assert property (p_simd_illegal_opcode_until_posedge) else $error(\"\");", "task_id": "3_8823", "predict_sva": "@(posedge clk)         $rose(simd_issue) |-> !illegal_opcode until !simd_issue"}
{"id": "618_5_0871", "name": "simd_segment_boundary_check_5", "sva": "@(posedge clk_i)     $rose(simd_segment_op) |-> (segment_base_i < VLEN_i && segment_len_i <= (VLEN_i - segment_base_i))", "ori_sva": "property simd_segment_boundary_check_5;\n@(posedge clk_i)     $rose(simd_segment_op) |-> (segment_base_i < VLEN_i && segment_len_i <= (VLEN_i - segment_base_i));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_boundary_check_5  \n**Trigger Condition**: At every rising edge of the `clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(simd_segment_op)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(segment_base_i < VLEN_i && segment_len_i <= (VLEN_i - segment_base_i))`  ", "sva_signals": ["clk_i", "rst_i", "[0:0] simd_segment_op", "[0:0] segment_base_i", "[0:0] segment_len_i", "[0:0] VLEN_i"], "clock": "clk_i", "attempts_left": 10, "sva_result": "@(posedge clk_i)     $rose(simd_segment_op) |-> (segment_base_i < VLEN_i && segment_len_i <= (VLEN_i - segment_base_i))", "sva_name": "simd_segment_boundary_check_1", "full_property": "property simd_segment_boundary_check_5;\n@(posedge clk_i)     $rose(simd_segment_op) |-> (segment_base_i < VLEN_i && segment_len_i <= (VLEN_i - segment_base_i))\nendproperty\nassert_simd_segment_boundary_check_5:assert property (simd_segment_boundary_check_5) else $error(\"\");", "task_id": "3_8909", "predict_sva": "@(posedge clk_i)         $rose(simd_segment_op) |-> (segment_base_i < VLEN_i) && (segment_len_i <= (VLEN_i - segment_base_i))"}
{"id": "620_3_0875", "name": "simd_segment_write_overflow_protection_p3", "sva": "@(posedge clk)     $changed(simd_segment_write) && simd_segment_write |-> segment_idx < NUM_SEGMENT", "ori_sva": "property simd_segment_write_overflow_protection_p3;\n@(posedge clk)     $changed(simd_segment_write) && simd_segment_write |-> segment_idx < NUM_SEGMENT;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: simd_segment_write_overflow_protection_p3  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(simd_segment_write) && simd_segment_write`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `segment_idx < NUM_SEGMENT`  ", "sva_signals": ["clk", "rst_n", "[0:0] simd_segment_write", "[0:0] segment_idx", "[0:0] NUM_SEGMENT"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $changed(simd_segment_write) && simd_segment_write |-> segment_idx < NUM_SEGMENT", "sva_name": "p_simd_segment_write_transition_segment_idx_check", "full_property": "property simd_segment_write_overflow_protection_p3;\n@(posedge clk)     $changed(simd_segment_write) && simd_segment_write |-> segment_idx < NUM_SEGMENT\nendproperty\nassert_simd_segment_write_overflow_protection_p3:assert property (simd_segment_write_overflow_protection_p3) else $error(\"\");", "task_id": "3_8920", "predict_sva": "@(posedge clk)         (simd_segment_write == 1 && $past(simd_segment_write) == 0) |-> (segment_idx < NUM_SEGMENT)"}
{"id": "622_5_0887", "name": "p_norm_max_abs_burst", "sva": "@(posedge clk)     (burst_valid && (abs_data < norm_max))[*8]", "ori_sva": "property p_norm_max_abs_burst;\n@(posedge clk)     (burst_valid && (abs_data < norm_max))[*8];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_norm_max_abs_burst  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: Not applicable (this is a sequence property, not an implication)  \n**Implication Operator**: Not applicable  \n**Consequent (RHS of Implication)**: Not applicable  \n**Sequence Description**: The sequence `(burst_valid && (abs_data < norm_max))` must hold true for **8 consecutive clock cycles**.  \n\n### Notes:  \n1. This is a **sequence property** (not an implication-based property), so it describes a temporal pattern (`[*8]`) rather than a logical implication.  \n2. The sequence requires that `burst_valid` is high **and** `abs_data` is less than `norm_max` for **8 consecutive clock cycles** after the triggering edge.  \n3. No disable condition (`disable iff`) is specified.", "sva_signals": ["clk", "rst_n", "[0:0] burst_valid", "[0:0] abs_data", "[0:0] norm_max"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     (burst_valid && (abs_data < norm_max))[*8]", "sva_name": "p_norm_max_abs_burst_sequence", "full_property": "property p_norm_max_abs_burst;\n@(posedge clk)     (burst_valid && (abs_data < norm_max))[*8]\nendproperty\nassert_p_norm_max_abs_burst:assert property (p_norm_max_abs_burst) else $error(\"\");", "task_id": "3_8936", "predict_sva": "@(posedge clk)     (burst_valid && (abs_data < norm_max)) [*8]"}
{"id": "636_4_1013", "name": "p_data_bus_no_x_stable", "sva": "@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)", "ori_sva": "property p_data_bus_no_x_stable;\n@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_bus_no_x_stable  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(data_bus)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(data_bus)`", "sva_signals": ["clk", "rst_n", "[0:0] data_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)", "sva_name": "p_Stable_Data_No_X", "full_property": "property p_data_bus_no_x_stable;\n@(posedge clk)     $stable(data_bus) |-> !$isunknown(data_bus)\nendproperty\nassert_p_data_bus_no_x_stable:assert property (p_data_bus_no_x_stable) else $error(\"\");", "task_id": "3_8995", "predict_sva": "@(posedge clk)         $stable(data_bus) |-> !$isunknown(data_bus)"}
{"id": "641_6_1067", "name": "sensor_redundancy_p6", "sva": "@(posedge clk_sys)     $past(sensor_1,1) - $past(sensor_2,1) inside {[-redundancy_tol:redundancy_tol]}", "ori_sva": "property sensor_redundancy_p6;\n@(posedge clk_sys)     $past(sensor_1,1) - $past(sensor_2,1) inside {[-redundancy_tol:redundancy_tol]};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sensor_redundancy_p6  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: None (This is a simple property without implication)  \n**Implication Operator**: None  \n**Consequent (RHS of Implication)**: The difference between the past value of `sensor_1` (one clock cycle ago) and the past value of `sensor_2` (one clock cycle ago) must be within the range `[-redundancy_tol : redundancy_tol]`.  \n\n(Note: This is a standalone property check rather than an implication-based assertion, so it directly evaluates the condition on every clock edge.)", "sva_signals": ["clk_sys", "[15:0] sensor_1", "[15:0] sensor_2", "[15:0] redundancy_tol"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($past(sensor_1) - $past(sensor_2)) inside {[-redundancy_tol : redundancy_tol]}", "sva_name": "p_sensor_redundancy_check", "full_property": "property sensor_redundancy_p6;\n@(posedge clk_sys)     ($past(sensor_1) - $past(sensor_2)) inside {[-redundancy_tol : redundancy_tol]}\nendproperty\nassert_sensor_redundancy_p6:assert property (sensor_redundancy_p6) else $error(\"\");", "task_id": "3_9017", "predict_sva": "@(posedge clk_sys)     ($past(sensor_1) - $past(sensor_2)) inside {[redundancy_tol:1]}"}
{"id": "647_9_1122", "name": "p_context_saved_pulse", "sva": "@(posedge clk_core)     $rose(thread_context_saved) |-> ##1 !$fell(thread_context_saved)", "ori_sva": "property p_context_saved_pulse;\n@(posedge clk_core)     $rose(thread_context_saved) |-> ##1 !$fell(thread_context_saved);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_context_saved_pulse  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(thread_context_saved)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !$fell(thread_context_saved)`  ", "sva_signals": ["clk_core", "thread_context_saved", "[0:0] rst_n"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(thread_context_saved) |-> ##1 !$fell(thread_context_saved)", "sva_name": "p_no_thread_context_saved_fall_after_rise", "full_property": "property p_context_saved_pulse;\n@(posedge clk_core)     $rose(thread_context_saved) |-> ##1 !$fell(thread_context_saved)\nendproperty\nassert_p_context_saved_pulse:assert property (p_context_saved_pulse) else $error(\"\");", "task_id": "3_9048", "predict_sva": "@(posedge clk_core)         $rose(thread_context_saved) |-> ##1 !$fell(thread_context_saved)"}
{"id": "649_7_1139", "name": "p_decoded_inst_onehot_fetch", "sva": "@(posedge clk_core)     fetch_complete_ |-> $onehot(decoded_inst_)", "ori_sva": "property p_decoded_inst_onehot_fetch;\n@(posedge clk_core)     fetch_complete_ |-> $onehot(decoded_inst_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_decoded_inst_onehot_fetch  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fetch_complete_ == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$onehot(decoded_inst_)`  \n\n(Explanation: The assertion checks that whenever `fetch_complete_` is high at a rising edge of `clk_core`, the signal `decoded_inst_` must be one-hot encoded, meaning exactly one bit is set to 1.)", "sva_signals": ["clk_core", "[0:0] fetch_complete_", "[0:0] decoded_inst_"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     fetch_complete_ == 1'b1 |-> $onehot(decoded_inst_)", "sva_name": "p_decoded_inst_onehot_on_fetch_complete", "full_property": "property p_decoded_inst_onehot_fetch;\n@(posedge clk_core)     fetch_complete_ == 1'b1 |-> $onehot(decoded_inst_)\nendproperty\nassert_p_decoded_inst_onehot_fetch:assert property (p_decoded_inst_onehot_fetch) else $error(\"\");", "task_id": "3_9055", "predict_sva": "@(posedge clk_core)         fetch_complete_ == 1 |-> $onehot(decoded_inst_)"}
{"id": "652_4_1170", "name": "tlp_header_tc_valid", "sva": "@(posedge clk_tlp)     tlp_header_valid |-> (tlp_tc inside {0,1,2,3,4,5,6,7})", "ori_sva": "property tlp_header_tc_valid;\n@(posedge clk_tlp)     tlp_header_valid |-> (tlp_tc inside {0,1,2,3,4,5,6,7});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: tlp_header_tc_valid  \n**Trigger Condition**: At every rising edge of the `clk_tlp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tlp_header_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `tlp_tc inside {0,1,2,3,4,5,6,7}`", "sva_signals": ["clk_tlp", "[2:0] tlp_tc", "[0:0] tlp_header_valid"], "clock": "clk_tlp", "attempts_left": 10, "sva_result": "@(posedge clk_tlp)     tlp_header_valid == 1'b1 |-> tlp_tc inside {0,1,2,3,4,5,6,7}", "sva_name": "p_tlp_header_valid_tlp_tc_range", "full_property": "property tlp_header_tc_valid;\n@(posedge clk_tlp)     tlp_header_valid == 1'b1 |-> tlp_tc inside {0,1,2,3,4,5,6,7}\nendproperty\nassert_tlp_header_tc_valid:assert property (tlp_header_tc_valid) else $error(\"\");", "task_id": "3_9076", "predict_sva": "@(posedge clk_tlp)         tlp_header_valid == 1'b1 |-> tlp_tc inside {0,1,2,3,4,5,6,7}"}
{"id": "657_4_1204", "name": "p_channel_gain_stable", "sva": "@(posedge clk_signal)     $stable(channel_gain) |-> channel_gain inside {[MIN_GAIN:MAX_GAIN]}", "ori_sva": "property p_channel_gain_stable;\n@(posedge clk_signal)     $stable(channel_gain) |-> channel_gain inside {[MIN_GAIN:MAX_GAIN]};\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_channel_gain_stable  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$stable(channel_gain)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `channel_gain inside {[MIN_GAIN:MAX_GAIN]}`  ", "sva_signals": ["clk_signal", "[0:0] channel_gain", "[0:0] MIN_GAIN", "[0:0] MAX_GAIN"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $stable(channel_gain) |-> channel_gain inside {[MIN_GAIN:MAX_GAIN]}", "sva_name": "p_channel_gain_stable_range", "full_property": "property p_channel_gain_stable;\n@(posedge clk_signal)     $stable(channel_gain) |-> channel_gain inside {[MIN_GAIN:MAX_GAIN]}\nendproperty\nassert_p_channel_gain_stable:assert property (p_channel_gain_stable) else $error(\"\");", "task_id": "3_9105", "predict_sva": "@(posedge clk_signal)         $stable(channel_gain) |-> channel_gain >= MIN_GAIN && channel_gain <= MAX_GAIN"}
{"id": "658_10_1198", "name": "ldpc_check_pass_p10", "sva": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct", "ori_sva": "property ldpc_check_pass_p10;\n@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ldpc_check_pass_p10  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `first_match(##[1:20] ldpc_check_finished)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ldpc_check_correct`  ", "sva_signals": ["clk_sys", "[0:0] ldpc_check_finished", "[0:0] ldpc_check_correct"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct", "sva_name": "p_ldpc_check_finished_correct", "full_property": "property ldpc_check_pass_p10;\n@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct\nendproperty\nassert_ldpc_check_pass_p10:assert property (ldpc_check_pass_p10) else $error(\"\");", "task_id": "3_9109", "predict_sva": "@(posedge clk_sys)     first_match(##[1:20] ldpc_check_finished) |-> ldpc_check_correct"}
{"id": "668_4_1322", "name": "p_temp_falling_check", "sva": "@(posedge clk_sys)     $fell(temp_alert_enable) |-> temp_value > MIN_TEMP", "ori_sva": "property p_temp_falling_check;\n@(posedge clk_sys)     $fell(temp_alert_enable) |-> temp_value > MIN_TEMP;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_falling_check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(temp_alert_enable)` (a falling edge detected on `temp_alert_enable`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `temp_value > MIN_TEMP` (the current temperature value is greater than the minimum threshold `MIN_TEMP`)", "sva_signals": ["clk_sys", "rst_n", "[0:0] temp_alert_enable", "[0:0] temp_value", "[0:0] MIN_TEMP"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $fell(temp_alert_enable) |-> temp_value > MIN_TEMP", "sva_name": "p_temp_alert_enable_falling_edge_temp_value_above_min_temp", "full_property": "property p_temp_falling_check;\n@(posedge clk_sys)         $fell(temp_alert_enable) |-> temp_value > MIN_TEMP\nendproperty\nassert_p_temp_falling_check:assert property (p_temp_falling_check) else $error(\"\");", "task_id": "3_9168", "predict_sva": "@(posedge clk_sys)         $fell(temp_alert_enable) |-> temp_value > MIN_TEMP"}
{"id": "668_8_1334", "name": "p_temp_power_on_check", "sva": "@(posedge clk_sys)     $rose(power_good) |=> temp_value > MIN_TEMP", "ori_sva": "property p_temp_power_on_check;\n@(posedge clk_sys)     $rose(power_good) |=> temp_value > MIN_TEMP;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_power_on_check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(power_good)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `temp_value > MIN_TEMP`  ", "sva_signals": ["clk_sys", "[0:0] power_good", "[0:0] temp_value", "[0:0] MIN_TEMP"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(power_good) |=> (temp_value > MIN_TEMP)", "sva_name": "p_temp_value_above_min_on_power_good_rise", "full_property": "property p_temp_power_on_check;\n@(posedge clk_sys)         $rose(power_good) |=> (temp_value > MIN_TEMP)\nendproperty\nassert_p_temp_power_on_check:assert property (p_temp_power_on_check) else $error(\"\");", "task_id": "3_9171", "predict_sva": "@(posedge clk_sys)         $rose(power_good) |-> temp_value > MIN_TEMP"}
{"id": "673_10_1374", "name": "stack_comm_no_x_p10", "sva": "@(posedge clk_sys)     (data_phase && !error_flag) |-> !$isunknown(stack_comm_bus)", "ori_sva": "property stack_comm_no_x_p10;\n@(posedge clk_sys)     (data_phase && !error_flag) |-> !$isunknown(stack_comm_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stack_comm_no_x_p10  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_phase && !error_flag`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$isunknown(stack_comm_bus)`  ", "sva_signals": ["clk_sys", "[0:0] data_phase", "[0:0] error_flag", "[0:0] stack_comm_bus"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (data_phase && !error_flag) |-> !$isunknown(stack_comm_bus)", "sva_name": "stack_comm_no_x_p2", "full_property": "property stack_comm_no_x_p10;\n@(posedge clk_sys)     (data_phase && !error_flag) |-> !$isunknown(stack_comm_bus)\nendproperty\nassert_stack_comm_no_x_p10:assert property (stack_comm_no_x_p10) else $error(\"\");", "task_id": "3_9195", "predict_sva": "@(posedge clk_sys)         (data_phase && !error_flag) |-> !$isunknown(stack_comm_bus)"}
{"id": "673_1_1341", "name": "stack_comm_no_x_p1", "sva": "@(posedge clk_sys)     !$isunknown(stack_comm_bus)", "ori_sva": "property stack_comm_no_x_p1;\n@(posedge clk_sys)     !$isunknown(stack_comm_bus);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: stack_comm_no_x_p1  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Assertion Check**: The signal `stack_comm_bus` must not contain any unknown ('x' or 'z') values.  \n\n(Note: This is a simple assertion property without an implication operator. It directly checks that `stack_comm_bus` is always known at every rising edge of `clk_sys`.)", "sva_signals": ["clk_sys", "stack_comm_bus"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     !$isunknown(stack_comm_bus)", "sva_name": "stack_comm_no_x_p6", "full_property": "property stack_comm_no_x_p1;\n@(posedge clk_sys)     !$isunknown(stack_comm_bus)\nendproperty\nassert_stack_comm_no_x_p1:assert property (stack_comm_no_x_p1) else $error(\"\");", "task_id": "3_9196", "predict_sva": "@(posedge clk_sys)         !$isunknown(stack_comm_bus)"}
{"id": "677_6_1400", "name": "batchnorm_param_stable_p6", "sva": "@(posedge clk)     $rose(inference_enable) |-> $stable(batchnorm_param) until $fell(inference_enable)", "ori_sva": "property batchnorm_param_stable_p6;\n@(posedge clk)     $rose(inference_enable) |-> $stable(batchnorm_param) until $fell(inference_enable);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: batchnorm_param_stable_p6  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(inference_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(batchnorm_param) until $fell(inference_enable)`  ", "sva_signals": ["clk", "rst_n", "[0:0] inference_enable", "[0:0] batchnorm_param"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(inference_enable) |-> $stable(batchnorm_param) until $fell(inference_enable)", "sva_name": "batchnorm_param_stable_during_inference", "full_property": "property batchnorm_param_stable_p6;\n@(posedge clk)         $rose(inference_enable) |-> $stable(batchnorm_param) until $fell(inference_enable)\nendproperty\nassert_batchnorm_param_stable_p6:assert property (batchnorm_param_stable_p6) else $error(\"\");", "task_id": "3_9227", "predict_sva": "@(posedge clk)     $rose(inference_enable) |-> $stable(batchnorm_param) until $fell(inference_enable)"}
{"id": "677_8_1399", "name": "batchnorm_param_stable_p8", "sva": "@(posedge clk)     disable iff (rst)     inference_active |-> $stable(batchnorm_param)", "ori_sva": "property batchnorm_param_stable_p8;\n@(posedge clk)     disable iff (rst)     inference_active |-> $stable(batchnorm_param);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: batchnorm_param_stable_p8  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: disable iff (`rst`)  \n**Antecedent (LHS of Implication)**: `inference_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(batchnorm_param)`  \n\n(Note: `$stable(batchnorm_param)` means the value of `batchnorm_param` must remain unchanged from its previous value when the antecedent is true.)", "sva_signals": ["clk", "rst", "[0:0] inference_active", "[0:0] batchnorm_param"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk) disable iff (rst)         inference_active == 1'b1 |-> $stable(batchnorm_param)", "sva_name": "batchnorm_param_stable_p2", "full_property": "property batchnorm_param_stable_p8;\n@(posedge clk) disable iff (rst)         inference_active == 1'b1 |-> $stable(batchnorm_param)\nendproperty\nassert_batchnorm_param_stable_p8:assert property (batchnorm_param_stable_p8) else $error(\"\");", "task_id": "3_9228", "predict_sva": "@(posedge clk) disable iff (rst == 1'b1)     inference_active == 1'b1 |-> $stable(batchnorm_param)"}
{"id": "688_6_1534", "name": "p_data_bus_highz_after_activity", "sva": "@(posedge clk)     $rose(!bus_active) |-> ##1 data_bus === 'z", "ori_sva": "property p_data_bus_highz_after_activity;\n@(posedge clk)     $rose(!bus_active) |-> ##1 data_bus === 'z;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_bus_highz_after_activity  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(!bus_active)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 data_bus === 'z`", "sva_signals": ["clk", "rst_n", "[0:0] bus_active", "[0:0] data_bus"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)         $rose(!bus_active) |-> ##1 data_bus === 'z", "sva_name": "p_data_bus_high_impedance_after_bus_inactive", "full_property": "property p_data_bus_highz_after_activity;\n@(posedge clk)         $rose(!bus_active) |-> ##1 data_bus === 'z\nendproperty\nassert_p_data_bus_highz_after_activity:assert property (p_data_bus_highz_after_activity) else $error(\"\");", "task_id": "3_9268", "predict_sva": "@(posedge clk)         $rose(!bus_active) |-> ##1 (data_bus === 'z)"}
{"id": "689_5_1492", "name": "error_prevents_tx_rise", "sva": "@(posedge can_clk)     can_error_state |-> !$rose(can_tx_en)", "ori_sva": "property error_prevents_tx_rise;\n@(posedge can_clk)     can_error_state |-> !$rose(can_tx_en);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: error_prevents_tx_rise  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_state == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$rose(can_tx_en)`  ", "sva_signals": ["can_clk", "can_error_state", "[0:0] can_tx_en"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)         can_error_state == 1'b1 |-> !$rose(can_tx_en)", "sva_name": "p_no_can_tx_en_rise_in_error_state", "full_property": "property error_prevents_tx_rise;\n@(posedge can_clk)         can_error_state == 1'b1 |-> !$rose(can_tx_en)\nendproperty\nassert_error_prevents_tx_rise:assert property (error_prevents_tx_rise) else $error(\"\");", "task_id": "3_9275", "predict_sva": "@(posedge can_clk)         can_error_state == 1'b1 |-> !$rose(can_tx_en)"}
{"id": "700_3_1601", "name": "p_thread_switch_stable_after_assert", "sva": "@(posedge clk)     $rose(|thread_switch) |-> ##1 $stable(thread_switch)", "ori_sva": "property p_thread_switch_stable_after_assert;\n@(posedge clk)     $rose(|thread_switch) |-> ##1 $stable(thread_switch);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_thread_switch_stable_after_assert  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(|thread_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(thread_switch)`  ", "sva_signals": ["clk", "rst_n", "[0:0] thread_switch"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $rose(|thread_switch) |-> ##1 $stable(thread_switch)", "sva_name": "p_thread_switch_stable_after_rise", "full_property": "property p_thread_switch_stable_after_assert;\n@(posedge clk)     $rose(|thread_switch) |-> ##1 $stable(thread_switch)\nendproperty\nassert_p_thread_switch_stable_after_assert:assert property (p_thread_switch_stable_after_assert) else $error(\"\");", "task_id": "3_9311", "predict_sva": "@(posedge clk)         $rose(|thread_switch) |-> ##1 thread_switch == $past(thread_switch)"}
{"id": "700_7_1595", "name": "p_thread_switch_no_burst", "sva": "@(posedge clk)     $fell(|thread_switch) |-> ##[1:$] !$rose(|thread_switch) until $rose(|thread_switch)", "ori_sva": "property p_thread_switch_no_burst;\n@(posedge clk)     $fell(|thread_switch) |-> ##[1:$] !$rose(|thread_switch) until $rose(|thread_switch);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_thread_switch_no_burst  \n**Trigger Condition**: At every rising edge of the `clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(|thread_switch)` (a falling edge on the OR of all bits in `thread_switch`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:$] !$rose(|thread_switch) until $rose(|thread_switch)`  \n- After the antecedent is true, within 1 to an unbounded number of clock cycles (`##[1:$]`), the OR of all bits in `thread_switch` must not rise (`!$rose(|thread_switch)`) until it eventually rises again (`until $rose(|thread_switch)`).  ", "sva_signals": ["clk", "rst_n", "[0:0] thread_switch"], "clock": "clk", "attempts_left": 10, "sva_result": "@(posedge clk)     $fell(|thread_switch) |-> ##[1:$] !$rose(|thread_switch) until $rose(|thread_switch)", "sva_name": "p_thread_switch_no_spurious_rise", "full_property": "property p_thread_switch_no_burst;\n@(posedge clk)     $fell(|thread_switch) |-> ##[1:$] !$rose(|thread_switch) until $rose(|thread_switch)\nendproperty\nassert_p_thread_switch_no_burst:assert property (p_thread_switch_no_burst) else $error(\"\");", "task_id": "3_9314", "predict_sva": "@(posedge clk)     $fell(|thread_switch) |-> ##1 (!($rose(|thread_switch)))[*1:$] ##1 $rose(|thread_switch)"}
{"id": "712_3_1698", "name": "p_channel_est_valid_after_reset", "sva": "@(posedge clk_signal)     $fell(reset_n) |-> ##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX)", "ori_sva": "property p_channel_est_valid_after_reset;\n@(posedge clk_signal)     $fell(reset_n) |-> ##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_channel_est_valid_after_reset  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(reset_n)` (reset_n transitions from high to low)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX)` (Within 1 to 10 clock cycles after the antecedent, `channel_est` must be within the range [`CH_MIN`, `CH_MAX`])", "sva_signals": ["clk_signal", "[0:0] reset_n", "[0:0] channel_est", "[0:0] CH_MIN", "[0:0] CH_MAX"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     $fell(reset_n) |-> ##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX)", "sva_name": "p_channel_est_valid_after_reset", "full_property": "property p_channel_est_valid_after_reset;\n@(posedge clk_signal)     $fell(reset_n) |-> ##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX)\nendproperty\nassert_p_channel_est_valid_after_reset:assert property (p_channel_est_valid_after_reset) else $error(\"\");", "task_id": "3_9367", "predict_sva": "@(posedge clk_signal)     $fell(reset_n) |-> ##[1:10] (channel_est >= CH_MIN && channel_est <= CH_MAX)"}
{"id": "716_6_1726", "name": "reram_write_transition_p", "sva": "@(posedge reram_clk)     reram_cell_state != expected_state && reram_write_enable |-> ##2 reram_cell_state == expected_state", "ori_sva": "property reram_write_transition_p;\n@(posedge reram_clk)     reram_cell_state != expected_state && reram_write_enable |-> ##2 reram_cell_state == expected_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: reram_write_transition_p  \n**Trigger Condition**: At every rising edge of the `reram_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `reram_cell_state != expected_state && reram_write_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 reram_cell_state == expected_state`  ", "sva_signals": ["reram_clk", "reram_write_enable", "[0:0] reram_cell_state", "[0:0] expected_state"], "clock": "reram_clk", "attempts_left": 10, "sva_result": "@(posedge reram_clk)         (reram_cell_state != expected_state && reram_write_enable) |-> ##2 (reram_cell_state == expected_state)", "sva_name": "reram_write_prop", "full_property": "property reram_write_transition_p;\n@(posedge reram_clk)         (reram_cell_state != expected_state && reram_write_enable) |-> ##2 (reram_cell_state == expected_state)\nendproperty\nassert_reram_write_transition_p:assert property (reram_write_transition_p) else $error(\"\");", "task_id": "3_9384", "predict_sva": "@(posedge reram_clk)    (reram_write_enable && (reram_cell_state != expected_state)) |=> ##2 (reram_cell_state == expected_state)"}
{"id": "718_3_1738", "name": "thermal_protect_implies_low_power_3", "sva": "@(posedge clk_sys)     $rose(thermal_protect_signal) |=> all_modules_low_power_state", "ori_sva": "property thermal_protect_implies_low_power_3;\n@(posedge clk_sys)     $rose(thermal_protect_signal) |=> all_modules_low_power_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_protect_implies_low_power_3  \n**Trigger Condition**: At every rising edge of `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(thermal_protect_signal)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `all_modules_low_power_state`  ", "sva_signals": ["clk_sys", "thermal_protect_signal", "all_modules_low_power_state"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(thermal_protect_signal) |=> all_modules_low_power_state", "sva_name": "p_thermal_protect_low_power_entry", "full_property": "property thermal_protect_implies_low_power_3;\n@(posedge clk_sys)         $rose(thermal_protect_signal) |=> all_modules_low_power_state\nendproperty\nassert_thermal_protect_implies_low_power_3:assert property (thermal_protect_implies_low_power_3) else $error(\"\");", "task_id": "3_9397", "predict_sva": "@(posedge clk_sys)         $rose(thermal_protect_signal) |-> all_modules_low_power_state == 1"}
{"id": "718_7_1749", "name": "thermal_protect_implies_low_power_7", "sva": "@(posedge clk_sys)     $rose(thermal_protect_signal) |-> ##[0:1] all_modules_low_power_state", "ori_sva": "property thermal_protect_implies_low_power_7;\n@(posedge clk_sys)     $rose(thermal_protect_signal) |-> ##[0:1] all_modules_low_power_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_protect_implies_low_power_7  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(thermal_protect_signal)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:1] all_modules_low_power_state`  ", "sva_signals": ["clk_sys", "[0:0] thermal_protect_signal", "[0:0] all_modules_low_power_state"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)         $rose(thermal_protect_signal) |-> ##[0:1] all_modules_low_power_state", "sva_name": "thermal_protect_implies_low_power_1", "full_property": "property thermal_protect_implies_low_power_7;\n@(posedge clk_sys)         $rose(thermal_protect_signal) |-> ##[0:1] all_modules_low_power_state\nendproperty\nassert_thermal_protect_implies_low_power_7:assert property (thermal_protect_implies_low_power_7) else $error(\"\");", "task_id": "3_9401", "predict_sva": "@(posedge clk_sys)     $rose(thermal_protect_signal) |-> ##[0:1] all_modules_low_power_state"}
{"id": "725_6_1794", "name": "elu_valid_range", "sva": "@(posedge clk_signal)     !$isunknown(act_elu_alpha) |-> (act_elu_out >= -act_elu_alpha)", "ori_sva": "property elu_valid_range;\n@(posedge clk_signal)     !$isunknown(act_elu_alpha) |-> (act_elu_out >= -act_elu_alpha);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: elu_valid_range  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!$isunknown(act_elu_alpha)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(act_elu_out >= -act_elu_alpha)`", "sva_signals": ["clk_signal", "[0:0] rst_n", "[0:0] act_elu_alpha", "[0:0] act_elu_out"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     !$isunknown(act_elu_alpha) |-> (act_elu_out >= -act_elu_alpha)", "sva_name": "p_act_elu_out_negation", "full_property": "property elu_valid_range;\n@(posedge clk_signal)     !$isunknown(act_elu_alpha) |-> (act_elu_out >= -act_elu_alpha)\nendproperty\nassert_elu_valid_range:assert property (elu_valid_range) else $error(\"\");", "task_id": "3_9431", "predict_sva": "@(posedge clk_signal)         !$isunknown(act_elu_alpha) |-> act_elu_out >= -act_elu_alpha"}
{"id": "726_8_1821", "name": "p_bn_param8_no_modify", "sva": "@(posedge clk_inference)     inference_in_progress_ && !bn_param_update_ |-> $stable(bn_param8_)", "ori_sva": "property p_bn_param8_no_modify;\n@(posedge clk_inference)     inference_in_progress_ && !bn_param_update_ |-> $stable(bn_param8_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bn_param8_no_modify  \n**Trigger Condition**: At every rising edge of the `clk_inference`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `inference_in_progress_ && !bn_param_update_`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(bn_param8_)`  ", "sva_signals": ["clk_inference", "inference_in_progress_", "bn_param_update_", "bn_param8_"], "clock": "clk_inference", "attempts_left": 10, "sva_result": "@(posedge clk_inference)         (inference_in_progress_ && !bn_param_update_) |-> $stable(bn_param8_)", "sva_name": "p_bn_param8_stable_during_inference", "full_property": "property p_bn_param8_no_modify;\n@(posedge clk_inference)         (inference_in_progress_ && !bn_param_update_) |-> $stable(bn_param8_)\nendproperty\nassert_p_bn_param8_no_modify:assert property (p_bn_param8_no_modify) else $error(\"\");", "task_id": "3_9439", "predict_sva": "@(posedge clk_inference)         (inference_in_progress_ == 1 && bn_param_update_ == 0) |-> $stable(bn_param8_)"}
{"id": "755_4_2080", "name": "all_lanes_same_state_after_negotiation_4", "sva": "@(posedge clk_signal)     link_width_done && $past(link_width_done) |-> lane_state == $past(lane_state)", "ori_sva": "property all_lanes_same_state_after_negotiation_4;\n@(posedge clk_signal)     link_width_done && $past(link_width_done) |-> lane_state == $past(lane_state);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: all_lanes_same_state_after_negotiation_4  \n**Trigger Condition**: At every rising edge of the `clk_signal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `link_width_done && $past(link_width_done)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `lane_state == $past(lane_state)`", "sva_signals": ["clk_signal", "[0:0] link_width_done", "[0:0] lane_state"], "clock": "clk_signal", "attempts_left": 10, "sva_result": "@(posedge clk_signal)     (link_width_done && $past(link_width_done)) |-> (lane_state == $past(lane_state))", "sva_name": "p_lane_state_stability_after_link_width_done", "full_property": "property all_lanes_same_state_after_negotiation_4;\n@(posedge clk_signal)     (link_width_done && $past(link_width_done)) |-> (lane_state == $past(lane_state))\nendproperty\nassert_all_lanes_same_state_after_negotiation_4:assert property (all_lanes_same_state_after_negotiation_4) else $error(\"\");", "task_id": "3_9586", "predict_sva": "@(posedge clk_signal)         (link_width_done == 1 && $past(link_width_done) == 1) |-> ##1 lane_state == $past(lane_state)"}
{"id": "765_6_2185", "name": "p_write_complete_before_read", "sva": "@(posedge re_clk)     $rose(write_en_) |-> !read_en_ until $fell(write_en_)", "ori_sva": "property p_write_complete_before_read;\n@(posedge re_clk)     $rose(write_en_) |-> !read_en_ until $fell(write_en_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_write_complete_before_read  \n**Trigger Condition**: At every rising edge of `re_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(write_en_)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!read_en_ until $fell(write_en_)`  ", "sva_signals": ["re_clk", "[0:0] write_en_", "[0:0] read_en_"], "clock": "re_clk", "attempts_left": 10, "sva_result": "@(posedge re_clk)     $rose(write_en_) |-> !read_en_ until $fell(write_en_)", "sva_name": "p_write_en_no_read_3", "full_property": "property p_write_complete_before_read;\n@(posedge re_clk)     $rose(write_en_) |-> !read_en_ until $fell(write_en_)\nendproperty\nassert_p_write_complete_before_read:assert property (p_write_complete_before_read) else $error(\"\");", "task_id": "3_9630", "predict_sva": "@(posedge re_clk)    $rose(write_en_) |-> !read_en_ until $fell(write_en_)"}
{"id": "772_6_2206", "name": "relu_batchnorm_pipeline", "sva": "@(posedge clk_core)     relu_valid_out |=> ##2 bn_valid_out", "ori_sva": "property relu_batchnorm_pipeline;\n@(posedge clk_core)     relu_valid_out |=> ##2 bn_valid_out;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: relu_batchnorm_pipeline  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `relu_valid_out == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##2 bn_valid_out == 1'b1`  ", "sva_signals": ["clk_core", "[0:0] relu_valid_out", "[0:0] bn_valid_out"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     relu_valid_out == 1'b1 |=> ##2 bn_valid_out == 1'b1", "sva_name": "p_relu_to_bn_valid_out", "full_property": "property relu_batchnorm_pipeline;\n@(posedge clk_core)     relu_valid_out == 1'b1 |=> ##2 bn_valid_out == 1'b1\nendproperty\nassert_relu_batchnorm_pipeline:assert property (relu_batchnorm_pipeline) else $error(\"\");", "task_id": "3_9673", "predict_sva": "@(posedge clk_core)     relu_valid_out == 1'b1 |=> ##2 bn_valid_out == 1'b1"}
{"id": "779_7_2319", "name": "backup_channel_ready", "sva": "@(posedge can_clk)     $fell(crc_valid_primary) |-> crc_valid_backup && frame_valid_backup && !signal_noise_backup", "ori_sva": "property backup_channel_ready;\n@(posedge can_clk)     $fell(crc_valid_primary) |-> crc_valid_backup && frame_valid_backup && !signal_noise_backup;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: backup_channel_ready  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(crc_valid_primary)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `crc_valid_backup && frame_valid_backup && !signal_noise_backup`", "sva_signals": ["can_clk", "crc_valid_primary", "[0:0] crc_valid_backup", "[0:0] frame_valid_backup", "[0:0] signal_noise_backup"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     $fell(crc_valid_primary) |-> (crc_valid_backup && frame_valid_backup && !signal_noise_backup)", "sva_name": "p_crc_valid_primary_fall_backup_signals_asserted", "full_property": "property backup_channel_ready;\n@(posedge can_clk)     $fell(crc_valid_primary) |-> (crc_valid_backup && frame_valid_backup && !signal_noise_backup)\nendproperty\nassert_backup_channel_ready:assert property (backup_channel_ready) else $error(\"\");", "task_id": "3_9730", "predict_sva": "@(posedge can_clk)         $fell(crc_valid_primary) |-> (crc_valid_backup == 1 && frame_valid_backup == 1 && signal_noise_backup == 0)"}
{"id": "780_4_2305", "name": "alarm_trigger", "sva": "@(posedge clk_sys)     (sensor_1_fault || sensor_2_fault || sensor_3_fault) |=> ##[1:5] alarm_active", "ori_sva": "property alarm_trigger;\n@(posedge clk_sys)     (sensor_1_fault || sensor_2_fault || sensor_3_fault) |=> ##[1:5] alarm_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: alarm_trigger  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(sensor_1_fault || sensor_2_fault || sensor_3_fault)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:5] alarm_active`  ", "sva_signals": ["clk_sys", "[0:0] sensor_1_fault", "[0:0] sensor_2_fault", "[0:0] sensor_3_fault", "[0:0] alarm_active"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     (sensor_1_fault || sensor_2_fault || sensor_3_fault) |=> ##[1:5] alarm_active", "sva_name": "p_alarm_active_after_sensor_fault", "full_property": "property alarm_trigger;\n@(posedge clk_sys)     (sensor_1_fault || sensor_2_fault || sensor_3_fault) |=> ##[1:5] alarm_active\nendproperty\nassert_alarm_trigger:assert property (alarm_trigger) else $error(\"\");", "task_id": "3_9737", "predict_sva": "@(posedge clk_sys)         (sensor_1_fault == 1 || sensor_2_fault == 1 || sensor_3_fault == 1) |-> ##[1:5] alarm_active == 1"}
{"id": "789_3_2410", "name": "crc_check_valid", "sva": "@(posedge clk_ucie)     $rose(packet_valid) && !crc_error |=> $rose(packet_ack)", "ori_sva": "property crc_check_valid;\n@(posedge clk_ucie)     $rose(packet_valid) && !crc_error |=> $rose(packet_ack);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: crc_check_valid  \n**Trigger Condition**: At every rising edge of the `clk_ucie`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(packet_valid) && !crc_error`  \n**Implication Operator**: `|=>` (non-overlapping implication)  \n**Consequent (RHS of Implication)**: `$rose(packet_ack)`  ", "sva_signals": ["clk_ucie", "packet_valid", "crc_error", "packet_ack"], "clock": "clk_ucie", "attempts_left": 10, "sva_result": "@(posedge clk_ucie)         ($rose(packet_valid) && !crc_error) |=> $rose(packet_ack)", "sva_name": "p_packet_ack_rise_after_valid_no_crc_error", "full_property": "property crc_check_valid;\n@(posedge clk_ucie)         ($rose(packet_valid) && !crc_error) |=> $rose(packet_ack)\nendproperty\nassert_crc_check_valid:assert property (crc_check_valid) else $error(\"\");", "task_id": "3_9819", "predict_sva": "@(posedge clk_ucie)         ($rose(packet_valid) && crc_error == 0) |-> ##1 $rose(packet_ack)"}
{"id": "790_3_2428", "name": "qam_symbol_flip_detect", "sva": "@(posedge clk_qam)     (iq_invert == 1'b0) |=> !$changed(iq_swap)", "ori_sva": "property qam_symbol_flip_detect;\n@(posedge clk_qam)     (iq_invert == 1'b0) |=> !$changed(iq_swap);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: qam_symbol_flip_detect  \n**Trigger Condition**: At every rising edge of the `clk_qam`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `iq_invert == 1'b0`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `!$changed(iq_swap)`  ", "sva_signals": ["clk_qam", "[0:0] iq_invert", "[0:0] iq_swap"], "clock": "clk_qam", "attempts_left": 10, "sva_result": "@(posedge clk_qam)     iq_invert == 1'b0 |=> !$changed(iq_swap)", "sva_name": "p_iq_swap_no_change_when_invert_deasserted", "full_property": "property qam_symbol_flip_detect;\n@(posedge clk_qam)     iq_invert == 1'b0 |=> !$changed(iq_swap)\nendproperty\nassert_qam_symbol_flip_detect:assert property (qam_symbol_flip_detect) else $error(\"\");", "task_id": "3_9829", "predict_sva": "@(posedge clk_qam)         iq_invert == 1'b0 |-> $stable(iq_swap)"}
{"id": "795_9_2499", "name": "p_ack_pulse_width", "sva": "@(posedge clk_pim)     $rose(ack_mode_switch) |-> ack_mode_switch[*1:2] ##0 !ack_mode_switch", "ori_sva": "property p_ack_pulse_width;\n@(posedge clk_pim)     $rose(ack_mode_switch) |-> ack_mode_switch[*1:2] ##0 !ack_mode_switch\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ack_pulse_width  \n**Trigger Condition**: At every rising edge of the `clk_pim`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ack_mode_switch)` (ack_mode_switch transitions from low to high)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ack_mode_switch[*1:2] ##0 !ack_mode_switch` (ack_mode_switch remains high for 1 to 2 clock cycles, then goes low in the same cycle)", "sva_signals": ["clk_pim", "ack_mode_switch"], "clock": "clk_pim", "attempts_left": 10, "sva_result": "@(posedge clk_pim)     $rose(ack_mode_switch) |-> ack_mode_switch[*1:2] ##0 !ack_mode_switch", "sva_name": "p_ack_mode_switch_pulse_width", "full_property": "property p_ack_pulse_width;\n@(posedge clk_pim)     $rose(ack_mode_switch) |-> ack_mode_switch[*1:2] ##0 !ack_mode_switch\nendproperty\nassert_p_ack_pulse_width:assert property (p_ack_pulse_width) else $error(\"\");", "task_id": "3_9880", "predict_sva": "@(posedge clk_pim)         $rose(ack_mode_switch) |->          (ack_mode_switch [*1:2]) ##1 !ack_mode_switch"}
{"id": "798_1_2530", "name": "sparse_count_consistency", "sva": "@(posedge clk_sparse)     $changed(sparsity_ratio) |-> ##1 (zero_count == prev_zero_count + $countones(~non_zero_mask))", "ori_sva": "property sparse_count_consistency;\n@(posedge clk_sparse)     $changed(sparsity_ratio) |-> ##1 (zero_count == prev_zero_count + $countones(~non_zero_mask));\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sparse_count_consistency  \n**Trigger Condition**: At every rising edge of `clk_sparse`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(sparsity_ratio)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (zero_count == prev_zero_count + $countones(~non_zero_mask))`  ", "sva_signals": ["clk_sparse", "[0:0] sparsity_ratio", "[0:0] zero_count", "[0:0] prev_zero_count", "[0:0] non_zero_mask"], "clock": "clk_sparse", "attempts_left": 10, "sva_result": "@(posedge clk_sparse)     $changed(sparsity_ratio) |-> ##1 (zero_count == prev_zero_count + $countones(~non_zero_mask))", "sva_name": "p_zero_count_update_on_sparsity_ratio_change", "full_property": "property sparse_count_consistency;\n@(posedge clk_sparse)     $changed(sparsity_ratio) |-> ##1 (zero_count == prev_zero_count + $countones(~non_zero_mask))\nendproperty\nassert_sparse_count_consistency:assert property (sparse_count_consistency) else $error(\"\");", "task_id": "3_9894", "predict_sva": "@(posedge clk_sparse)         $changed(sparsity_ratio) |-> ##1 zero_count == prev_zero_count + $countones(~non_zero_mask)"}
{"id": "799_9_2545", "name": "p_sample_rate", "sva": "@(posedge temp_clk)     sensor_enable |-> ##[100:110] $rose(sensor_data_valid)", "ori_sva": "property p_sample_rate;\n@(posedge temp_clk)     sensor_enable |-> ##[100:110] $rose(sensor_data_valid);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sample_rate  \n**Trigger Condition**: At every rising edge of the `temp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sensor_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[100:110] $rose(sensor_data_valid)`  \n\n", "sva_signals": ["temp_clk", "[0:0] sensor_enable", "[0:0] sensor_data_valid"], "clock": "temp_clk", "attempts_left": 10, "sva_result": "@(posedge temp_clk)     sensor_enable == 1'b1 |-> ##[100:110] $rose(sensor_data_valid)", "sva_name": "p_sensor_data_valid_rise_within_100_110_cycles_after_enable", "full_property": "property p_sample_rate;\n@(posedge temp_clk)     sensor_enable == 1'b1 |-> ##[100:110] $rose(sensor_data_valid)\nendproperty\nassert_p_sample_rate:assert property (p_sample_rate) else $error(\"\");", "task_id": "3_9910", "predict_sva": "@(posedge temp_clk)         sensor_enable == 1'b1 |-> ##[100:110] $rose(sensor_data_valid)"}
{"id": "812_1_2705", "name": "p_mode_switch_no_data_loss", "sva": "@(posedge clk_core)     $changed(dec_mode_sel) |-> ##[1:3] (!dec_data_valid || (dec_data_valid && !$isunknown(dec_out_data)))", "ori_sva": "property p_mode_switch_no_data_loss;\n@(posedge clk_core)     $changed(dec_mode_sel) |-> ##[1:3] (!dec_data_valid || (dec_data_valid && !$isunknown(dec_out_data)))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mode_switch_no_data_loss  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$changed(dec_mode_sel)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] (!dec_data_valid || (dec_data_valid && !$isunknown(dec_out_data)))`  \n\n", "sva_signals": ["clk_core", "dec_mode_sel", "dec_data_valid", "dec_out_data"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $changed(dec_mode_sel) |-> ##[1:3] (!dec_data_valid || (dec_data_valid && !$isunknown(dec_out_data)))", "sva_name": "p_dec_mode_switch_data_valid", "full_property": "property p_mode_switch_no_data_loss;\n@(posedge clk_core)     $changed(dec_mode_sel) |-> ##[1:3] (!dec_data_valid || (dec_data_valid && !$isunknown(dec_out_data)))\nendproperty\nassert_p_mode_switch_no_data_loss:assert property (p_mode_switch_no_data_loss) else $error(\"\");", "task_id": "3_10017", "predict_sva": "@(posedge clk_core)     $changed(dec_mode_sel) |-> ##[1:3] (!dec_data_valid || !$isunknown(dec_out_data))"}
{"id": "816_13_2760", "name": "odt_proper_switch", "sva": "@(posedge ddr_clk)     $rose(rank_switch_req_) |-> ##[1:2] $changed(odt_control_)", "ori_sva": "property odt_proper_switch;\n@(posedge ddr_clk)     $rose(rank_switch_req_) |-> ##[1:2] $changed(odt_control_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: odt_proper_switch  \n**Trigger Condition**: At every rising edge of the `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(rank_switch_req_)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] $changed(odt_control_)`  ", "sva_signals": ["ddr_clk", "rank_switch_req_", "odt_control_"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         $rose(rank_switch_req_) |-> ##[1:2] $changed(odt_control_)", "sva_name": "rank_switch_odt_update", "full_property": "property odt_proper_switch;\n@(posedge ddr_clk)         $rose(rank_switch_req_) |-> ##[1:2] $changed(odt_control_)\nendproperty\nassert_odt_proper_switch:assert property (odt_proper_switch) else $error(\"\");", "task_id": "3_10047", "predict_sva": "@(posedge ddr_clk)    $rose(rank_switch_req_) |-> ##[1:2] $changed(odt_control_)"}
{"id": "834_2_2942", "name": "p_mipi_hotplug_detection", "sva": "@(posedge mipi_clk)     $fell(camera_power_2) |=> ##[1:3] $fell(camera_active_2)", "ori_sva": "property p_mipi_hotplug_detection;\n@(posedge mipi_clk)     $fell(camera_power_2) |=> ##[1:3] $fell(camera_active_2);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mipi_hotplug_detection  \n**Trigger Condition**: At every rising edge of the `mipi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(camera_power_2)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:3] $fell(camera_active_2)`  ", "sva_signals": ["mipi_clk", "camera_power_2", "camera_active_2"], "clock": "mipi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_clk)     $fell(camera_power_2) |=> ##[1:3] $fell(camera_active_2)", "sva_name": "p_camera_power_to_active_fall_within_3_cycles", "full_property": "property p_mipi_hotplug_detection;\n@(posedge mipi_clk)     $fell(camera_power_2) |=> ##[1:3] $fell(camera_active_2)\nendproperty\nassert_p_mipi_hotplug_detection:assert property (p_mipi_hotplug_detection) else $error(\"\");", "task_id": "3_10219", "predict_sva": "@(posedge mipi_clk)         $fell(camera_power_2) |-> ##[1:3] $fell(camera_active_2)"}
{"id": "835_8_2968", "name": "p_consistent_clock_during_transfer", "sva": "@(posedge mipi_clk)     mipi_data_valid |-> $stable(mipi_clock_freq)", "ori_sva": "property p_consistent_clock_during_transfer;\n@(posedge mipi_clk)     mipi_data_valid |-> $stable(mipi_clock_freq);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_consistent_clock_during_transfer  \n**Trigger Condition**: At every rising edge of `mipi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mipi_data_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(mipi_clock_freq)`  ", "sva_signals": ["mipi_clk", "mipi_data_valid", "[0:0] mipi_clock_freq"], "clock": "mipi_clk", "attempts_left": 10, "sva_result": "@(posedge mipi_clk)     mipi_data_valid == 1'b1 |-> $stable(mipi_clock_freq)", "sva_name": "p_mipi_clock_freq_stable_when_data_valid", "full_property": "property p_consistent_clock_during_transfer;\n@(posedge mipi_clk)     mipi_data_valid == 1'b1 |-> $stable(mipi_clock_freq)\nendproperty\nassert_p_consistent_clock_during_transfer:assert property (p_consistent_clock_during_transfer) else $error(\"\");", "task_id": "3_10235", "predict_sva": "@(posedge mipi_clk)         mipi_data_valid == 1'b1 |-> $stable(mipi_clock_freq)"}
{"id": "840_8_3058", "name": "refresh_complete_before_pwr_down", "sva": "@(posedge ddr_clk)     $rose(ddr_pwr_down) |-> $past(!ddr_refresh_pending, 1)", "ori_sva": "property refresh_complete_before_pwr_down;\n@(posedge ddr_clk)     $rose(ddr_pwr_down) |-> $past(!ddr_refresh_pending, 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: refresh_complete_before_pwr_down  \n**Trigger Condition**: At every rising edge of `ddr_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ddr_pwr_down)` (detects a rising edge on `ddr_pwr_down`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(!ddr_refresh_pending, 1)` (checks that `ddr_refresh_pending` was low in the previous clock cycle)", "sva_signals": ["ddr_clk", "ddr_pwr_down", "ddr_refresh_pending"], "clock": "ddr_clk", "attempts_left": 10, "sva_result": "@(posedge ddr_clk)         $rose(ddr_pwr_down) |-> $past(!ddr_refresh_pending, 1)", "sva_name": "pwr_down_no_refresh_pending", "full_property": "property refresh_complete_before_pwr_down;\n@(posedge ddr_clk)         $rose(ddr_pwr_down) |-> $past(!ddr_refresh_pending, 1)\nendproperty\nassert_refresh_complete_before_pwr_down:assert property (refresh_complete_before_pwr_down) else $error(\"\");", "task_id": "3_10294", "predict_sva": "@(posedge ddr_clk)         $rose(ddr_pwr_down) |-> $past(ddr_refresh_pending) == 1'b0"}
{"id": "843_1_3084", "name": "p_awvalid_awready_reset_handshake", "sva": "@(posedge axi_clk)     $rose(master_reset_) |-> ##[0:3] (awvalid_ && awready_)", "ori_sva": "property p_awvalid_awready_reset_handshake;\n@(posedge axi_clk)     $rose(master_reset_) |-> ##[0:3] (awvalid_ && awready_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_awvalid_awready_reset_handshake  \n**Trigger Condition**: At every rising edge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(master_reset_)` (master_reset_ transitions from low to high)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:3] (awvalid_ && awready_)` (Within 0 to 3 clock cycles after the antecedent, both `awvalid_` and `awready_` must be high)", "sva_signals": ["axi_clk", "master_reset_", "[0:0] awvalid_", "[0:0] awready_"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)     $rose(master_reset_) |-> ##[0:3] (awvalid_ && awready_)", "sva_name": "p_aw_handshake_after_master_reset", "full_property": "property p_awvalid_awready_reset_handshake;\n@(posedge axi_clk)     $rose(master_reset_) |-> ##[0:3] (awvalid_ && awready_)\nendproperty\nassert_p_awvalid_awready_reset_handshake:assert property (p_awvalid_awready_reset_handshake) else $error(\"\");", "task_id": "3_10326", "predict_sva": "@(posedge axi_clk)    $rose(master_reset_) |-> ##[0:3] (awvalid_ && awready_)"}
{"id": "845_8_3108", "name": "data_beat_count", "sva": "@(posedge axi_clk)     $rose(w_valid) && w_last |-> w_cnt == $past(w_len)", "ori_sva": "property data_beat_count;\n@(posedge axi_clk)     $rose(w_valid) && w_last |-> w_cnt == $past(w_len);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_beat_count  \n**Trigger Condition**: At every posedge of `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(w_valid) && w_last`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `w_cnt == $past(w_len)`", "sva_signals": ["axi_clk", "w_valid", "w_last", "w_cnt", "w_len"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)         ($rose(w_valid) && w_last) |-> (w_cnt == $past(w_len))", "sva_name": "p_w_cnt_matches_prev_w_len_on_w_valid_rise", "full_property": "property data_beat_count;\n@(posedge axi_clk)         ($rose(w_valid) && w_last) |-> (w_cnt == $past(w_len))\nendproperty\nassert_data_beat_count:assert property (data_beat_count) else $error(\"\");", "task_id": "3_10349", "predict_sva": "@(posedge axi_clk)         ($rose(w_valid) && w_last) |-> (w_cnt == $past(w_len))"}
{"id": "846_3_3105", "name": "pcie_lane_reversal_check", "sva": "@(posedge pcie_clk_i)     (lane_reversal_en_i && $rose(phy_ready_o)) |-> ##[1:4] lane_polarity_o == expected_polarity_i", "ori_sva": "property pcie_lane_reversal_check;\n@(posedge pcie_clk_i)     (lane_reversal_en_i && $rose(phy_ready_o)) |-> ##[1:4] lane_polarity_o == expected_polarity_i;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_lane_reversal_check  \n**Trigger Condition**: At every rising edge of the `pcie_clk_i`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lane_reversal_en_i && $rose(phy_ready_o)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] lane_polarity_o == expected_polarity_i`  ", "sva_signals": ["pcie_clk_i", "lane_reversal_en_i", "phy_ready_o", "lane_polarity_o", "expected_polarity_i"], "clock": "pcie_clk_i", "attempts_left": 10, "sva_result": "@(posedge pcie_clk_i)     (lane_reversal_en_i && $rose(phy_ready_o)) |-> ##[1:4] (lane_polarity_o == expected_polarity_i)", "sva_name": "pcie_lane_reversal_polarity_check", "full_property": "property pcie_lane_reversal_check;\n@(posedge pcie_clk_i)     (lane_reversal_en_i && $rose(phy_ready_o)) |-> ##[1:4] (lane_polarity_o == expected_polarity_i)\nendproperty\nassert_pcie_lane_reversal_check:assert property (pcie_lane_reversal_check) else $error(\"\");", "task_id": "3_10354", "predict_sva": "@(posedge pcie_clk_i)    (lane_reversal_en_i && $rose(phy_ready_o)) |->     (##[1:4] (lane_polarity_o == expected_polarity_i))"}
{"id": "852_10_3206", "name": "lane_config_persistence", "sva": "@(posedge serdes_clk)     $rose(restore_state) |-> lane_config == saved_lane_config", "ori_sva": "property lane_config_persistence;\n@(posedge serdes_clk)     $rose(restore_state) |-> lane_config == saved_lane_config;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: lane_config_persistence  \n**Trigger Condition**: At every rising edge of `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(restore_state)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `lane_config == saved_lane_config`  \n\n", "sva_signals": ["serdes_clk", "restore_state", "[0:0] lane_config", "[0:0] saved_lane_config"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)         $rose(restore_state) |-> lane_config == saved_lane_config", "sva_name": "p_lane_config_restore_on_restore_state_rise", "full_property": "property lane_config_persistence;\n@(posedge serdes_clk)         $rose(restore_state) |-> lane_config == saved_lane_config\nendproperty\nassert_lane_config_persistence:assert property (lane_config_persistence) else $error(\"\");", "task_id": "3_10405", "predict_sva": "@(posedge serdes_clk)         $rose(restore_state) |-> lane_config == saved_lane_config"}
{"id": "852_7_3229", "name": "lane_skew_compensation", "sva": "@(posedge serdes_clk)     $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)", "ori_sva": "property lane_skew_compensation;\n@(posedge serdes_clk)     $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: lane_skew_compensation  \n**Trigger Condition**: At every posedge of the `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(lane_sync_done)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:10] (lane_skew < max_skew_threshold)`  ", "sva_signals": ["serdes_clk", "lane_sync_done", "[0:0] lane_skew", "[0:0] max_skew_threshold"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)         $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)", "sva_name": "p_lane_skew_reduction_after_sync", "full_property": "property lane_skew_compensation;\n@(posedge serdes_clk)         $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)\nendproperty\nassert_lane_skew_compensation:assert property (lane_skew_compensation) else $error(\"\");", "task_id": "3_10413", "predict_sva": "@(posedge serdes_clk)         $rose(lane_sync_done) |-> ##[0:10] (lane_skew < max_skew_threshold)"}
{"id": "857_6_3268", "name": "sensitive_bus_unknown_after_reset", "sva": "@(posedge clk_core)     $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)", "ori_sva": "property sensitive_bus_unknown_after_reset;\n@(posedge clk_core)     $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sensitive_bus_unknown_after_reset  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(reset_n)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:5] !$isunknown(secure_bus_internal)`  ", "sva_signals": ["clk", "reset_n", "[0:0] secure_bus_internal", "clk_core"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)", "sva_name": "p_SecureBusInternalAfterReset", "full_property": "property sensitive_bus_unknown_after_reset;\n@(posedge clk_core)         $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)\nendproperty\nassert_sensitive_bus_unknown_after_reset:assert property (sensitive_bus_unknown_after_reset) else $error(\"\");", "task_id": "3_10456", "predict_sva": "@(posedge clk_core)     $rose(reset_n) |-> ##[1:5] !$isunknown(secure_bus_internal)"}
{"id": "854_2_3237", "name": "p_retransmission_timeout", "sva": "@(posedge clk_mac)     (tx_fail && !spectrum_switching_active) |=> ##[1:16] retransmit_en", "ori_sva": "property p_retransmission_timeout;\n@(posedge clk_mac)     (tx_fail && !spectrum_switching_active) |=> ##[1:16] retransmit_en;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_retransmission_timeout  \n**Trigger Condition**: At every rising edge of the `clk_mac`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_fail && !spectrum_switching_active`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:16] retransmit_en`  ", "sva_signals": ["clk_mac", "rst_n", "[0:0] tx_fail", "[0:0] spectrum_switching_active", "[0:0] retransmit_en"], "clock": "clk_mac", "attempts_left": 10, "sva_result": "@(posedge clk_mac)     (tx_fail && !spectrum_switching_active) |=> ##[1:16] retransmit_en", "sva_name": "p_retransmit_en_after_tx_fail_no_spectrum_switching", "full_property": "property p_retransmission_timeout;\n@(posedge clk_mac)     (tx_fail && !spectrum_switching_active) |=> ##[1:16] retransmit_en\nendproperty\nassert_p_retransmission_timeout:assert property (p_retransmission_timeout) else $error(\"\");", "task_id": "3_10427", "predict_sva": "@(posedge clk_mac)         (tx_fail == 1 && spectrum_switching_active == 0) |-> ##[1:16] (retransmit_en == 1)"}
{"id": "858_15_3288", "name": "p_no_intr_during_handler_setup", "sva": "@(posedge mcu_clk)     $rose(intr_ack) |-> ##[1:3] !intr_request", "ori_sva": "property p_no_intr_during_handler_setup;\n@(posedge mcu_clk)     $rose(intr_ack) |-> ##[1:3] !intr_request;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_no_intr_during_handler_setup  \n**Trigger Condition**: At every rising edge of the `mcu_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(intr_ack)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] !intr_request`  ", "sva_signals": ["mcu_clk", "[0:0] intr_ack", "[0:0] intr_request"], "clock": "mcu_clk", "attempts_left": 10, "sva_result": "@(posedge mcu_clk)         $rose(intr_ack) |-> ##[1:3] !intr_request", "sva_name": "p_intr_request_low_after_ack", "full_property": "property p_no_intr_during_handler_setup;\n@(posedge mcu_clk)         $rose(intr_ack) |-> ##[1:3] !intr_request\nendproperty\nassert_p_no_intr_during_handler_setup:assert property (p_no_intr_during_handler_setup) else $error(\"\");", "task_id": "3_10464", "predict_sva": "@(posedge mcu_clk)    $rose(intr_ack) |-> ##[1:3] (intr_request == 0)"}
{"id": "863_2_3340", "name": "speed_negotiation_complete", "sva": "@(posedge usb_clk)     usb_speed_change_req |=> ##[1:5] (usb_current_speed == usb_negotiated_speed)", "ori_sva": "property speed_negotiation_complete;\n@(posedge usb_clk)     usb_speed_change_req |=> ##[1:5] (usb_current_speed == usb_negotiated_speed)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: speed_negotiation_complete  \n**Trigger Condition**: At every rising edge of `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_speed_change_req == 1'b1`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:5] (usb_current_speed == usb_negotiated_speed)`  ", "sva_signals": ["usb_clk", "usb_speed_change_req", "[0:0] usb_current_speed", "[0:0] usb_negotiated_speed"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_speed_change_req == 1'b1 |=> ##[1:5] (usb_current_speed == usb_negotiated_speed)", "sva_name": "speed_adaptation_complete", "full_property": "property speed_negotiation_complete;\n@(posedge usb_clk)     usb_speed_change_req == 1'b1 |=> ##[1:5] (usb_current_speed == usb_negotiated_speed)\nendproperty\nassert_speed_negotiation_complete:assert property (speed_negotiation_complete) else $error(\"\");", "task_id": "3_10517", "predict_sva": "@(posedge usb_clk)    usb_speed_change_req == 1'b1 |=>     (##[1:5] (usb_current_speed == usb_negotiated_speed))"}
{"id": "865_7_3378", "name": "usb_pid_sequence_valid", "sva": "@(posedge usb_clk)     (usb_pid_valid) |-> (usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL})", "ori_sva": "property usb_pid_sequence_valid;\n@(posedge usb_clk)     (usb_pid_valid) |-> (usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL});\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_pid_sequence_valid  \n**Trigger Condition**: At every rising edge of the `usb_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_pid_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}`", "sva_signals": ["usb_clk", "usb_pid_valid", "[3:0] usb_pid_type", "DATA0", "DATA1", "ACK", "NAK", "STALL"], "clock": "usb_clk", "attempts_left": 10, "sva_result": "@(posedge usb_clk)     usb_pid_valid == 1'b1 |-> usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}", "sva_name": "p_usb_pid_type_valid_when_pid_valid", "full_property": "property usb_pid_sequence_valid;\n@(posedge usb_clk)     usb_pid_valid == 1'b1 |-> usb_pid_type inside {DATA0, DATA1, ACK, NAK, STALL}\nendproperty\nassert_usb_pid_sequence_valid:assert property (usb_pid_sequence_valid) else $error(\"\");", "task_id": "3_10544", "predict_sva": "@(posedge usb_clk)         usb_pid_valid == 1'b1 |-> (usb_pid_type == DATA0 || usb_pid_type == DATA1 || usb_pid_type == ACK || usb_pid_type == NAK || usb_pid_type == STALL)"}
{"id": "867_1_3388", "name": "arbitration_collision_resolution", "sva": "@(posedge can_clk)     $rose(can_tx_active[0]) && $rose(can_tx_active[1]) |=> ##[1:10] $onehot0(can_tx_active)", "ori_sva": "property arbitration_collision_resolution;\n@(posedge can_clk)     $rose(can_tx_active[0]) && $rose(can_tx_active[1]) |=> ##[1:10] $onehot0(can_tx_active);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: arbitration_collision_resolution  \n**Trigger Condition**: At every rising edge of `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(can_tx_active[0]) && $rose(can_tx_active[1])`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:10] $onehot0(can_tx_active)`  \n\n", "sva_signals": ["can_clk", "[1:0] can_tx_active"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     ($rose(can_tx_active[0]) && $rose(can_tx_active[1])) |=> ##[1:10] $onehot0(can_tx_active)", "sva_name": "p_can_tx_active_collision_resolution", "full_property": "property arbitration_collision_resolution;\n@(posedge can_clk)     ($rose(can_tx_active[0]) && $rose(can_tx_active[1])) |=> ##[1:10] $onehot0(can_tx_active)\nendproperty\nassert_arbitration_collision_resolution:assert property (arbitration_collision_resolution) else $error(\"\");", "task_id": "3_10567", "predict_sva": "@(posedge can_clk)         ($rose(can_tx_active[0]) && $rose(can_tx_active[1])) |-> ##[1:10] (can_tx_active[0] == 1 || can_tx_active[1] == 1) && (can_tx_active[0] == 0 || can_tx_active[1] == 0)"}
{"id": "870_3_3421", "name": "can_bus_open_circuit_detection", "sva": "@(posedge can_clk)     $isunknown(can_tx_data) && $isunknown(can_rx_data) |=> can_bus_off_state", "ori_sva": "property can_bus_open_circuit_detection;\n@(posedge can_clk)     $isunknown(can_tx_data) && $isunknown(can_rx_data) |=> can_bus_off_state;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_bus_open_circuit_detection  \n**Trigger Condition**: At every rising edge of `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$isunknown(can_tx_data) && $isunknown(can_rx_data)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `can_bus_off_state`  ", "sva_signals": ["can_clk", "can_tx_data[7:0]", "can_rx_data[7:0]", "can_bus_off_state[0:0]"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     ($isunknown(can_tx_data) && $isunknown(can_rx_data)) |=> can_bus_off_state", "sva_name": "p_can_bus_off_state_on_data_unknown", "full_property": "property can_bus_open_circuit_detection;\n@(posedge can_clk)     ($isunknown(can_tx_data) && $isunknown(can_rx_data)) |=> can_bus_off_state\nendproperty\nassert_can_bus_open_circuit_detection:assert property (can_bus_open_circuit_detection) else $error(\"\");", "task_id": "3_10596", "predict_sva": "@(posedge can_clk)         (can_tx_data === 1'b0 || can_tx_data === 1'b1) && (can_rx_data === 1'b0 || can_rx_data === 1'b1) |-> ##1 can_bus_off_state == 1'b1"}
{"id": "872_7_3466", "name": "multicast_filtering", "sva": "@(posedge eth_clk)     (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop", "ori_sva": "property multicast_filtering;\n@(posedge eth_clk)     (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: multicast_filtering  \n**Trigger Condition**: At every rising edge of the `eth_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `pkt_drop`  ", "sva_signals": ["eth_clk", "eth_pkt_valid", "eth_pkt_multicast", "multicast_group_enabled", "[0:0] pkt_drop"], "clock": "eth_clk", "attempts_left": 10, "sva_result": "@(posedge eth_clk)         (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop", "sva_name": "p_multicast_packet_drop_when_filtering_disabled", "full_property": "property multicast_filtering;\n@(posedge eth_clk)         (eth_pkt_valid && eth_pkt_multicast && !multicast_group_enabled) |=> pkt_drop\nendproperty\nassert_multicast_filtering:assert property (multicast_filtering) else $error(\"\");", "task_id": "3_10615", "predict_sva": "@(posedge eth_clk)         (eth_pkt_valid == 1 && eth_pkt_multicast == 1 && multicast_group_enabled == 0) |-> (eth_pkt_dropped == 1)"}
{"id": "877_3_3488", "name": "read_disturb_protection", "sva": "@(posedge nand_clk)     (read_cmd_active && $past(read_cmd_active, 3)) |-> !write_cmd_active", "ori_sva": "property read_disturb_protection;\n@(posedge nand_clk)     (read_cmd_active && $past(read_cmd_active, 3)) |-> !write_cmd_active;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: read_disturb_protection  \n**Trigger Condition**: At every rising edge of the `nand_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `read_cmd_active && $past(read_cmd_active, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!write_cmd_active`  ", "sva_signals": ["nand_clk", "[0:0] read_cmd_active", "[0:0] write_cmd_active"], "clock": "nand_clk", "attempts_left": 10, "sva_result": "@(posedge nand_clk)     (read_cmd_active && $past(read_cmd_active, 3)) |-> !write_cmd_active", "sva_name": "p_read_cmd_active_no_write_cmd_4cycles", "full_property": "property read_disturb_protection;\n@(posedge nand_clk)     (read_cmd_active && $past(read_cmd_active, 3)) |-> !write_cmd_active\nendproperty\nassert_read_disturb_protection:assert property (read_disturb_protection) else $error(\"\");", "task_id": "3_10664", "predict_sva": "@(posedge nand_clk)         (read_cmd_active == 1 && $past(read_cmd_active, 3) == 1) |-> (write_cmd_active == 0)"}
{"id": "874_7_3496", "name": "frame_preemption_handling", "sva": "@(posedge tsn_clk)     $rose(express_traffic) && tx_packet_active |->      ##1 $fell(tx_packet_active) [*1:8] ##1 $rose(tx_packet_active)", "ori_sva": "property frame_preemption_handling;\n@(posedge tsn_clk)     $rose(express_traffic) && tx_packet_active |->      ##1 $fell(tx_packet_active) [*1:8] ##1 $rose(tx_packet_active);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: frame_preemption_handling  \n**Trigger Condition**: At every rising edge of `tsn_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(express_traffic) && tx_packet_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(tx_packet_active) [*1:8] ##1 $rose(tx_packet_active)`  ", "sva_signals": ["tsn_clk", "express_traffic", "tx_packet_active"], "clock": "tsn_clk", "attempts_left": 10, "sva_result": "@(posedge tsn_clk)         ($rose(express_traffic) && tx_packet_active) |->          ##1 $fell(tx_packet_active)[*1:8] ##1 $rose(tx_packet_active)", "sva_name": "p_tx_packet_active_fall_and_rise_on_express_traffic_rise", "full_property": "property frame_preemption_handling;\n@(posedge tsn_clk)         ($rose(express_traffic) && tx_packet_active) |->          ##1 $fell(tx_packet_active)[*1:8] ##1 $rose(tx_packet_active)\nendproperty\nassert_frame_preemption_handling:assert property (frame_preemption_handling) else $error(\"\");", "task_id": "3_10633", "predict_sva": "@(posedge tsn_clk)         ($rose(express_traffic) && tx_packet_active) |-> ##[1:8] (tx_packet_active == 1'b0) ##1 (tx_packet_active == 1'b1)"}
{"id": "878_4_3523", "name": "ecc_consistency_check", "sva": "@(posedge flash_clk)     ecc_correction_active |-> ecc_parity_bits_valid throughout ecc_correction_cycle", "ori_sva": "property ecc_consistency_check;\n@(posedge flash_clk)     ecc_correction_active |-> ecc_parity_bits_valid throughout ecc_correction_cycle;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ecc_consistency_check  \n**Trigger Condition**: At every rising edge of the `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ecc_correction_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `ecc_parity_bits_valid` must hold true **throughout** the entire `ecc_correction_cycle`.  ", "sva_signals": ["flash_clk", "ecc_correction_active", "ecc_parity_bits_valid", "ecc_correction_cycle"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)     ecc_correction_active == 1'b1 |-> ecc_parity_bits_valid throughout ecc_correction_cycle", "sva_name": "p_ecc_correction_parity_valid", "full_property": "property ecc_consistency_check;\n@(posedge flash_clk)     ecc_correction_active == 1'b1 |-> ecc_parity_bits_valid throughout ecc_correction_cycle\nendproperty\nassert_ecc_consistency_check:assert property (ecc_consistency_check) else $error(\"\");", "task_id": "3_10677", "predict_sva": "@(posedge flash_clk)    ecc_correction_active == 1'b1 |->     (ecc_parity_bits_valid throughout ecc_correction_cycle)"}
{"id": "882_10_3559", "name": "write_retry_mechanism", "sva": "@(posedge flash_clk)     $rose(flash_write_error) && !flash_write_retry_exhausted |=> ##1 flash_write_retry_attempt", "ori_sva": "property write_retry_mechanism;\n@(posedge flash_clk)     $rose(flash_write_error) && !flash_write_retry_exhausted |=> ##1 flash_write_retry_attempt;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: write_retry_mechanism  \n**Trigger Condition**: At every rising edge of `flash_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(flash_write_error) && !flash_write_retry_exhausted`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##1 flash_write_retry_attempt`  ", "sva_signals": ["flash_clk", "[0:0] flash_write_error", "[0:0] flash_write_retry_exhausted", "[0:0] flash_write_retry_attempt"], "clock": "flash_clk", "attempts_left": 10, "sva_result": "@(posedge flash_clk)         ($rose(flash_write_error) && !flash_write_retry_exhausted) |=> ##1 flash_write_retry_attempt", "sva_name": "p_flash_write_retry_attempt_on_error", "full_property": "property write_retry_mechanism;\n@(posedge flash_clk)         ($rose(flash_write_error) && !flash_write_retry_exhausted) |=> ##1 flash_write_retry_attempt\nendproperty\nassert_write_retry_mechanism:assert property (write_retry_mechanism) else $error(\"\");", "task_id": "3_10717", "predict_sva": "@(posedge flash_clk)         ($rose(flash_write_error) && flash_write_retry_exhausted == 0) |-> ##1 flash_write_retry_attempt == 1"}
{"id": "883_9_3586", "name": "p_sink_to_source_transition", "sva": "@(posedge pd_clk)     (pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=>      ##[1:50] (pd_role == SOURCE_ROLE)", "ori_sva": "property p_sink_to_source_transition;\n@(posedge pd_clk)     (pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP) |=>      ##[1:50] (pd_role == SOURCE_ROLE);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sink_to_source_transition  \n**Trigger Condition**: At every rising edge of the `pd_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[1:50] (pd_role == SOURCE_ROLE)`  ", "sva_signals": ["pd_clk", "[0:0] pd_role", "[0:0] rx_packet", "[0:0] SINK_ROLE", "[0:0] SOURCE_ROLE", "[0:0] PD_CTRL_PR_SWAP"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     ((pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)) |=> ##[1:50] (pd_role == SOURCE_ROLE)", "sva_name": "p_sink_to_source_transition", "full_property": "property p_sink_to_source_transition;\n@(posedge pd_clk)     ((pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)) |=> ##[1:50] (pd_role == SOURCE_ROLE)\nendproperty\nassert_p_sink_to_source_transition:assert property (p_sink_to_source_transition) else $error(\"\");", "task_id": "3_10741", "predict_sva": "@(posedge pd_clk)    ((pd_role == SINK_ROLE) && (rx_packet == PD_CTRL_PR_SWAP)) |=>     (##[1:50] (pd_role == SOURCE_ROLE))"}
{"id": "888_8_3663", "name": "p_hdr_wdr_switch_sync", "sva": "@(posedge isp_clk)     $rose(hdr_to_wdr_switch) |-> ##3 (hdr_active == 0 && wdr_active == 1)", "ori_sva": "property p_hdr_wdr_switch_sync;\n@(posedge isp_clk)     $rose(hdr_to_wdr_switch) |-> ##3 (hdr_active == 0 && wdr_active == 1);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hdr_wdr_switch_sync  \n**Trigger Condition**: At every rising edge of the `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(hdr_to_wdr_switch)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 (hdr_active == 0 && wdr_active == 1)`  ", "sva_signals": ["isp_clk", "[0:0] hdr_to_wdr_switch", "[0:0] hdr_active", "[0:0] wdr_active"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     $rose(hdr_to_wdr_switch) |-> ##3 (hdr_active == 0 && wdr_active == 1)", "sva_name": "p_hdr_to_wdr_switch", "full_property": "property p_hdr_wdr_switch_sync;\n@(posedge isp_clk)     $rose(hdr_to_wdr_switch) |-> ##3 (hdr_active == 0 && wdr_active == 1)\nendproperty\nassert_p_hdr_wdr_switch_sync:assert property (p_hdr_wdr_switch_sync) else $error(\"\");", "task_id": "3_10795", "predict_sva": "@(posedge isp_clk)    $rose(hdr_to_wdr_switch) |-> ##3 (hdr_active == 1'b0 && wdr_active == 1'b1)"}
{"id": "885_4_3616", "name": "mode_exclusivity", "sva": "@(posedge pd_clk)     always (dp_mode_active_ -> !hdmi_mode_active_) and            (hdmi_mode_active_ -> !dp_mode_active_)", "ori_sva": "property mode_exclusivity;\n@(posedge pd_clk)     always (dp_mode_active_ -> !hdmi_mode_active_) and            (hdmi_mode_active_ -> !dp_mode_active_)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: mode_exclusivity  \n**Trigger Condition**: At every rising edge of `pd_clk`  \n**Disable Condition**: None  \n**Property Expression**:  \n- The property checks that `dp_mode_active_` and `hdmi_mode_active_` are mutually exclusive. Specifically:  \n  1. If `dp_mode_active_` is true (`dp_mode_active_`), then `hdmi_mode_active_` must be false (`!hdmi_mode_active_`).  \n  2. If `hdmi_mode_active_` is true (`hdmi_mode_active_`), then `dp_mode_active_` must be false (`!dp_mode_active_`).  \n- The property is implemented as a conjunction (`and`) of two implications:  \n  - `(dp_mode_active_ -> !hdmi_mode_active_)`  \n  - `(hdmi_mode_active_ -> !dp_mode_active_)`  \n\n**Note**: Unlike the previous examples, this property does not use an implication operator (`|->`) but instead directly asserts the mutual exclusivity condition using logical implications (`->`) combined with `always`. The check is evaluated continuously at every clock edge.", "sva_signals": ["pd_clk", "[0:0] dp_mode_active_", "[0:0] hdmi_mode_active_"], "clock": "pd_clk", "attempts_left": 10, "sva_result": "@(posedge pd_clk)     always (         (dp_mode_active_ -> !hdmi_mode_active_) and         (hdmi_mode_active_ -> !dp_mode_active_)     )", "sva_name": "p_mode_mutual_exclusivity", "full_property": "property mode_exclusivity;\n@(posedge pd_clk)     always (         (dp_mode_active_ -> !hdmi_mode_active_) and         (hdmi_mode_active_ -> !dp_mode_active_)     )\nendproperty\nassert_mode_exclusivity:assert property (mode_exclusivity) else $error(\"\");", "task_id": "3_10761", "predict_sva": "@(posedge pd_clk)         1 |-> (dp_mode_active_ == 1) |-> (hdmi_mode_active_ == 0) && (hdmi_mode_active_ == 1) |-> (dp_mode_active_ == 0)"}
{"id": "889_1_3647", "name": "frame_sync_stable_during_active", "sva": "@(posedge isp_clk)     $rose(frame_valid) |-> frame_valid throughout data_valid[->1]", "ori_sva": "property frame_sync_stable_during_active;\n@(posedge isp_clk)     $rose(frame_valid) |-> frame_valid throughout data_valid[->1];\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: frame_sync_stable_during_active  \n**Trigger Condition**: At every rising edge of `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(frame_valid)` (The signal `frame_valid` transitions from low to high)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `frame_valid throughout data_valid[->1]` (The signal `frame_valid` must remain high continuously until and including the first occurrence where `data_valid` is high)", "sva_signals": ["isp_clk", "frame_valid", "data_valid"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)         $rose(frame_valid) |-> frame_valid throughout data_valid[->1]", "sva_name": "frame_sequence_integrity", "full_property": "property frame_sync_stable_during_active;\n@(posedge isp_clk)         $rose(frame_valid) |-> frame_valid throughout data_valid[->1]\nendproperty\nassert_frame_sync_stable_during_active:assert property (frame_sync_stable_during_active) else $error(\"\");", "task_id": "3_10801", "predict_sva": "@(posedge isp_clk)    $rose(frame_valid) |->     (frame_valid throughout (data_valid[->1]))"}
{"id": "890_2_3678", "name": "p_param_stable_during_processing", "sva": "@(posedge isp_clk)     isp_busy |-> $stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_)", "ori_sva": "property p_param_stable_during_processing;\n@(posedge isp_clk)     isp_busy |-> $stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_);\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_param_stable_during_processing  \n**Trigger Condition**: At every rising edge of `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `isp_busy == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_)`  ", "sva_signals": ["isp_clk", "[0:0] isp_busy", "denoise_param_", "sharpen_param_", "gamma_param_"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     isp_busy == 1'b1 |-> $stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_)", "sva_name": "p_isp_param_stable_during_exec", "full_property": "property p_param_stable_during_processing;\n@(posedge isp_clk)     isp_busy == 1'b1 |-> $stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_)\nendproperty\nassert_p_param_stable_during_processing:assert property (p_param_stable_during_processing) else $error(\"\");", "task_id": "3_10818", "predict_sva": "@(posedge isp_clk)     isp_busy == 1'b1 |-> $stable(denoise_param_) && $stable(sharpen_param_) && $stable(gamma_param_)"}
{"id": "891_4_3701", "name": "p_sensor_error_recovery", "sva": "@(posedge isp_clk)     $rose(sensor_data_error) |-> ##[1:15] $fell(sensor_data_error) && image_stable", "ori_sva": "property p_sensor_error_recovery;\n@(posedge isp_clk)     $rose(sensor_data_error) |-> ##[1:15] $fell(sensor_data_error) && image_stable;\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: p_sensor_error_recovery  \n**Trigger Condition**: At every rising edge of the `isp_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(sensor_data_error)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:15] $fell(sensor_data_error) && image_stable`  \n\nThe assertion checks that whenever a rising edge is detected on `sensor_data_error` (indicating the start of an error condition), then within 1 to 15 clock cycles, the `sensor_data_error` signal must fall (indicating error recovery) and the `image_stable` signal must be asserted (indicating stable image data).", "sva_signals": ["isp_clk", "sensor_data_error", "image_stable"], "clock": "isp_clk", "attempts_left": 10, "sva_result": "@(posedge isp_clk)     $rose(sensor_data_error) |-> ##[1:15] ($fell(sensor_data_error) && image_stable)", "sva_name": "sensor_error_recovery", "full_property": "property p_sensor_error_recovery;\n@(posedge isp_clk)     $rose(sensor_data_error) |-> ##[1:15] ($fell(sensor_data_error) && image_stable)\nendproperty\nassert_p_sensor_error_recovery:assert property (p_sensor_error_recovery) else $error(\"\");", "task_id": "3_10829", "predict_sva": "@(posedge isp_clk)    $rose(sensor_data_error) |-> ##[1:15] ($fell(sensor_data_error) && image_stable)"}
{"id": "898_12_3805", "name": "network_param_sync", "sva": "@(posedge clk_core)     $rose(network_changed) |->     ##[1:100] $stable(stored_params) && $stable(current_params)", "ori_sva": "property network_param_sync;\n@(posedge clk_core)     $rose(network_changed) |->     ##[1:100] $stable(stored_params) && $stable(current_params)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: network_param_sync  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(network_changed)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:100] $stable(stored_params) && $stable(current_params)`  ", "sva_signals": ["clk_core", "rst_n", "[0:0] network_changed", "[0:0] stored_params", "[0:0] current_params"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     $rose(network_changed) |-> ##[1:100] ($stable(stored_params) && $stable(current_params))", "sva_name": "network_change_stable_params", "full_property": "property network_param_sync;\n@(posedge clk_core)     $rose(network_changed) |-> ##[1:100] ($stable(stored_params) && $stable(current_params))\nendproperty\nassert_network_param_sync:assert property (network_param_sync) else $error(\"\");", "task_id": "3_10899", "predict_sva": "@(posedge clk_core)     $rose(network_changed) |-> ##[1:100] ($stable(stored_params) && $stable(current_params))"}
{"id": "10_22_0477", "name": "spi_transfer_done_past_check_22", "sva": "@(posedge clk_spi)     spi_transfer_done |-> $past(spi_start, 1) && $past(spi_busy, 2) == 1'b1 && $past(spi_count, 3) == 8'h00", "ori_sva": "property spi_transfer_done_past_check_22;\n@(posedge clk_spi)     spi_transfer_done |-> $past(spi_start, 1) && $past(spi_busy, 2) == 1'b1 && $past(spi_count, 3) == 8'h00\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_transfer_done_past_check  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `spi_transfer_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n`$past(spi_start, 1) && $past(spi_busy, 2) == 1'b1 && $past(spi_count, 3) == 8'h00`  ", "sva_signals": ["clk_spi", "[0:0] spi_transfer_done", "[0:0] spi_start", "[0:0] spi_busy", "[7:0] spi_count"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi)     spi_transfer_done == 1'b1 |->      $past(spi_start, 1) &&      $past(spi_busy, 2) == 1'b1 &&      $past(spi_count, 3) == 8'h00;", "sva_name": "p_spi_transfer_done_past_conditions", "full_property": "property p_spi_transfer_done_past_check;\n@(posedge clk_spi)     spi_transfer_done == 1'b1 |->      $past(spi_start, 1) &&      $past(spi_busy, 2) == 1'b1 &&      $past(spi_count, 3) == 8'h00;\nendproperty\nassert_p_spi_transfer_done_past_check:assert property (p_spi_transfer_done_past_check) else $error(\"\");", "task_id": "4_13", "predict_sva": "@(posedge clk_spi)         spi_transfer_done == 1'b1 |->          $past(spi_start, 1) == 1'b1 &&          $past(spi_busy, 2) == 1'b1 &&          $past(spi_count, 3) == 8'h00"}
{"id": "10_34_0491", "name": "video_vsync_past_check_34", "sva": "@(posedge clk_video)     $rose(video_vsync) |-> $past(video_enable, 1) && $past(video_active, 2) && $past(video_line_count, 3) == 11'd0", "ori_sva": "property video_vsync_past_check_34;\n@(posedge clk_video)     $rose(video_vsync) |-> $past(video_enable, 1) && $past(video_active, 2) && $past(video_line_count, 3) == 11'd0\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Video_Vsync_Past_Check_34  \n**Trigger Condition**: At every rising edge of the `clk_video`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(video_vsync)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(video_enable, 1) && $past(video_active, 2) && $past(video_line_count, 3) == 11'd0`", "sva_signals": ["clk_video", "video_vsync", "[0:0] video_enable", "[0:0] video_active", "[10:0] video_line_count"], "clock": "clk_video", "attempts_left": 10, "sva_result": "@(posedge clk_video)     $rose(video_vsync) |-> ($past(video_enable, 1) && $past(video_active, 2) && $past(video_line_count, 3) == 11'd0);", "sva_name": "p_video_vsync_rising_edge_past_conditions", "full_property": "property p_Video_Vsync_Past_Check_34;\n@(posedge clk_video)     $rose(video_vsync) |-> ($past(video_enable, 1) && $past(video_active, 2) && $past(video_line_count, 3) == 11'd0);\nendproperty\nassert_p_Video_Vsync_Past_Check_34:assert property (p_Video_Vsync_Past_Check_34) else $error(\"\");", "task_id": "4_26", "predict_sva": "@(posedge clk_video)         $rose(video_vsync) |->          ($past(video_enable, 1) == 1) &&         ($past(video_active, 2) == 1) &&         ($past(video_line_count, 3) == 11'd0)"}
{"id": "10_42_0505", "name": "rf_tx_done_past_check_42", "sva": "@(posedge clk_rf)     rf_tx_done |-> $past(rf_tx_start, 1) && $past(rf_busy, 2) && $past(rf_packet_valid, 3)", "ori_sva": "property rf_tx_done_past_check_42;\n@(posedge clk_rf)     rf_tx_done |-> $past(rf_tx_start, 1) && $past(rf_busy, 2) && $past(rf_packet_valid, 3)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rf_tx_done_past_check_42  \n**Trigger Condition**: At every rising edge of the `clk_rf`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rf_tx_done == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(rf_tx_start, 1) && $past(rf_busy, 2) && $past(rf_packet_valid, 3)`  ", "sva_signals": ["clk_rf", "rst_n", "[0:0] rf_tx_done", "[0:0] rf_tx_start", "[0:0] rf_busy", "[0:0] rf_packet_valid"], "clock": "clk_rf", "attempts_left": 10, "sva_result": "@(posedge clk_rf)         rf_tx_done == 1'b1 |-> $past(rf_tx_start, 1) && $past(rf_busy, 2) && $past(rf_packet_valid, 3);", "sva_name": "p_rf_tx_done_sequence_check", "full_property": "property p_rf_tx_done_past_check_42;\n@(posedge clk_rf)         rf_tx_done == 1'b1 |-> $past(rf_tx_start, 1) && $past(rf_busy, 2) && $past(rf_packet_valid, 3);\nendproperty\nassert_p_rf_tx_done_past_check_42:assert property (p_rf_tx_done_past_check_42) else $error(\"\");", "task_id": "4_35", "predict_sva": "@(posedge clk_rf)         rf_tx_done == 1 |-> $past(rf_tx_start, 1) == 1 && $past(rf_busy, 2) == 1 && $past(rf_packet_valid, 3) == 1"}
{"id": "10_6_0464", "name": "mem_write_past_check_6", "sva": "@(posedge clk_mem)     $rose(mem_write) |-> $past(mem_ready, 3) && $past(mem_req, 1) && $past(mem_addr_valid, 2)", "ori_sva": "property mem_write_past_check_6;\n@(posedge clk_mem)     $rose(mem_write) |-> $past(mem_ready, 3) && $past(mem_req, 1) && $past(mem_addr_valid, 2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_write_past_check_6  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(mem_write)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(mem_ready, 3) && $past(mem_req, 1) && $past(mem_addr_valid, 2)`", "sva_signals": ["clk_mem", "mem_write", "mem_ready", "mem_req", "mem_addr_valid"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)     $rose(mem_write) |-> ($past(mem_ready, 3) && $past(mem_req, 1) && $past(mem_addr_valid, 2));", "sva_name": "p_mem_write_rising_edge_past_conditions", "full_property": "property p_mem_write_past_check_6;\n@(posedge clk_mem)     $rose(mem_write) |-> ($past(mem_ready, 3) && $past(mem_req, 1) && $past(mem_addr_valid, 2));\nendproperty\nassert_p_mem_write_past_check_6:assert property (p_mem_write_past_check_6) else $error(\"\");", "task_id": "4_46", "predict_sva": "@(posedge clk_mem)         $rose(mem_write) |-> ($past(mem_ready, 3) && $past(mem_addr_valid, 2) && $past(mem_req, 1))"}
{"id": "11_45_0539", "name": "dma_buffer_overflow_check", "sva": "@(posedge clk_dma_buf)     (dma_active && buffer_full) |-> ##0 $rose(overflow_flag)", "ori_sva": "property dma_buffer_overflow_check;\n@(posedge clk_dma_buf)     (dma_active && buffer_full) |-> ##0 $rose(overflow_flag)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_buffer_overflow_check  \n**Trigger Condition**: At every rising edge of the `clk_dma_buf`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_active && buffer_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##0 $rose(overflow_flag)`  ", "sva_signals": ["clk_dma_buf", "dma_active", "buffer_full", "overflow_flag"], "clock": "clk_dma_buf", "attempts_left": 10, "sva_result": "@(posedge clk_dma_buf)         dma_active && buffer_full |-> ##0 $rose(overflow_flag);", "sva_name": "p_overflow_flag_rise_on_dma_active_and_buffer_full", "full_property": "property p_dma_buffer_overflow_check;\n@(posedge clk_dma_buf)         dma_active && buffer_full |-> ##0 $rose(overflow_flag);\nendproperty\nassert_p_dma_buffer_overflow_check:assert property (p_dma_buffer_overflow_check) else $error(\"\");", "task_id": "4_84", "predict_sva": "@(posedge clk_dma_buf)         (dma_active == 1 && buffer_full == 1) |-> ($rose(overflow_flag) == 1)"}
{"id": "12_14_0563", "name": "dma_req_or_sw_trigger_check_14", "sva": "@(posedge clk_dma)     dma_request || sw_trigger |-> ##2 dma_ack", "ori_sva": "property dma_req_or_sw_trigger_check_14;\n@(posedge clk_dma)     dma_request || sw_trigger |-> ##2 dma_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_req_or_sw_trigger_check_14  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_request || sw_trigger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 dma_ack`", "sva_signals": ["clk_dma", "[0:0] dma_request", "[0:0] sw_trigger", "[0:0] dma_ack"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma)         (dma_request || sw_trigger) |-> ##2 dma_ack;", "sva_name": "p_dma_ack_after_request_or_sw_trigger", "full_property": "property p_dma_req_or_sw_trigger_check_14;\n@(posedge clk_dma)         (dma_request || sw_trigger) |-> ##2 dma_ack;\nendproperty\nassert_p_dma_req_or_sw_trigger_check_14:assert property (p_dma_req_or_sw_trigger_check_14) else $error(\"\");", "task_id": "4_96", "predict_sva": "@(posedge clk_dma)         (dma_request == 1 || sw_trigger == 1) |-> ##2 dma_ack == 1"}
{"id": "15_8_0707", "name": "can_bus_error_frame_check", "sva": "@(posedge clk_can)     disable iff(can_bus_off)     (error_flag_detected && !error_passive) |-> ##[6:12] error_frame_detected", "ori_sva": "property can_bus_error_frame_check;\n@(posedge clk_can)     disable iff(can_bus_off)     (error_flag_detected && !error_passive) |-> ##[6:12] error_frame_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_bus_error_frame_check  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: disable iff (`can_bus_off`)  \n**Antecedent (LHS of Implication)**: `error_flag_detected && !error_passive`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[6:12] error_frame_detected`  ", "sva_signals": ["clk_can", "can_bus_off", "[0:0] error_flag_detected", "[0:0] error_passive", "[0:0] error_frame_detected"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can) disable iff (can_bus_off)     (error_flag_detected && !error_passive) |-> ##[6:12] error_frame_detected;", "sva_name": "p_error_frame_within_6_to_12_cycles", "full_property": "property p_can_bus_error_frame_check;\n@(posedge clk_can) disable iff (can_bus_off)     (error_flag_detected && !error_passive) |-> ##[6:12] error_frame_detected;\nendproperty\nassert_p_can_bus_error_frame_check:assert property (p_can_bus_error_frame_check) else $error(\"\");", "task_id": "4_195", "predict_sva": "@(posedge clk_can) disable iff (can_bus_off)         (error_flag_detected == 1 && error_passive == 0 && can_bus_off == 0) |-> ##[6:12] (error_frame == 1)"}
{"id": "2_6_0072", "name": "tx_start_delay_check", "sva": "@(posedge clk_uart)      tx_start |-> ##[2:7] tx_busy && $onehot(tx_byte)", "ori_sva": "property tx_start_delay_check;\n@(posedge clk_uart)      tx_start |-> ##[2:7] tx_busy && $onehot(tx_byte)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_tx_start_delay_check  \n**Trigger Condition**: At every rising edge of the `clk_uart`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tx_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:7] tx_busy && $onehot(tx_byte)`  ", "sva_signals": ["clk_uart", "rst_n", "[0:0] tx_start", "[0:0] tx_busy", "[7:0] tx_byte"], "clock": "clk_uart", "attempts_left": 10, "sva_result": "@(posedge clk_uart)     tx_start == 1'b1 |-> ##[2:7] tx_busy && $onehot(tx_byte);", "sva_name": "p_tx_busy_onehot_tx_byte_after_tx_start", "full_property": "property p_tx_start_delay_check;\n@(posedge clk_uart)     tx_start == 1'b1 |-> ##[2:7] tx_busy && $onehot(tx_byte);\nendproperty\nassert_p_tx_start_delay_check:assert property (p_tx_start_delay_check) else $error(\"\");", "task_id": "4_281", "predict_sva": "@(posedge clk_uart)         tx_start == 1'b1 |-> ##[2:7] (tx_busy == 1'b1 && $onehot(tx_byte))"}
{"id": "3_19_0088", "name": "pll_lock_sequence_verification", "sva": "@(posedge clk_ref)     (pll_reset_released && !bypass_mode) |-> ##[10:20] pll_locked ##1 $stable(vco_freq)", "ori_sva": "property pll_lock_sequence_verification;\n@(posedge clk_ref)     (pll_reset_released && !bypass_mode) |-> ##[10:20] pll_locked ##1 $stable(vco_freq)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PllLockSequenceVerification  \n**Trigger Condition**: At every rising edge of the `clk_ref`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pll_reset_released && !bypass_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] pll_locked ##1 $stable(vco_freq)`  ", "sva_signals": ["clk_ref", "pll_reset_released", "bypass_mode", "[0:0] pll_locked", "[0:0] vco_freq"], "clock": "clk_ref", "attempts_left": 10, "sva_result": "@(posedge clk_ref)     (pll_reset_released && !bypass_mode) |-> ##[10:20] pll_locked ##1 $stable(vco_freq);", "sva_name": "p_pll_locked_and_vco_freq_stability_after_reset_release", "full_property": "property p_PllLockSequenceVerification;\n@(posedge clk_ref)     (pll_reset_released && !bypass_mode) |-> ##[10:20] pll_locked ##1 $stable(vco_freq);\nendproperty\nassert_p_PllLockSequenceVerification:assert property (p_PllLockSequenceVerification) else $error(\"\");", "task_id": "4_292", "predict_sva": "@(posedge clk_ref)         (pll_reset_released == 1 && bypass_mode == 0) |-> ##[10:20] pll_locked == 1 ##1 $stable(vco_freq)"}
{"id": "8_27_0377", "name": "dram_zq_calibration_complete", "sva": "@(posedge dram_ck)     $fell(dram_zq_cal_start) |-> ##[512:1024] dram_zq_cal_done && !dram_zq_cal_error", "ori_sva": "property dram_zq_calibration_complete;\n@(posedge dram_ck)     $fell(dram_zq_cal_start) |-> ##[512:1024] dram_zq_cal_done && !dram_zq_cal_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dram_zq_calibration_complete  \n**Trigger Condition**: At every rising edge of the `dram_ck`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(dram_zq_cal_start)` (a falling edge on `dram_zq_cal_start`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[512:1024] dram_zq_cal_done && !dram_zq_cal_error` (Between 512 to 1024 clock cycles later, `dram_zq_cal_done` must be asserted and `dram_zq_cal_error` must remain deasserted)", "sva_signals": ["dram_ck", "dram_zq_cal_start", "dram_zq_cal_done", "dram_zq_cal_error"], "clock": "dram_ck", "attempts_left": 10, "sva_result": "@(posedge dram_ck)     $fell(dram_zq_cal_start) |-> ##[512:1024] (dram_zq_cal_done && !dram_zq_cal_error);", "sva_name": "p_dram_zq_cal_done_within_512_1024_cycles", "full_property": "property p_dram_zq_calibration_complete;\n@(posedge dram_ck)     $fell(dram_zq_cal_start) |-> ##[512:1024] (dram_zq_cal_done && !dram_zq_cal_error);\nendproperty\nassert_p_dram_zq_calibration_complete:assert property (p_dram_zq_calibration_complete) else $error(\"\");", "task_id": "4_474", "predict_sva": "@(posedge dram_ck)         $fell(dram_zq_cal_start) |-> ##[512:1024] (dram_zq_cal_done == 1 && dram_zq_cal_error == 0)"}
{"id": "8_31_0383", "name": "video_timing_gen_hblank", "sva": "@(posedge vid_gen_clk)     $fell(vid_hblank_n) |-> ##[40:44] $fell(vid_hsync_n) || vid_line_end", "ori_sva": "property video_timing_gen_hblank;\n@(posedge vid_gen_clk)     $fell(vid_hblank_n) |-> ##[40:44] $fell(vid_hsync_n) || vid_line_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_video_timing_gen_hblank  \n**Trigger Condition**: At every rising edge of the vid_gen_clk  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: $fell(vid_hblank_n)  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: ##[40:44] $fell(vid_hsync_n) || vid_line_end  \n\n", "sva_signals": ["vid_gen_clk", "vid_hblank_n", "vid_hsync_n", "vid_line_end"], "clock": "vid_gen_clk", "attempts_left": 10, "sva_result": "@(posedge vid_gen_clk)     $fell(vid_hblank_n) |-> ##[40:44] ($fell(vid_hsync_n) || vid_line_end);", "sva_name": "p_hblank_fall_triggers_hsync_or_lineend", "full_property": "property p_video_timing_gen_hblank;\n@(posedge vid_gen_clk)     $fell(vid_hblank_n) |-> ##[40:44] ($fell(vid_hsync_n) || vid_line_end);\nendproperty\nassert_p_video_timing_gen_hblank:assert property (p_video_timing_gen_hblank) else $error(\"\");", "task_id": "4_479", "predict_sva": "@(posedge vid_gen_clk)         $fell(vid_hblank_n) |-> ##[40:44] ($fell(vid_hsync_n) || (vid_line_end == 1))"}
{"id": "8_49_0398", "name": "i2s_tdm_slot_sync", "sva": "@(posedge i2s_tdm_bclk)     $fell(i2s_tdm_ws) |-> ##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data,32)", "ori_sva": "property i2s_tdm_slot_sync;\n@(posedge i2s_tdm_bclk)     $fell(i2s_tdm_ws) |-> ##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data,32)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_i2s_tdm_slot_sync  \n**Trigger Condition**: At every rising edge of the `i2s_tdm_bclk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(i2s_tdm_ws)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data, 32)`  \n\n", "sva_signals": ["i2s_tdm_bclk", "i2s_tdm_ws", "i2s_tdm_sd", "[31:0] i2s_tdm_ch0_data"], "clock": "i2s_tdm_bclk", "attempts_left": 10, "sva_result": "@(posedge i2s_tdm_bclk)     $fell(i2s_tdm_ws) |-> ##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data, 32);", "sva_name": "p_i2s_tdm_sd_assignment_after_ws_fall", "full_property": "property p_i2s_tdm_slot_sync;\n@(posedge i2s_tdm_bclk)     $fell(i2s_tdm_ws) |-> ##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data, 32);\nendproperty\nassert_p_i2s_tdm_slot_sync:assert property (p_i2s_tdm_slot_sync) else $error(\"\");", "task_id": "4_497", "predict_sva": "@(posedge i2s_tdm_bclk)         $fell(i2s_tdm_ws) |-> ##[32:64] i2s_tdm_sd == $past(i2s_tdm_ch0_data, 32)"}
{"id": "10_12_0470", "name": "complex_past_expression_12", "sva": "@(posedge clk_audio)      sample_ready |-> $past(fifo_empty,2)==0 || ($past(dma_enable,4) && $past(irq_pending,1))", "ori_sva": "property complex_past_expression_12;\n@(posedge clk_audio)      sample_ready |-> $past(fifo_empty,2)==0 || ($past(dma_enable,4) && $past(irq_pending,1))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sample_Ready_Check  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sample_ready == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(fifo_empty, 2) == 0 || ($past(dma_enable, 4) && $past(irq_pending, 1))`  ", "sva_signals": ["clk_audio", "rst_n", "[0:0] sample_ready", "[0:0] fifo_empty", "[0:0] dma_enable", "[0:0] irq_pending"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     sample_ready == 1'b1 |-> ($past(fifo_empty, 2) == 0 || ($past(dma_enable, 4) && $past(irq_pending, 1)));", "sva_name": "p_sample_ready_fifo_empty_or_dma_irq_check", "full_property": "property p_Sample_Ready_Check;\n@(posedge clk_audio)     sample_ready == 1'b1 |-> ($past(fifo_empty, 2) == 0 || ($past(dma_enable, 4) && $past(irq_pending, 1)));\nendproperty\nassert_p_Sample_Ready_Check:assert property (p_Sample_Ready_Check) else $error(\"\");", "task_id": "4_554", "predict_sva": "@(posedge clk_audio)         sample_ready == 1'b1 |-> ($past(fifo_empty, 2) == 1'b0) || ($past(dma_enable, 4) == 1'b1 && $past(irq_pending, 1) == 1'b1)"}
{"id": "10_29_0530", "name": "complex_temporal_past_29", "sva": "@(negedge clk_uart_dbg)      break_detected |-> ##[1:4] $past(line_status,5) == 8'hFF && $past(break_int_en,2)", "ori_sva": "property complex_temporal_past_29;\n@(negedge clk_uart_dbg)      break_detected |-> ##[1:4] $past(line_status,5) == 8'hFF && $past(break_int_en,2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_complex_temporal_past_29  \n**Trigger Condition**: At every falling edge of the `clk_uart_dbg`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `break_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 4 clock cycles (`##[1:4]`), the value of `line_status` 5 cycles ago (`$past(line_status,5)`) equals `8'hFF`, and the value of `break_int_en` 2 cycles ago (`$past(break_int_en,2)`) is true.", "sva_signals": ["clk_uart_dbg", "[0:0] break_detected", "[7:0] line_status", "[0:0] break_int_en"], "clock": "clk_uart_dbg", "attempts_left": 10, "sva_result": "@(negedge clk_uart_dbg)     break_detected |-> ##[1:4] ($past(line_status,5) == 8'hFF) && ($past(break_int_en,2));", "sva_name": "p_break_detected_line_status_break_int_en", "full_property": "property p_complex_temporal_past_29;\n@(negedge clk_uart_dbg)     break_detected |-> ##[1:4] ($past(line_status,5) == 8'hFF) && ($past(break_int_en,2));\nendproperty\nassert_p_complex_temporal_past_29:assert property (p_complex_temporal_past_29) else $error(\"\");", "task_id": "4_568", "predict_sva": "@(negedge clk_uart_dbg)         break_detected == 1'b1 |-> ##[1:4] ($past(line_status, 5) == 8'hFF) && ($past(break_int_en, 2) == 1'b1)"}
{"id": "10_30_0487", "name": "past_with_multiple_conditions_30", "sva": "@(posedge clk_pcie_phy)      phy_ready |-> $past(training_done,3) && $past(power_good,2) && $past(reset_deasserted,1)", "ori_sva": "property past_with_multiple_conditions_30;\n@(posedge clk_pcie_phy)      phy_ready |-> $past(training_done,3) && $past(power_good,2) && $past(reset_deasserted,1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Past_With_Multiple_Conditions_30  \n**Trigger Condition**: At every rising edge of the `clk_pcie_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phy_ready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(training_done, 3) && $past(power_good, 2) && $past(reset_deasserted, 1)`  ", "sva_signals": ["clk_pcie_phy", "[0:0] phy_ready", "[0:0] training_done", "[0:0] power_good", "[0:0] reset_deasserted"], "clock": "clk_pcie_phy", "attempts_left": 10, "sva_result": "@(posedge clk_pcie_phy)     phy_ready |-> ($past(training_done, 3) && $past(power_good, 2) && $past(reset_deasserted, 1));", "sva_name": "p_phy_ready_preconditions", "full_property": "property p_Past_With_Multiple_Conditions_30;\n@(posedge clk_pcie_phy)     phy_ready |-> ($past(training_done, 3) && $past(power_good, 2) && $past(reset_deasserted, 1));\nendproperty\nassert_p_Past_With_Multiple_Conditions_30:assert property (p_Past_With_Multiple_Conditions_30) else $error(\"\");", "task_id": "4_570", "predict_sva": "@(posedge clk_pcie_phy)         phy_ready == 1 |-> $past(training_done, 3) == 1 && $past(power_good, 2) == 1 && $past(reset_deasserted, 1) == 1"}
{"id": "10_8_0471", "name": "conditional_past_check_8", "sva": "@(posedge clk_spi)      cs_fell |-> $past(sck_divider,5)==current_divider || $past(config_valid,1)", "ori_sva": "property conditional_past_check_8;\n@(posedge clk_spi)      cs_fell |-> $past(sck_divider,5)==current_divider || $past(config_valid,1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_conditional_past_check_8  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cs_fell`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(sck_divider, 5) == current_divider || $past(config_valid, 1)`  ", "sva_signals": ["clk_spi", "[0:0] cs_fell", "[0:0] sck_divider", "[0:0] current_divider", "[0:0] config_valid"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi)     cs_fell |-> ($past(sck_divider, 5) == current_divider || $past(config_valid, 1));", "sva_name": "p_cs_fell_divider_config_check", "full_property": "property p_conditional_past_check_8;\n@(posedge clk_spi)     cs_fell |-> ($past(sck_divider, 5) == current_divider || $past(config_valid, 1));\nendproperty\nassert_p_conditional_past_check_8:assert property (p_conditional_past_check_8) else $error(\"\");", "task_id": "4_591", "predict_sva": "@(posedge clk_spi)         cs_fell == 1 |-> ($past(sck_divider, 5) == current_divider) || ($past(config_valid, 1) == 1)"}
{"id": "12_30_0595", "name": "sync_lost_or_force_reset", "sva": "@(posedge recovery_clk)     sync_lost || force_reset |-> ##1 reset_issued", "ori_sva": "property sync_lost_or_force_reset;\n@(posedge recovery_clk)     sync_lost || force_reset |-> ##1 reset_issued\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sync_lost_or_force_reset  \n**Trigger Condition**: At every rising edge of the `recovery_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_lost || force_reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 reset_issued`", "sva_signals": ["recovery_clk", "[0:0] sync_lost", "[0:0] force_reset", "[0:0] reset_issued"], "clock": "recovery_clk", "attempts_left": 10, "sva_result": "@(posedge recovery_clk)     (sync_lost || force_reset) |-> ##1 reset_issued;", "sva_name": "p_reset_issued_on_sync_lost_or_force", "full_property": "property p_sync_lost_or_force_reset;\n@(posedge recovery_clk)     (sync_lost || force_reset) |-> ##1 reset_issued;\nendproperty\nassert_p_sync_lost_or_force_reset:assert property (p_sync_lost_or_force_reset) else $error(\"\");", "task_id": "4_659", "predict_sva": "@(posedge recovery_clk)         (sync_lost == 1 || force_reset == 1) |-> ##1 reset_issued == 1"}
{"id": "13_13_0612", "name": "not_fault_with_operation", "sva": "@(posedge clk_op)      !fault_detected |-> ##1 normal_op", "ori_sva": "property not_fault_with_operation;\n@(posedge clk_op)      !fault_detected |-> ##1 normal_op\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Fault_With_Operation  \n**Trigger Condition**: At every rising edge of the `clk_op`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!fault_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 normal_op`", "sva_signals": ["clk_op", "[0:0] fault_detected", "[0:0] normal_op"], "clock": "clk_op", "attempts_left": 10, "sva_result": "@(posedge clk_op)     !fault_detected |-> ##1 normal_op;", "sva_name": "p_normal_op_on_no_fault", "full_property": "property p_Not_Fault_With_Operation;\n@(posedge clk_op)     !fault_detected |-> ##1 normal_op;\nendproperty\nassert_p_Not_Fault_With_Operation:assert property (p_Not_Fault_With_Operation) else $error(\"\");", "task_id": "4_686", "predict_sva": "@(posedge clk_op)         fault_detected == 0 |-> ##1 normal_op == 1"}
{"id": "13_23_0638", "name": "not_collision_with_retry", "sva": "@(posedge clk_net)      !collision_detected |-> ##[2:4] retry_attempt", "ori_sva": "property not_collision_with_retry;\n@(posedge clk_net)      !collision_detected |-> ##[2:4] retry_attempt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_collision_with_retry  \n**Trigger Condition**: At every rising edge of the `clk_net`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!collision_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] retry_attempt`", "sva_signals": ["clk", "rst_n", "[0:0] collision_detected", "[0:0] retry_attempt", "clk_net"], "clock": "clk_net", "attempts_left": 10, "sva_result": "@(posedge clk_net)     !collision_detected |-> ##[2:4] retry_attempt;", "sva_name": "p_retry_attempt_after_no_collision", "full_property": "property p_not_collision_with_retry;\n@(posedge clk_net)     !collision_detected |-> ##[2:4] retry_attempt;\nendproperty\nassert_p_not_collision_with_retry:assert property (p_not_collision_with_retry) else $error(\"\");", "task_id": "4_692", "predict_sva": "@(posedge clk_net)         collision_detected == 0 |-> ##[2:4] retry_attempt == 1"}
{"id": "15_19_0728", "name": "temp_sensor_alarm_check", "sva": "@(posedge clk_sensor) disable iff(test_mode)     temp_over_threshold |-> ##[3:5] alarm_triggered ##1 !alarm_clear", "ori_sva": "property temp_sensor_alarm_check;\n@(posedge clk_sensor) disable iff(test_mode)     temp_over_threshold |-> ##[3:5] alarm_triggered ##1 !alarm_clear\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_sensor_alarm_check  \n**Trigger Condition**: At every rising edge of the `clk_sensor`  \n**Disable Condition**: disable iff (`test_mode`)  \n**Antecedent (LHS of Implication)**: `temp_over_threshold`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:5] alarm_triggered ##1 !alarm_clear`  ", "sva_signals": ["clk_sensor", "test_mode", "[0:0] temp_over_threshold", "[0:0] alarm_triggered", "[0:0] alarm_clear"], "clock": "clk_sensor", "attempts_left": 10, "sva_result": "@(posedge clk_sensor) disable iff (test_mode)     temp_over_threshold |-> ##[3:5] alarm_triggered ##1 !alarm_clear;", "sva_name": "p_alarm_triggered_and_clear_after_temp_over_threshold", "full_property": "property p_temp_sensor_alarm_check;\n@(posedge clk_sensor) disable iff (test_mode)     temp_over_threshold |-> ##[3:5] alarm_triggered ##1 !alarm_clear;\nendproperty\nassert_p_temp_sensor_alarm_check:assert property (p_temp_sensor_alarm_check) else $error(\"\");", "task_id": "4_736", "predict_sva": "@(posedge clk_sensor) disable iff (test_mode)         (test_mode == 0 && temp_over_threshold == 1) |-> ##[3:5] (alarm_triggered == 1) ##1 (alarm_clear == 0)"}
{"id": "15_20_0729", "name": "watchdog_timeout_check", "sva": "@(posedge clk_wdt) disable iff(debug_halt)     !wdt_refresh |-> ##[0:255] system_reset", "ori_sva": "property watchdog_timeout_check;\n@(posedge clk_wdt) disable iff(debug_halt)     !wdt_refresh |-> ##[0:255] system_reset\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Watchdog_Timeout_Check  \n**Trigger Condition**: At every rising edge of the `clk_wdt`  \n**Disable Condition**: `disable iff (debug_halt)`  \n**Antecedent (LHS of Implication)**: `!wdt_refresh`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:255] system_reset`  ", "sva_signals": ["clk_wdt", "debug_halt", "[0:0] wdt_refresh", "system_reset"], "clock": "clk_wdt", "attempts_left": 10, "sva_result": "@(posedge clk_wdt) disable iff (debug_halt)     !wdt_refresh |-> ##[0:255] system_reset;", "sva_name": "p_wdt_refresh_triggers_system_reset", "full_property": "property p_Watchdog_Timeout_Check;\n@(posedge clk_wdt) disable iff (debug_halt)     !wdt_refresh |-> ##[0:255] system_reset;\nendproperty\nassert_p_Watchdog_Timeout_Check:assert property (p_Watchdog_Timeout_Check) else $error(\"\");", "task_id": "4_737", "predict_sva": "@(posedge clk_wdt) disable iff (debug_halt)         (debug_halt == 0 && wdt_refresh == 0) |-> ##[0:255] system_reset == 1"}
{"id": "15_29_0737", "name": "trace_fifo_watermark_check", "sva": "@(posedge clk_trace) disable iff(trace_disabled)     trace_watermark |-> ##[0:3] trigger_out ##1 !fifo_overflow", "ori_sva": "property trace_fifo_watermark_check;\n@(posedge clk_trace) disable iff(trace_disabled)     trace_watermark |-> ##[0:3] trigger_out ##1 !fifo_overflow\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Trace_Fifo_Watermark_Check  \n**Trigger Condition**: At every rising edge of the `clk_trace`  \n**Disable Condition**: disable iff (`trace_disabled`)  \n**Antecedent (LHS of Implication)**: `trace_watermark == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:3] trigger_out ##1 !fifo_overflow`  ", "sva_signals": ["clk_trace", "trace_disabled", "[0:0] trace_watermark", "[0:0] trigger_out", "[0:0] fifo_overflow"], "clock": "clk_trace", "attempts_left": 10, "sva_result": "@(posedge clk_trace) disable iff (trace_disabled)     trace_watermark == 1'b1 |-> ##[0:3] trigger_out ##1 !fifo_overflow;", "sva_name": "p_trace_watermark_trigger_fifo_check", "full_property": "property p_Trace_Fifo_Watermark_Check;\n@(posedge clk_trace) disable iff (trace_disabled)     trace_watermark == 1'b1 |-> ##[0:3] trigger_out ##1 !fifo_overflow;\nendproperty\nassert_p_Trace_Fifo_Watermark_Check:assert property (p_Trace_Fifo_Watermark_Check) else $error(\"\");", "task_id": "4_744", "predict_sva": "@(posedge clk_trace) disable iff (trace_disabled)         (trace_disabled == 0 && trace_watermark == 1) |-> ##[0:3] (trigger_out == 1) ##1 (fifo_overflow == 0)"}
{"id": "1_11_0038", "name": "thermal_throttling_sequence", "sva": "@(posedge clk_temp)      temperature_critical |-> ##3 clock_throttled ##5 temperature_normal", "ori_sva": "property thermal_throttling_sequence;\n@(posedge clk_temp)      temperature_critical |-> ##3 clock_throttled ##5 temperature_normal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Throttling_Sequence  \n**Trigger Condition**: At every rising edge of the `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temperature_critical == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 clock_throttled ##5 temperature_normal`  ", "sva_signals": ["clk_temp", "[0:0] temperature_critical", "[0:0] clock_throttled", "[0:0] temperature_normal"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     temperature_critical == 1'b1 |-> ##3 clock_throttled ##5 temperature_normal;", "sva_name": "p_temperature_critical_to_normal_sequence", "full_property": "property p_Thermal_Throttling_Sequence;\n@(posedge clk_temp)     temperature_critical == 1'b1 |-> ##3 clock_throttled ##5 temperature_normal;\nendproperty\nassert_p_Thermal_Throttling_Sequence:assert property (p_Thermal_Throttling_Sequence) else $error(\"\");", "task_id": "4_769", "predict_sva": "@(posedge clk_temp)         temperature_critical == 1'b1 |-> ##3 clock_throttled == 1'b1 ##5 temperature_normal == 1'b1"}
{"id": "2_11_0026", "name": "dma_transfer_completion", "sva": "@(posedge clk_dma)     dma_start |-> ##[16:64] dma_done", "ori_sva": "property dma_transfer_completion;\n@(posedge clk_dma)     dma_start |-> ##[16:64] dma_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_transfer_completion  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `dma_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:64] dma_done` (DMA transfer completes between 16 to 64 clock cycles after DMA start)", "sva_signals": ["clk_dma", "[0:0] dma_start", "[0:0] dma_done"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma)     dma_start == 1'b1 |-> ##[16:64] dma_done;", "sva_name": "p_dma_done_within_16_to_64_cycles_after_start", "full_property": "property p_dma_transfer_completion;\n@(posedge clk_dma)     dma_start == 1'b1 |-> ##[16:64] dma_done;\nendproperty\nassert_p_dma_transfer_completion:assert property (p_dma_transfer_completion) else $error(\"\");", "task_id": "4_817", "predict_sva": "@(posedge clk_dma)         dma_start == 1'b1 |-> ##[16:64] dma_done == 1'b1"}
{"id": "2_19_0070", "name": "voltage_ramp_completion", "sva": "@(posedge clk_pmu)     voltage_change |-> ##[16:64] voltage_stable", "ori_sva": "property voltage_ramp_completion;\n@(posedge clk_pmu)     voltage_change |-> ##[16:64] voltage_stable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_voltage_ramp_completion  \n**Trigger Condition**: At every posedge of the `clk_pmu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `voltage_change`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:64] voltage_stable`  ", "sva_signals": ["clk_pmu", "[0:0] voltage_change", "[0:0] voltage_stable"], "clock": "clk_pmu", "attempts_left": 10, "sva_result": "@(posedge clk_pmu)         voltage_change |-> ##[16:64] voltage_stable;", "sva_name": "p_voltage_stable_after_change", "full_property": "property p_voltage_ramp_completion;\n@(posedge clk_pmu)         voltage_change |-> ##[16:64] voltage_stable;\nendproperty\nassert_p_voltage_ramp_completion:assert property (p_voltage_ramp_completion) else $error(\"\");", "task_id": "4_825", "predict_sva": "@(posedge clk_pmu)         voltage_change == 1 |-> ##[16:64] voltage_stable == 1"}
{"id": "2_44_0089", "name": "fpga_config_done", "sva": "@(posedge clk_cfg)     cfg_start |-> ##[128:256] cfg_done", "ori_sva": "property fpga_config_done;\n@(posedge clk_cfg)     cfg_start |-> ##[128:256] cfg_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fpga_config_done  \n**Trigger Condition**: At every rising edge of the `clk_cfg`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cfg_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[128:256] cfg_done == 1'b1`  \n\n(Note: The consequent checks that `cfg_done` becomes high between 128 to 256 clock cycles after `cfg_start` is asserted.)", "sva_signals": ["clk_cfg", "[0:0] cfg_start", "[0:0] cfg_done"], "clock": "clk_cfg", "attempts_left": 10, "sva_result": "@(posedge clk_cfg)     cfg_start == 1'b1 |-> ##[128:256] cfg_done == 1'b1;", "sva_name": "p_cfg_done_within_128_256_cycles_after_cfg_start", "full_property": "property p_fpga_config_done;\n@(posedge clk_cfg)     cfg_start == 1'b1 |-> ##[128:256] cfg_done == 1'b1;\nendproperty\nassert_p_fpga_config_done:assert property (p_fpga_config_done) else $error(\"\");", "task_id": "4_850", "predict_sva": "@(posedge clk_cfg)         cfg_start == 1'b1 |-> ##[128:256] cfg_done == 1'b1"}
{"id": "3_14_0136", "name": "voltage_monitor_check", "sva": "@(posedge clk_pmon)     vmon_alert |-> ##1 voltage_adjust ##[3:6] vmon_normal", "ori_sva": "property voltage_monitor_check;\n@(posedge clk_pmon)     vmon_alert |-> ##1 voltage_adjust ##[3:6] vmon_normal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Voltage_Monitor_Check  \n**Trigger Condition**: At every rising edge of the `clk_pmon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vmon_alert`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 voltage_adjust ##[3:6] vmon_normal`  ", "sva_signals": ["clk_pmon", "vmon_alert", "voltage_adjust", "vmon_normal"], "clock": "clk_pmon", "attempts_left": 10, "sva_result": "@(posedge clk_pmon)     vmon_alert |-> ##1 voltage_adjust ##[3:6] vmon_normal;", "sva_name": "p_vmon_alert_voltage_adjust_vmon_normal", "full_property": "property p_Voltage_Monitor_Check;\n@(posedge clk_pmon)     vmon_alert |-> ##1 voltage_adjust ##[3:6] vmon_normal;\nendproperty\nassert_p_Voltage_Monitor_Check:assert property (p_Voltage_Monitor_Check) else $error(\"\");", "task_id": "4_863", "predict_sva": "@(posedge clk_pmon)         vmon_alert == 1 |-> ##1 voltage_adjust == 1 ##[3:6] vmon_normal == 1"}
{"id": "7_40_0336", "name": "rising_edge_detection_40", "sva": "@(posedge clk_wifi)      $rose(plcp_header_detected) |-> ##1 (data_unit_ready && $stable(rate_field))", "ori_sva": "property rising_edge_detection_40;\n@(posedge clk_wifi)      $rose(plcp_header_detected) |-> ##1 (data_unit_ready && $stable(rate_field))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rising_edge_detection_40  \n**Trigger Condition**: At every rising edge of the `clk_wifi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(plcp_header_detected)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 (data_unit_ready && $stable(rate_field))`", "sva_signals": ["clk_wifi", "plcp_header_detected", "[0:0] data_unit_ready", "[0:0] rate_field"], "clock": "clk_wifi", "attempts_left": 10, "sva_result": "@(posedge clk_wifi)     $rose(plcp_header_detected) |-> ##1 (data_unit_ready && $stable(rate_field));", "sva_name": "p_data_unit_ready_and_rate_field_stability_after_plcp_header_detected", "full_property": "property p_rising_edge_detection_40;\n@(posedge clk_wifi)     $rose(plcp_header_detected) |-> ##1 (data_unit_ready && $stable(rate_field));\nendproperty\nassert_p_rising_edge_detection_40:assert property (p_rising_edge_detection_40) else $error(\"\");", "task_id": "4_1026", "predict_sva": "@(posedge clk_wifi)         $rose(plcp_header_detected) |-> ##1 (data_unit_ready && $stable(rate_field))"}
{"id": "10_55_0532", "name": "delayed_power_up_check", "sva": "@(posedge clk_pwrup)     $past(pwr_ok,5) |-> $past(core_ready,4) && $past(pll_lock,3)", "ori_sva": "property delayed_power_up_check;\n@(posedge clk_pwrup)     $past(pwr_ok,5) |-> $past(core_ready,4) && $past(pll_lock,3)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Delayed_Power_Up_Check  \n**Trigger Condition**: At every rising edge of the `clk_pwrup`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(pwr_ok, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(core_ready, 4) && $past(pll_lock, 3)`  ", "sva_signals": ["clk_pwrup", "[0:0] pwr_ok", "[0:0] core_ready", "[0:0] pll_lock"], "clock": "clk_pwrup", "attempts_left": 10, "sva_result": "@(posedge clk_pwrup)     $past(pwr_ok, 5) |-> $past(core_ready, 4) && $past(pll_lock, 3);", "sva_name": "p_pwr_ok_core_ready_pll_lock_sequence", "full_property": "property p_Delayed_Power_Up_Check;\n@(posedge clk_pwrup)     $past(pwr_ok, 5) |-> $past(core_ready, 4) && $past(pll_lock, 3);\nendproperty\nassert_p_Delayed_Power_Up_Check:assert property (p_Delayed_Power_Up_Check) else $error(\"\");", "task_id": "4_1114", "predict_sva": "@(posedge clk_pwrup)         $past(pwr_ok, 5) |-> ($past(core_ready, 4) && $past(pll_lock, 3))"}
{"id": "11_20_0528", "name": "pwm_period_match_20", "sva": "@(posedge clk_pwm)      pwm_enable && (pwm_counter == period_reg) |-> ##1 pwm_out", "ori_sva": "property pwm_period_match_20;\n@(posedge clk_pwm)      pwm_enable && (pwm_counter == period_reg) |-> ##1 pwm_out\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pwm_period_match_20  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwm_enable && (pwm_counter == period_reg)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 pwm_out`", "sva_signals": ["clk_pwm", "pwm_enable", "pwm_counter", "period_reg", "[0:0] pwm_out"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)         (pwm_enable && (pwm_counter == period_reg)) |-> ##1 pwm_out;", "sva_name": "p_pwm_out_assertion_on_period_match", "full_property": "property pwm_period_match_20;\n@(posedge clk_pwm)         (pwm_enable && (pwm_counter == period_reg)) |-> ##1 pwm_out;\nendproperty\nassert_pwm_period_match_20:assert property (pwm_period_match_20) else $error(\"\");", "task_id": "4_1128", "predict_sva": "@(posedge clk_pwm)         (pwm_enable == 1 && pwm_counter == period_reg) |-> ##1 (pwm_out == 1)"}
{"id": "11_17_0554", "name": "i2c_start_stop_17", "sva": "@(posedge clk_i2c)      i2c_start && !i2c_stop |-> ##[2:4] i2c_ack", "ori_sva": "property i2c_start_stop_17;\n@(posedge clk_i2c)      i2c_start && !i2c_stop |-> ##[2:4] i2c_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_i2c_start_stop_ack  \n**Trigger Condition**: At every rising edge of the `clk_i2c`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `i2c_start && !i2c_stop`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] i2c_ack`  ", "sva_signals": ["clk_i2c", "rst_n", "[0:0] i2c_start", "[0:0] i2c_stop", "[0:0] i2c_ack"], "clock": "clk_i2c", "attempts_left": 10, "sva_result": "@(posedge clk_i2c)     (i2c_start && !i2c_stop) |-> ##[2:4] i2c_ack;", "sva_name": "p_i2c_ack_within_2_to_4_cycles_after_start", "full_property": "property p_i2c_start_stop_ack;\n@(posedge clk_i2c)     (i2c_start && !i2c_stop) |-> ##[2:4] i2c_ack;\nendproperty\nassert_p_i2c_start_stop_ack:assert property (p_i2c_start_stop_ack) else $error(\"\");", "task_id": "4_1125", "predict_sva": "@(posedge clk_i2c)         (i2c_start == 1 && i2c_stop == 0) |-> ##[2:4] (i2c_ack == 1)"}
{"id": "11_43_0558", "name": "rf_tx_complete_43", "sva": "@(posedge clk_rf)      rf_tx_start && !rf_tx_busy |-> ##[16:32] rf_tx_done", "ori_sva": "property rf_tx_complete_43;\n@(posedge clk_rf)      rf_tx_start && !rf_tx_busy |-> ##[16:32] rf_tx_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rf_tx_complete_43  \n**Trigger Condition**: At every rising edge of the `clk_rf`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rf_tx_start && !rf_tx_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:32] rf_tx_done`  ", "sva_signals": ["clk_rf", "rst_n", "[0:0] rf_tx_start", "[0:0] rf_tx_busy", "[0:0] rf_tx_done"], "clock": "clk_rf", "attempts_left": 10, "sva_result": "@(posedge clk_rf)     (rf_tx_start && !rf_tx_busy) |-> ##[16:32] rf_tx_done;", "sva_name": "p_rf_tx_done_within_16_32_cycles_after_start", "full_property": "property p_rf_tx_complete_43;\n@(posedge clk_rf)     (rf_tx_start && !rf_tx_busy) |-> ##[16:32] rf_tx_done;\nendproperty\nassert_p_rf_tx_complete_43:assert property (p_rf_tx_complete_43) else $error(\"\");", "task_id": "4_1150", "predict_sva": "@(posedge clk_rf)         (rf_tx_start == 1 && rf_tx_busy == 0) |-> ##[16:32] rf_tx_done == 1"}
{"id": "11_45_0562", "name": "satellite_lock_45", "sva": "@(posedge clk_sat)      lock_start && !lock_busy |-> ##[128:256] lock_done", "ori_sva": "property satellite_lock_45;\n@(posedge clk_sat)      lock_start && !lock_busy |-> ##[128:256] lock_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_satellite_lock_45  \n**Trigger Condition**: At every rising edge of the `clk_sat`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lock_start && !lock_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[128:256] lock_done`  \n\n", "sva_signals": ["clk_sat", "lock_start", "lock_busy", "lock_done"], "clock": "clk_sat", "attempts_left": 10, "sva_result": "@(posedge clk_sat)     (lock_start && !lock_busy) |-> ##[128:256] lock_done;", "sva_name": "p_lock_done_within_128_256_cycles_after_start", "full_property": "property p_satellite_lock_45;\n@(posedge clk_sat)     (lock_start && !lock_busy) |-> ##[128:256] lock_done;\nendproperty\nassert_p_satellite_lock_45:assert property (p_satellite_lock_45) else $error(\"\");", "task_id": "4_1153", "predict_sva": "@(posedge clk_sat)         (lock_start == 1 && lock_busy == 0) |-> ##[128:256] (lock_done == 1)"}
{"id": "12_14_0580", "name": "watchdog_expire_or_sw_wd_check", "sva": "@(posedge clk_wdt)      wdt_expire_pulse || sw_wd_trigger |-> ##0 system_reset", "ori_sva": "property watchdog_expire_or_sw_wd_check;\n@(posedge clk_wdt)      wdt_expire_pulse || sw_wd_trigger |-> ##0 system_reset\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_watchdog_expire_or_sw_wd_check  \n**Trigger Condition**: At every rising edge of the `clk_wdt`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `wdt_expire_pulse || sw_wd_trigger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##0 system_reset`", "sva_signals": ["clk_wdt", "system_reset", "[0:0] wdt_expire_pulse", "[0:0] sw_wd_trigger"], "clock": "clk_wdt", "attempts_left": 10, "sva_result": "@(posedge clk_wdt)     (wdt_expire_pulse || sw_wd_trigger) |-> ##0 system_reset;", "sva_name": "p_system_reset_on_wdt_or_sw_wd", "full_property": "property p_watchdog_expire_or_sw_wd_check;\n@(posedge clk_wdt)     (wdt_expire_pulse || sw_wd_trigger) |-> ##0 system_reset;\nendproperty\nassert_p_watchdog_expire_or_sw_wd_check:assert property (p_watchdog_expire_or_sw_wd_check) else $error(\"\");", "task_id": "4_1168", "predict_sva": "@(posedge clk_wdt)         (wdt_expire_pulse == 1 || sw_wd_trigger == 1) |-> system_reset == 1"}
{"id": "12_18_0579", "name": "pattern_match_or_force_alert_check", "sva": "@(posedge clk_dsp)      pattern_match_flag || force_alert_signal |-> ##2 interrupt_pending", "ori_sva": "property pattern_match_or_force_alert_check;\n@(posedge clk_dsp)      pattern_match_flag || force_alert_signal |-> ##2 interrupt_pending\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pattern_Match_Or_Force_Alert_Check  \n**Trigger Condition**: At every rising edge of the `clk_dsp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pattern_match_flag || force_alert_signal`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 interrupt_pending`", "sva_signals": ["clk_dsp", "force_alert_signal", "[0:0] pattern_match_flag", "[0:0] interrupt_pending"], "clock": "clk_dsp", "attempts_left": 10, "sva_result": "@(posedge clk_dsp)     (pattern_match_flag || force_alert_signal) |-> ##2 interrupt_pending;", "sva_name": "p_interrupt_pending_after_alert", "full_property": "property p_Pattern_Match_Or_Force_Alert_Check;\n@(posedge clk_dsp)     (pattern_match_flag || force_alert_signal) |-> ##2 interrupt_pending;\nendproperty\nassert_p_Pattern_Match_Or_Force_Alert_Check:assert property (p_Pattern_Match_Or_Force_Alert_Check) else $error(\"\");", "task_id": "4_1172", "predict_sva": "@(posedge clk_dsp)         (pattern_match_flag == 1 || force_alert_signal == 1) |-> ##2 interrupt_pending == 1"}
{"id": "12_30_0598", "name": "threshold_exceed_or_forced_check", "sva": "@(posedge clk_adc)      threshold_exceeded || forced_alert_en |-> ##3 interrupt_assert", "ori_sva": "property threshold_exceed_or_forced_check;\n@(posedge clk_adc)      threshold_exceeded || forced_alert_en |-> ##3 interrupt_assert\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Threshold_Exceed_Or_Forced_Check  \n**Trigger Condition**: At every rising edge of the `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `threshold_exceeded || forced_alert_en`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 interrupt_assert`", "sva_signals": ["clk_adc", "[0:0] threshold_exceeded", "[0:0] forced_alert_en", "[0:0] interrupt_assert"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     (threshold_exceeded || forced_alert_en) |-> ##3 interrupt_assert;", "sva_name": "p_interrupt_assert_after_alert", "full_property": "property p_Threshold_Exceed_Or_Forced_Check;\n@(posedge clk_adc)     (threshold_exceeded || forced_alert_en) |-> ##3 interrupt_assert;\nendproperty\nassert_p_Threshold_Exceed_Or_Forced_Check:assert property (p_Threshold_Exceed_Or_Forced_Check) else $error(\"\");", "task_id": "4_1184", "predict_sva": "@(posedge clk_adc)         (threshold_exceeded == 1 || forced_alert_en == 1) |-> ##3 interrupt_assert == 1"}
{"id": "15_46_0767", "name": "power_domain_check", "sva": "@(posedge clk_pd) disable iff(pd_rst)     pd_on |-> ##[5:10] pd_ready ##1 $stable(pd_status)", "ori_sva": "property power_domain_check;\n@(posedge clk_pd) disable iff(pd_rst)     pd_on |-> ##[5:10] pd_ready ##1 $stable(pd_status)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_domain_check  \n**Trigger Condition**: At every rising edge of the `clk_pd`  \n**Disable Condition**: disable iff (`pd_rst`)  \n**Antecedent (LHS of Implication)**: `pd_on == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] pd_ready ##1 $stable(pd_status)`  \n\n**Explanation of Consequent**:  \n- `##[5:10] pd_ready`: After the antecedent is true, `pd_ready` must become high within 5 to 10 clock cycles.  \n- `##1 $stable(pd_status)`: One clock cycle after `pd_ready` is asserted, `pd_status` must remain stable (unchanged).  \n\n**Note**: The property ensures that when the power domain is turned on (`pd_on`), it becomes ready (`pd_ready`) within 5 to 10 clock cycles, followed by a stable `pd_status` signal. The assertion is disabled if `pd_rst` is asserted.", "sva_signals": ["clk_pd", "pd_rst", "[0:0] pd_on", "[0:0] pd_ready", "[0:0] pd_status"], "clock": "clk_pd", "attempts_left": 10, "sva_result": "@(posedge clk_pd) disable iff (pd_rst)     pd_on == 1'b1 |-> ##[5:10] pd_ready ##1 $stable(pd_status);", "sva_name": "p_pd_ready_and_status_stability_after_on", "full_property": "property p_power_domain_check;\n@(posedge clk_pd) disable iff (pd_rst)     pd_on == 1'b1 |-> ##[5:10] pd_ready ##1 $stable(pd_status);\nendproperty\nassert_p_power_domain_check:assert property (p_power_domain_check) else $error(\"\");", "task_id": "4_1289", "predict_sva": "@(posedge clk_pd) disable iff (pd_rst)         (pd_rst == 0 && pd_on == 1) |-> ##[5:10] (pd_ready == 1) ##1 $stable(pd_status)"}
{"id": "1_15_0058", "name": "thermal_throttle_check", "sva": "@(posedge clk_temp)     temp_alert |-> ##5 (clock_divider_active && !over_temp)", "ori_sva": "property thermal_throttle_check;\n@(posedge clk_temp)     temp_alert |-> ##5 (clock_divider_active && !over_temp)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Throttle_Check  \n**Trigger Condition**: At every rising edge of the `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_alert == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 (clock_divider_active && !over_temp)`  ", "sva_signals": ["clk_temp", "[0:0] temp_alert", "[0:0] clock_divider_active", "[0:0] over_temp"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     temp_alert == 1'b1 |-> ##5 (clock_divider_active && !over_temp);", "sva_name": "p_temp_alert_clock_divider_active_over_temp", "full_property": "property p_Thermal_Throttle_Check;\n@(posedge clk_temp)     temp_alert == 1'b1 |-> ##5 (clock_divider_active && !over_temp);\nendproperty\nassert_p_Thermal_Throttle_Check:assert property (p_Thermal_Throttle_Check) else $error(\"\");", "task_id": "4_1308", "predict_sva": "@(posedge clk_temp)         temp_alert == 1'b1 |-> ##5 (clock_divider_active == 1'b1 && over_temp == 1'b0)"}
{"id": "1_5_0049", "name": "fifo_write_read_check", "sva": "@(posedge clk_fifo)     (fifo_wr_en && !fifo_full) |-> ##3 (fifo_rd_en && !fifo_empty)", "ori_sva": "property fifo_write_read_check;\n@(posedge clk_fifo)     (fifo_wr_en && !fifo_full) |-> ##3 (fifo_rd_en && !fifo_empty)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Fifo_Write_Read_Check  \n**Trigger Condition**: At every rising edge of the `clk_fifo`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_wr_en && !fifo_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 (fifo_rd_en && !fifo_empty)`  ", "sva_signals": ["clk_fifo", "fifo_wr_en", "fifo_full", "fifo_rd_en", "fifo_empty"], "clock": "clk_fifo", "attempts_left": 10, "sva_result": "@(posedge clk_fifo)     (fifo_wr_en && !fifo_full) |-> ##3 (fifo_rd_en && !fifo_empty);", "sva_name": "p_fifo_write_followed_by_read_3cycles", "full_property": "property p_Fifo_Write_Read_Check;\n@(posedge clk_fifo)     (fifo_wr_en && !fifo_full) |-> ##3 (fifo_rd_en && !fifo_empty);\nendproperty\nassert_p_Fifo_Write_Read_Check:assert property (p_Fifo_Write_Read_Check) else $error(\"\");", "task_id": "4_1346", "predict_sva": "@(posedge clk_fifo)         (fifo_wr_en == 1 && fifo_full == 0) |-> ##3 (fifo_rd_en == 1 && fifo_empty == 0)"}
{"id": "2_49_0103", "name": "proximity_detection_latency", "sva": "@(posedge clk_proximity)     proximity_enable |-> ##[1:3] proximity_detect ##1 $stable(proximity_distance)", "ori_sva": "property proximity_detection_latency;\n@(posedge clk_proximity)     proximity_enable |-> ##[1:3] proximity_detect ##1 $stable(proximity_distance)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Proximity_Detection_Latency  \n**Trigger Condition**: At every rising edge of the `clk_proximity`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `proximity_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] proximity_detect ##1 $stable(proximity_distance)`  ", "sva_signals": ["clk_proximity", "proximity_enable", "proximity_detect", "proximity_distance"], "clock": "clk_proximity", "attempts_left": 10, "sva_result": "@(posedge clk_proximity)     proximity_enable == 1'b1 |-> ##[1:3] proximity_detect ##1 $stable(proximity_distance);", "sva_name": "p_proximity_detect_and_distance_stability", "full_property": "property p_Proximity_Detection_Latency;\n@(posedge clk_proximity)     proximity_enable == 1'b1 |-> ##[1:3] proximity_detect ##1 $stable(proximity_distance);\nendproperty\nassert_p_Proximity_Detection_Latency:assert property (p_Proximity_Detection_Latency) else $error(\"\");", "task_id": "4_1385", "predict_sva": "@(posedge clk_proximity)         proximity_enable == 1'b1 |-> ##[1:3] proximity_detect == 1'b1 ##1 $stable(proximity_distance)"}
{"id": "5_15_0227", "name": "memory_init_sequence_1", "sva": "@(posedge clk_ddr)     init_start |-> init_cmd[*6] ##1 init_done", "ori_sva": "property memory_init_sequence_1;\n@(posedge clk_ddr)     init_start |-> init_cmd[*6] ##1 init_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_init_sequence_1  \n**Trigger Condition**: At every rising edge of the `clk_ddr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `init_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `init_cmd[*6] ##1 init_done`  ", "sva_signals": ["clk_ddr", "init_start", "[0:0] init_cmd", "init_done"], "clock": "clk_ddr", "attempts_left": 10, "sva_result": "@(posedge clk_ddr)     init_start |-> init_cmd[*6] ##1 init_done;", "sva_name": "p_init_cmd_done_sequence", "full_property": "property p_memory_init_sequence_1;\n@(posedge clk_ddr)     init_start |-> init_cmd[*6] ##1 init_done;\nendproperty\nassert_p_memory_init_sequence_1:assert property (p_memory_init_sequence_1) else $error(\"\");", "task_id": "4_1486", "predict_sva": "@(posedge clk_ddr)         init_start == 1 |->          (init_cmd == 1 [*6]) ##1 init_done == 1"}
{"id": "2_4_0043", "name": "cache_invalidate_completion", "sva": "@(posedge clk_mem)     cache_inv_req && !bus_lock |-> ##[8:16] cache_inv_done ##1 $stable(cache_tag_array)", "ori_sva": "property cache_invalidate_completion;\n@(posedge clk_mem)     cache_inv_req && !bus_lock |-> ##[8:16] cache_inv_done ##1 $stable(cache_tag_array)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_invalidate_completion  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_inv_req && !bus_lock`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] cache_inv_done ##1 $stable(cache_tag_array)`  \n\n**Explanation of Consequent**:  \n- `##[8:16] cache_inv_done`: The signal `cache_inv_done` must be asserted between 8 to 16 clock cycles after the antecedent is true.  \n- `##1 $stable(cache_tag_array)`: One clock cycle after `cache_inv_done` is asserted, the `cache_tag_array` must remain stable (unchanged).", "sva_signals": ["clk_mem", "bus_lock", "[0:0] cache_inv_req", "[0:0] cache_inv_done", "cache_tag_array"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)         (cache_inv_req && !bus_lock) |-> ##[8:16] cache_inv_done ##1 $stable(cache_tag_array);", "sva_name": "p_cache_invalidate_done_and_tag_stability", "full_property": "property p_cache_invalidate_completion;\n@(posedge clk_mem)         (cache_inv_req && !bus_lock) |-> ##[8:16] cache_inv_done ##1 $stable(cache_tag_array);\nendproperty\nassert_p_cache_invalidate_completion:assert property (p_cache_invalidate_completion) else $error(\"\");", "task_id": "4_1386", "predict_sva": "@(posedge clk_mem)         (cache_inv_req == 1'b1 && bus_lock == 1'b0) |-> ##[8:16] (cache_inv_done == 1'b1) ##1 $stable(cache_tag_array)"}
{"id": "5_26_0234", "name": "bus_priority_rotation_1", "sva": "@(posedge clk_bus_arb)     high_pri[*2] |-> ##1 medium_pri[*2]", "ori_sva": "property bus_priority_rotation_1;\n@(posedge clk_bus_arb)     high_pri[*2] |-> ##1 medium_pri[*2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_priority_rotation_1  \n**Trigger Condition**: At every rising edge of the `clk_bus_arb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `high_pri` is true for two consecutive clock cycles (`high_pri[*2]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After one clock cycle (`##1`), `medium_pri` must be true for the next two consecutive clock cycles (`medium_pri[*2]`)", "sva_signals": ["clk_bus_arb", "high_pri", "medium_pri"], "clock": "clk_bus_arb", "attempts_left": 10, "sva_result": "@(posedge clk_bus_arb)     high_pri[*2] |-> ##1 medium_pri[*2];", "sva_name": "p_high_pri_to_medium_pri_sequence", "full_property": "property p_bus_priority_rotation_1;\n@(posedge clk_bus_arb)     high_pri[*2] |-> ##1 medium_pri[*2];\nendproperty\nassert_p_bus_priority_rotation_1:assert property (p_bus_priority_rotation_1) else $error(\"\");", "task_id": "4_1496", "predict_sva": "@(posedge clk_bus_arb)         high_pri [*2] |-> ##1 medium_pri [*2]"}
{"id": "6_25_0269", "name": "sd_card_response_25", "sva": "@(posedge clk_sd)      cmd_sent |-> (busy_response[*1:8] ##1 data_ready[*1:4])", "ori_sva": "property sd_card_response_25;\n@(posedge clk_sd)      cmd_sent |-> (busy_response[*1:8] ##1 data_ready[*1:4])\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sd_card_response_25  \n**Trigger Condition**: At every rising edge of the `clk_sd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cmd_sent == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(busy_response[*1:8] ##1 data_ready[*1:4])`  \n\n**Explanation of Consequent**:  \nThe consequent requires that after `cmd_sent` is true, the following sequence must occur:  \n1. `busy_response` must stay high for **1 to 8 consecutive clock cycles**, followed by  \n2. `data_ready` must stay high for **1 to 4 consecutive clock cycles**.  \n\nThe `[*1:8]` and `[*1:4]` denote repetition ranges, meaning the signals must hold for at least 1 cycle and at most 8 (for `busy_response`) or 4 (for `data_ready`) cycles. The `##1` ensures a one-cycle delay between the end of `busy_response` and the start of `data_ready`.", "sva_signals": ["clk_sd", "[0:0] cmd_sent", "[0:0] busy_response", "[0:0] data_ready"], "clock": "clk_sd", "attempts_left": 10, "sva_result": "@(posedge clk_sd)     cmd_sent == 1'b1 |-> (busy_response[*1:8] ##1 data_ready[*1:4]);", "sva_name": "p_cmd_sent_busy_data_sequence", "full_property": "property p_sd_card_response_25;\n@(posedge clk_sd)     cmd_sent == 1'b1 |-> (busy_response[*1:8] ##1 data_ready[*1:4]);\nendproperty\nassert_p_sd_card_response_25:assert property (p_sd_card_response_25) else $error(\"\");", "task_id": "4_1542", "predict_sva": "@(posedge clk_sd)         cmd_sent == 1'b1 |->      (busy_response [*1:8]) ##1 (data_ready [*1:4])"}
{"id": "6_44_0279", "name": "led_pwm_fade_44", "sva": "@(posedge clk_led)      fade_start |-> (brightness_up[*10:100] ##1 brightness_down[*10:100])", "ori_sva": "property led_pwm_fade_44;\n@(posedge clk_led)      fade_start |-> (brightness_up[*10:100] ##1 brightness_down[*10:100])\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_led_pwm_fade_44  \n**Trigger Condition**: At every rising edge of the `clk_led`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fade_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `(brightness_up[*10:100] ##1 brightness_down[*10:100])`  \n\n**Explanation of Consequent**:  \nThe consequent specifies that after the antecedent (`fade_start`) is true, the following sequence must occur:  \n1. `brightness_up` must hold true for **10 to 100 consecutive clock cycles**, followed by  \n2. `brightness_down` must hold true for **another 10 to 100 consecutive clock cycles**.  \n\nThe `##1` operator ensures the transition from the `brightness_up` phase to the `brightness_down` phase occurs in the next clock cycle after the `brightness_up` sequence completes.", "sva_signals": ["clk_led", "[0:0] fade_start", "[0:0] brightness_up", "[0:0] brightness_down"], "clock": "clk_led", "attempts_left": 10, "sva_result": "@(posedge clk_led)     fade_start |-> (brightness_up[*10:100] ##1 brightness_down[*10:100]);", "sva_name": "p_fade_start_brightness_sequence", "full_property": "property p_led_pwm_fade_44;\n@(posedge clk_led)     fade_start |-> (brightness_up[*10:100] ##1 brightness_down[*10:100]);\nendproperty\nassert_p_led_pwm_fade_44:assert property (p_led_pwm_fade_44) else $error(\"\");", "task_id": "4_1561", "predict_sva": "@(posedge clk_led)         fade_start == 1 |->     (brightness_up [*10:100]) ##1 (brightness_down [*10:100])"}
{"id": "7_1_0307", "name": "data_valid_rise_to_req_ack", "sva": "@(posedge sys_clk)     $rose(data_valid) |-> ##[1:3] req_pending ##2 ack_received", "ori_sva": "property data_valid_rise_to_req_ack;\n@(posedge sys_clk)     $rose(data_valid) |-> ##[1:3] req_pending ##2 ack_received\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_data_valid_rise_to_req_ack  \n**Trigger Condition**: At every rising edge of `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(data_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] req_pending ##2 ack_received`  ", "sva_signals": ["sys_clk", "data_valid", "[0:0] req_pending", "[0:0] ack_received"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)     $rose(data_valid) |-> ##[1:3] req_pending ##2 ack_received;", "sva_name": "p_data_valid_req_pending_ack_received_sequence", "full_property": "property p_data_valid_rise_to_req_ack;\n@(posedge sys_clk)     $rose(data_valid) |-> ##[1:3] req_pending ##2 ack_received;\nendproperty\nassert_p_data_valid_rise_to_req_ack:assert property (p_data_valid_rise_to_req_ack) else $error(\"\");", "task_id": "4_1580", "predict_sva": "@(posedge sys_clk)         $rose(data_valid) |-> ##[1:3] req_pending ##2 ack_received"}
{"id": "7_40_0357", "name": "init_rise_to_clk_stable", "sva": "@(posedge sys_clk)     $rose(init_complete) |-> ##[3:6] clock_stable ##1 !reset_active", "ori_sva": "property init_rise_to_clk_stable;\n@(posedge sys_clk)     $rose(init_complete) |-> ##[3:6] clock_stable ##1 !reset_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_init_rise_to_clk_stable  \n**Trigger Condition**: At every rising edge of the `sys_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(init_complete)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] clock_stable ##1 !reset_active`  ", "sva_signals": ["sys_clk", "[0:0] init_complete", "[0:0] clock_stable", "[0:0] reset_active"], "clock": "sys_clk", "attempts_left": 10, "sva_result": "@(posedge sys_clk)     $rose(init_complete) |-> ##[3:6] clock_stable ##1 !reset_active;", "sva_name": "p_init_complete_clock_stable_reset", "full_property": "property p_init_rise_to_clk_stable;\n@(posedge sys_clk)     $rose(init_complete) |-> ##[3:6] clock_stable ##1 !reset_active;\nendproperty\nassert_p_init_rise_to_clk_stable:assert property (p_init_rise_to_clk_stable) else $error(\"\");", "task_id": "4_1603", "predict_sva": "@(posedge sys_clk)    $rose(init_complete) |-> ##[3:6] clock_stable ##1 !reset_active"}
{"id": "11_35_0522", "name": "bluetooth_pairing_check", "sva": "@(posedge clk_bt)      pairing_req && !bonded |-> ##[5:10] $rose(link_key) ##2 $stable(device_addr)", "ori_sva": "property bluetooth_pairing_check;\n@(posedge clk_bt)      pairing_req && !bonded |-> ##[5:10] $rose(link_key) ##2 $stable(device_addr)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Bluetooth_Pairing_Check  \n**Trigger Condition**: At every rising edge of the `clk_bt`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pairing_req && !bonded`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] $rose(link_key) ##2 $stable(device_addr)`  ", "sva_signals": ["clk_bt", "rst_n", "[0:0] pairing_req", "[0:0] bonded", "[0:0] link_key", "[0:0] device_addr"], "clock": "clk_bt", "attempts_left": 10, "sva_result": "@(posedge clk_bt)         pairing_req && !bonded |-> ##[5:10] $rose(link_key) ##2 $stable(device_addr);", "sva_name": "p_bt_pairing_link_key_and_device_addr_stability", "full_property": "property p_Bluetooth_Pairing_Check;\n@(posedge clk_bt)         pairing_req && !bonded |-> ##[5:10] $rose(link_key) ##2 $stable(device_addr);\nendproperty\nassert_p_Bluetooth_Pairing_Check:assert property (p_Bluetooth_Pairing_Check) else $error(\"\");", "task_id": "4_1768", "predict_sva": "@(posedge clk_bt)         (pairing_req == 1 && bonded == 0) |-> ##[5:10] ($rose(link_key) ##2 $stable(device_addr))"}
{"id": "12_15_0558", "name": "frame_start_or_force_check", "sva": "@(posedge clk_video)      frame_start || force_frame |-> ##[4:8] vertical_sync", "ori_sva": "property frame_start_or_force_check;\n@(posedge clk_video)      frame_start || force_frame |-> ##[4:8] vertical_sync\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Frame_Start_Or_Force_Check  \n**Trigger Condition**: At every rising edge of the `clk_video`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_start || force_frame`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:8] vertical_sync`  ", "sva_signals": ["clk_video", "frame_start", "force_frame", "vertical_sync"], "clock": "clk_video", "attempts_left": 10, "sva_result": "@(posedge clk_video)     (frame_start || force_frame) |-> ##[4:8] vertical_sync;", "sva_name": "p_vertical_sync_after_frame_event", "full_property": "property p_Frame_Start_Or_Force_Check;\n@(posedge clk_video)     (frame_start || force_frame) |-> ##[4:8] vertical_sync;\nendproperty\nassert_p_Frame_Start_Or_Force_Check:assert property (p_Frame_Start_Or_Force_Check) else $error(\"\");", "task_id": "4_1795", "predict_sva": "@(posedge clk_video)         (frame_start == 1 || force_frame == 1) |-> ##[4:8] vertical_sync == 1"}
{"id": "12_38_0587", "name": "overflow_or_force_check", "sva": "@(posedge clk_counter)      counter_overflow || force_overflow |-> ##2 overflow_interrupt", "ori_sva": "property overflow_or_force_check;\n@(posedge clk_counter)      counter_overflow || force_overflow |-> ##2 overflow_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_overflow_or_force_check  \n**Trigger Condition**: At every rising edge of the `clk_counter`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `counter_overflow || force_overflow`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 overflow_interrupt`", "sva_signals": ["clk_counter", "[0:0] counter_overflow", "[0:0] force_overflow", "[0:0] overflow_interrupt"], "clock": "clk_counter", "attempts_left": 10, "sva_result": "@(posedge clk_counter)     (counter_overflow || force_overflow) |-> ##2 overflow_interrupt;", "sva_name": "p_overflow_interrupt_after_overflow", "full_property": "property p_overflow_or_force_check;\n@(posedge clk_counter)     (counter_overflow || force_overflow) |-> ##2 overflow_interrupt;\nendproperty\nassert_p_overflow_or_force_check:assert property (p_overflow_or_force_check) else $error(\"\");", "task_id": "4_1814", "predict_sva": "@(posedge clk_counter)         (counter_overflow == 1 || force_overflow == 1) |-> ##2 overflow_interrupt == 1"}
{"id": "12_40_0594", "name": "complete_or_skip_check", "sva": "@(posedge clk_operation)      operation_complete || skip_operation |-> ##1 next_operation", "ori_sva": "property complete_or_skip_check;\n@(posedge clk_operation)      operation_complete || skip_operation |-> ##1 next_operation\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Complete_Or_Skip_Check  \n**Trigger Condition**: At every rising edge of the `clk_operation`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `operation_complete || skip_operation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 next_operation`", "sva_signals": ["clk", "rst_n", "[0:0] operation_complete", "[0:0] skip_operation", "[0:0] next_operation", "[0:0] clk_operation"], "clock": "clk_operation", "attempts_left": 10, "sva_result": "@(posedge clk_operation)     (operation_complete || skip_operation) |-> ##1 next_operation;", "sva_name": "p_next_operation_on_complete_or_skip", "full_property": "property p_Complete_Or_Skip_Check;\n@(posedge clk_operation)     (operation_complete || skip_operation) |-> ##1 next_operation;\nendproperty\nassert_p_Complete_Or_Skip_Check:assert property (p_Complete_Or_Skip_Check) else $error(\"\");", "task_id": "4_1816", "predict_sva": "@(posedge clk_operation)         (operation_complete == 1 || skip_operation == 1) |-> ##1 next_operation == 1"}
{"id": "13_31_0641", "name": "not_retention_mode_exit", "sva": "@(posedge clk_ret) $rose(!retention_mode) |-> ##3 normal_operation", "ori_sva": "property not_retention_mode_exit;\n@(posedge clk_ret) $rose(!retention_mode) |-> ##3 normal_operation\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_retention_mode_exit  \n**Trigger Condition**: At every rising edge of the `clk_ret`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(!retention_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 normal_operation`  ", "sva_signals": ["clk", "rst_n", "[0:0] retention_mode", "[0:0] normal_operation", "clk_ret"], "clock": "clk_ret", "attempts_left": 10, "sva_result": "@(posedge clk_ret)     $rose(!retention_mode) |-> ##3 normal_operation;", "sva_name": "p_normal_operation_after_retention_release", "full_property": "property p_not_retention_mode_exit;\n@(posedge clk_ret)     $rose(!retention_mode) |-> ##3 normal_operation;\nendproperty\nassert_p_not_retention_mode_exit:assert property (p_not_retention_mode_exit) else $error(\"\");", "task_id": "4_1851", "predict_sva": "@(posedge clk_ret)         $rose(!retention_mode) |-> ##3 normal_operation"}
{"id": "13_36_0647", "name": "not_clock_stop_condition", "sva": "@(posedge clk_stop) !clock_stop_request |-> ##3 clock_running", "ori_sva": "property not_clock_stop_condition;\n@(posedge clk_stop) !clock_stop_request |-> ##3 clock_running\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Clock_Stop_Condition  \n**Trigger Condition**: At every posedge of the `clk_stop`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!clock_stop_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 clock_running`", "sva_signals": ["clk", "rst_n", "[0:0] clock_stop_request", "[0:0] clock_running", "clk_stop"], "clock": "clk_stop", "attempts_left": 10, "sva_result": "@(posedge clk_stop)     !clock_stop_request |-> ##3 clock_running;", "sva_name": "p_clock_running_after_stop_request_deasserted", "full_property": "property p_Not_Clock_Stop_Condition;\n@(posedge clk_stop)     !clock_stop_request |-> ##3 clock_running;\nendproperty\nassert_p_Not_Clock_Stop_Condition:assert property (p_Not_Clock_Stop_Condition) else $error(\"\");", "task_id": "4_1856", "predict_sva": "@(posedge clk_stop)         clock_stop_request == 0 |-> ##3 clock_running == 1"}
{"id": "2_19_0011", "name": "encryption_completion_time", "sva": "@(posedge clk_crypto)      encrypt_start |-> ##[8:16] encrypt_done", "ori_sva": "property encryption_completion_time;\n@(posedge clk_crypto)      encrypt_start |-> ##[8:16] encrypt_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encryption_completion_time  \n**Trigger Condition**: At every rising edge of the clk_crypto  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: encrypt_start  \n**Implication Operator**: |->  \n**Consequent (RHS of Implication)**: ##[8:16] encrypt_done  ", "sva_signals": ["clk_crypto", "[0:0] encrypt_start", "[0:0] encrypt_done"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)         encrypt_start |-> ##[8:16] encrypt_done;", "sva_name": "p_encrypt_done_latency", "full_property": "property p_encryption_completion_time;\n@(posedge clk_crypto)         encrypt_start |-> ##[8:16] encrypt_done;\nendproperty\nassert_p_encryption_completion_time:assert property (p_encryption_completion_time) else $error(\"\");", "task_id": "4_2001", "predict_sva": "@(posedge clk_crypto)         encrypt_start == 1 |-> ##[8:16] encrypt_done == 1"}
{"id": "1_38_0003", "name": "sd_card_init_check", "sva": "@(posedge clk_sd)     sd_init_start |-> ##5 sd_cmd_busy ##50 sd_init_done", "ori_sva": "property sd_card_init_check;\n@(posedge clk_sd)     sd_init_start |-> ##5 sd_cmd_busy ##50 sd_init_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sd_card_init_check  \n**Trigger Condition**: At every rising edge of the `clk_sd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sd_init_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 sd_cmd_busy ##50 sd_init_done`  ", "sva_signals": ["clk_sd", "sd_init_start", "sd_cmd_busy", "sd_init_done"], "clock": "clk_sd", "attempts_left": 10, "sva_result": "@(posedge clk_sd)         sd_init_start == 1'b1 |-> ##5 sd_cmd_busy ##50 sd_init_done;", "sva_name": "p_sd_cmd_busy_and_init_done_sequence", "full_property": "property p_sd_card_init_check;\n@(posedge clk_sd)         sd_init_start == 1'b1 |-> ##5 sd_cmd_busy ##50 sd_init_done;\nendproperty\nassert_p_sd_card_init_check:assert property (p_sd_card_init_check) else $error(\"\");", "task_id": "4_1972", "predict_sva": "@(posedge clk_sd)         sd_init_start == 1'b1 |-> ##5 sd_cmd_busy == 1'b1 ##50 sd_init_done == 1'b1"}
{"id": "2_20_0004", "name": "decryption_completion_time", "sva": "@(posedge clk_crypto)      decrypt_start |-> ##[8:16] decrypt_done", "ori_sva": "property decryption_completion_time;\n@(posedge clk_crypto)      decrypt_start |-> ##[8:16] decrypt_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Decryption_Completion_Time  \n**Trigger Condition**: At every rising edge of the `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `decrypt_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] decrypt_done`  ", "sva_signals": ["clk_crypto", "decrypt_start", "decrypt_done"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)     decrypt_start |-> ##[8:16] decrypt_done;", "sva_name": "p_decrypt_done_latency", "full_property": "property p_Decryption_Completion_Time;\n@(posedge clk_crypto)     decrypt_start |-> ##[8:16] decrypt_done;\nendproperty\nassert_p_Decryption_Completion_Time:assert property (p_Decryption_Completion_Time) else $error(\"\");", "task_id": "4_2003", "predict_sva": "@(posedge clk_crypto)         decrypt_start == 1 |-> ##[8:16] decrypt_done == 1"}
{"id": "2_30_0080", "name": "ethernet_frame_transmit", "sva": "@(posedge clk_eth)      eth_tx_start |-> ##[8:16] eth_tx_done", "ori_sva": "property ethernet_frame_transmit;\n@(posedge clk_eth)      eth_tx_start |-> ##[8:16] eth_tx_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Ethernet_Frame_Transmit  \n**Trigger Condition**: At every rising edge of the `clk_eth`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `eth_tx_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] eth_tx_done == 1'b1`  ", "sva_signals": ["clk_eth", "eth_tx_start", "eth_tx_done"], "clock": "clk_eth", "attempts_left": 10, "sva_result": "@(posedge clk_eth)     eth_tx_start == 1'b1 |-> ##[8:16] eth_tx_done == 1'b1;", "sva_name": "p_eth_tx_done_within_8_to_16_cycles_after_start", "full_property": "property p_Ethernet_Frame_Transmit;\n@(posedge clk_eth)     eth_tx_start == 1'b1 |-> ##[8:16] eth_tx_done == 1'b1;\nendproperty\nassert_p_Ethernet_Frame_Transmit:assert property (p_Ethernet_Frame_Transmit) else $error(\"\");", "task_id": "4_2015", "predict_sva": "@(posedge clk_eth)         eth_tx_start == 1'b1 |-> ##[8:16] eth_tx_done == 1'b1"}
{"id": "2_5_0051", "name": "cache_miss_penalty", "sva": "@(posedge clk_mem)      cache_miss |-> ##[4:12] mem_resp", "ori_sva": "property cache_miss_penalty;\n@(posedge clk_mem)      cache_miss |-> ##[4:12] mem_resp\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_miss_penalty  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_miss == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:12] mem_resp` (memory response occurs between 4 to 12 clock cycles after the cache miss)", "sva_signals": ["clk_mem", "mem_resp", "[0:0] cache_miss"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)     cache_miss == 1'b1 |-> ##[4:12] mem_resp;", "sva_name": "p_cache_miss_mem_resp_window", "full_property": "property p_cache_miss_penalty;\n@(posedge clk_mem)     cache_miss == 1'b1 |-> ##[4:12] mem_resp;\nendproperty\nassert_p_cache_miss_penalty:assert property (p_cache_miss_penalty) else $error(\"\");", "task_id": "4_2037", "predict_sva": "@(posedge clk_mem)         cache_miss == 1'b1 |-> ##[4:12] mem_resp == 1'b1"}
{"id": "3_20_0115", "name": "can_error_with_recovery", "sva": "@(posedge clk_can)      error_frame_detected |-> ##[5:8] recovery_sequence_started ##1 bus_ok_status", "ori_sva": "property can_error_with_recovery;\n@(posedge clk_can)      error_frame_detected |-> ##[5:8] recovery_sequence_started ##1 bus_ok_status\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_error_with_recovery  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_frame_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:8] recovery_sequence_started ##1 bus_ok_status`  ", "sva_signals": ["clk_can", "rst_n", "[0:0] error_frame_detected", "[0:0] recovery_sequence_started", "[0:0] bus_ok_status"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     error_frame_detected |-> ##[5:8] recovery_sequence_started ##1 bus_ok_status;", "sva_name": "p_recovery_sequence_after_error_frame", "full_property": "property p_can_error_with_recovery;\n@(posedge clk_can)     error_frame_detected |-> ##[5:8] recovery_sequence_started ##1 bus_ok_status;\nendproperty\nassert_p_can_error_with_recovery:assert property (p_can_error_with_recovery) else $error(\"\");", "task_id": "4_2052", "predict_sva": "@(posedge clk_can)         error_frame_detected == 1 |-> ##[5:8] recovery_sequence_started == 1 ##1 bus_ok_status == 1"}
{"id": "3_21_0137", "name": "adc_conversion_with_ready", "sva": "@(posedge clk_adc)      conversion_started |-> ##[8:12] data_ready_flag ##1 result_valid", "ori_sva": "property adc_conversion_with_ready;\n@(posedge clk_adc)      conversion_started |-> ##[8:12] data_ready_flag ##1 result_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_adc_conversion_with_ready  \n**Trigger Condition**: At every rising edge of the `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `conversion_started`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:12] data_ready_flag ##1 result_valid`  \n\n**Explanation of Consequent**:  \n- After the antecedent (`conversion_started`) is true, the assertion checks that:  \n  1. `data_ready_flag` becomes true within **8 to 12 clock cycles** (`##[8:12]`), and  \n  2. In the **immediately following clock cycle** (`##1`), `result_valid` becomes true.  \n\nThis ensures that the ADC conversion completes with valid data within the specified latency window after the conversion starts.", "sva_signals": ["clk_adc", "[0:0] conversion_started", "[0:0] data_ready_flag", "[0:0] result_valid"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     conversion_started |-> ##[8:12] data_ready_flag ##1 result_valid;", "sva_name": "p_conversion_data_ready_result_valid", "full_property": "property p_adc_conversion_with_ready;\n@(posedge clk_adc)     conversion_started |-> ##[8:12] data_ready_flag ##1 result_valid;\nendproperty\nassert_p_adc_conversion_with_ready:assert property (p_adc_conversion_with_ready) else $error(\"\");", "task_id": "4_2053", "predict_sva": "@(posedge clk_adc)         conversion_started |-> ##[8:12] data_ready_flag ##1 result_valid"}
{"id": "3_8_0092", "name": "packet_start_with_crc_check", "sva": "@(posedge clk_net)      packet_start_indicator |-> ##[2:5] crc_check_enabled ##1 header_valid", "ori_sva": "property packet_start_with_crc_check;\n@(posedge clk_net)      packet_start_indicator |-> ##[2:5] crc_check_enabled ##1 header_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_packet_start_with_crc_check  \n**Trigger Condition**: At every rising edge of the `clk_net`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `packet_start_indicator == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] crc_check_enabled ##1 header_valid`  \n", "sva_signals": ["clk", "rst_n", "[0:0] packet_start_indicator", "[0:0] crc_check_enabled", "[0:0] header_valid", "clk_net"], "clock": "clk_net", "attempts_left": 10, "sva_result": "@(posedge clk_net)     packet_start_indicator == 1'b1 |-> ##[2:5] crc_check_enabled ##1 header_valid;", "sva_name": "p_packet_start_crc_header_sequence", "full_property": "property p_packet_start_with_crc_check;\n@(posedge clk_net)     packet_start_indicator == 1'b1 |-> ##[2:5] crc_check_enabled ##1 header_valid;\nendproperty\nassert_p_packet_start_with_crc_check:assert property (p_packet_start_with_crc_check) else $error(\"\");", "task_id": "4_2087", "predict_sva": "@(posedge clk_net)         packet_start_indicator == 1'b1 |-> ##[2:5] crc_check_enabled == 1'b1 ##1 header_valid == 1'b1"}
{"id": "6_27_0284", "name": "gpio_debounce_period_27", "sva": "@(posedge clk_gpio)     gpio_in_changed |-> gpio_in_stable[*10:50] ##1 gpio_out_updated", "ori_sva": "property gpio_debounce_period_27;\n@(posedge clk_gpio)     gpio_in_changed |-> gpio_in_stable[*10:50] ##1 gpio_out_updated\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gpio_debounce_period_27  \n**Trigger Condition**: At every rising edge of the `clk_gpio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gpio_in_changed`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `gpio_in_stable[*10:50] ##1 gpio_out_updated`  ", "sva_signals": ["clk_gpio", "rst_n", "[0:0] gpio_in_changed", "[0:0] gpio_in_stable", "[0:0] gpio_out_updated"], "clock": "clk_gpio", "attempts_left": 10, "sva_result": "@(posedge clk_gpio)     gpio_in_changed |-> gpio_in_stable[*10:50] ##1 gpio_out_updated;", "sva_name": "p_gpio_in_stable_duration_and_out_update", "full_property": "property p_gpio_debounce_period_27;\n@(posedge clk_gpio)     gpio_in_changed |-> gpio_in_stable[*10:50] ##1 gpio_out_updated;\nendproperty\nassert_p_gpio_debounce_period_27:assert property (p_gpio_debounce_period_27) else $error(\"\");", "task_id": "4_2193", "predict_sva": "@(posedge clk_gpio)         gpio_in_changed == 1 |-> (gpio_in_stable [*10:50]) ##1 gpio_out_updated == 1"}
{"id": "10_17_0482", "name": "packet_sync_past_5cyc", "sva": "@(posedge clk_rx) disable iff (!link_up)     $past(sync_header,5) == 8'hA5 |-> ##2 $past(payload_start,3)", "ori_sva": "property packet_sync_past_5cyc;\n@(posedge clk_rx) disable iff (!link_up)     $past(sync_header,5) == 8'hA5 |-> ##2 $past(payload_start,3)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Sync_Past_5cyc  \n**Trigger Condition**: At every rising edge of the `clk_rx`  \n**Disable Condition**: disable iff (`!link_up`)  \n**Antecedent (LHS of Implication)**: `$past(sync_header, 5) == 8'hA5`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 $past(payload_start, 3)`  ", "sva_signals": ["clk_rx", "link_up", "[7:0] sync_header", "[0:0] payload_start"], "clock": "clk_rx", "attempts_left": 10, "sva_result": "@(posedge clk_rx) disable iff (!link_up)     $past(sync_header, 5) == 8'hA5 |-> ##2 $past(payload_start, 3);", "sva_name": "p_sync_header_payload_start_relation", "full_property": "property p_Packet_Sync_Past_5cyc;\n@(posedge clk_rx) disable iff (!link_up)     $past(sync_header, 5) == 8'hA5 |-> ##2 $past(payload_start, 3);\nendproperty\nassert_p_Packet_Sync_Past_5cyc:assert property (p_Packet_Sync_Past_5cyc) else $error(\"\");", "task_id": "4_2351", "predict_sva": "@(posedge clk_rx) disable iff (!link_up)         (link_up == 1 && $past(sync_header, 5) == 8'hA5) |-> ##2 ($past(payload_start, 3) == 1)"}
{"id": "10_30_0477", "name": "packet_filter_past_5cyc", "sva": "@(posedge clk_net) disable iff (filter_bypass)     $past(filter_enable,5) && $past(packet_type,5) == 8'hFF |-> ##1 $rose(drop_packet)", "ori_sva": "property packet_filter_past_5cyc;\n@(posedge clk_net) disable iff (filter_bypass)     $past(filter_enable,5) && $past(packet_type,5) == 8'hFF |-> ##1 $rose(drop_packet)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Packet_Filter_Past_5cyc  \n**Trigger Condition**: At every rising edge of the `clk_net`  \n**Disable Condition**: disable iff (`filter_bypass`)  \n**Antecedent (LHS of Implication)**: `$past(filter_enable, 5) && $past(packet_type, 5) == 8'hFF`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $rose(drop_packet)`", "sva_signals": ["clk", "filter_bypass", "filter_enable", "[7:0] packet_type", "drop_packet", "clk_net"], "clock": "clk_net", "attempts_left": 10, "sva_result": "@(posedge clk_net) disable iff (filter_bypass)         ($past(filter_enable, 5) && $past(packet_type, 5) == 8'hFF) |-> ##1 $rose(drop_packet);", "sva_name": "p_drop_packet_after_filter_enable_and_packet_type", "full_property": "property p_Packet_Filter_Past_5cyc;\n@(posedge clk_net) disable iff (filter_bypass)         ($past(filter_enable, 5) && $past(packet_type, 5) == 8'hFF) |-> ##1 $rose(drop_packet);\nendproperty\nassert_p_Packet_Filter_Past_5cyc:assert property (p_Packet_Filter_Past_5cyc) else $error(\"\");", "task_id": "4_2361", "predict_sva": "@(posedge clk_net) disable iff (filter_bypass)         (filter_bypass == 0 && $past(filter_enable, 5) == 1 && $past(packet_type, 5) == 8'hFF) |-> ##1 $rose(drop_packet)"}
{"id": "12_42_0592", "name": "usb_phy_or_reset_check", "sva": "@(posedge clk_usb_phy)     phy_ready || phy_reset |-> ##0 $isunknown(usb_data)", "ori_sva": "property usb_phy_or_reset_check;\n@(posedge clk_usb_phy)     phy_ready || phy_reset |-> ##0 $isunknown(usb_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_USB_PHY_OR_RESET_CHECK  \n**Trigger Condition**: At every rising edge of the `clk_usb_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `phy_ready || phy_reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##0 $isunknown(usb_data)`  ", "sva_signals": ["clk_usb_phy", "phy_ready", "phy_reset", "usb_data"], "clock": "clk_usb_phy", "attempts_left": 10, "sva_result": "@(posedge clk_usb_phy)     (phy_ready || phy_reset) |-> ##0 $isunknown(usb_data);", "sva_name": "p_usb_data_unknown_on_phy_ready_or_reset", "full_property": "property p_USB_PHY_OR_RESET_CHECK;\n@(posedge clk_usb_phy)     (phy_ready || phy_reset) |-> ##0 $isunknown(usb_data);\nendproperty\nassert_p_USB_PHY_OR_RESET_CHECK:assert property (p_USB_PHY_OR_RESET_CHECK) else $error(\"\");", "task_id": "4_2413", "predict_sva": "@(posedge clk_usb_phy)         (phy_ready == 1 || phy_reset == 1) |-> (usb_data !== 'x && usb_data !== 'z)"}
{"id": "12_46_0607", "name": "flash_busy_or_error_check", "sva": "@(posedge clk_flash_ctrl)     flash_busy || flash_error |-> ##1 $rose(flash_reset)", "ori_sva": "property flash_busy_or_error_check;\n@(posedge clk_flash_ctrl)     flash_busy || flash_error |-> ##1 $rose(flash_reset)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_flash_busy_or_error_check  \n**Trigger Condition**: At every rising edge of the `clk_flash_ctrl`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `flash_busy || flash_error`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $rose(flash_reset)`", "sva_signals": ["clk", "[0:0] flash_busy", "[0:0] flash_error", "[0:0] flash_reset", "clk_flash_ctrl"], "clock": "clk_flash_ctrl", "attempts_left": 10, "sva_result": "@(posedge clk_flash_ctrl)         (flash_busy || flash_error) |-> ##1 $rose(flash_reset);", "sva_name": "p_flash_reset_on_busy_or_error", "full_property": "property p_flash_busy_or_error_check;\n@(posedge clk_flash_ctrl)         (flash_busy || flash_error) |-> ##1 $rose(flash_reset);\nendproperty\nassert_p_flash_busy_or_error_check:assert property (p_flash_busy_or_error_check) else $error(\"\");", "task_id": "4_2417", "predict_sva": "@(posedge clk_flash_ctrl)         (flash_busy == 1 || flash_error == 1) |-> ##1 $rose(flash_reset)"}
{"id": "15_18_0731", "name": "usb_phy_resume_detection_check", "sva": "@(posedge usb_phy_clk) disable iff(!usb_phy_reset_n)     resume_detected |-> ##[2:5] host_wakeup", "ori_sva": "property usb_phy_resume_detection_check;\n@(posedge usb_phy_clk) disable iff(!usb_phy_reset_n)     resume_detected |-> ##[2:5] host_wakeup\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_usb_phy_resume_detection_check  \n**Trigger Condition**: At every rising edge of the `usb_phy_clk`  \n**Disable Condition**: disable iff `(!usb_phy_reset_n)`  \n**Antecedent (LHS of Implication)**: `resume_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] host_wakeup`  ", "sva_signals": ["usb_phy_clk", "usb_phy_reset_n", "[0:0] resume_detected", "[0:0] host_wakeup"], "clock": "usb_phy_clk", "attempts_left": 10, "sva_result": "@(posedge usb_phy_clk) disable iff (!usb_phy_reset_n)         resume_detected |-> ##[2:5] host_wakeup;", "sva_name": "p_host_wakeup_after_resume_detected", "full_property": "property p_usb_phy_resume_detection_check;\n@(posedge usb_phy_clk) disable iff (!usb_phy_reset_n)         resume_detected |-> ##[2:5] host_wakeup;\nendproperty\nassert_p_usb_phy_resume_detection_check:assert property (p_usb_phy_resume_detection_check) else $error(\"\");", "task_id": "4_2488", "predict_sva": "@(posedge usb_phy_clk) disable iff (!usb_phy_reset_n)         (usb_phy_reset_n == 1 && resume_detected == 1) |-> ##[2:5] host_wakeup == 1"}
{"id": "1_33_0014", "name": "usb_packet_check", "sva": "@(posedge clk_usb)     usb_pkt_start |-> ##6 usb_pkt_end", "ori_sva": "property usb_packet_check;\n@(posedge clk_usb)     usb_pkt_start |-> ##6 usb_pkt_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_usb_packet_check  \n**Trigger Condition**: At every rising edge of the `clk_usb`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `usb_pkt_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 usb_pkt_end == 1'b1`  \n\n", "sva_signals": ["clk_usb", "usb_pkt_start", "usb_pkt_end"], "clock": "clk_usb", "attempts_left": 10, "sva_result": "@(posedge clk_usb)     usb_pkt_start == 1'b1 |-> ##6 usb_pkt_end == 1'b1;", "sva_name": "p_usb_pkt_end_after_start_6cycles", "full_property": "property p_usb_packet_check;\n@(posedge clk_usb)     usb_pkt_start == 1'b1 |-> ##6 usb_pkt_end == 1'b1;\nendproperty\nassert_p_usb_packet_check:assert property (p_usb_packet_check) else $error(\"\");", "task_id": "4_2552", "predict_sva": "@(posedge clk_usb)         usb_pkt_start == 1'b1 |-> ##6 usb_pkt_end == 1'b1"}
{"id": "1_41_0072", "name": "timer_expire_check", "sva": "@(posedge clk_timer)     timer_en |-> ##6 timer_int", "ori_sva": "property timer_expire_check;\n@(posedge clk_timer)     timer_en |-> ##6 timer_int\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Timer_Expire_Check  \n**Trigger Condition**: At every posedge of the `clk_timer`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timer_en == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##6 timer_int == 1'b1`  \n\n(Note: The consequent checks that `timer_int` is asserted 6 clock cycles after the antecedent condition is met.)", "sva_signals": ["clk_timer", "timer_en", "timer_int"], "clock": "clk_timer", "attempts_left": 10, "sva_result": "@(posedge clk_timer)     timer_en == 1'b1 |-> ##6 timer_int == 1'b1;", "sva_name": "p_timer_int_after_timer_en_6cycles", "full_property": "property p_Timer_Expire_Check;\n@(posedge clk_timer)     timer_en == 1'b1 |-> ##6 timer_int == 1'b1;\nendproperty\nassert_p_Timer_Expire_Check:assert property (p_Timer_Expire_Check) else $error(\"\");", "task_id": "4_2561", "predict_sva": "@(posedge clk_timer)         timer_en == 1'b1 |-> ##6 timer_int == 1'b1"}
{"id": "2_11_0053", "name": "ddr_init_check_11", "sva": "@(posedge clk_ddr)      ddr_init_start |-> ##[16:128] ddr_init_done", "ori_sva": "property ddr_init_check_11;\n@(posedge clk_ddr)      ddr_init_start |-> ##[16:128] ddr_init_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ddr_init_check_11  \n**Trigger Condition**: At every rising edge of the `clk_ddr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `ddr_init_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:128] ddr_init_done == 1'b1`  \n\n", "sva_signals": ["clk_ddr", "rst_n", "[0:0] ddr_init_start", "[0:0] ddr_init_done"], "clock": "clk_ddr", "attempts_left": 10, "sva_result": "@(posedge clk_ddr)     ddr_init_start == 1'b1 |-> ##[16:128] ddr_init_done == 1'b1;", "sva_name": "p_ddr_init_done_within_16_128_cycles", "full_property": "property p_ddr_init_check_11;\n@(posedge clk_ddr)     ddr_init_start == 1'b1 |-> ##[16:128] ddr_init_done == 1'b1;\nendproperty\nassert_p_ddr_init_check_11:assert property (p_ddr_init_check_11) else $error(\"\");", "task_id": "4_2576", "predict_sva": "@(posedge clk_ddr)         ddr_init_start == 1'b1 |-> ##[16:128] ddr_init_done == 1'b1"}
{"id": "2_12_0019", "name": "pcie_link_check_12", "sva": "@(posedge clk_pcie)      link_training_start |-> ##[8:32] link_training_complete", "ori_sva": "property pcie_link_check_12;\n@(posedge clk_pcie)      link_training_start |-> ##[8:32] link_training_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pcie_link_check_12  \n**Trigger Condition**: At every rising edge of `clk_pcie`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `link_training_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:32] link_training_complete == 1'b1`  ", "sva_signals": ["clk_pcie", "[0:0] link_training_start", "[0:0] link_training_complete"], "clock": "clk_pcie", "attempts_left": 10, "sva_result": "@(posedge clk_pcie)         link_training_start == 1'b1 |-> ##[8:32] link_training_complete == 1'b1;", "sva_name": "p_link_training_completion_within_8_to_32_cycles", "full_property": "property pcie_link_check_12;\n@(posedge clk_pcie)         link_training_start == 1'b1 |-> ##[8:32] link_training_complete == 1'b1;\nendproperty\nassert_pcie_link_check_12:assert property (pcie_link_check_12) else $error(\"\");", "task_id": "4_2577", "predict_sva": "@(posedge clk_pcie)         link_training_start == 1'b1 |-> ##[8:32] link_training_complete == 1'b1"}
{"id": "2_45_0093", "name": "satellite_lock_check_45", "sva": "@(posedge clk_sat)      acquisition_start |-> ##[128:256] lock_achieved", "ori_sva": "property satellite_lock_check_45;\n@(posedge clk_sat)      acquisition_start |-> ##[128:256] lock_achieved\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_satellite_lock_check_45  \n**Trigger Condition**: At every rising edge of the `clk_sat`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `acquisition_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[128:256] lock_achieved`  \n\n", "sva_signals": ["clk_sat", "[0:0] acquisition_start", "[0:0] lock_achieved"], "clock": "clk_sat", "attempts_left": 10, "sva_result": "@(posedge clk_sat)     acquisition_start |-> ##[128:256] lock_achieved;", "sva_name": "p_lock_achieved_within_128_256_cycles_after_acquisition_start", "full_property": "property p_satellite_lock_check_45;\n@(posedge clk_sat)     acquisition_start |-> ##[128:256] lock_achieved;\nendproperty\nassert_p_satellite_lock_check_45:assert property (p_satellite_lock_check_45) else $error(\"\");", "task_id": "4_2613", "predict_sva": "@(posedge clk_sat)         acquisition_start == 1 |-> ##[128:256] lock_achieved == 1"}
{"id": "3_33_0152", "name": "jtag_tap_state_check", "sva": "@(posedge clk_jtag)     (tms_sequence_start && !reset_b) |-> ##5 state_capture", "ori_sva": "property jtag_tap_state_check;\n@(posedge clk_jtag)     (tms_sequence_start && !reset_b) |-> ##5 state_capture\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Jtag_Tap_State_Check  \n**Trigger Condition**: At every rising edge of the `clk_jtag`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tms_sequence_start && !reset_b`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 state_capture`", "sva_signals": ["clk_jtag", "reset_b", "[0:0] tms_sequence_start", "state_capture"], "clock": "clk_jtag", "attempts_left": 10, "sva_result": "@(posedge clk_jtag)     (tms_sequence_start && !reset_b) |-> ##5 state_capture;", "sva_name": "p_state_capture_after_tms_sequence_start", "full_property": "property p_Jtag_Tap_State_Check;\n@(posedge clk_jtag)     (tms_sequence_start && !reset_b) |-> ##5 state_capture;\nendproperty\nassert_p_Jtag_Tap_State_Check:assert property (p_Jtag_Tap_State_Check) else $error(\"\");", "task_id": "4_2643", "predict_sva": "@(posedge clk_jtag)         (tms_sequence_start == 1 && reset_b == 0) |-> ##5 (state_capture == 1)"}
{"id": "3_48_0144", "name": "infrared_protocol_check", "sva": "@(posedge clk_ir)     (start_bit_detected && !repeat_mode) |-> ##[8:16] command_complete", "ori_sva": "property infrared_protocol_check;\n@(posedge clk_ir)     (start_bit_detected && !repeat_mode) |-> ##[8:16] command_complete\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_infrared_protocol_check  \n**Trigger Condition**: At every rising edge of the `clk_ir`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `start_bit_detected && !repeat_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:16] command_complete`  ", "sva_signals": ["clk", "rst_n", "[0:0] start_bit_detected", "[0:0] repeat_mode", "[0:0] command_complete", "clk_ir"], "clock": "clk_ir", "attempts_left": 10, "sva_result": "@(posedge clk_ir)     (start_bit_detected && !repeat_mode) |-> ##[8:16] command_complete;", "sva_name": "p_command_complete_within_8_to_16_cycles_after_start", "full_property": "property p_infrared_protocol_check;\n@(posedge clk_ir)     (start_bit_detected && !repeat_mode) |-> ##[8:16] command_complete;\nendproperty\nassert_p_infrared_protocol_check:assert property (p_infrared_protocol_check) else $error(\"\");", "task_id": "4_2658", "predict_sva": "@(posedge clk_ir)         (start_bit_detected == 1 && repeat_mode == 0) |-> ##[8:16] (command_complete == 1)"}
{"id": "5_27_0231", "name": "fan_control_monitor_27", "sva": "@(posedge clk_pwm)      (temp_rise[*4] ##1 !fan_stuck) |-> pwm_increase[*3]", "ori_sva": "property fan_control_monitor_27;\n@(posedge clk_pwm)      (temp_rise[*4] ##1 !fan_stuck) |-> pwm_increase[*3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fan_control_monitor_27  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_rise` occurs consecutively for 4 clock cycles followed by `!fan_stuck` in the next cycle  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `pwm_increase` occurs consecutively for 3 clock cycles starting from the same cycle as the consequent trigger", "sva_signals": ["clk_pwm", "fan_stuck", "[0:0] temp_rise", "[0:0] pwm_increase"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)     (temp_rise [*4] ##1 !fan_stuck) |-> (pwm_increase [*3]);", "sva_name": "p_pwm_increase_after_temp_rise_and_fan_unstuck", "full_property": "property p_fan_control_monitor_27;\n@(posedge clk_pwm)     (temp_rise [*4] ##1 !fan_stuck) |-> (pwm_increase [*3]);\nendproperty\nassert_p_fan_control_monitor_27:assert property (p_fan_control_monitor_27) else $error(\"\");", "task_id": "4_2725", "predict_sva": "@(posedge clk_pwm)         (temp_rise [*4]) ##1 (!fan_stuck) |-> (pwm_increase [*3])"}
{"id": "5_28_0227", "name": "encryption_flow_28", "sva": "@(posedge clk_crypto)      (data_in_valid[*3] ##1 !key_ready) |-> cipher_text_valid[*2]", "ori_sva": "property encryption_flow_28;\n@(posedge clk_crypto)      (data_in_valid[*3] ##1 !key_ready) |-> cipher_text_valid[*2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encryption_flow_28  \n**Trigger Condition**: At every rising edge of the `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `data_in_valid` is high for 3 consecutive cycles (`[*3]`), followed by `!key_ready` in the next cycle (`##1 !key_ready`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `cipher_text_valid` is high for 2 consecutive cycles (`[*2]`)", "sva_signals": ["clk_crypto", "rst_n", "[0:0] data_in_valid", "[0:0] key_ready", "[0:0] cipher_text_valid"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)         (data_in_valid[*3] ##1 !key_ready) |-> cipher_text_valid[*2];", "sva_name": "p_cipher_text_valid_after_data_in_valid_and_key_not_ready", "full_property": "property p_encryption_flow_28;\n@(posedge clk_crypto)         (data_in_valid[*3] ##1 !key_ready) |-> cipher_text_valid[*2];\nendproperty\nassert_p_encryption_flow_28:assert property (p_encryption_flow_28) else $error(\"\");", "task_id": "4_2726", "predict_sva": "@(posedge clk_crypto)         (data_in_valid [*3] ##1 !key_ready) |-> (cipher_text_valid [*2])"}
{"id": "5_32_0220", "name": "pipeline_stall_check_32", "sva": "@(posedge clk_cpu)      (stall_condition[*4] ##1 !flush) |-> bubble_insert[*3]", "ori_sva": "property pipeline_stall_check_32;\n@(posedge clk_cpu)      (stall_condition[*4] ##1 !flush) |-> bubble_insert[*3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Pipeline_Stall_Check_32  \n**Trigger Condition**: At every rising edge of the `clk_cpu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `stall_condition` holds true for 4 consecutive cycles (`[*4]`), followed by `!flush` in the next cycle (`##1 !flush`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `bubble_insert` holds true for 3 consecutive cycles (`[*3]`)  ", "sva_signals": ["clk_cpu", "[0:0] stall_condition", "[0:0] flush", "[0:0] bubble_insert"], "clock": "clk_cpu", "attempts_left": 10, "sva_result": "@(posedge clk_cpu)     stall_condition[*4] ##1 !flush |-> bubble_insert[*3];", "sva_name": "p_bubble_insert_after_stall_and_flush", "full_property": "property p_Pipeline_Stall_Check_32;\n@(posedge clk_cpu)     stall_condition[*4] ##1 !flush |-> bubble_insert[*3];\nendproperty\nassert_p_Pipeline_Stall_Check_32:assert property (p_Pipeline_Stall_Check_32) else $error(\"\");", "task_id": "4_2729", "predict_sva": "@(posedge clk_cpu)         (stall_condition [*4]) ##1 (!flush) |-> (bubble_insert [*3])"}
{"id": "5_35_0232", "name": "memory_refresh_35", "sva": "@(posedge clk_dram)      refresh_req[*5] |-> refresh_ack[*2]", "ori_sva": "property memory_refresh_35;\n@(posedge clk_dram)      refresh_req[*5] |-> refresh_ack[*2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_refresh_35  \n**Trigger Condition**: At every rising edge of the `clk_dram`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `refresh_req` occurs consecutively for 5 clock cycles (`refresh_req[*5]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `refresh_ack` occurs consecutively for 2 clock cycles (`refresh_ack[*2]`)  ", "sva_signals": ["clk_dram", "refresh_req", "refresh_ack"], "clock": "clk_dram", "attempts_left": 10, "sva_result": "@(posedge clk_dram)     refresh_req[*5] |-> refresh_ack[*2];", "sva_name": "p_refresh_req_ack_sequence", "full_property": "property p_memory_refresh_35;\n@(posedge clk_dram)     refresh_req[*5] |-> refresh_ack[*2];\nendproperty\nassert_p_memory_refresh_35:assert property (p_memory_refresh_35) else $error(\"\");", "task_id": "4_2732", "predict_sva": "@(posedge clk_dram)         refresh_req [*5] |-> refresh_ack [*2]"}
{"id": "5_38_0238", "name": "power_good_check_38", "sva": "@(posedge clk_pgood)      (power_up[*3] ##1 !fault_detected) |-> all_rails_good[*2]", "ori_sva": "property power_good_check_38;\n@(posedge clk_pgood)      (power_up[*3] ##1 !fault_detected) |-> all_rails_good[*2]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_good_check_38  \n**Trigger Condition**: At every rising edge of the `clk_pgood`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_up` is high for 3 consecutive cycles, followed by `!fault_detected` in the next cycle (`power_up[*3] ##1 !fault_detected`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `all_rails_good` remains high for 2 consecutive cycles (`all_rails_good[*2]`)", "sva_signals": ["clk_pgood", "[0:0] power_up", "[0:0] fault_detected", "[0:0] all_rails_good"], "clock": "clk_pgood", "attempts_left": 10, "sva_result": "@(posedge clk_pgood)     power_up[*3] ##1 !fault_detected |-> all_rails_good[*2];", "sva_name": "p_all_rails_good_after_powerup_no_fault", "full_property": "property p_power_good_check_38;\n@(posedge clk_pgood)     power_up[*3] ##1 !fault_detected |-> all_rails_good[*2];\nendproperty\nassert_p_power_good_check_38:assert property (p_power_good_check_38) else $error(\"\");", "task_id": "4_2735", "predict_sva": "@(posedge clk_pgood)         (power_up [*3] ##1 !fault_detected) |-> (all_rails_good [*2])"}
{"id": "8_10_0362", "name": "can_tx_fall_ack_check", "sva": "@(posedge clk_can)      $fell(can_tx_enable) |-> ##[2:4] can_tx_ack && (can_tx_id == $past(can_tx_id,3))", "ori_sva": "property can_tx_fall_ack_check;\n@(posedge clk_can)      $fell(can_tx_enable) |-> ##[2:4] can_tx_ack && (can_tx_id == $past(can_tx_id,3))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_tx_fall_ack_check  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(can_tx_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] can_tx_ack && (can_tx_id == $past(can_tx_id, 3))`  ", "sva_signals": ["clk_can", "can_tx_enable", "can_tx_ack", "can_tx_id"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     $fell(can_tx_enable) |-> ##[2:4] (can_tx_ack && (can_tx_id == $past(can_tx_id, 3)));", "sva_name": "p_can_tx_ack_and_id_match_after_enable_fall", "full_property": "property p_can_tx_fall_ack_check;\n@(posedge clk_can)     $fell(can_tx_enable) |-> ##[2:4] (can_tx_ack && (can_tx_id == $past(can_tx_id, 3)));\nendproperty\nassert_p_can_tx_fall_ack_check:assert property (p_can_tx_fall_ack_check) else $error(\"\");", "task_id": "4_2834", "predict_sva": "@(posedge clk_can)         $fell(can_tx_enable) |-> ##[2:4] (can_tx_ack && (can_tx_id == $past(can_tx_id, 3)))"}
{"id": "8_50_0418", "name": "tof_int_fall_distance", "sva": "@(negedge clk_tof)      $fell(tof_int) |-> ##3 (tof_distance > $past(tof_threshold,2)) && tof_valid", "ori_sva": "property tof_int_fall_distance;\n@(negedge clk_tof)      $fell(tof_int) |-> ##3 (tof_distance > $past(tof_threshold,2)) && tof_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Tof_Int_Fall_Distance  \n**Trigger Condition**: At every falling edge of the `clk_tof`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(tof_int)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 (tof_distance > $past(tof_threshold, 2)) && tof_valid`", "sva_signals": ["clk_tof", "tof_int", "[0:0] tof_distance", "[0:0] tof_threshold", "[0:0] tof_valid"], "clock": "clk_tof", "attempts_left": 10, "sva_result": "@(negedge clk_tof)     $fell(tof_int) |-> ##3 (tof_distance > $past(tof_threshold, 2)) && tof_valid;", "sva_name": "p_tof_distance_threshold_valid_after_fall", "full_property": "property p_Tof_Int_Fall_Distance;\n@(negedge clk_tof)     $fell(tof_int) |-> ##3 (tof_distance > $past(tof_threshold, 2)) && tof_valid;\nendproperty\nassert_p_Tof_Int_Fall_Distance:assert property (p_Tof_Int_Fall_Distance) else $error(\"\");", "task_id": "4_2872", "predict_sva": "@(negedge clk_tof)     $fell(tof_int) |-> ##3 (tof_distance > $past(tof_threshold, 2) && tof_valid)"}
{"id": "10_39_0499", "name": "delayed_can_bus_ack", "sva": "@(posedge clk_can)      $past(frame_sent,2) |-> $past(ack_received,5) || $past(error_flag,3)", "ori_sva": "property delayed_can_bus_ack;\n@(posedge clk_can)      $past(frame_sent,2) |-> $past(ack_received,5) || $past(error_flag,3)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Delayed_Can_Bus_Ack  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(frame_sent, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ack_received, 5) || $past(error_flag, 3)`  ", "sva_signals": ["clk_can", "[0:0] frame_sent", "[0:0] ack_received", "[0:0] error_flag"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     $past(frame_sent, 2) |-> ($past(ack_received, 5) || $past(error_flag, 3));", "sva_name": "p_frame_sent_ack_or_error", "full_property": "property p_Delayed_Can_Bus_Ack;\n@(posedge clk_can)     $past(frame_sent, 2) |-> ($past(ack_received, 5) || $past(error_flag, 3));\nendproperty\nassert_p_Delayed_Can_Bus_Ack:assert property (p_Delayed_Can_Bus_Ack) else $error(\"\");", "task_id": "4_2952", "predict_sva": "@(posedge clk_can)         $past(frame_sent, 2) |-> ($past(ack_received, 5) || $past(error_flag, 3))"}
{"id": "11_19_0555", "name": "voltage_monitor_check_19", "sva": "@(posedge clk_vmon)     vcc_low && !vcc_bypass |-> ##1 power_warning", "ori_sva": "property voltage_monitor_check_19;\n@(posedge clk_vmon)     vcc_low && !vcc_bypass |-> ##1 power_warning\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Voltage_Monitor_Check_19  \n**Trigger Condition**: At every rising edge of the `clk_vmon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vcc_low && !vcc_bypass`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 power_warning`", "sva_signals": ["clk", "rst_n", "[0:0] vcc_low", "[0:0] vcc_bypass", "[0:0] power_warning", "clk_vmon"], "clock": "clk_vmon", "attempts_left": 10, "sva_result": "@(posedge clk_vmon)     (vcc_low && !vcc_bypass) |-> ##1 power_warning;", "sva_name": "p_power_warning_on_vcc_low_no_bypass", "full_property": "property p_Voltage_Monitor_Check_19;\n@(posedge clk_vmon)     (vcc_low && !vcc_bypass) |-> ##1 power_warning;\nendproperty\nassert_p_Voltage_Monitor_Check_19:assert property (p_Voltage_Monitor_Check_19) else $error(\"\");", "task_id": "4_2978", "predict_sva": "@(posedge clk_vmon)         (vcc_low == 1 && vcc_bypass == 0) |-> ##1 (power_warning == 1)"}
{"id": "11_30_0546", "name": "ethernet_crc_check_30", "sva": "@(posedge clk_eth)     frame_valid && !crc_error |-> ##1 crc_ok", "ori_sva": "property ethernet_crc_check_30;\n@(posedge clk_eth)     frame_valid && !crc_error |-> ##1 crc_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ethernet_crc_check_30  \n**Trigger Condition**: At every rising edge of the `clk_eth`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_valid && !crc_error`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 crc_ok`", "sva_signals": ["clk_eth", "rst_n", "[0:0] frame_valid", "[0:0] crc_error", "[0:0] crc_ok"], "clock": "clk_eth", "attempts_left": 10, "sva_result": "@(posedge clk_eth)     (frame_valid && !crc_error) |-> ##1 crc_ok;", "sva_name": "p_crc_ok_on_valid_frame_no_crc_error", "full_property": "property p_ethernet_crc_check_30;\n@(posedge clk_eth)     (frame_valid && !crc_error) |-> ##1 crc_ok;\nendproperty\nassert_p_ethernet_crc_check_30:assert property (p_ethernet_crc_check_30) else $error(\"\");", "task_id": "4_2990", "predict_sva": "@(posedge clk_eth)         (frame_valid == 1 && crc_error == 0) |-> ##1 (crc_ok == 1)"}
{"id": "11_31_0540", "name": "spi_transfer_check_31", "sva": "@(posedge clk_spi)     cs_active && sck_rising |-> ##8 $stable(mosi_data)", "ori_sva": "property spi_transfer_check_31;\n@(posedge clk_spi)     cs_active && sck_rising |-> ##8 $stable(mosi_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_transfer_check_31  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cs_active && sck_rising`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 $stable(mosi_data)`  ", "sva_signals": ["clk", "rst_n", "[0:0] cs_active", "[0:0] sck_rising", "[7:0] mosi_data", "clk_spi"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi)     (cs_active && sck_rising) |-> ##8 $stable(mosi_data);", "sva_name": "p_mosi_data_stable_after_cs_active_and_sck_rising", "full_property": "property p_spi_transfer_check_31;\n@(posedge clk_spi)     (cs_active && sck_rising) |-> ##8 $stable(mosi_data);\nendproperty\nassert_p_spi_transfer_check_31:assert property (p_spi_transfer_check_31) else $error(\"\");", "task_id": "4_2991", "predict_sva": "@(posedge clk_spi)         (cs_active == 1 && sck_rising == 1) |-> ##8 (mosi_data == $past(mosi_data))"}
{"id": "11_34_0536", "name": "pwm_duty_check_34", "sva": "@(posedge clk_pwm)     duty_changed && !pwm_disabled |-> ##1 $changed(pwm_out)", "ori_sva": "property pwm_duty_check_34;\n@(posedge clk_pwm)     duty_changed && !pwm_disabled |-> ##1 $changed(pwm_out)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PwmDutyCheck34  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `duty_changed && !pwm_disabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $changed(pwm_out)`  \n\n(Note: The property checks that if the PWM duty cycle changes (`duty_changed`) and PWM is not disabled (`!pwm_disabled`), then in the next clock cycle, the `pwm_out` signal must change its value.)", "sva_signals": ["clk_pwm", "pwm_disabled", "[0:0] duty_changed", "pwm_out"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)     (duty_changed && !pwm_disabled) |-> ##1 $changed(pwm_out);", "sva_name": "p_pwm_out_change_on_duty_change", "full_property": "property p_PwmDutyCheck34;\n@(posedge clk_pwm)     (duty_changed && !pwm_disabled) |-> ##1 $changed(pwm_out);\nendproperty\nassert_p_PwmDutyCheck34:assert property (p_PwmDutyCheck34) else $error(\"\");", "task_id": "4_2994", "predict_sva": "@(posedge clk_pwm)         (duty_changed == 1 && pwm_disabled == 0) |-> ##1 pwm_out != $past(pwm_out)"}
{"id": "11_42_0542", "name": "crypto_hash_check_42", "sva": "@(posedge clk_crypto)     hash_start && !hash_busy |-> ##[16:32] hash_done", "ori_sva": "property crypto_hash_check_42;\n@(posedge clk_crypto)     hash_start && !hash_busy |-> ##[16:32] hash_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_crypto_hash_check_42  \n**Trigger Condition**: At every rising edge of the `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `hash_start && !hash_busy`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:32] hash_done`  ", "sva_signals": ["clk_crypto", "hash_start", "hash_busy", "hash_done"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)     (hash_start && !hash_busy) |-> ##[16:32] hash_done;", "sva_name": "p_hash_done_within_16_to_32_cycles_after_start", "full_property": "property p_crypto_hash_check_42;\n@(posedge clk_crypto)     (hash_start && !hash_busy) |-> ##[16:32] hash_done;\nendproperty\nassert_p_crypto_hash_check_42:assert property (p_crypto_hash_check_42) else $error(\"\");", "task_id": "4_3002", "predict_sva": "@(posedge clk_crypto)         (hash_start == 1 && hash_busy == 0) |-> ##[16:32] hash_done == 1"}
{"id": "11_6_0525", "name": "memory_access_check_6", "sva": "@(posedge clk_mem)     cs_n && we_n && oe_n |-> ##[1:3] $stable(mem_data)", "ori_sva": "property memory_access_check_6;\n@(posedge clk_mem)     cs_n && we_n && oe_n |-> ##[1:3] $stable(mem_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_access_check_6  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cs_n && we_n && oe_n`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] $stable(mem_data)`  ", "sva_signals": ["clk_mem", "[0:0] cs_n", "[0:0] we_n", "[0:0] oe_n", "[15:0] mem_data"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)     (cs_n && we_n && oe_n) |-> ##[1:3] $stable(mem_data);", "sva_name": "p_mem_data_stability_when_cs_we_oe_high", "full_property": "property p_memory_access_check_6;\n@(posedge clk_mem)     (cs_n && we_n && oe_n) |-> ##[1:3] $stable(mem_data);\nendproperty\nassert_p_memory_access_check_6:assert property (p_memory_access_check_6) else $error(\"\");", "task_id": "4_3013", "predict_sva": "@(posedge clk_mem)         (cs_n == 1 && we_n == 1 && oe_n == 1) |-> ##[1:3] mem_data == $past(mem_data)"}
{"id": "12_28_0599", "name": "buffer_underrun_or_overrun_check", "sva": "@(negedge clk_audio_processing)     buffer_underrun || buffer_overrun |-> ##1 flow_control_activate", "ori_sva": "property buffer_underrun_or_overrun_check;\n@(negedge clk_audio_processing)     buffer_underrun || buffer_overrun |-> ##1 flow_control_activate\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_buffer_underrun_or_overrun_check  \n**Trigger Condition**: At every falling edge of the `clk_audio_processing`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `buffer_underrun || buffer_overrun`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 flow_control_activate`", "sva_signals": ["clk_audio_processing", "[0:0] buffer_underrun", "[0:0] buffer_overrun", "[0:0] flow_control_activate"], "clock": "clk_audio_processing", "attempts_left": 10, "sva_result": "@(negedge clk_audio_processing)         (buffer_underrun || buffer_overrun) |-> ##1 flow_control_activate;", "sva_name": "p_flow_control_activate_on_buffer_error", "full_property": "property p_buffer_underrun_or_overrun_check;\n@(negedge clk_audio_processing)         (buffer_underrun || buffer_overrun) |-> ##1 flow_control_activate;\nendproperty\nassert_p_buffer_underrun_or_overrun_check:assert property (p_buffer_underrun_or_overrun_check) else $error(\"\");", "task_id": "4_3028", "predict_sva": "@(negedge clk_audio_processing)         (buffer_underrun == 1 || buffer_overrun == 1) |-> ##1 flow_control_activate == 1"}
{"id": "13_15_0629", "name": "not_crc_err_delay", "sva": "@(posedge clk_data) !crc_err |-> ##3 crc_valid", "ori_sva": "property not_crc_err_delay;\n@(posedge clk_data) !crc_err |-> ##3 crc_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_crc_err_delay  \n**Trigger Condition**: At every rising edge of the `clk_data`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!crc_err`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 crc_valid`", "sva_signals": ["clk", "rst_n", "[0:0] crc_err", "[0:0] crc_valid", "clk_data"], "clock": "clk_data", "attempts_left": 10, "sva_result": "@(posedge clk_data)         !crc_err |-> ##3 crc_valid;", "sva_name": "p_crc_valid_after_crc_err_low", "full_property": "property p_not_crc_err_delay;\n@(posedge clk_data)         !crc_err |-> ##3 crc_valid;\nendproperty\nassert_p_not_crc_err_delay:assert property (p_not_crc_err_delay) else $error(\"\");", "task_id": "4_3059", "predict_sva": "@(posedge clk_data)         crc_err == 0 |-> ##3 crc_valid == 1"}
{"id": "12_45_0623", "name": "buffer_threshold_or_manual_flush_check", "sva": "@(negedge clk_data_processing)     buffer_threshold_reached || manual_flush_request |-> ##[0:2] flush_buffer", "ori_sva": "property buffer_threshold_or_manual_flush_check;\n@(negedge clk_data_processing)     buffer_threshold_reached || manual_flush_request |-> ##[0:2] flush_buffer\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_buffer_threshold_or_manual_flush_check  \n**Trigger Condition**: At every falling edge of the `clk_data_processing`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `buffer_threshold_reached || manual_flush_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] flush_buffer`  ", "sva_signals": ["clk_data_processing", "rst_n", "[0:0] buffer_threshold_reached", "[0:0] manual_flush_request", "[0:0] flush_buffer"], "clock": "clk_data_processing", "attempts_left": 10, "sva_result": "@(negedge clk_data_processing)     (buffer_threshold_reached || manual_flush_request) |-> ##[0:2] flush_buffer;", "sva_name": "p_flush_buffer_within_2_cycles_after_threshold_or_manual_request", "full_property": "property p_buffer_threshold_or_manual_flush_check;\n@(negedge clk_data_processing)     (buffer_threshold_reached || manual_flush_request) |-> ##[0:2] flush_buffer;\nendproperty\nassert_p_buffer_threshold_or_manual_flush_check:assert property (p_buffer_threshold_or_manual_flush_check) else $error(\"\");", "task_id": "4_3044", "predict_sva": "@(negedge clk_data_processing)         (buffer_threshold_reached == 1 || manual_flush_request == 1) |-> ##[0:2] flush_buffer == 1"}
{"id": "13_16_0642", "name": "not_overflow_check", "sva": "@(posedge clk_math) !overflow_flag |-> ##1 $stable(alu_result)", "ori_sva": "property not_overflow_check;\n@(posedge clk_math) !overflow_flag |-> ##1 $stable(alu_result)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_overflow_check  \n**Trigger Condition**: At every rising edge of the `clk_math`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!overflow_flag`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $stable(alu_result)`  ", "sva_signals": ["clk_math", "overflow_flag", "alu_result"], "clock": "clk_math", "attempts_left": 10, "sva_result": "@(posedge clk_math)         !overflow_flag |-> ##1 $stable(alu_result);", "sva_name": "p_alu_result_stable_no_overflow", "full_property": "property p_not_overflow_check;\n@(posedge clk_math)         !overflow_flag |-> ##1 $stable(alu_result);\nendproperty\nassert_p_not_overflow_check:assert property (p_not_overflow_check) else $error(\"\");", "task_id": "4_3060", "predict_sva": "@(posedge clk_math)         overflow_flag == 0 |-> ##1 alu_result == $past(alu_result)"}
{"id": "13_32_0646", "name": "not_autoneg_sequence", "sva": "@(posedge clk_xgmii) !autoneg_complete |-> ##[2:4] autoneg_restart", "ori_sva": "property not_autoneg_sequence;\n@(posedge clk_xgmii) !autoneg_complete |-> ##[2:4] autoneg_restart\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Autoneg_Sequence  \n**Trigger Condition**: At every rising edge of the `clk_xgmii`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!autoneg_complete`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] autoneg_restart`  ", "sva_signals": ["clk", "rst_n", "[0:0] autoneg_complete", "[0:0] autoneg_restart", "clk_xgmii"], "clock": "clk_xgmii", "attempts_left": 10, "sva_result": "@(posedge clk_xgmii)     !autoneg_complete |-> ##[2:4] autoneg_restart;", "sva_name": "p_autoneg_restart_within_2_to_4_cycles_after_incomplete", "full_property": "property p_Not_Autoneg_Sequence;\n@(posedge clk_xgmii)     !autoneg_complete |-> ##[2:4] autoneg_restart;\nendproperty\nassert_p_Not_Autoneg_Sequence:assert property (p_Not_Autoneg_Sequence) else $error(\"\");", "task_id": "4_3078", "predict_sva": "@(posedge clk_xgmii)         autoneg_complete == 0 |-> ##[2:4] autoneg_restart == 1"}
{"id": "13_8_0628", "name": "not_cache_hit_delay", "sva": "@(posedge clk_cache) !cache_hit |-> ##[1:3] cache_miss", "ori_sva": "property not_cache_hit_delay;\n@(posedge clk_cache) !cache_hit |-> ##[1:3] cache_miss\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Cache_Hit_Delay  \n**Trigger Condition**: At every rising edge of the `clk_cache`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!cache_hit`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] cache_miss`  \n\n", "sva_signals": ["clk_cache", "[0:0] cache_hit", "[0:0] cache_miss"], "clock": "clk_cache", "attempts_left": 10, "sva_result": "@(posedge clk_cache)     !cache_hit |-> ##[1:3] cache_miss;", "sva_name": "p_cache_miss_after_cache_hit_deasserted", "full_property": "property p_Not_Cache_Hit_Delay;\n@(posedge clk_cache)     !cache_hit |-> ##[1:3] cache_miss;\nendproperty\nassert_p_Not_Cache_Hit_Delay:assert property (p_Not_Cache_Hit_Delay) else $error(\"\");", "task_id": "4_3101", "predict_sva": "@(posedge clk_cache)         cache_hit == 0 |-> ##[1:3] cache_miss == 1"}
{"id": "15_12_0704", "name": "timeout_supervision_check", "sva": "@(posedge clk_timer) disable iff(timer_reset)     timer_start |-> ##[10:20] timer_expire", "ori_sva": "property timeout_supervision_check;\n@(posedge clk_timer) disable iff(timer_reset)     timer_start |-> ##[10:20] timer_expire\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_timeout_supervision_check  \n**Trigger Condition**: At every rising edge of the `clk_timer`  \n**Disable Condition**: `disable iff (timer_reset)`  \n**Antecedent (LHS of Implication)**: `timer_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[10:20] timer_expire`  \n\n(Note: The consequent means that within **10 to 20 clock cycles** after the antecedent is true, `timer_expire` must be asserted.)", "sva_signals": ["clk_timer", "timer_reset", "[0:0] timer_start", "[0:0] timer_expire"], "clock": "clk_timer", "attempts_left": 10, "sva_result": "@(posedge clk_timer) disable iff (timer_reset)     timer_start == 1'b1 |-> ##[10:20] timer_expire;", "sva_name": "p_timer_expire_within_10_to_20_cycles_after_start", "full_property": "property p_timeout_supervision_check;\n@(posedge clk_timer) disable iff (timer_reset)     timer_start == 1'b1 |-> ##[10:20] timer_expire;\nendproperty\nassert_p_timeout_supervision_check:assert property (p_timeout_supervision_check) else $error(\"\");", "task_id": "4_3124", "predict_sva": "@(posedge clk_timer) disable iff (timer_reset)         (timer_reset == 0 && timer_start == 1) |-> ##[10:20] timer_expire == 1"}
{"id": "15_44_0762", "name": "bus_bandwidth_check", "sva": "@(posedge clk_bw) disable iff(bw_reset)     bw_monitor |-> ##[5:10] bw_limit", "ori_sva": "property bus_bandwidth_check;\n@(posedge clk_bw) disable iff(bw_reset)     bw_monitor |-> ##[5:10] bw_limit\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_bus_bandwidth_check  \n**Trigger Condition**: At every rising edge of the `clk_bw`  \n**Disable Condition**: disable iff (`bw_reset`)  \n**Antecedent (LHS of Implication)**: `bw_monitor`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] bw_limit`  ", "sva_signals": ["clk_bw", "bw_reset", "[0:0] bw_monitor", "[0:0] bw_limit"], "clock": "clk_bw", "attempts_left": 10, "sva_result": "@(posedge clk_bw) disable iff (bw_reset)         bw_monitor |-> ##[5:10] bw_limit;", "sva_name": "p_bw_limit_within_5_to_10_cycles_after_monitor", "full_property": "property p_bus_bandwidth_check;\n@(posedge clk_bw) disable iff (bw_reset)         bw_monitor |-> ##[5:10] bw_limit;\nendproperty\nassert_p_bus_bandwidth_check:assert property (p_bus_bandwidth_check) else $error(\"\");", "task_id": "4_3153", "predict_sva": "@(posedge clk_bw) disable iff (bw_reset)         (bw_reset == 0 && bw_monitor == 1) |-> ##[5:10] (bw_limit == 1)"}
{"id": "15_49_0756", "name": "security_handshake_check", "sva": "@(posedge clk_shake) disable iff(shake_reset)     shake_req |-> ##[1:4] shake_ack", "ori_sva": "property security_handshake_check;\n@(posedge clk_shake) disable iff(shake_reset)     shake_req |-> ##[1:4] shake_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_security_handshake_check  \n**Trigger Condition**: At every rising edge of the `clk_shake`  \n**Disable Condition**: disable iff (`shake_reset`)  \n**Antecedent (LHS of Implication)**: `shake_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] shake_ack` (i.e., `shake_ack` must be asserted within 1 to 4 clock cycles after `shake_req` is asserted)", "sva_signals": ["clk_shake", "shake_reset", "[0:0] shake_req", "[0:0] shake_ack"], "clock": "clk_shake", "attempts_left": 10, "sva_result": "@(posedge clk_shake) disable iff (shake_reset)     shake_req == 1'b1 |-> ##[1:4] shake_ack;", "sva_name": "p_shake_ack_within_4_cycles_after_req", "full_property": "property p_security_handshake_check;\n@(posedge clk_shake) disable iff (shake_reset)     shake_req == 1'b1 |-> ##[1:4] shake_ack;\nendproperty\nassert_p_security_handshake_check:assert property (p_security_handshake_check) else $error(\"\");", "task_id": "4_3158", "predict_sva": "@(posedge clk_shake) disable iff (shake_reset)         (shake_reset == 0 && shake_req == 1'b1) |-> ##[1:4] shake_ack == 1'b1"}
{"id": "1_23_0026", "name": "pll_lock_sequence", "sva": "@(posedge clk_ref)     pll_reset_release |-> ##[5:8] pll_locked ##1 !pll_unstable", "ori_sva": "property pll_lock_sequence;\n@(posedge clk_ref)     pll_reset_release |-> ##[5:8] pll_locked ##1 !pll_unstable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PLL_Lock_Sequence  \n**Trigger Condition**: At every rising edge of the `clk_ref`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pll_reset_release`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:8] pll_locked ##1 !pll_unstable`  \n\n", "sva_signals": ["clk_ref", "pll_reset_release", "pll_locked", "pll_unstable"], "clock": "clk_ref", "attempts_left": 10, "sva_result": "@(posedge clk_ref)     pll_reset_release |-> ##[5:8] pll_locked ##1 !pll_unstable;", "sva_name": "p_pll_locked_and_unstable_after_reset_release", "full_property": "property p_PLL_Lock_Sequence;\n@(posedge clk_ref)     pll_reset_release |-> ##[5:8] pll_locked ##1 !pll_unstable;\nendproperty\nassert_p_PLL_Lock_Sequence:assert property (p_PLL_Lock_Sequence) else $error(\"\");", "task_id": "4_3176", "predict_sva": "@(posedge clk_ref)         pll_reset_release |-> ##[5:8] pll_locked ##1 !pll_unstable"}
{"id": "15_8_0702", "name": "power_gating_sequence_check", "sva": "@(posedge clk_pwr) disable iff(pwr_reset)     pwr_down_req |-> ##[2:5] pwr_ack ##1 pwr_down_ack", "ori_sva": "property power_gating_sequence_check;\n@(posedge clk_pwr) disable iff(pwr_reset)     pwr_down_req |-> ##[2:5] pwr_ack ##1 pwr_down_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_gating_sequence_check  \n**Trigger Condition**: At every rising edge of the `clk_pwr`  \n**Disable Condition**: disable iff (`pwr_reset`)  \n**Antecedent (LHS of Implication)**: `pwr_down_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] pwr_ack ##1 pwr_down_ack`  ", "sva_signals": ["clk_pwr", "pwr_reset", "[0:0] pwr_down_req", "[0:0] pwr_ack", "[0:0] pwr_down_ack"], "clock": "clk_pwr", "attempts_left": 10, "sva_result": "@(posedge clk_pwr) disable iff (pwr_reset)     pwr_down_req == 1'b1 |-> ##[2:5] pwr_ack ##1 pwr_down_ack;", "sva_name": "p_pwr_down_ack_sequence", "full_property": "property p_power_gating_sequence_check;\n@(posedge clk_pwr) disable iff (pwr_reset)     pwr_down_req == 1'b1 |-> ##[2:5] pwr_ack ##1 pwr_down_ack;\nendproperty\nassert_p_power_gating_sequence_check:assert property (p_power_gating_sequence_check) else $error(\"\");", "task_id": "4_3164", "predict_sva": "@(posedge clk_pwr) disable iff (pwr_reset)         (pwr_reset == 0 && pwr_down_req == 1'b1) |-> ##[2:5] (pwr_ack == 1'b1) ##1 (pwr_down_ack == 1'b1)"}
{"id": "1_39_0055", "name": "gpio_interrupt_check", "sva": "@(posedge clk_gpio)     $fell(gpio_int) |-> ##[1:3] int_ack ##1 !gpio_int_pending", "ori_sva": "property gpio_interrupt_check;\n@(posedge clk_gpio)     $fell(gpio_int) |-> ##[1:3] int_ack ##1 !gpio_int_pending\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_gpio_interrupt_check  \n**Trigger Condition**: At every rising edge of the `clk_gpio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(gpio_int)` (a falling edge on `gpio_int`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] int_ack ##1 !gpio_int_pending`  \n(Within 1 to 3 clock cycles after the trigger, `int_ack` must be asserted, followed by `gpio_int_pending` being deasserted in the next cycle.)", "sva_signals": ["clk_gpio", "gpio_int", "int_ack", "gpio_int_pending"], "clock": "clk_gpio", "attempts_left": 10, "sva_result": "@(posedge clk_gpio)     $fell(gpio_int) |-> ##[1:3] int_ack ##1 !gpio_int_pending;", "sva_name": "p_gpio_int_fall_int_ack_pending_clear", "full_property": "property p_gpio_interrupt_check;\n@(posedge clk_gpio)     $fell(gpio_int) |-> ##[1:3] int_ack ##1 !gpio_int_pending;\nendproperty\nassert_p_gpio_interrupt_check:assert property (p_gpio_interrupt_check) else $error(\"\");", "task_id": "4_3191", "predict_sva": "@(posedge clk_gpio)         $fell(gpio_int) |-> ##[1:3] int_ack ##1 !gpio_int_pending"}
{"id": "1_45_0042", "name": "mmu_translation_check", "sva": "@(posedge clk_mmu)     $rose(tlb_miss) |-> ##[3:6] tlb_hit ##1 !page_fault", "ori_sva": "property mmu_translation_check;\n@(posedge clk_mmu)     $rose(tlb_miss) |-> ##[3:6] tlb_hit ##1 !page_fault\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mmu_translation_check  \n**Trigger Condition**: At every rising edge of the `clk_mmu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(tlb_miss)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] tlb_hit ##1 !page_fault`  ", "sva_signals": ["clk_mmu", "[0:0] tlb_miss", "[0:0] tlb_hit", "[0:0] page_fault"], "clock": "clk_mmu", "attempts_left": 10, "sva_result": "@(posedge clk_mmu)     $rose(tlb_miss) |-> ##[3:6] tlb_hit ##1 !page_fault;", "sva_name": "p_tlb_hit_and_page_fault_after_miss", "full_property": "property p_mmu_translation_check;\n@(posedge clk_mmu)     $rose(tlb_miss) |-> ##[3:6] tlb_hit ##1 !page_fault;\nendproperty\nassert_p_mmu_translation_check:assert property (p_mmu_translation_check) else $error(\"\");", "task_id": "4_3198", "predict_sva": "@(posedge clk_mmu)         $rose(tlb_miss) |-> ##[3:6] (tlb_hit ##1 !page_fault)"}
{"id": "2_14_0004", "name": "encryption_start_done", "sva": "@(posedge clk_crypto)     encrypt_start |-> ##[16:64] encrypt_done", "ori_sva": "property encryption_start_done;\n@(posedge clk_crypto)     encrypt_start |-> ##[16:64] encrypt_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encryption_start_done  \n**Trigger Condition**: At every rising edge of the `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encrypt_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:64] encrypt_done == 1'b1`  \n\n(Note: The consequent checks that `encrypt_done` becomes `1` between 16 to 64 clock cycles after `encrypt_start` is asserted.)", "sva_signals": ["clk_crypto", "[0:0] encrypt_start", "[0:0] encrypt_done"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)     encrypt_start == 1'b1 |-> ##[16:64] encrypt_done == 1'b1;", "sva_name": "p_encrypt_done_within_16_to_64_cycles_after_start", "full_property": "property p_encryption_start_done;\n@(posedge clk_crypto)     encrypt_start == 1'b1 |-> ##[16:64] encrypt_done == 1'b1;\nendproperty\nassert_p_encryption_start_done:assert property (p_encryption_start_done) else $error(\"\");", "task_id": "4_3214", "predict_sva": "@(posedge clk_crypto)         encrypt_start == 1'b1 |-> ##[16:64] encrypt_done == 1'b1"}
{"id": "2_15_0074", "name": "temperature_alert_response", "sva": "@(posedge clk_temp)     temp_alert |-> ##[2:8] cooling_fan_on", "ori_sva": "property temperature_alert_response;\n@(posedge clk_temp)     temp_alert |-> ##[2:8] cooling_fan_on\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temperature_alert_response  \n**Trigger Condition**: At every rising edge of the `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_alert == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:8] cooling_fan_on == 1'b1`  ", "sva_signals": ["clk_temp", "[0:0] temp_alert", "[0:0] cooling_fan_on"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     temp_alert == 1'b1 |-> ##[2:8] cooling_fan_on == 1'b1;", "sva_name": "p_temp_alert_cooling_fan_on_within_2_to_8_cycles", "full_property": "property p_temperature_alert_response;\n@(posedge clk_temp)     temp_alert == 1'b1 |-> ##[2:8] cooling_fan_on == 1'b1;\nendproperty\nassert_p_temperature_alert_response:assert property (p_temperature_alert_response) else $error(\"\");", "task_id": "4_3215", "predict_sva": "@(posedge clk_temp)         temp_alert == 1'b1 |-> ##[2:8] cooling_fan_on == 1'b1"}
{"id": "2_30_0083", "name": "hdmi_link_stable", "sva": "@(posedge clk_hdmi)     hdmi_pll_lock |-> ##[16:64] $stable(hdmi_tmds)", "ori_sva": "property hdmi_link_stable;\n@(posedge clk_hdmi)     hdmi_pll_lock |-> ##[16:64] $stable(hdmi_tmds)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_hdmi_link_stable  \n**Trigger Condition**: At every rising edge of the `clk_hdmi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `hdmi_pll_lock == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 16 to 64 clock cycles (`##[16:64]`), the `hdmi_tmds` signal remains stable (`$stable(hdmi_tmds)`)", "sva_signals": ["clk_hdmi", "hdmi_pll_lock", "[0:0] hdmi_tmds"], "clock": "clk_hdmi", "attempts_left": 10, "sva_result": "@(posedge clk_hdmi)     hdmi_pll_lock == 1'b1 |-> ##[16:64] $stable(hdmi_tmds);", "sva_name": "p_hdmi_tmds_stability_after_pll_lock", "full_property": "property p_hdmi_link_stable;\n@(posedge clk_hdmi)     hdmi_pll_lock == 1'b1 |-> ##[16:64] $stable(hdmi_tmds);\nendproperty\nassert_p_hdmi_link_stable:assert property (p_hdmi_link_stable) else $error(\"\");", "task_id": "4_3232", "predict_sva": "@(posedge clk_hdmi)         hdmi_pll_lock == 1'b1 |-> ##[16:64] hdmi_tmds == $past(hdmi_tmds)"}
{"id": "2_32_0095", "name": "audio_sample_ready", "sva": "@(posedge clk_audio)     audio_dma_req |-> ##[2:8] audio_data_valid", "ori_sva": "property audio_sample_ready;\n@(posedge clk_audio)     audio_dma_req |-> ##[2:8] audio_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_audio_sample_ready  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `audio_dma_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:8] audio_data_valid == 1'b1` (i.e., `audio_data_valid` must be asserted between 2 to 8 clock cycles after `audio_dma_req` is asserted).", "sva_signals": ["clk_audio", "audio_dma_req", "audio_data_valid"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     audio_dma_req == 1'b1 |-> ##[2:8] audio_data_valid == 1'b1;", "sva_name": "p_audio_data_valid_after_dma_req", "full_property": "property p_audio_sample_ready;\n@(posedge clk_audio)     audio_dma_req == 1'b1 |-> ##[2:8] audio_data_valid == 1'b1;\nendproperty\nassert_p_audio_sample_ready:assert property (p_audio_sample_ready) else $error(\"\");", "task_id": "4_3234", "predict_sva": "@(posedge clk_audio)         audio_dma_req == 1'b1 |-> ##[2:8] audio_data_valid == 1'b1"}
{"id": "2_34_0084", "name": "timer_expire_check", "sva": "@(posedge clk_timer)     timer_load |-> ##[16:64] timer_expire", "ori_sva": "property timer_expire_check;\n@(posedge clk_timer)     timer_load |-> ##[16:64] timer_expire\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Timer_Expire_Check  \n**Trigger Condition**: At every rising edge of the `clk_timer`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `timer_load == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:64] timer_expire == 1'b1`  \n\n(Note: The consequent checks that `timer_expire` becomes true between 16 to 64 clock cycles after `timer_load` is asserted.)", "sva_signals": ["clk", "rst_n", "[0:0] timer_load", "[0:0] timer_expire", "clk_timer"], "clock": "clk_timer", "attempts_left": 10, "sva_result": "@(posedge clk_timer)     timer_load == 1'b1 |-> ##[16:64] timer_expire == 1'b1;", "sva_name": "p_timer_expire_within_16_to_64_cycles_after_load", "full_property": "property p_Timer_Expire_Check;\n@(posedge clk_timer)     timer_load == 1'b1 |-> ##[16:64] timer_expire == 1'b1;\nendproperty\nassert_p_Timer_Expire_Check:assert property (p_Timer_Expire_Check) else $error(\"\");", "task_id": "4_3237", "predict_sva": "@(posedge clk_timer)         timer_load == 1'b1 |-> ##[16:64] timer_expire == 1'b1"}
{"id": "2_45_0138", "name": "thermal_shutdown_check", "sva": "@(posedge clk_thermal)     temp_critical |-> ##[1:4] power_off", "ori_sva": "property thermal_shutdown_check;\n@(posedge clk_thermal)     temp_critical |-> ##[1:4] power_off\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Shutdown_Check  \n**Trigger Condition**: At every rising edge of the `clk_thermal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_critical == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] power_off == 1'b1` (power_off must be asserted within 1 to 4 clock cycles after temp_critical is detected)", "sva_signals": ["clk_thermal", "[0:0] temp_critical", "[0:0] power_off"], "clock": "clk_thermal", "attempts_left": 10, "sva_result": "@(posedge clk_thermal)     temp_critical == 1'b1 |-> ##[1:4] power_off == 1'b1;", "sva_name": "p_power_off_within_4_cycles_after_temp_critical", "full_property": "property p_Thermal_Shutdown_Check;\n@(posedge clk_thermal)     temp_critical == 1'b1 |-> ##[1:4] power_off == 1'b1;\nendproperty\nassert_p_Thermal_Shutdown_Check:assert property (p_Thermal_Shutdown_Check) else $error(\"\");", "task_id": "4_3247", "predict_sva": "@(posedge clk_thermal)         temp_critical == 1'b1 |-> ##[1:4] power_off == 1'b1"}
{"id": "2_5_0018", "name": "power_down_sequence_check", "sva": "@(posedge clk_pwr)     power_down_req |-> ##[8:32] power_good==0", "ori_sva": "property power_down_sequence_check;\n@(posedge clk_pwr)     power_down_req |-> ##[8:32] power_good==0\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Power_Down_Sequence_Check  \n**Trigger Condition**: At every rising edge of the `clk_pwr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_down_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:32] power_good == 1'b0`  ", "sva_signals": ["clk_pwr", "power_down_req", "power_good"], "clock": "clk_pwr", "attempts_left": 10, "sva_result": "@(posedge clk_pwr)         power_down_req == 1'b1 |-> ##[8:32] power_good == 1'b0;", "sva_name": "p_power_good_deassertion_after_power_down_req", "full_property": "property p_Power_Down_Sequence_Check;\n@(posedge clk_pwr)         power_down_req == 1'b1 |-> ##[8:32] power_good == 1'b0;\nendproperty\nassert_p_Power_Down_Sequence_Check:assert property (p_Power_Down_Sequence_Check) else $error(\"\");", "task_id": "4_3251", "predict_sva": "@(posedge clk_pwr)         power_down_req == 1'b1 |-> ##[8:32] power_good == 1'b0"}
{"id": "3_44_0150", "name": "power_sequence_44", "sva": "@(posedge clk_power)      power_up_trigger |-> ##[5:8] vcore_stable ##1 pll_enable", "ori_sva": "property power_sequence_44;\n@(posedge clk_power)      power_up_trigger |-> ##[5:8] vcore_stable ##1 pll_enable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_sequence_44  \n**Trigger Condition**: At every rising edge of the `clk_power`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_up_trigger`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:8] vcore_stable ##1 pll_enable`  ", "sva_signals": ["clk_power", "vcore_stable", "pll_enable", "[0:0] power_up_trigger"], "clock": "clk_power", "attempts_left": 10, "sva_result": "@(posedge clk_power)     power_up_trigger |-> ##[5:8] vcore_stable ##1 pll_enable;", "sva_name": "p_power_up_trigger_vcore_stable_pll_enable_sequence", "full_property": "property p_power_sequence_44;\n@(posedge clk_power)     power_up_trigger |-> ##[5:8] vcore_stable ##1 pll_enable;\nendproperty\nassert_p_power_sequence_44:assert property (p_power_sequence_44) else $error(\"\");", "task_id": "4_3286", "predict_sva": "@(posedge clk_power)         power_up_trigger |-> ##[5:8] vcore_stable ##1 pll_enable"}
{"id": "11_28_0513", "name": "rfid_collision_detect", "sva": "@(posedge clk_rfid)     rx_active && tx_attempt |-> ##[1:3] collision_detected && !ack_received", "ori_sva": "property rfid_collision_detect;\n@(posedge clk_rfid)     rx_active && tx_attempt |-> ##[1:3] collision_detected && !ack_received\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rfid_collision_detect  \n**Trigger Condition**: At every rising edge of the `clk_rfid`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rx_active && tx_attempt`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] collision_detected && !ack_received`  ", "sva_signals": ["clk_rfid", "rst_n", "[0:0] rx_active", "[0:0] tx_attempt", "[0:0] collision_detected", "[0:0] ack_received"], "clock": "clk_rfid", "attempts_left": 10, "sva_result": "@(posedge clk_rfid)         (rx_active && tx_attempt) |-> ##[1:3] (collision_detected && !ack_received);", "sva_name": "p_collision_detected_ack_received_within_3_cycles", "full_property": "property p_rfid_collision_detect;\n@(posedge clk_rfid)         (rx_active && tx_attempt) |-> ##[1:3] (collision_detected && !ack_received);\nendproperty\nassert_p_rfid_collision_detect:assert property (p_rfid_collision_detect) else $error(\"\");", "task_id": "4_3614", "predict_sva": "@(posedge clk_rfid)         (rx_active == 1 && tx_attempt == 1) |-> ##[1:3] (collision_detected == 1 && ack_received == 0)"}
{"id": "12_21_0561", "name": "instr_or_data_fault_check", "sva": "@(posedge clk_cpu)      instruction_fault || data_fault |-> ##[1:4] exception_handler", "ori_sva": "property instr_or_data_fault_check;\n@(posedge clk_cpu)      instruction_fault || data_fault |-> ##[1:4] exception_handler\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Instr_Or_Data_Fault_Check  \n**Trigger Condition**: At every rising edge of the `clk_cpu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `instruction_fault || data_fault`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] exception_handler`  ", "sva_signals": ["clk_cpu", "instruction_fault", "data_fault", "exception_handler"], "clock": "clk_cpu", "attempts_left": 10, "sva_result": "@(posedge clk_cpu)     (instruction_fault || data_fault) |-> ##[1:4] exception_handler;", "sva_name": "p_exception_handler_on_fault", "full_property": "property p_Instr_Or_Data_Fault_Check;\n@(posedge clk_cpu)     (instruction_fault || data_fault) |-> ##[1:4] exception_handler;\nendproperty\nassert_p_Instr_Or_Data_Fault_Check:assert property (p_Instr_Or_Data_Fault_Check) else $error(\"\");", "task_id": "4_3647", "predict_sva": "@(posedge clk_cpu)         (instruction_fault == 1 || data_fault == 1) |-> ##[1:4] exception_handler == 1"}
{"id": "11_7_0505", "name": "ddr_burst_termination", "sva": "@(posedge clk_ddr)     burst_en && cmd[1:0]==2'b01 |-> ##8 $fell(burst_en) && data_strobe[->1]", "ori_sva": "property ddr_burst_termination;\n@(posedge clk_ddr)     burst_en && cmd[1:0]==2'b01 |-> ##8 $fell(burst_en) && data_strobe[->1]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ddr_burst_termination  \n**Trigger Condition**: At every rising edge of the `clk_ddr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `burst_en && cmd[1:0] == 2'b01`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 $fell(burst_en) && data_strobe[->1]`  ", "sva_signals": ["clk_ddr", "burst_en", "[1:0] cmd", "data_strobe"], "clock": "clk_ddr", "attempts_left": 10, "sva_result": "@(posedge clk_ddr)         (burst_en && cmd[1:0] == 2'b01) |-> ##8 ($fell(burst_en) && data_strobe[->1]);", "sva_name": "p_ddr_burst_en_fall_and_data_strobe_single_cycle", "full_property": "property p_ddr_burst_termination;\n@(posedge clk_ddr)         (burst_en && cmd[1:0] == 2'b01) |-> ##8 ($fell(burst_en) && data_strobe[->1]);\nendproperty\nassert_p_ddr_burst_termination:assert property (p_ddr_burst_termination) else $error(\"\");", "task_id": "4_3635", "predict_sva": "@(posedge clk_ddr)         (burst_en == 1 && cmd[1:0] == 2'b01) |-> ##8 ($fell(burst_en) && data_strobe[->1])"}
{"id": "1_12_0055", "name": "interrupt_latency_check", "sva": "@(posedge clk_cpu)     irq_asserted |-> ##[2:5] irq_acknowledged ##1 irq_serviced", "ori_sva": "property interrupt_latency_check;\n@(posedge clk_cpu)     irq_asserted |-> ##[2:5] irq_acknowledged ##1 irq_serviced\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_interrupt_latency_check  \n**Trigger Condition**: At every rising edge of the `clk_cpu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `irq_asserted`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] irq_acknowledged ##1 irq_serviced`  ", "sva_signals": ["clk_cpu", "[0:0] irq_asserted", "[0:0] irq_acknowledged", "[0:0] irq_serviced"], "clock": "clk_cpu", "attempts_left": 10, "sva_result": "@(posedge clk_cpu)     irq_asserted |-> ##[2:5] irq_acknowledged ##1 irq_serviced;", "sva_name": "p_irq_acknowledge_and_service_sequence", "full_property": "property p_interrupt_latency_check;\n@(posedge clk_cpu)     irq_asserted |-> ##[2:5] irq_acknowledged ##1 irq_serviced;\nendproperty\nassert_p_interrupt_latency_check:assert property (p_interrupt_latency_check) else $error(\"\");", "task_id": "4_3804", "predict_sva": "@(posedge clk_cpu)         irq_asserted == 1 |-> ##[2:5] irq_acknowledged == 1 ##1 irq_serviced == 1"}
{"id": "1_28_0004", "name": "voltage_scale_transition", "sva": "@(posedge vreg_clk)     scale_request |-> ##3 voltage_stable ##1 freq_update", "ori_sva": "property voltage_scale_transition;\n@(posedge vreg_clk)     scale_request |-> ##3 voltage_stable ##1 freq_update\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Voltage_Scale_Transition  \n**Trigger Condition**: At every rising edge of the `vreg_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `scale_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 voltage_stable ##1 freq_update`  ", "sva_signals": ["vreg_clk", "[0:0] scale_request", "[0:0] voltage_stable", "[0:0] freq_update"], "clock": "vreg_clk", "attempts_left": 10, "sva_result": "@(posedge vreg_clk)     scale_request |-> ##3 voltage_stable ##1 freq_update;", "sva_name": "p_scale_request_voltage_stable_freq_update", "full_property": "property p_Voltage_Scale_Transition;\n@(posedge vreg_clk)     scale_request |-> ##3 voltage_stable ##1 freq_update;\nendproperty\nassert_p_Voltage_Scale_Transition:assert property (p_Voltage_Scale_Transition) else $error(\"\");", "task_id": "4_3809", "predict_sva": "@(posedge vreg_clk)         scale_request |-> ##3 voltage_stable ##1 freq_update"}
{"id": "1_36_0077", "name": "sensor_fusion_sync", "sva": "@(posedge fusion_clk)     new_data |-> ##[1:3] data_processed ##1 output_updated", "ori_sva": "property sensor_fusion_sync;\n@(posedge fusion_clk)     new_data |-> ##[1:3] data_processed ##1 output_updated\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_sensor_fusion_sync  \n**Trigger Condition**: At every rising edge of the `fusion_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `new_data`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] data_processed ##1 output_updated`  \n\n", "sva_signals": ["fusion_clk", "[0:0] new_data", "[0:0] data_processed", "[0:0] output_updated"], "clock": "fusion_clk", "attempts_left": 10, "sva_result": "@(posedge fusion_clk)     new_data |-> ##[1:3] data_processed ##1 output_updated;", "sva_name": "p_new_data_processed_output_updated", "full_property": "property p_sensor_fusion_sync;\n@(posedge fusion_clk)     new_data |-> ##[1:3] data_processed ##1 output_updated;\nendproperty\nassert_p_sensor_fusion_sync:assert property (p_sensor_fusion_sync) else $error(\"\");", "task_id": "4_3818", "predict_sva": "@(posedge fusion_clk)         new_data |-> ##[1:3] data_processed ##1 output_updated"}
{"id": "1_40_0023", "name": "multi_lane_serial_sync", "sva": "@(posedge serdes_clk)     lane_sync |-> ##[2:5] all_lanes_locked ##1 data_valid", "ori_sva": "property multi_lane_serial_sync;\n@(posedge serdes_clk)     lane_sync |-> ##[2:5] all_lanes_locked ##1 data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_multi_lane_serial_sync  \n**Trigger Condition**: At every rising edge of the `serdes_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lane_sync == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] all_lanes_locked ##1 data_valid`  \n\n**Explanation of Consequent**:  \n- The consequent specifies that within **2 to 5 clock cycles** after the antecedent (`lane_sync` being high), `all_lanes_locked` must be true.  \n- **Exactly one clock cycle** after `all_lanes_locked` is true, `data_valid` must also be true.  \n\n**Key Notes**:  \n1. The property checks synchronization across multiple lanes in a serial interface.  \n2. The timing window (`##[2:5]`) allows flexibility for `all_lanes_locked` to stabilize within 25 cycles after synchronization starts (`lane_sync`).  \n3. The `##1` delay enforces that `data_valid` must follow `all_lanes_locked` immediately in the next cycle.  \n\n*(No disable condition is specified, so the assertion is always active.)*", "sva_signals": ["serdes_clk", "[0:0] lane_sync", "[0:0] all_lanes_locked", "[0:0] data_valid"], "clock": "serdes_clk", "attempts_left": 10, "sva_result": "@(posedge serdes_clk)     lane_sync == 1'b1 |-> ##[2:5] all_lanes_locked ##1 data_valid;", "sva_name": "p_lane_sync_to_data_valid", "full_property": "property p_multi_lane_serial_sync;\n@(posedge serdes_clk)     lane_sync == 1'b1 |-> ##[2:5] all_lanes_locked ##1 data_valid;\nendproperty\nassert_p_multi_lane_serial_sync:assert property (p_multi_lane_serial_sync) else $error(\"\");", "task_id": "4_3823", "predict_sva": "@(posedge serdes_clk)    lane_sync == 1'b1 |-> ##[2:5] all_lanes_locked == 1'b1 ##1 data_valid == 1'b1"}
{"id": "1_41_0002", "name": "power_on_reset_sequence", "sva": "@(posedge por_clk)     power_good |-> ##10 reset_deassert ##1 clock_stable", "ori_sva": "property power_on_reset_sequence;\n@(posedge por_clk)     power_good |-> ##10 reset_deassert ##1 clock_stable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_power_on_reset_sequence  \n**Trigger Condition**: At every rising edge of the `por_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `power_good`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##10 reset_deassert ##1 clock_stable`  ", "sva_signals": ["por_clk", "[0:0] power_good", "[0:0] reset_deassert", "[0:0] clock_stable"], "clock": "por_clk", "attempts_left": 10, "sva_result": "@(posedge por_clk)         power_good |-> ##10 reset_deassert ##1 clock_stable;", "sva_name": "p_power_good_reset_clock_sequence", "full_property": "property p_power_on_reset_sequence;\n@(posedge por_clk)         power_good |-> ##10 reset_deassert ##1 clock_stable;\nendproperty\nassert_p_power_on_reset_sequence:assert property (p_power_on_reset_sequence) else $error(\"\");", "task_id": "4_3824", "predict_sva": "@(posedge por_clk)         power_good |-> ##10 reset_deassert ##1 clock_stable"}
{"id": "2_20_0032", "name": "pwm_period_stable", "sva": "@(posedge clk_pwm)     pwm_enable_change |-> ##[7:56] $stable(pwm_period)[*3]", "ori_sva": "property pwm_period_stable;\n@(posedge clk_pwm)     pwm_enable_change |-> ##[7:56] $stable(pwm_period)[*3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_PWM_Period_Stable  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwm_enable_change`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[7:56] $stable(pwm_period)[*3]`  ", "sva_signals": ["clk_pwm", "[0:0] pwm_enable_change", "[0:0] pwm_period"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)     pwm_enable_change |-> ##[7:56] $stable(pwm_period)[*3];", "sva_name": "p_pwm_period_stability_after_enable_change", "full_property": "property p_PWM_Period_Stable;\n@(posedge clk_pwm)     pwm_enable_change |-> ##[7:56] $stable(pwm_period)[*3];\nendproperty\nassert_p_PWM_Period_Stable:assert property (p_PWM_Period_Stable) else $error(\"\");", "task_id": "4_3848", "predict_sva": "@(posedge clk_pwm)         pwm_enable_change == 1 |-> ##[7:56] (pwm_period == $past(pwm_period)) [*3]"}
{"id": "2_45_0146", "name": "axi_stream_tlast_check", "sva": "@(posedge clk_axis)     tvalid && tready |-> ##[1:8] tlast || !tvalid", "ori_sva": "property axi_stream_tlast_check;\n@(posedge clk_axis)     tvalid && tready |-> ##[1:8] tlast || !tvalid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_axi_stream_tlast_check  \n**Trigger Condition**: At every rising edge of the `clk_axis`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `tvalid && tready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:8] tlast || !tvalid`  ", "sva_signals": ["clk_axis", "tvalid", "tready", "tlast"], "clock": "clk_axis", "attempts_left": 10, "sva_result": "@(posedge clk_axis)         (tvalid && tready) |-> ##[1:8] (tlast || !tvalid);", "sva_name": "p_axi_stream_transfer_completion", "full_property": "property p_axi_stream_tlast_check;\n@(posedge clk_axis)         (tvalid && tready) |-> ##[1:8] (tlast || !tvalid);\nendproperty\nassert_p_axi_stream_tlast_check:assert property (p_axi_stream_tlast_check) else $error(\"\");", "task_id": "4_3875", "predict_sva": "@(posedge clk_axis)         (tvalid == 1 && tready == 1) |-> ##[1:8] (tlast == 1 || tvalid == 0)"}
{"id": "7_34_0338", "name": "motor_start_sequence", "sva": "@(posedge motor_clk)      $rose(motor_start) |-> ##[5:8] motor_phase_valid ##1 motor_running", "ori_sva": "property motor_start_sequence;\n@(posedge motor_clk)      $rose(motor_start) |-> ##[5:8] motor_phase_valid ##1 motor_running\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_motor_start_sequence  \n**Trigger Condition**: At every rising edge of the `motor_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(motor_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:8] motor_phase_valid ##1 motor_running`  \n\n", "sva_signals": ["motor_clk", "rst_n", "[0:0] motor_start", "[0:0] motor_phase_valid", "[0:0] motor_running"], "clock": "motor_clk", "attempts_left": 10, "sva_result": "@(posedge motor_clk)     $rose(motor_start) |-> ##[5:8] motor_phase_valid ##1 motor_running;", "sva_name": "p_motor_start_phase_valid_running_sequence", "full_property": "property p_motor_start_sequence;\n@(posedge motor_clk)     $rose(motor_start) |-> ##[5:8] motor_phase_valid ##1 motor_running;\nendproperty\nassert_p_motor_start_sequence:assert property (p_motor_start_sequence) else $error(\"\");", "task_id": "4_4091", "predict_sva": "@(posedge motor_clk)         $rose(motor_start) |-> ##[5:8] motor_phase_valid ##1 motor_running"}
{"id": "3_43_0120", "name": "ddr_phy_calibration", "sva": "@(posedge clk_ddr_phy)     (calibration_start && !read_active) |-> ##[50:200] (calibration_done && eye_optimal)", "ori_sva": "property ddr_phy_calibration;\n@(posedge clk_ddr_phy)     (calibration_start && !read_active) |-> ##[50:200] (calibration_done && eye_optimal)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ddr_phy_calibration  \n**Trigger Condition**: At every rising edge of the `clk_ddr_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `calibration_start && !read_active`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[50:200] (calibration_done && eye_optimal)`  ", "sva_signals": ["clk_ddr_phy", "[0:0] calibration_start", "[0:0] read_active", "[0:0] calibration_done", "[0:0] eye_optimal"], "clock": "clk_ddr_phy", "attempts_left": 10, "sva_result": "@(posedge clk_ddr_phy)     (calibration_start && !read_active) |-> ##[50:200] (calibration_done && eye_optimal);", "sva_name": "p_calibration_done_eye_optimal_within_200_cycles", "full_property": "property p_ddr_phy_calibration;\n@(posedge clk_ddr_phy)     (calibration_start && !read_active) |-> ##[50:200] (calibration_done && eye_optimal);\nendproperty\nassert_p_ddr_phy_calibration:assert property (p_ddr_phy_calibration) else $error(\"\");", "task_id": "4_3920", "predict_sva": "@(posedge clk_ddr_phy)         (calibration_start == 1 && read_active == 0) |-> ##[50:200] (calibration_done == 1 && eye_optimal == 1)"}
{"id": "7_8_0299", "name": "uart_break_detect_prop", "sva": "@(posedge uart_clk)      $rose(uart_rx_break) |-> ##[1:2] uart_frame_error ##1 uart_break_interrupt", "ori_sva": "property uart_break_detect_prop;\n@(posedge uart_clk)      $rose(uart_rx_break) |-> ##[1:2] uart_frame_error ##1 uart_break_interrupt\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Uart_Break_Detect  \n**Trigger Condition**: At every rising edge of the `uart_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(uart_rx_break)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] uart_frame_error ##1 uart_break_interrupt`  ", "sva_signals": ["uart_clk", "uart_rx_break", "uart_frame_error", "uart_break_interrupt"], "clock": "uart_clk", "attempts_left": 10, "sva_result": "@(posedge uart_clk)     $rose(uart_rx_break) |-> ##[1:2] uart_frame_error ##1 uart_break_interrupt;", "sva_name": "uart_break_frame_error_interrupt", "full_property": "property p_Uart_Break_Detect;\n@(posedge uart_clk)     $rose(uart_rx_break) |-> ##[1:2] uart_frame_error ##1 uart_break_interrupt;\nendproperty\nassert_p_Uart_Break_Detect:assert property (p_Uart_Break_Detect) else $error(\"\");", "task_id": "4_4111", "predict_sva": "@(posedge uart_clk)    $rose(uart_rx_break) |-> ##[1:2] uart_frame_error ##1 uart_break_interrupt"}
{"id": "8_19_0351", "name": "p_fall_uart_break_detect", "sva": "@(posedge clk_baud)     $fell(rx_line) |-> ##[12:15] $fell(rx_active) ##1 break_condition", "ori_sva": "property p_fall_uart_break_detect;\n@(posedge clk_baud)     $fell(rx_line) |-> ##[12:15] $fell(rx_active) ##1 break_condition\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fall_uart_break_detect  \n**Trigger Condition**: At every rising edge of the `clk_baud`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(rx_line)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[12:15] $fell(rx_active) ##1 break_condition`  ", "sva_signals": ["clk", "rst_n", "[0:0] rx_line", "[0:0] rx_active", "[0:0] break_condition", "[3:0] clk_baud"], "clock": "clk_baud", "attempts_left": 10, "sva_result": "@(posedge clk_baud)     $fell(rx_line) |-> ##[12:15] $fell(rx_active) ##1 break_condition;", "sva_name": "p_rx_line_fall_rx_active_break_condition", "full_property": "property p_fall_uart_break_detect;\n@(posedge clk_baud)     $fell(rx_line) |-> ##[12:15] $fell(rx_active) ##1 break_condition;\nendproperty\nassert_p_fall_uart_break_detect:assert property (p_fall_uart_break_detect) else $error(\"\");", "task_id": "4_4122", "predict_sva": "@(posedge clk_baud)         $fell(rx_line) |-> ##[12:15] ($fell(rx_active) ##1 break_condition)"}
{"id": "8_32_0368", "name": "p_fall_pll_bypass_mode", "sva": "@(posedge clk_ref_in)     $fell(pll_bypass) |-> ##[3:6] $fell(pll_lock) ##1 clock_unstable", "ori_sva": "property p_fall_pll_bypass_mode;\n@(posedge clk_ref_in)     $fell(pll_bypass) |-> ##[3:6] $fell(pll_lock) ##1 clock_unstable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fall_pll_bypass_mode  \n**Trigger Condition**: At every rising edge of the `clk_ref_in`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(pll_bypass)` (a falling edge on `pll_bypass`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] $fell(pll_lock) ##1 clock_unstable`  \n(After the falling edge of `pll_bypass`, within 3 to 6 clock cycles, `pll_lock` must fall, followed by `clock_unstable` being true in the next cycle.)", "sva_signals": ["clk_ref_in", "pll_bypass", "pll_lock", "clock_unstable"], "clock": "clk_ref_in", "attempts_left": 10, "sva_result": "@(posedge clk_ref_in)     $fell(pll_bypass) |-> ##[3:6] $fell(pll_lock) ##1 clock_unstable;", "sva_name": "p_pll_lock_and_clock_unstable_after_bypass_fall", "full_property": "property p_fall_pll_bypass_mode;\n@(posedge clk_ref_in)     $fell(pll_bypass) |-> ##[3:6] $fell(pll_lock) ##1 clock_unstable;\nendproperty\nassert_p_fall_pll_bypass_mode:assert property (p_fall_pll_bypass_mode) else $error(\"\");", "task_id": "4_4134", "predict_sva": "@(posedge clk_ref_in)         $fell(pll_bypass) |-> ##[3:6] ($fell(pll_lock) ##1 clock_unstable == 1)"}
{"id": "11_28_0520", "name": "temp_sensor_threshold", "sva": "@(posedge sensor_clk)     (temp_exceed && !sensor_off) |-> ##[3:6] alarm_trigger ##0 $stable(temp_code)", "ori_sva": "property temp_sensor_threshold;\n@(posedge sensor_clk)     (temp_exceed && !sensor_off) |-> ##[3:6] alarm_trigger ##0 $stable(temp_code)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_temp_sensor_threshold  \n**Trigger Condition**: At every rising edge of the `sensor_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_exceed && !sensor_off`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] alarm_trigger ##0 $stable(temp_code)`  \n\n**Explanation of Consequent**:  \nThe consequent specifies that within **3 to 6 clock cycles** after the antecedent holds, the following must occur:  \n1. `alarm_trigger` must be asserted (high).  \n2. Simultaneously (`##0`), the `temp_code` signal must remain stable (unchanged from its previous value).  \n\nThis assertion checks that when the temperature exceeds the threshold (`temp_exceed`) and the sensor is not turned off (`!sensor_off`), an alarm is triggered within 3 to 6 clock cycles, and the temperature code remains stable at the time of the alarm.", "sva_signals": ["sensor_clk", "sensor_off", "[0:0] temp_exceed", "[0:0] alarm_trigger", "[0:0] temp_code"], "clock": "sensor_clk", "attempts_left": 10, "sva_result": "@(posedge sensor_clk)         (temp_exceed && !sensor_off) |-> ##[3:6] (alarm_trigger ##0 $stable(temp_code));", "sva_name": "p_alarm_trigger_within_3_to_6_cycles_and_temp_code_stable", "full_property": "property p_temp_sensor_threshold;\n@(posedge sensor_clk)         (temp_exceed && !sensor_off) |-> ##[3:6] (alarm_trigger ##0 $stable(temp_code));\nendproperty\nassert_p_temp_sensor_threshold:assert property (p_temp_sensor_threshold) else $error(\"\");", "task_id": "4_4255", "predict_sva": "@(posedge sensor_clk)         (temp_exceed == 1 && sensor_off == 0) |-> ##[3:6] (alarm_trigger == 1 && temp_code == $past(temp_code))"}
{"id": "11_31_0532", "name": "rtc_second_tick_verify", "sva": "@(posedge rtc_clk)     (counter_max && !calibration_mode) |-> ##1 second_tick ##0 $stable(rtc_regs)", "ori_sva": "property rtc_second_tick_verify;\n@(posedge rtc_clk)     (counter_max && !calibration_mode) |-> ##1 second_tick ##0 $stable(rtc_regs)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rtc_second_tick_verify  \n**Trigger Condition**: At every rising edge of the `rtc_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(counter_max && !calibration_mode)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 second_tick ##0 $stable(rtc_regs)`  ", "sva_signals": ["rtc_clk", "counter_max", "calibration_mode", "[0:0] second_tick", "rtc_regs"], "clock": "rtc_clk", "attempts_left": 10, "sva_result": "@(posedge rtc_clk)     (counter_max && !calibration_mode) |-> ##1 second_tick ##0 $stable(rtc_regs);", "sva_name": "p_second_tick_and_rtc_regs_stability_on_counter_max", "full_property": "property p_rtc_second_tick_verify;\n@(posedge rtc_clk)     (counter_max && !calibration_mode) |-> ##1 second_tick ##0 $stable(rtc_regs);\nendproperty\nassert_p_rtc_second_tick_verify:assert property (p_rtc_second_tick_verify) else $error(\"\");", "task_id": "4_4257", "predict_sva": "@(posedge rtc_clk)         (counter_max == 1 && calibration_mode == 0) |-> ##1 (second_tick == 1 && $stable(rtc_regs))"}
{"id": "12_24_0582", "name": "voltage_drop_or_ocp_check", "sva": "@(posedge clk_pwr_mgmt)      vdrop_detected || overcurrent_prot |-> ##2 shutdown_en", "ori_sva": "property voltage_drop_or_ocp_check;\n@(posedge clk_pwr_mgmt)      vdrop_detected || overcurrent_prot |-> ##2 shutdown_en\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Voltage_Drop_or_OCP_Check  \n**Trigger Condition**: At every rising edge of the `clk_pwr_mgmt`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `vdrop_detected || overcurrent_prot`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 shutdown_en`  ", "sva_signals": ["clk_pwr_mgmt", "[0:0] vdrop_detected", "[0:0] overcurrent_prot", "[0:0] shutdown_en"], "clock": "clk_pwr_mgmt", "attempts_left": 10, "sva_result": "@(posedge clk_pwr_mgmt)     (vdrop_detected || overcurrent_prot) |-> ##2 shutdown_en;", "sva_name": "p_shutdown_en_after_vdrop_or_overcurrent", "full_property": "property p_Voltage_Drop_or_OCP_Check;\n@(posedge clk_pwr_mgmt)     (vdrop_detected || overcurrent_prot) |-> ##2 shutdown_en;\nendproperty\nassert_p_Voltage_Drop_or_OCP_Check:assert property (p_Voltage_Drop_or_OCP_Check) else $error(\"\");", "task_id": "4_4292", "predict_sva": "@(posedge clk_pwr_mgmt)         (vdrop_detected == 1 || overcurrent_prot == 1) |-> ##2 shutdown_en == 1"}
{"id": "12_30_0576", "name": "sync_lost_or_reset_check", "sva": "@(posedge clk_serial)      sync_lost || reset_received |-> ##0 !data_valid", "ori_sva": "property sync_lost_or_reset_check;\n@(posedge clk_serial)      sync_lost || reset_received |-> ##0 !data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Sync_Lost_Or_Reset_Check  \n**Trigger Condition**: At every rising edge of the `clk_serial`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sync_lost || reset_received`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##0 !data_valid`  ", "sva_signals": ["clk_serial", "[0:0] sync_lost", "[0:0] reset_received", "[0:0] data_valid"], "clock": "clk_serial", "attempts_left": 10, "sva_result": "@(posedge clk_serial)         (sync_lost || reset_received) |-> ##0 !data_valid;", "sva_name": "p_data_valid_deassert_on_sync_or_reset", "full_property": "property p_Sync_Lost_Or_Reset_Check;\n@(posedge clk_serial)         (sync_lost || reset_received) |-> ##0 !data_valid;\nendproperty\nassert_p_Sync_Lost_Or_Reset_Check:assert property (p_Sync_Lost_Or_Reset_Check) else $error(\"\");", "task_id": "4_4299", "predict_sva": "@(posedge clk_serial)         (sync_lost == 1 || reset_received == 1) |-> data_valid == 0"}
{"id": "13_28_0624", "name": "not_overflow_with_monitor", "sva": "@(posedge clk_mon) !counter_overflow |-> ##[2:4] monitor_triggered", "ori_sva": "property not_overflow_with_monitor;\n@(posedge clk_mon) !counter_overflow |-> ##[2:4] monitor_triggered\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_overflow_with_monitor  \n**Trigger Condition**: At every rising edge of the `clk_mon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!counter_overflow`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] monitor_triggered`  ", "sva_signals": ["clk", "rst_n", "[0:0] counter_overflow", "[0:0] monitor_triggered", "clk_mon"], "clock": "clk_mon", "attempts_left": 10, "sva_result": "@(posedge clk_mon)     !counter_overflow |-> ##[2:4] monitor_triggered;", "sva_name": "p_monitor_triggered_after_no_overflow", "full_property": "property p_not_overflow_with_monitor;\n@(posedge clk_mon)     !counter_overflow |-> ##[2:4] monitor_triggered;\nendproperty\nassert_p_not_overflow_with_monitor:assert property (p_not_overflow_with_monitor) else $error(\"\");", "task_id": "4_4343", "predict_sva": "@(posedge clk_mon)         counter_overflow == 0 |-> ##[2:4] monitor_triggered == 1"}
{"id": "13_34_0650", "name": "not_jitter_with_cal", "sva": "@(posedge clk_cal) !excess_jitter |-> ##2 calibration_done", "ori_sva": "property not_jitter_with_cal;\n@(posedge clk_cal) !excess_jitter |-> ##2 calibration_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_jitter_with_cal  \n**Trigger Condition**: At every rising edge of the `clk_cal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!excess_jitter`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 calibration_done`", "sva_signals": ["clk_cal", "excess_jitter", "calibration_done"], "clock": "clk_cal", "attempts_left": 10, "sva_result": "@(posedge clk_cal)     !excess_jitter |-> ##2 calibration_done;", "sva_name": "p_calibration_done_after_no_excess_jitter", "full_property": "property p_not_jitter_with_cal;\n@(posedge clk_cal)     !excess_jitter |-> ##2 calibration_done;\nendproperty\nassert_p_not_jitter_with_cal:assert property (p_not_jitter_with_cal) else $error(\"\");", "task_id": "4_4350", "predict_sva": "@(posedge clk_cal)         excess_jitter == 0 |-> ##2 calibration_done == 1"}
{"id": "13_37_0634", "name": "not_starvation_with_arb", "sva": "@(posedge clk_shared) !starvation_detected |-> ##1 arbiter_rotated", "ori_sva": "property not_starvation_with_arb;\n@(posedge clk_shared) !starvation_detected |-> ##1 arbiter_rotated\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_starvation_with_arb  \n**Trigger Condition**: At every rising edge of the `clk_shared`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!starvation_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 arbiter_rotated`", "sva_signals": ["clk", "rst_n", "[0:0] starvation_detected", "[0:0] arbiter_rotated", "clk_shared"], "clock": "clk_shared", "attempts_left": 10, "sva_result": "@(posedge clk_shared)     !starvation_detected |-> ##1 arbiter_rotated;", "sva_name": "p_arbiter_rotates_on_no_starvation", "full_property": "property p_not_starvation_with_arb;\n@(posedge clk_shared)     !starvation_detected |-> ##1 arbiter_rotated;\nendproperty\nassert_p_not_starvation_with_arb:assert property (p_not_starvation_with_arb) else $error(\"\");", "task_id": "4_4352", "predict_sva": "@(posedge clk_shared)         starvation_detected == 0 |-> ##1 arbiter_rotated == 1"}
{"id": "13_39_0640", "name": "not_contention_with_pri", "sva": "@(posedge clk_res) !resource_contention |-> ##2 priority_resolved", "ori_sva": "property not_contention_with_pri;\n@(posedge clk_res) !resource_contention |-> ##2 priority_resolved\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_contention_with_pri  \n**Trigger Condition**: At every rising edge of the `clk_res`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!resource_contention`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 priority_resolved`", "sva_signals": ["clk", "rst_n", "[0:0] resource_contention", "[0:0] priority_resolved", "clk_res"], "clock": "clk_res", "attempts_left": 10, "sva_result": "@(posedge clk_res)     !resource_contention |-> ##2 priority_resolved;", "sva_name": "p_priority_resolved_after_no_contention", "full_property": "property p_not_contention_with_pri;\n@(posedge clk_res)     !resource_contention |-> ##2 priority_resolved;\nendproperty\nassert_p_not_contention_with_pri:assert property (p_not_contention_with_pri) else $error(\"\");", "task_id": "4_4354", "predict_sva": "@(posedge clk_res)         resource_contention == 0 |-> ##2 priority_resolved == 1"}
{"id": "13_40_0637", "name": "not_violation_with_prot", "sva": "@(posedge clk_sec) !protocol_violation |-> ##[1:4] protection_active", "ori_sva": "property not_violation_with_prot;\n@(posedge clk_sec) !protocol_violation |-> ##[1:4] protection_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Violation_With_Prot  \n**Trigger Condition**: At every rising edge of `clk_sec`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!protocol_violation`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] protection_active`  \n\n(Explanation: The assertion checks that if there is no protocol violation (`!protocol_violation`), then within 1 to 4 clock cycles (`##[1:4]`), the `protection_active` signal must be asserted.)", "sva_signals": ["clk_sec", "[0:0] protocol_violation", "[0:0] protection_active"], "clock": "clk_sec", "attempts_left": 10, "sva_result": "@(posedge clk_sec)     !protocol_violation |-> ##[1:4] protection_active;", "sva_name": "p_protection_active_after_no_violation", "full_property": "property p_Not_Violation_With_Prot;\n@(posedge clk_sec)     !protocol_violation |-> ##[1:4] protection_active;\nendproperty\nassert_p_Not_Violation_With_Prot:assert property (p_Not_Violation_With_Prot) else $error(\"\");", "task_id": "4_4356", "predict_sva": "@(posedge clk_sec)         protocol_violation == 0 |-> ##[1:4] protection_active == 1"}
{"id": "13_44_0631", "name": "not_saturation_with_limit", "sva": "@(posedge clk_dsp) $fell(!saturated_output) |-> ##2 limiter_active", "ori_sva": "property not_saturation_with_limit;\n@(posedge clk_dsp) $fell(!saturated_output) |-> ##2 limiter_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_not_saturation_with_limit  \n**Trigger Condition**: At every rising edge of the `clk_dsp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(!saturated_output)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 limiter_active`", "sva_signals": ["clk_dsp", "saturated_output", "[0:0] limiter_active"], "clock": "clk_dsp", "attempts_left": 10, "sva_result": "@(posedge clk_dsp)     $fell(!saturated_output) |-> ##2 limiter_active;", "sva_name": "p_limiter_active_after_saturation_fall", "full_property": "property p_not_saturation_with_limit;\n@(posedge clk_dsp)     $fell(!saturated_output) |-> ##2 limiter_active;\nendproperty\nassert_p_not_saturation_with_limit:assert property (p_not_saturation_with_limit) else $error(\"\");", "task_id": "4_4360", "predict_sva": "@(posedge clk_dsp)     $fell(!saturated_output) |-> ##2 limiter_active"}
{"id": "15_17_0716", "name": "qspi_io_mode_switch", "sva": "@(posedge clk_qspi) disable iff(qspi_reset)     qspi_dual_mode_enable |-> ##[2:4] qspi_io2_enable ##1 qspi_io3_enable", "ori_sva": "property qspi_io_mode_switch;\n@(posedge clk_qspi) disable iff(qspi_reset)     qspi_dual_mode_enable |-> ##[2:4] qspi_io2_enable ##1 qspi_io3_enable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_qspi_io_mode_switch  \n**Trigger Condition**: At every rising edge of the `clk_qspi`  \n**Disable Condition**: disable iff (`qspi_reset`)  \n**Antecedent (LHS of Implication)**: `qspi_dual_mode_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] qspi_io2_enable ##1 qspi_io3_enable`  ", "sva_signals": ["clk_qspi", "qspi_reset", "[0:0] qspi_dual_mode_enable", "[0:0] qspi_io2_enable", "[0:0] qspi_io3_enable"], "clock": "clk_qspi", "attempts_left": 10, "sva_result": "@(posedge clk_qspi) disable iff (qspi_reset)     qspi_dual_mode_enable == 1'b1 |-> ##[2:4] qspi_io2_enable ##1 qspi_io3_enable;", "sva_name": "p_qspi_dual_mode_enable_sequence", "full_property": "property p_qspi_io_mode_switch;\n@(posedge clk_qspi) disable iff (qspi_reset)     qspi_dual_mode_enable == 1'b1 |-> ##[2:4] qspi_io2_enable ##1 qspi_io3_enable;\nendproperty\nassert_p_qspi_io_mode_switch:assert property (p_qspi_io_mode_switch) else $error(\"\");", "task_id": "4_4391", "predict_sva": "@(posedge clk_qspi) disable iff (qspi_reset)         (qspi_reset == 0 && qspi_dual_mode_enable == 1) |->          (##[2:4] qspi_io2_enable == 1) ##1 qspi_io3_enable == 1"}
{"id": "15_33_0732", "name": "smartcard_atr_response", "sva": "@(posedge clk_scard) disable iff(!scard_present)     scard_atr_request |-> ##[20:40] scard_atr_response_valid ##1 $onehot(scard_protocol_select)", "ori_sva": "property smartcard_atr_response;\n@(posedge clk_scard) disable iff(!scard_present)     scard_atr_request |-> ##[20:40] scard_atr_response_valid ##1 $onehot(scard_protocol_select)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Smartcard_Atr_Response  \n**Trigger Condition**: At every rising edge of the `clk_scard`  \n**Disable Condition**: disable iff (`!scard_present`)  \n**Antecedent (LHS of Implication)**: `scard_atr_request`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[20:40] scard_atr_response_valid ##1 $onehot(scard_protocol_select)`  ", "sva_signals": ["clk_scard", "scard_present", "[0:0] scard_atr_request", "[0:0] scard_atr_response_valid", "[0:0] scard_protocol_select"], "clock": "clk_scard", "attempts_left": 10, "sva_result": "@(posedge clk_scard) disable iff (!scard_present)     scard_atr_request |-> ##[20:40] scard_atr_response_valid ##1 $onehot(scard_protocol_select);", "sva_name": "p_scard_atr_response_valid_and_protocol_select", "full_property": "property p_Smartcard_Atr_Response;\n@(posedge clk_scard) disable iff (!scard_present)     scard_atr_request |-> ##[20:40] scard_atr_response_valid ##1 $onehot(scard_protocol_select);\nendproperty\nassert_p_Smartcard_Atr_Response:assert property (p_Smartcard_Atr_Response) else $error(\"\");", "task_id": "4_4407", "predict_sva": "@(posedge clk_scard) disable iff (!scard_present)         (scard_present == 1 && scard_atr_request == 1) |->          (##[20:40] scard_atr_response_valid == 1) ##1          ($onehot(scard_protocol_select))"}
{"id": "15_44_0752", "name": "ethernet_mac_flow_control", "sva": "@(posedge clk_eth_mac) disable iff(!eth_mac_reset_n)     eth_pause_frame_received |-> ##[1:2] eth_tx_pause_enable ##[16:32] eth_tx_resume_normal", "ori_sva": "property ethernet_mac_flow_control;\n@(posedge clk_eth_mac) disable iff(!eth_mac_reset_n)     eth_pause_frame_received |-> ##[1:2] eth_tx_pause_enable ##[16:32] eth_tx_resume_normal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Ethernet_Mac_Flow_Control  \n**Trigger Condition**: At every rising edge of the `clk_eth_mac`  \n**Disable Condition**: disable iff (`!eth_mac_reset_n`)  \n**Antecedent (LHS of Implication)**: `eth_pause_frame_received`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:2] eth_tx_pause_enable ##[16:32] eth_tx_resume_normal`  ", "sva_signals": ["clk_eth_mac", "eth_mac_reset_n", "[0:0] eth_pause_frame_received", "[0:0] eth_tx_pause_enable", "[0:0] eth_tx_resume_normal"], "clock": "clk_eth_mac", "attempts_left": 10, "sva_result": "@(posedge clk_eth_mac) disable iff (!eth_mac_reset_n)     eth_pause_frame_received |-> ##[1:2] eth_tx_pause_enable ##[16:32] eth_tx_resume_normal;", "sva_name": "p_mac_pause_resume_sequence", "full_property": "property p_Ethernet_Mac_Flow_Control;\n@(posedge clk_eth_mac) disable iff (!eth_mac_reset_n)     eth_pause_frame_received |-> ##[1:2] eth_tx_pause_enable ##[16:32] eth_tx_resume_normal;\nendproperty\nassert_p_Ethernet_Mac_Flow_Control:assert property (p_Ethernet_Mac_Flow_Control) else $error(\"\");", "task_id": "4_4414", "predict_sva": "@(posedge clk_eth_mac) disable iff (!eth_mac_reset_n)         (eth_mac_reset_n == 1 && eth_pause_frame_received == 1) |->          (##[1:2] eth_tx_pause_enable == 1) ##[16:32] eth_tx_resume_normal == 1"}
{"id": "2_11_0003", "name": "mem_write_check_11", "sva": "@(posedge clk_mem)      $rose(wr_en) |-> ##[2:10] wr_ack ##[1:2] $stable(wr_data)", "ori_sva": "property mem_write_check_11;\n@(posedge clk_mem)      $rose(wr_en) |-> ##[2:10] wr_ack ##[1:2] $stable(wr_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mem_write_check_11  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(wr_en)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:10] wr_ack ##[1:2] $stable(wr_data)`  ", "sva_signals": ["clk_mem", "wr_en", "[0:0] wr_ack", "wr_data"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)         $rose(wr_en) |-> ##[2:10] wr_ack ##[1:2] $stable(wr_data);", "sva_name": "p_wr_ack_and_wr_data_stability_after_wr_en", "full_property": "property p_mem_write_check_11;\n@(posedge clk_mem)         $rose(wr_en) |-> ##[2:10] wr_ack ##[1:2] $stable(wr_data);\nendproperty\nassert_p_mem_write_check_11:assert property (p_mem_write_check_11) else $error(\"\");", "task_id": "4_4487", "predict_sva": "@(posedge clk_mem)         $rose(wr_en) |-> ##[2:10] wr_ack ##[1:2] $stable(wr_data)"}
{"id": "2_27_0045", "name": "spi_transfer_check_27", "sva": "@(posedge clk_spi)      $rose(cs_n) |-> ##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode)", "ori_sva": "property spi_transfer_check_27;\n@(posedge clk_spi)      $rose(cs_n) |-> ##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_transfer_check_27  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(cs_n)` (a rising edge on `cs_n`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode)`  \n- After the rising edge of `cs_n`, within **8 to 32 clock cycles**, `cs_n` must fall (`$fell(cs_n)`).  \n- Then, within **1 to 3 clock cycles**, `spi_mode` must remain stable (`$stable(spi_mode)`).  ", "sva_signals": ["clk_spi", "cs_n", "[0:0] spi_mode"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi)     $rose(cs_n) |-> ##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode);", "sva_name": "p_cs_n_fall_and_spi_mode_stability", "full_property": "property p_spi_transfer_check_27;\n@(posedge clk_spi)     $rose(cs_n) |-> ##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode);\nendproperty\nassert_p_spi_transfer_check_27:assert property (p_spi_transfer_check_27) else $error(\"\");", "task_id": "4_4503", "predict_sva": "@(posedge clk_spi)         $rose(cs_n) |-> ##[8:32] $fell(cs_n) ##[1:3] $stable(spi_mode)"}
{"id": "2_43_0096", "name": "mipi_packet_check_43", "sva": "@(posedge clk_mipi)      $rose(pkt_start) |-> ##[4:32] pkt_end ##[1:2] $stable(pkt_type)", "ori_sva": "property mipi_packet_check_43;\n@(posedge clk_mipi)      $rose(pkt_start) |-> ##[4:32] pkt_end ##[1:2] $stable(pkt_type)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_mipi_packet_check_43  \n**Trigger Condition**: At every rising edge of the `clk_mipi`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(pkt_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:32] pkt_end ##[1:2] $stable(pkt_type)`  ", "sva_signals": ["clk_mipi", "[0:0] pkt_start", "[0:0] pkt_end", "[0:0] pkt_type"], "clock": "clk_mipi", "attempts_left": 10, "sva_result": "@(posedge clk_mipi)     $rose(pkt_start) |-> ##[4:32] pkt_end ##[1:2] $stable(pkt_type);", "sva_name": "p_pkt_end_and_pkt_type_stability_after_pkt_start", "full_property": "property p_mipi_packet_check_43;\n@(posedge clk_mipi)     $rose(pkt_start) |-> ##[4:32] pkt_end ##[1:2] $stable(pkt_type);\nendproperty\nassert_p_mipi_packet_check_43:assert property (p_mipi_packet_check_43) else $error(\"\");", "task_id": "4_4523", "predict_sva": "@(posedge clk_mipi)         $rose(pkt_start) |-> ##[4:32] pkt_end ##[1:2] $stable(pkt_type)"}
{"id": "3_16_0111", "name": "thermal_throttle_check_16", "sva": "@(posedge clk_temp)      overtemp_alert |-> ##1 frequency_reduced ##2 voltage_reduced", "ori_sva": "property thermal_throttle_check_16;\n@(posedge clk_temp)      overtemp_alert |-> ##1 frequency_reduced ##2 voltage_reduced\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Throttle_Check_16  \n**Trigger Condition**: At every rising edge of the `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `overtemp_alert`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 frequency_reduced ##2 voltage_reduced`  ", "sva_signals": ["clk_temp", "[0:0] overtemp_alert", "[0:0] frequency_reduced", "[0:0] voltage_reduced"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     overtemp_alert |-> ##1 frequency_reduced ##2 voltage_reduced;", "sva_name": "p_overtemp_alert_frequency_voltage_reduced", "full_property": "property p_Thermal_Throttle_Check_16;\n@(posedge clk_temp)     overtemp_alert |-> ##1 frequency_reduced ##2 voltage_reduced;\nendproperty\nassert_p_Thermal_Throttle_Check_16:assert property (p_Thermal_Throttle_Check_16) else $error(\"\");", "task_id": "4_4537", "predict_sva": "@(posedge clk_temp)         overtemp_alert == 1 |-> ##1 frequency_reduced == 1 ##2 voltage_reduced == 1"}
{"id": "3_18_0126", "name": "memory_refresh_check_18", "sva": "@(posedge clk_dram)      refresh_required |-> ##[7:9] refresh_active && !access_granted", "ori_sva": "property memory_refresh_check_18;\n@(posedge clk_dram)      refresh_required |-> ##[7:9] refresh_active && !access_granted\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_memory_refresh_check_18  \n**Trigger Condition**: At every rising edge of the `clk_dram`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `refresh_required`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[7:9] refresh_active && !access_granted`  ", "sva_signals": ["clk_dram", "[0:0] refresh_required", "[0:0] refresh_active", "[0:0] access_granted"], "clock": "clk_dram", "attempts_left": 10, "sva_result": "@(posedge clk_dram)     refresh_required |-> ##[7:9] (refresh_active && !access_granted);", "sva_name": "p_refresh_active_and_access_granted_on_refresh_required", "full_property": "property p_memory_refresh_check_18;\n@(posedge clk_dram)     refresh_required |-> ##[7:9] (refresh_active && !access_granted);\nendproperty\nassert_p_memory_refresh_check_18:assert property (p_memory_refresh_check_18) else $error(\"\");", "task_id": "4_4538", "predict_sva": "@(posedge clk_dram)         refresh_required == 1 |-> ##[7:9] (refresh_active == 1 && access_granted == 0)"}
{"id": "6_9_0239", "name": "fifo_flow_control_check", "sva": "@(posedge clk_fifo)     fifo_not_full |-> data_in_valid[*1:4] ##1 fifo_write_enable[*2:3]", "ori_sva": "property fifo_flow_control_check;\n@(posedge clk_fifo)     fifo_not_full |-> data_in_valid[*1:4] ##1 fifo_write_enable[*2:3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_flow_control_check  \n**Trigger Condition**: At every rising edge of the `clk_fifo`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_not_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `data_in_valid[*1:4] ##1 fifo_write_enable[*2:3]`  ", "sva_signals": ["clk_fifo", "rst_n", "[0:0] fifo_not_full", "[0:0] data_in_valid", "[0:0] fifo_write_enable"], "clock": "clk_fifo", "attempts_left": 10, "sva_result": "@(posedge clk_fifo)         fifo_not_full |-> data_in_valid[*1:4] ##1 fifo_write_enable[*2:3];", "sva_name": "p_fifo_not_full_data_in_valid_write_enable_sequence", "full_property": "property p_fifo_flow_control_check;\n@(posedge clk_fifo)         fifo_not_full |-> data_in_valid[*1:4] ##1 fifo_write_enable[*2:3];\nendproperty\nassert_p_fifo_flow_control_check:assert property (p_fifo_flow_control_check) else $error(\"\");", "task_id": "4_4661", "predict_sva": "@(posedge clk_fifo)         fifo_not_full == 1 |->      (data_in_valid [*1:4]) ##1 (fifo_write_enable [*2:3])"}
{"id": "9_24_0437", "name": "stable_with_conditional_stable", "sva": "@(negedge clk_cond)      cond_met |-> $stable(cond_data_a) || $stable(cond_data_b)", "ori_sva": "property stable_with_conditional_stable;\n@(negedge clk_cond)      cond_met |-> $stable(cond_data_a) || $stable(cond_data_b)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_with_conditional_stable  \n**Trigger Condition**: At every falling edge of the `clk_cond`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cond_met`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(cond_data_a) || $stable(cond_data_b)`  \n\n(Note: The property checks that whenever `cond_met` is true at the falling edge of `clk_cond`, either `cond_data_a` or `cond_data_b` must remain stable compared to their previous values.)", "sva_signals": ["clk", "rst_n", "[0:0] cond_met", "[0:0] cond_data_a", "[0:0] cond_data_b", "clk_cond"], "clock": "clk_cond", "attempts_left": 10, "sva_result": "@(negedge clk_cond)     cond_met |-> ($stable(cond_data_a) || $stable(cond_data_b));", "sva_name": "p_cond_met_stable_data", "full_property": "property p_stable_with_conditional_stable;\n@(negedge clk_cond)     cond_met |-> ($stable(cond_data_a) || $stable(cond_data_b));\nendproperty\nassert_p_stable_with_conditional_stable:assert property (p_stable_with_conditional_stable) else $error(\"\");", "task_id": "4_4765", "predict_sva": "@(negedge clk_cond)     cond_met == 1'b1 |-> ($stable(cond_data_a) || $stable(cond_data_b))"}
{"id": "9_46_0416", "name": "stable_with_clock_mux_check", "sva": "@(posedge clk_mux)      mux_select |-> $stable(mux_data_a) or $stable(mux_data_b)", "ori_sva": "property stable_with_clock_mux_check;\n@(posedge clk_mux)      mux_select |-> $stable(mux_data_a) or $stable(mux_data_b)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_stable_with_clock_mux_check  \n**Trigger Condition**: At every rising edge of the `clk_mux`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `mux_select == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$stable(mux_data_a) or $stable(mux_data_b)`  \n\n", "sva_signals": ["clk_mux", "[0:0] mux_select", "[0:0] mux_data_a", "[0:0] mux_data_b"], "clock": "clk_mux", "attempts_left": 10, "sva_result": "@(posedge clk_mux)     mux_select == 1'b1 |-> ($stable(mux_data_a) || $stable(mux_data_b));", "sva_name": "p_mux_select_stable_data", "full_property": "property p_stable_with_clock_mux_check;\n@(posedge clk_mux)     mux_select == 1'b1 |-> ($stable(mux_data_a) || $stable(mux_data_b));\nendproperty\nassert_p_stable_with_clock_mux_check:assert property (p_stable_with_clock_mux_check) else $error(\"\");", "task_id": "4_4783", "predict_sva": "@(posedge clk_mux)     mux_select == 1'b1 |-> $stable(mux_data_a) || $stable(mux_data_b)"}
{"id": "10_3_0450", "name": "dma_start_past_config_check", "sva": "@(posedge clk_dma)      $fell(dma_start) |-> $past(dma_cfg_valid,2) && $past(dma_mode[1:0],3) == 2'b01", "ori_sva": "property dma_start_past_config_check;\n@(posedge clk_dma)      $fell(dma_start) |-> $past(dma_cfg_valid,2) && $past(dma_mode[1:0],3) == 2'b01\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Dma_Start_Past_Config_Check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(dma_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(dma_cfg_valid, 2) && $past(dma_mode[1:0], 3) == 2'b01`", "sva_signals": ["clk_dma", "dma_start", "[0:0] dma_cfg_valid", "[1:0] dma_mode"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma)     $fell(dma_start) |-> $past(dma_cfg_valid, 2) && ($past(dma_mode[1:0], 3) == 2'b01);", "sva_name": "p_dma_start_fall_cfg_valid_mode_check", "full_property": "property p_Dma_Start_Past_Config_Check;\n@(posedge clk_dma)     $fell(dma_start) |-> $past(dma_cfg_valid, 2) && ($past(dma_mode[1:0], 3) == 2'b01);\nendproperty\nassert_p_Dma_Start_Past_Config_Check:assert property (p_Dma_Start_Past_Config_Check) else $error(\"\");", "task_id": "4_4824", "predict_sva": "@(posedge clk_dma)         $fell(dma_start) |-> ($past(dma_cfg_valid, 2) && ($past(dma_mode[1:0] == 2'b01, 3)))"}
{"id": "10_9_0463", "name": "rx_overflow_past_write_check", "sva": "@(posedge clk_serial)      rx_overflow |-> $past(rx_write,2) && $past(rx_full,1) ##[1:3] $past(fifo_clear,3)", "ori_sva": "property rx_overflow_past_write_check;\n@(posedge clk_serial)      rx_overflow |-> $past(rx_write,2) && $past(rx_full,1) ##[1:3] $past(fifo_clear,3)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rx_overflow_past_write_check  \n**Trigger Condition**: At every rising edge of the `clk_serial`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `rx_overflow`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(rx_write, 2) && $past(rx_full, 1) ##[1:3] $past(fifo_clear, 3)`  ", "sva_signals": ["clk_serial", "rst_n", "[0:0] rx_overflow", "[0:0] rx_write", "[0:0] rx_full", "[0:0] fifo_clear"], "clock": "clk_serial", "attempts_left": 10, "sva_result": "@(posedge clk_serial)     rx_overflow |-> $past(rx_write, 2) && $past(rx_full, 1) ##[1:3] $past(fifo_clear, 3);", "sva_name": "p_rx_overflow_sequence_check", "full_property": "property p_rx_overflow_past_write_check;\n@(posedge clk_serial)     rx_overflow |-> $past(rx_write, 2) && $past(rx_full, 1) ##[1:3] $past(fifo_clear, 3);\nendproperty\nassert_p_rx_overflow_past_write_check:assert property (p_rx_overflow_past_write_check) else $error(\"\");", "task_id": "4_4841", "predict_sva": "@(posedge clk_serial)         rx_overflow == 1 |-> $past(rx_write, 2) == 1 && $past(rx_full, 1) == 1 && ##[1:3] $past(fifo_clear, 3) == 1"}
{"id": "11_4_0496", "name": "cache_tag_match_hit", "sva": "@(posedge clk_mem)     (cache_hit && (tag_array == $past(tag_compare,2))) |-> ##2 valid_data && !cache_miss", "ori_sva": "property cache_tag_match_hit;\n@(posedge clk_mem)     (cache_hit && (tag_array == $past(tag_compare,2))) |-> ##2 valid_data && !cache_miss\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_cache_tag_match_hit  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_hit && (tag_array == $past(tag_compare, 2))`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 valid_data && !cache_miss`  ", "sva_signals": ["clk_mem", "rst_n", "[0:0] cache_hit", "[0:0] valid_data", "[0:0] cache_miss", "[0:0] tag_array", "[0:0] tag_compare"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)         (cache_hit && (tag_array == $past(tag_compare, 2))) |-> ##2 (valid_data && !cache_miss);", "sva_name": "p_cache_hit_tag_compare_valid_data", "full_property": "property p_cache_tag_match_hit;\n@(posedge clk_mem)         (cache_hit && (tag_array == $past(tag_compare, 2))) |-> ##2 (valid_data && !cache_miss);\nendproperty\nassert_p_cache_tag_match_hit:assert property (p_cache_tag_match_hit) else $error(\"\");", "task_id": "4_4874", "predict_sva": "@(posedge clk_mem)         (cache_hit == 1 && tag_array == $past(tag_compare, 2)) |-> ##2 (valid_data == 1 && cache_miss == 0)"}
{"id": "12_17_0588", "name": "frame_sync_or_reset_check_17", "sva": "@(posedge clk_audio)      (frame_sync_pulse || codec_reset) |-> ##1 $fell(data_ready)", "ori_sva": "property frame_sync_or_reset_check_17;\n@(posedge clk_audio)      (frame_sync_pulse || codec_reset) |-> ##1 $fell(data_ready)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_frame_sync_or_reset_check  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_sync_pulse || codec_reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(data_ready)`", "sva_signals": ["clk_audio", "codec_reset", "[0:0] frame_sync_pulse", "[0:0] data_ready"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     (frame_sync_pulse || codec_reset) |-> ##1 $fell(data_ready);", "sva_name": "p_data_ready_fall_on_sync_or_reset", "full_property": "property p_frame_sync_or_reset_check;\n@(posedge clk_audio)     (frame_sync_pulse || codec_reset) |-> ##1 $fell(data_ready);\nendproperty\nassert_p_frame_sync_or_reset_check:assert property (p_frame_sync_or_reset_check) else $error(\"\");", "task_id": "4_4887", "predict_sva": "@(posedge clk_audio)         (frame_sync_pulse == 1 || codec_reset == 1) |-> ##1 $fell(data_ready)"}
{"id": "13_10_0619", "name": "not_clock_gate_active_phase_check", "sva": "@(posedge clk_core) !clock_gate_enable |-> ##1 phase_alignment && !skew_detected", "ori_sva": "property not_clock_gate_active_phase_check;\n@(posedge clk_core) !clock_gate_enable |-> ##1 phase_alignment && !skew_detected\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Clock_Gate_Active_Phase_Check  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!clock_gate_enable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 phase_alignment && !skew_detected`", "sva_signals": ["clk_core", "[0:0] clock_gate_enable", "[0:0] phase_alignment", "[0:0] skew_detected"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     !clock_gate_enable |-> ##1 (phase_alignment && !skew_detected);", "sva_name": "p_phase_alignment_and_no_skew_when_gate_disabled", "full_property": "property p_Not_Clock_Gate_Active_Phase_Check;\n@(posedge clk_core)     !clock_gate_enable |-> ##1 (phase_alignment && !skew_detected);\nendproperty\nassert_p_Not_Clock_Gate_Active_Phase_Check:assert property (p_Not_Clock_Gate_Active_Phase_Check) else $error(\"\");", "task_id": "4_4921", "predict_sva": "@(posedge clk_core)         clock_gate_enable == 0 |-> ##1 (phase_alignment == 1 && skew_detected == 0)"}
{"id": "13_44_0632", "name": "not_linearity_error_correction_check", "sva": "@(posedge clk_corr) !linearity_error_detected |-> ##2 correction_applied && !temperature_drift", "ori_sva": "property not_linearity_error_correction_check;\n@(posedge clk_corr) !linearity_error_detected |-> ##2 correction_applied && !temperature_drift\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Not_Linearity_Error_Correction_Check  \n**Trigger Condition**: At every rising edge of the `clk_corr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!linearity_error_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 correction_applied && !temperature_drift`", "sva_signals": ["clk_corr", "rst_n", "[0:0] linearity_error_detected", "[0:0] correction_applied", "[0:0] temperature_drift"], "clock": "clk_corr", "attempts_left": 10, "sva_result": "@(posedge clk_corr)     !linearity_error_detected |-> ##2 (correction_applied && !temperature_drift);", "sva_name": "p_no_linearity_error_correction_applied", "full_property": "property p_Not_Linearity_Error_Correction_Check;\n@(posedge clk_corr)     !linearity_error_detected |-> ##2 (correction_applied && !temperature_drift);\nendproperty\nassert_p_Not_Linearity_Error_Correction_Check:assert property (p_Not_Linearity_Error_Correction_Check) else $error(\"\");", "task_id": "4_4958", "predict_sva": "@(posedge clk_corr)         linearity_error_detected == 0 |-> ##2 (correction_applied == 1 && temperature_drift == 0)"}
{"id": "15_11_0725", "name": "error_correction_check", "sva": "@(posedge clk_ecc) disable iff(ecc_reset)     ecc_trigger |-> ##2 ecc_corrected[*2] ##1 ecc_clean", "ori_sva": "property error_correction_check;\n@(posedge clk_ecc) disable iff(ecc_reset)     ecc_trigger |-> ##2 ecc_corrected[*2] ##1 ecc_clean\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_error_correction_check  \n**Trigger Condition**: At every rising edge of the `clk_ecc`  \n**Disable Condition**: disable iff (`ecc_reset`)  \n**Antecedent (LHS of Implication)**: `ecc_trigger == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 ecc_corrected[*2] ##1 ecc_clean`  ", "sva_signals": ["clk_ecc", "ecc_reset", "[0:0] ecc_trigger", "[0:0] ecc_corrected", "[0:0] ecc_clean"], "clock": "clk_ecc", "attempts_left": 10, "sva_result": "@(posedge clk_ecc) disable iff (ecc_reset)     ecc_trigger == 1'b1 |-> ##2 ecc_corrected[*2] ##1 ecc_clean;", "sva_name": "p_ecc_correction_and_clean_sequence", "full_property": "property p_error_correction_check;\n@(posedge clk_ecc) disable iff (ecc_reset)     ecc_trigger == 1'b1 |-> ##2 ecc_corrected[*2] ##1 ecc_clean;\nendproperty\nassert_p_error_correction_check:assert property (p_error_correction_check) else $error(\"\");", "task_id": "4_4974", "predict_sva": "@(posedge clk_ecc) disable iff (ecc_reset)         (ecc_reset == 0 && ecc_trigger == 1'b1) |-> ##2 (ecc_corrected [*2]) ##1 ecc_clean"}
{"id": "15_12_0697", "name": "dma_transfer_check", "sva": "@(posedge clk_dma) disable iff(dma_reset)     dma_start |-> ##[3:7] dma_active ##1 dma_done", "ori_sva": "property dma_transfer_check;\n@(posedge clk_dma) disable iff(dma_reset)     dma_start |-> ##[3:7] dma_active ##1 dma_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_dma_transfer_check  \n**Trigger Condition**: At every rising edge of the `clk_dma`  \n**Disable Condition**: disable iff (`dma_reset`)  \n**Antecedent (LHS of Implication)**: `dma_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:7] dma_active ##1 dma_done`  ", "sva_signals": ["clk_dma", "dma_reset", "[0:0] dma_start", "[0:0] dma_active", "[0:0] dma_done"], "clock": "clk_dma", "attempts_left": 10, "sva_result": "@(posedge clk_dma) disable iff (dma_reset)     dma_start == 1'b1 |-> ##[3:7] dma_active ##1 dma_done;", "sva_name": "p_dma_start_to_active_to_done_sequence", "full_property": "property p_dma_transfer_check;\n@(posedge clk_dma) disable iff (dma_reset)     dma_start == 1'b1 |-> ##[3:7] dma_active ##1 dma_done;\nendproperty\nassert_p_dma_transfer_check:assert property (p_dma_transfer_check) else $error(\"\");", "task_id": "4_4975", "predict_sva": "@(posedge clk_dma) disable iff (dma_reset)         (dma_reset == 0 && dma_start == 1'b1) |-> ##[3:7] dma_active == 1'b1 ##1 dma_done == 1'b1"}
{"id": "15_27_0726", "name": "spi_transfer_check", "sva": "@(posedge clk_spi) disable iff(spi_reset)     cs_assert |-> ##[4:6] data_valid ##1 cs_deassert", "ori_sva": "property spi_transfer_check;\n@(posedge clk_spi) disable iff(spi_reset)     cs_assert |-> ##[4:6] data_valid ##1 cs_deassert\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_spi_transfer_check  \n**Trigger Condition**: At every rising edge of the `clk_spi`  \n**Disable Condition**: disable iff (`spi_reset`)  \n**Antecedent (LHS of Implication)**: `cs_assert`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:6] data_valid ##1 cs_deassert`  \n\n**Explanation of Consequent**:  \n- `##[4:6] data_valid`: After the antecedent (`cs_assert`) is true, `data_valid` must occur between 4 to 6 clock cycles later.  \n- `##1 cs_deassert`: One clock cycle after `data_valid` is detected, `cs_deassert` must be true.  \n\nThis assertion ensures that during an SPI transfer:  \n1. When `cs_assert` is active, the SPI data (`data_valid`) becomes valid within 4 to 6 clock cycles.  \n2. The chip select (`cs_deassert`) is deactivated one cycle after the data is valid.  \n3. The check is disabled if `spi_reset` is asserted.", "sva_signals": ["clk_spi", "spi_reset", "[0:0] cs_assert", "[0:0] data_valid", "[0:0] cs_deassert"], "clock": "clk_spi", "attempts_left": 10, "sva_result": "@(posedge clk_spi) disable iff (spi_reset)     cs_assert |-> ##[4:6] data_valid ##1 cs_deassert;", "sva_name": "p_spi_data_valid_and_cs_deassertion_sequence", "full_property": "property p_spi_transfer_check;\n@(posedge clk_spi) disable iff (spi_reset)     cs_assert |-> ##[4:6] data_valid ##1 cs_deassert;\nendproperty\nassert_p_spi_transfer_check:assert property (p_spi_transfer_check) else $error(\"\");", "task_id": "4_4989", "predict_sva": "@(posedge clk_spi) disable iff (spi_reset)         (spi_reset == 0 && cs_assert == 1) |-> ##[4:6] data_valid == 1 ##1 cs_deassert == 1"}
{"id": "15_29_0724", "name": "can_bus_check", "sva": "@(posedge clk_can) disable iff(can_reset)     frame_start |-> ##[6:9] ack_field ##1 frame_end", "ori_sva": "property can_bus_check;\n@(posedge clk_can) disable iff(can_reset)     frame_start |-> ##[6:9] ack_field ##1 frame_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_can_bus_check  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: disable iff (`can_reset`)  \n**Antecedent (LHS of Implication)**: `frame_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[6:9] ack_field ##1 frame_end`  ", "sva_signals": ["clk_can", "can_reset", "[0:0] frame_start", "[0:0] ack_field", "[0:0] frame_end"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can) disable iff (can_reset)     frame_start |-> ##[6:9] ack_field ##1 frame_end;", "sva_name": "p_frame_start_ack_field_frame_end_sequence", "full_property": "property p_can_bus_check;\n@(posedge clk_can) disable iff (can_reset)     frame_start |-> ##[6:9] ack_field ##1 frame_end;\nendproperty\nassert_p_can_bus_check:assert property (p_can_bus_check) else $error(\"\");", "task_id": "4_4990", "predict_sva": "@(posedge clk_can) disable iff (can_reset)         (frame_start == 1 && can_reset == 0) |-> ##[6:9] (ack_field == 1) ##1 (frame_end == 1)"}
{"id": "15_32_0746", "name": "ethernet_crc_check", "sva": "@(posedge clk_eth) disable iff(eth_reset)     frame_valid |-> ##[12:16] crc_check ##1 frame_done", "ori_sva": "property ethernet_crc_check;\n@(posedge clk_eth) disable iff(eth_reset)     frame_valid |-> ##[12:16] crc_check ##1 frame_done\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_ethernet_crc_check  \n**Trigger Condition**: At every rising edge of the `clk_eth`  \n**Disable Condition**: disable iff (`eth_reset`)  \n**Antecedent (LHS of Implication)**: `frame_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[12:16] crc_check ##1 frame_done`  ", "sva_signals": ["clk_eth", "eth_reset", "[0:0] frame_valid", "[0:0] crc_check", "[0:0] frame_done"], "clock": "clk_eth", "attempts_left": 10, "sva_result": "@(posedge clk_eth) disable iff (eth_reset)     frame_valid == 1'b1 |-> ##[12:16] crc_check ##1 frame_done;", "sva_name": "p_frame_valid_crc_check_frame_done_sequence", "full_property": "property p_ethernet_crc_check;\n@(posedge clk_eth) disable iff (eth_reset)     frame_valid == 1'b1 |-> ##[12:16] crc_check ##1 frame_done;\nendproperty\nassert_p_ethernet_crc_check:assert property (p_ethernet_crc_check) else $error(\"\");", "task_id": "4_4995", "predict_sva": "@(posedge clk_eth) disable iff (eth_reset)         (eth_reset == 0 && frame_valid == 1'b1) |-> ##[12:16] (crc_check == 1'b1) ##1 (frame_done == 1'b1)"}
{"id": "2_35_0083", "name": "fifo_overflow_protection_check_35", "sva": "@(posedge clk_stream)      fifo_almost_full |-> ##[1:3] backpressure_asserted || overflow_error", "ori_sva": "property fifo_overflow_protection_check_35;\n@(posedge clk_stream)      fifo_almost_full |-> ##[1:3] backpressure_asserted || overflow_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_fifo_overflow_protection_check  \n**Trigger Condition**: At every rising edge of the `clk_stream`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_almost_full`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] backpressure_asserted || overflow_error`  ", "sva_signals": ["clk_stream", "[0:0] fifo_almost_full", "[0:0] backpressure_asserted", "[0:0] overflow_error"], "clock": "clk_stream", "attempts_left": 10, "sva_result": "@(posedge clk_stream)         fifo_almost_full |-> ##[1:3] (backpressure_asserted || overflow_error);", "sva_name": "p_fifo_almost_full_overflow_protection", "full_property": "property p_fifo_overflow_protection_check;\n@(posedge clk_stream)         fifo_almost_full |-> ##[1:3] (backpressure_asserted || overflow_error);\nendproperty\nassert_p_fifo_overflow_protection_check:assert property (p_fifo_overflow_protection_check) else $error(\"\");", "task_id": "4_5084", "predict_sva": "@(posedge clk_stream)         fifo_almost_full == 1 |-> ##[1:3] (backpressure_asserted == 1 || overflow_error == 1)"}
{"id": "3_13_0112", "name": "multi_bit_error_detection_13", "sva": "@(posedge clk_ecc)      uncorrectable_error |-> ##[2:3] system_halt ##1 error_logged", "ori_sva": "property multi_bit_error_detection_13;\n@(posedge clk_ecc)      uncorrectable_error |-> ##[2:3] system_halt ##1 error_logged\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_multi_bit_error_detection_13  \n**Trigger Condition**: At every rising edge of the `clk_ecc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `uncorrectable_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:3] system_halt ##1 error_logged`  ", "sva_signals": ["clk", "rst_n", "[0:0] uncorrectable_error", "[0:0] system_halt", "[0:0] error_logged", "clk_ecc"], "clock": "clk_ecc", "attempts_left": 10, "sva_result": "@(posedge clk_ecc)     uncorrectable_error == 1'b1 |-> ##[2:3] system_halt ##1 error_logged;", "sva_name": "p_uncorrectable_error_halt_and_log", "full_property": "property p_multi_bit_error_detection_13;\n@(posedge clk_ecc)     uncorrectable_error == 1'b1 |-> ##[2:3] system_halt ##1 error_logged;\nendproperty\nassert_p_multi_bit_error_detection_13:assert property (p_multi_bit_error_detection_13) else $error(\"\");", "task_id": "4_5106", "predict_sva": "@(posedge clk_ecc)         uncorrectable_error == 1'b1 |-> ##[2:3] (system_halt == 1'b1) ##1 (error_logged == 1'b1)"}
{"id": "6_34_0279", "name": "thermal_sensor_response_34", "sva": "@(posedge clk_thermal)      temp_rising[*2:4] |-> ##[3:6] fan_speed_increase", "ori_sva": "property thermal_sensor_response_34;\n@(posedge clk_thermal)      temp_rising[*2:4] |-> ##[3:6] fan_speed_increase\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Thermal_Sensor_Response_34  \n**Trigger Condition**: At every rising edge of the `clk_thermal`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_rising` occurs consecutively 2 to 4 times (`temp_rising[*2:4]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: After 3 to 6 clock cycles (`##[3:6]`), `fan_speed_increase` must be true.  ", "sva_signals": ["clk_thermal", "[0:0] temp_rising", "[0:0] fan_speed_increase"], "clock": "clk_thermal", "attempts_left": 10, "sva_result": "@(posedge clk_thermal)     temp_rising[*2:4] |-> ##[3:6] fan_speed_increase;", "sva_name": "p_fan_speed_increase_after_temp_rising", "full_property": "property p_Thermal_Sensor_Response_34;\n@(posedge clk_thermal)     temp_rising[*2:4] |-> ##[3:6] fan_speed_increase;\nendproperty\nassert_p_Thermal_Sensor_Response_34:assert property (p_Thermal_Sensor_Response_34) else $error(\"\");", "task_id": "4_5245", "predict_sva": "@(posedge clk_thermal)         (temp_rising [*2:4]) |-> ##[3:6] fan_speed_increase"}
{"id": "7_46_0349", "name": "rise_with_delayed_sequence_check", "sva": "@(posedge clk_delseq) $rose(delseq_trigger) |-> ##5 delseq_ack ##2 delseq_data_valid ##1 delseq_complete", "ori_sva": "property rise_with_delayed_sequence_check;\n@(posedge clk_delseq) $rose(delseq_trigger) |-> ##5 delseq_ack ##2 delseq_data_valid ##1 delseq_complete;\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_rise_with_delayed_sequence_check  \n**Trigger Condition**: At every rising edge of the `clk_delseq`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(delseq_trigger)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 delseq_ack ##2 delseq_data_valid ##1 delseq_complete`  ", "sva_signals": ["clk_delseq", "[0:0] delseq_trigger", "[0:0] delseq_ack", "[0:0] delseq_data_valid", "[0:0] delseq_complete"], "clock": "clk_delseq", "attempts_left": 10, "sva_result": "@(posedge clk_delseq)     $rose(delseq_trigger) |-> ##5 delseq_ack ##2 delseq_data_valid ##1 delseq_complete;", "sva_name": "p_delseq_trigger_ack_data_complete", "full_property": "property p_rise_with_delayed_sequence_check;\n@(posedge clk_delseq)     $rose(delseq_trigger) |-> ##5 delseq_ack ##2 delseq_data_valid ##1 delseq_complete;\nendproperty\nassert_p_rise_with_delayed_sequence_check:assert property (p_rise_with_delayed_sequence_check) else $error(\"\");", "task_id": "4_5300", "predict_sva": "@(posedge clk_delseq)         $rose(delseq_trigger) |-> ##5 delseq_ack == 1 ##2 delseq_data_valid == 1 ##1 delseq_complete == 1"}
{"id": "10_29_0486", "name": "historical_watchdog_timeout_check", "sva": "@(posedge clk_wdt)      $past(wdt_armed, 7) |-> $past(wdt_refreshed, 4) || $past(wdt_timeout, 2)", "ori_sva": "property historical_watchdog_timeout_check;\n@(posedge clk_wdt)      $past(wdt_armed, 7) |-> $past(wdt_refreshed, 4) || $past(wdt_timeout, 2)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: historical_watchdog_timeout_check  \n**Trigger Condition**: At every rising edge of the `clk_wdt`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(wdt_armed, 7)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(wdt_refreshed, 4) || $past(wdt_timeout, 2)`  ", "sva_signals": ["clk_wdt", "wdt_armed", "wdt_refreshed", "wdt_timeout"], "clock": "clk_wdt", "attempts_left": 10, "sva_result": "@(posedge clk_wdt)     $past(wdt_armed, 7) |-> ($past(wdt_refreshed, 4) || $past(wdt_timeout, 2));", "sva_name": "p_wdt_refresh_or_timeout_after_armed", "full_property": "property historical_watchdog_timeout_check;\n@(posedge clk_wdt)     $past(wdt_armed, 7) |-> ($past(wdt_refreshed, 4) || $past(wdt_timeout, 2));\nendproperty\nassert_historical_watchdog_timeout_check:assert property (historical_watchdog_timeout_check) else $error(\"\");", "task_id": "4_5371", "predict_sva": "@(posedge clk_wdt)         $past(wdt_armed, 7) |-> ($past(wdt_refreshed, 4) || $past(wdt_timeout, 2))"}
{"id": "10_49_0488", "name": "historical_power_cycle_count_check", "sva": "@(posedge clk_pmon)      $past(power_cycle, 8) > 1000 |-> $past(eol_warning, 2) || $past(degredation_mode, 1)", "ori_sva": "property historical_power_cycle_count_check;\n@(posedge clk_pmon)      $past(power_cycle, 8) > 1000 |-> $past(eol_warning, 2) || $past(degredation_mode, 1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: historical_power_cycle_count_check  \n**Trigger Condition**: At every rising edge of the `clk_pmon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(power_cycle, 8) > 1000`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(eol_warning, 2) || $past(degredation_mode, 1)`  ", "sva_signals": ["clk_pmon", "[0:0] power_cycle", "[0:0] eol_warning", "[0:0] degredation_mode"], "clock": "clk_pmon", "attempts_left": 10, "sva_result": "@(posedge clk_pmon)     $past(power_cycle, 8) > 1000 |-> $past(eol_warning, 2) || $past(degredation_mode, 1);", "sva_name": "p_power_cycle_eol_or_degradation", "full_property": "property historical_power_cycle_count_check;\n@(posedge clk_pmon)     $past(power_cycle, 8) > 1000 |-> $past(eol_warning, 2) || $past(degredation_mode, 1);\nendproperty\nassert_historical_power_cycle_count_check:assert property (historical_power_cycle_count_check) else $error(\"\");", "task_id": "4_5387", "predict_sva": "@(posedge clk_pmon)         $past(power_cycle, 8) > 1000 |-> ($past(eol_warning, 2) == 1) || ($past(degredation_mode, 1) == 1)"}
{"id": "10_50_0497", "name": "delayed_memory_test_check", "sva": "@(posedge clk_mem)      $past(mem_test_start, 3) |-> ##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1))", "ori_sva": "property delayed_memory_test_check;\n@(posedge clk_mem)      $past(mem_test_start, 3) |-> ##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: delayed_memory_test_check  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(mem_test_start, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1))`  ", "sva_signals": ["clk_mem", "rst_n", "[0:0] mem_test_start", "[0:0] mem_test_done", "[0:0] mem_test_pass"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)         $past(mem_test_start, 3) |-> ##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1));", "sva_name": "p_mem_test_start_done_pass_sequence", "full_property": "property delayed_memory_test_check;\n@(posedge clk_mem)         $past(mem_test_start, 3) |-> ##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1));\nendproperty\nassert_delayed_memory_test_check:assert property (delayed_memory_test_check) else $error(\"\");", "task_id": "4_5388", "predict_sva": "@(posedge clk_mem)         $past(mem_test_start, 3) |-> ##1 ($past(mem_test_done, 2) && $past(mem_test_pass, 1))"}
{"id": "10_6_0457", "name": "delayed_credit_update_verify", "sva": "@(posedge clk_tx)      $past(tx_credit, 7) < $past(tx_credit_thresh, 5) |-> ##1 ($past(rx_credit_update, 3) || credit_overflow)", "ori_sva": "property delayed_credit_update_verify;\n@(posedge clk_tx)      $past(tx_credit, 7) < $past(tx_credit_thresh, 5) |-> ##1 ($past(rx_credit_update, 3) || credit_overflow)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: delayed_credit_update_verify  \n**Trigger Condition**: At every rising edge of the `clk_tx`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(tx_credit, 7) < $past(tx_credit_thresh, 5)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 ($past(rx_credit_update, 3) || credit_overflow)`", "sva_signals": ["clk_tx", "tx_credit", "tx_credit_thresh", "rx_credit_update", "credit_overflow", "[0:0] rst_n"], "clock": "clk_tx", "attempts_left": 10, "sva_result": "@(posedge clk_tx)     $past(tx_credit, 7) < $past(tx_credit_thresh, 5) |-> ##1 ($past(rx_credit_update, 3) || credit_overflow);", "sva_name": "p_tx_credit_thresh_rx_credit_update_or_overflow", "full_property": "property delayed_credit_update_verify;\n@(posedge clk_tx)     $past(tx_credit, 7) < $past(tx_credit_thresh, 5) |-> ##1 ($past(rx_credit_update, 3) || credit_overflow);\nendproperty\nassert_delayed_credit_update_verify:assert property (delayed_credit_update_verify) else $error(\"\");", "task_id": "4_5393", "predict_sva": "@(posedge clk_tx)         ($past(tx_credit, 7) < $past(tx_credit_thresh, 5)) |-> ##1 ($past(rx_credit_update, 3) || credit_overflow)"}
{"id": "11_37_0546", "name": "temp_compensation_done", "sva": "@(posedge clk_comp)     compensation_start && !calibration_mode |-> ##[50:100] offset_adjusted", "ori_sva": "property temp_compensation_done;\n@(posedge clk_comp)     compensation_start && !calibration_mode |-> ##[50:100] offset_adjusted\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: temp_compensation_done  \n**Trigger Condition**: At every rising edge of the `clk_comp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `compensation_start && !calibration_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[50:100] offset_adjusted`  ", "sva_signals": ["clk_comp", "[0:0] compensation_start", "[0:0] calibration_mode", "[0:0] offset_adjusted"], "clock": "clk_comp", "attempts_left": 10, "sva_result": "@(posedge clk_comp)         (compensation_start && !calibration_mode) |-> ##[50:100] offset_adjusted;", "sva_name": "p_offset_adjusted_within_50_100_cycles_after_compensation_start", "full_property": "property temp_compensation_done;\n@(posedge clk_comp)         (compensation_start && !calibration_mode) |-> ##[50:100] offset_adjusted;\nendproperty\nassert_temp_compensation_done:assert property (temp_compensation_done) else $error(\"\");", "task_id": "4_5419", "predict_sva": "@(posedge clk_comp)         (compensation_start == 1 && calibration_mode == 0) |-> ##[50:100] offset_adjusted == 1"}
{"id": "11_43_0536", "name": "cellular_registration", "sva": "@(posedge clk_cell)     location_update && !roaming_disabled |-> ##[5:10] registered_status", "ori_sva": "property cellular_registration;\n@(posedge clk_cell)     location_update && !roaming_disabled |-> ##[5:10] registered_status\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cellular_registration  \n**Trigger Condition**: At every rising edge of the `clk_cell`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `location_update && !roaming_disabled`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:10] registered_status`  ", "sva_signals": ["clk_cell", "roaming_disabled", "[0:0] location_update", "[0:0] registered_status"], "clock": "clk_cell", "attempts_left": 10, "sva_result": "@(posedge clk_cell)         (location_update && !roaming_disabled) |-> ##[5:10] registered_status;", "sva_name": "p_registered_status_after_location_update", "full_property": "property cellular_registration;\n@(posedge clk_cell)         (location_update && !roaming_disabled) |-> ##[5:10] registered_status;\nendproperty\nassert_cellular_registration:assert property (cellular_registration) else $error(\"\");", "task_id": "4_5424", "predict_sva": "@(posedge clk_cell)         (location_update == 1 && roaming_disabled == 0) |-> ##[5:10] registered_status == 1"}
{"id": "11_44_0540", "name": "gps_fix_acquired", "sva": "@(posedge clk_gps)     satellite_lock && !cold_start |-> ##[60:120] position_valid", "ori_sva": "property gps_fix_acquired;\n@(posedge clk_gps)     satellite_lock && !cold_start |-> ##[60:120] position_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: gps_fix_acquired  \n**Trigger Condition**: At every rising edge of the `clk_gps`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `satellite_lock && !cold_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[60:120] position_valid`  ", "sva_signals": ["clk_gps", "cold_start", "[0:0] satellite_lock", "[0:0] position_valid"], "clock": "clk_gps", "attempts_left": 10, "sva_result": "@(posedge clk_gps)     (satellite_lock && !cold_start) |-> ##[60:120] position_valid;", "sva_name": "p_position_valid_within_60_120_cycles_after_satellite_lock", "full_property": "property gps_fix_acquired;\n@(posedge clk_gps)     (satellite_lock && !cold_start) |-> ##[60:120] position_valid;\nendproperty\nassert_gps_fix_acquired:assert property (gps_fix_acquired) else $error(\"\");", "task_id": "4_5425", "predict_sva": "@(posedge clk_gps)         (satellite_lock == 1 && cold_start == 0) |-> ##[60:120] position_valid == 1"}
{"id": "12_42_0596", "name": "crc_match_or_force_accept", "sva": "@(posedge clk_data_link)      crc_match || force_accept |-> ##1 packet_good && $fell(error_flag)", "ori_sva": "property crc_match_or_force_accept;\n@(posedge clk_data_link)      crc_match || force_accept |-> ##1 packet_good && $fell(error_flag)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: crc_match_or_force_accept  \n**Trigger Condition**: At every rising edge of the `clk_data_link`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `crc_match || force_accept`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 packet_good && $fell(error_flag)`", "sva_signals": ["clk_data_link", "[0:0] crc_match", "[0:0] force_accept", "[0:0] packet_good", "[0:0] error_flag"], "clock": "clk_data_link", "attempts_left": 10, "sva_result": "@(posedge clk_data_link)     (crc_match || force_accept) |-> ##1 (packet_good && $fell(error_flag));", "sva_name": "p_packet_good_on_crc_or_force_accept", "full_property": "property crc_match_or_force_accept;\n@(posedge clk_data_link)     (crc_match || force_accept) |-> ##1 (packet_good && $fell(error_flag));\nendproperty\nassert_crc_match_or_force_accept:assert property (crc_match_or_force_accept) else $error(\"\");", "task_id": "4_5463", "predict_sva": "@(posedge clk_data_link)         (crc_match == 1 || force_accept == 1) |-> ##1 (packet_good == 1 && $past(error_flag) == 1 && error_flag == 0)"}
{"id": "1_21_0060", "name": "can_bus_error_check", "sva": "@(posedge clk_can)     error_frame_detected |-> ##[2:4] (error_counter_inc ##1 !tx_enable)", "ori_sva": "property can_bus_error_check;\n@(posedge clk_can)     error_frame_detected |-> ##[2:4] (error_counter_inc ##1 !tx_enable)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_bus_error_check  \n**Trigger Condition**: At every rising edge of `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_frame_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] (error_counter_inc ##1 !tx_enable)`  \n\n**Explanation of Consequent**:  \n- The consequent specifies a sequence of events that must occur after the antecedent is true:  \n  1. After 2 to 4 clock cycles (`##[2:4]`), the signal `error_counter_inc` must be asserted (1 clock cycle).  \n  2. Immediately in the next clock cycle (`##1`), the signal `tx_enable` must be deasserted (`!tx_enable`).  \n\nThis assertion checks that when an error frame is detected (`error_frame_detected`), the error counter increments (`error_counter_inc`) within 2 to 4 clock cycles, followed by disabling the transmit enable (`tx_enable`) in the subsequent cycle.", "sva_signals": ["clk_can", "error_frame_detected", "[0:0] error_counter_inc", "[0:0] tx_enable"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     error_frame_detected == 1'b1 |-> ##[2:4] (error_counter_inc ##1 !tx_enable);", "sva_name": "p_error_frame_counter_tx_disable", "full_property": "property can_bus_error_check;\n@(posedge clk_can)     error_frame_detected == 1'b1 |-> ##[2:4] (error_counter_inc ##1 !tx_enable);\nendproperty\nassert_can_bus_error_check:assert property (can_bus_error_check) else $error(\"\");", "task_id": "4_5547", "predict_sva": "@(posedge clk_can)         error_frame_detected == 1'b1 |-> ##[2:4] (error_counter_inc == 1'b1) ##1 (tx_enable == 1'b0)"}
{"id": "1_44_0069", "name": "pwm_deadtime_check", "sva": "@(posedge clk_pwm)     pwm_high |-> ##[1:3] (!pwm_low ##1 deadtime_elapsed)", "ori_sva": "property pwm_deadtime_check;\n@(posedge clk_pwm)     pwm_high |-> ##[1:3] (!pwm_low ##1 deadtime_elapsed)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pwm_deadtime_check  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwm_high == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 1 to 3 clock cycles after the antecedent is true, `pwm_low` must be low (`!pwm_low`) for one clock cycle, followed by `deadtime_elapsed` being true in the next clock cycle.  ", "sva_signals": ["clk_pwm", "[0:0] pwm_high", "[0:0] pwm_low", "[0:0] deadtime_elapsed"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)     pwm_high == 1'b1 |->      (##[1:3] (!pwm_low)) ##1 deadtime_elapsed;", "sva_name": "p_pwm_high_deadtime_sequence", "full_property": "property pwm_deadtime_check;\n@(posedge clk_pwm)     pwm_high == 1'b1 |->      (##[1:3] (!pwm_low)) ##1 deadtime_elapsed;\nendproperty\nassert_pwm_deadtime_check:assert property (pwm_deadtime_check) else $error(\"\");", "task_id": "4_5570", "predict_sva": "@(posedge clk_pwm)         pwm_high == 1'b1 |-> ##[1:3] (pwm_low == 1'b0) ##1 (deadtime_elapsed == 1'b1)"}
{"id": "2_12_0066", "name": "temperature_alert_response", "sva": "@(posedge clk_sensor)      temp_alert_high |-> ##[2:5] cooling_fan_on ##[3:8] temp_normal", "ori_sva": "property temperature_alert_response;\n@(posedge clk_sensor)      temp_alert_high |-> ##[2:5] cooling_fan_on ##[3:8] temp_normal\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: temperature_alert_response  \n**Trigger Condition**: At every rising edge of the `clk_sensor`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_alert_high == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 2 to 5 clock cycles (`##[2:5]`), `cooling_fan_on` must be asserted (`cooling_fan_on == 1'b1`).  \n- Then, after another 3 to 8 clock cycles (`##[3:8]`), `temp_normal` must be asserted (`temp_normal == 1'b1`).  \n\nThe assertion checks that when a high-temperature alert (`temp_alert_high`) occurs, the cooling fan turns on within 2 to 5 clock cycles, and the temperature returns to normal within 3 to 8 clock cycles after the fan is activated.", "sva_signals": ["clk_sensor", "[0:0] temp_alert_high", "[0:0] cooling_fan_on", "[0:0] temp_normal"], "clock": "clk_sensor", "attempts_left": 10, "sva_result": "@(posedge clk_sensor)     temp_alert_high == 1'b1 |-> ##[2:5] cooling_fan_on == 1'b1 ##[3:8] temp_normal == 1'b1;", "sva_name": "p_temp_alert_fan_and_normal_sequence", "full_property": "property temperature_alert_response;\n@(posedge clk_sensor)     temp_alert_high == 1'b1 |-> ##[2:5] cooling_fan_on == 1'b1 ##[3:8] temp_normal == 1'b1;\nendproperty\nassert_temperature_alert_response:assert property (temperature_alert_response) else $error(\"\");", "task_id": "4_5584", "predict_sva": "@(posedge clk_sensor)         temp_alert_high == 1'b1 |-> ##[2:5] cooling_fan_on == 1'b1 ##[3:8] temp_normal == 1'b1"}
{"id": "2_31_0086", "name": "cache_coherency_check", "sva": "@(posedge clk_snoop)      snoop_hit |-> ##[1:3] cache_invalidate ##[2:4] $stable(memory_data)", "ori_sva": "property cache_coherency_check;\n@(posedge clk_snoop)      snoop_hit |-> ##[1:3] cache_invalidate ##[2:4] $stable(memory_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cache_coherency_check  \n**Trigger Condition**: At every rising edge of the `clk_snoop`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `snoop_hit == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] cache_invalidate ##[2:4] $stable(memory_data)`  \n\n**Explanation of Consequent**:  \n- The consequent specifies a sequence of events that must occur after the antecedent is true:  \n  1. Within 1 to 3 clock cycles (`##[1:3]`), `cache_invalidate` must be asserted.  \n  2. After `cache_invalidate` is asserted, within 2 to 4 clock cycles (`##[2:4]`), `memory_data` must remain stable (`$stable(memory_data)`).  \n\nThis assertion ensures that when a `snoop_hit` occurs, the cache is invalidated within 1 to 3 clock cycles, and subsequently, the memory data remains stable for 2 to 4 clock cycles after invalidation.", "sva_signals": ["clk_snoop", "rst_n", "[0:0] snoop_hit", "[0:0] cache_invalidate", "memory_data"], "clock": "clk_snoop", "attempts_left": 10, "sva_result": "@(posedge clk_snoop)     snoop_hit == 1'b1 |-> ##[1:3] cache_invalidate ##[2:4] $stable(memory_data);", "sva_name": "p_snoop_hit_invalidate_and_data_stability", "full_property": "property cache_coherency_check;\n@(posedge clk_snoop)     snoop_hit == 1'b1 |-> ##[1:3] cache_invalidate ##[2:4] $stable(memory_data);\nendproperty\nassert_cache_coherency_check:assert property (cache_coherency_check) else $error(\"\");", "task_id": "4_5604", "predict_sva": "@(posedge clk_snoop)         snoop_hit == 1'b1 |-> ##[1:3] cache_invalidate == 1'b1 ##[2:4] $stable(memory_data)"}
{"id": "2_44_0110", "name": "data_integrity_check", "sva": "@(posedge clk_chk)      parity_error |-> ##[1:3] data_retry ##[2:4] $stable(corrected_data)", "ori_sva": "property data_integrity_check;\n@(posedge clk_chk)      parity_error |-> ##[1:3] data_retry ##[2:4] $stable(corrected_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_integrity_check  \n**Trigger Condition**: At every rising edge of `clk_chk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `parity_error == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 1 to 3 clock cycles (`##[1:3]`), `data_retry` must be asserted.  \n- After `data_retry` is asserted, within 2 to 4 clock cycles (`##[2:4]`), `corrected_data` must remain stable (`$stable(corrected_data)`).  ", "sva_signals": ["clk_chk", "rst_n", "[0:0] parity_error", "[0:0] data_retry", "corrected_data"], "clock": "clk_chk", "attempts_left": 10, "sva_result": "@(posedge clk_chk)     parity_error == 1'b1 |-> ##[1:3] data_retry ##[2:4] $stable(corrected_data);", "sva_name": "p_parity_error_data_retry_corrected_data_stability", "full_property": "property data_integrity_check;\n@(posedge clk_chk)     parity_error == 1'b1 |-> ##[1:3] data_retry ##[2:4] $stable(corrected_data);\nendproperty\nassert_data_integrity_check:assert property (data_integrity_check) else $error(\"\");", "task_id": "4_5616", "predict_sva": "@(posedge clk_chk)         parity_error == 1'b1 |-> ##[1:3] data_retry == 1'b1 ##[2:4] $stable(corrected_data)"}
{"id": "2_51_0111", "name": "clock_align_detection", "sva": "@(posedge clk_align)      align_request |-> ##[8:16] align_done ##[1:2] $stable(phase_status)", "ori_sva": "property clock_align_detection;\n@(posedge clk_align)      align_request |-> ##[8:16] align_done ##[1:2] $stable(phase_status)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: clock_align_detection  \n**Trigger Condition**: At every rising edge of `clk_align`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `align_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After the trigger (`align_request` is true), `align_done` must occur between **8 to 16 clock cycles** (`##[8:16] align_done`).  \n- After `align_done` occurs, the signal `phase_status` must remain stable for **1 to 2 clock cycles** (`##[1:2] $stable(phase_status)`).  ", "sva_signals": ["clk_align", "rst_n", "[0:0] align_request", "[0:0] align_done", "[0:0] phase_status"], "clock": "clk_align", "attempts_left": 10, "sva_result": "@(posedge clk_align)     align_request == 1'b1 |-> ##[8:16] align_done ##[1:2] $stable(phase_status);", "sva_name": "p_align_done_and_phase_status_stability", "full_property": "property clock_align_detection;\n@(posedge clk_align)     align_request == 1'b1 |-> ##[8:16] align_done ##[1:2] $stable(phase_status);\nendproperty\nassert_clock_align_detection:assert property (clock_align_detection) else $error(\"\");", "task_id": "4_5623", "predict_sva": "@(posedge clk_align)         align_request == 1'b1 |-> ##[8:16] align_done == 1'b1 ##[1:2] $stable(phase_status)"}
{"id": "3_23_0144", "name": "cam_pixel_data_valid_check", "sva": "@(posedge cam_pixel_clk)      cam_vsync_high |-> ##[1280:1300] cam_href_high ##1 cam_data_valid", "ori_sva": "property cam_pixel_data_valid_check;\n@(posedge cam_pixel_clk)      cam_vsync_high |-> ##[1280:1300] cam_href_high ##1 cam_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cam_pixel_data_valid_check  \n**Trigger Condition**: At every rising edge of the `cam_pixel_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cam_vsync_high`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1280:1300] cam_href_high ##1 cam_data_valid`  ", "sva_signals": ["cam_pixel_clk", "cam_vsync_high", "cam_href_high", "cam_data_valid"], "clock": "cam_pixel_clk", "attempts_left": 10, "sva_result": "@(posedge cam_pixel_clk)     cam_vsync_high |-> ##[1280:1300] cam_href_high ##1 cam_data_valid;", "sva_name": "p_cam_vsync_high_to_href_and_data_valid", "full_property": "property cam_pixel_data_valid_check;\n@(posedge cam_pixel_clk)     cam_vsync_high |-> ##[1280:1300] cam_href_high ##1 cam_data_valid;\nendproperty\nassert_cam_pixel_data_valid_check:assert property (cam_pixel_data_valid_check) else $error(\"\");", "task_id": "4_5637", "predict_sva": "@(posedge cam_pixel_clk)         cam_vsync_high |-> ##[1280:1300] (cam_href_high ##1 cam_data_valid)"}
{"id": "5_17_0193", "name": "cache_line_fill_duration", "sva": "@(posedge clk_cache)     fill_request |-> ##2 (fill_busy[*4] ##1 fill_complete)", "ori_sva": "property cache_line_fill_duration;\n@(posedge clk_cache)     fill_request |-> ##2 (fill_busy[*4] ##1 fill_complete)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: cache_line_fill_duration  \n**Trigger Condition**: At every rising edge of the `clk_cache`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fill_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 (fill_busy[*4] ##1 fill_complete)`  ", "sva_signals": ["clk_cache", "fill_request", "fill_busy", "fill_complete"], "clock": "clk_cache", "attempts_left": 10, "sva_result": "@(posedge clk_cache)         fill_request == 1'b1 |-> ##2 (fill_busy[*4] ##1 fill_complete);", "sva_name": "p_fill_request_busy_complete_sequence", "full_property": "property cache_line_fill_duration;\n@(posedge clk_cache)         fill_request == 1'b1 |-> ##2 (fill_busy[*4] ##1 fill_complete);\nendproperty\nassert_cache_line_fill_duration:assert property (cache_line_fill_duration) else $error(\"\");", "task_id": "4_5717", "predict_sva": "@(posedge clk_cache)         fill_request == 1'b1 |-> ##2 (fill_busy == 1'b1) [*4] ##1 fill_complete == 1'b1"}
{"id": "6_49_0291", "name": "usb_sof_tracking_49", "sva": "@(posedge clk_usb_host)     sof_packet |-> ##[1:3] !missing_sof[*125:250] ##1 frame_number_increment", "ori_sva": "property usb_sof_tracking_49;\n@(posedge clk_usb_host)     sof_packet |-> ##[1:3] !missing_sof[*125:250] ##1 frame_number_increment\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: usb_sof_tracking_49  \n**Trigger Condition**: At every rising edge of the `clk_usb_host`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sof_packet == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 1 to 3 clock cycles (`##[1:3]`), the signal `missing_sof` must remain low (`!missing_sof`) for 125 to 250 consecutive cycles (`[*125:250]`),  \n- Followed by exactly 1 clock cycle later (`##1`), the signal `frame_number_increment` must be asserted.  \n\n(Note: The consequent describes a sequence where `missing_sof` is continuously deasserted for a specified range of cycles, ending with a `frame_number_increment` assertion.)", "sva_signals": ["clk_usb_host", "[0:0] sof_packet", "[0:0] missing_sof", "[0:0] frame_number_increment"], "clock": "clk_usb_host", "attempts_left": 10, "sva_result": "@(posedge clk_usb_host)     sof_packet == 1'b1 |-> ##[1:3] (!missing_sof [*125:250]) ##1 frame_number_increment;", "sva_name": "p_sof_packet_frame_sequence", "full_property": "property usb_sof_tracking_49;\n@(posedge clk_usb_host)     sof_packet == 1'b1 |-> ##[1:3] (!missing_sof [*125:250]) ##1 frame_number_increment;\nendproperty\nassert_usb_sof_tracking_49:assert property (usb_sof_tracking_49) else $error(\"\");", "task_id": "4_5792", "predict_sva": "@(posedge clk_usb_host)         sof_packet == 1'b1 |-> ##[1:3] (missing_sof == 1'b0) [*125:250] ##1 (frame_number_increment == 1'b1)"}
{"id": "10_47_0495", "name": "past_clock_division_47", "sva": "@(posedge clk_div)     $rose(div_valid) |-> $past(ref_count, 3) == $past(div_factor, 5)", "ori_sva": "property past_clock_division_47;\n@(posedge clk_div)     $rose(div_valid) |-> $past(ref_count, 3) == $past(div_factor, 5)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: past_clock_division_47  \n**Trigger Condition**: At every rising edge of the `clk_div`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(div_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(ref_count, 3) == $past(div_factor, 5)`  ", "sva_signals": ["clk", "rst_n", "[0:0] div_valid", "[0:0] ref_count", "[0:0] div_factor", "clk_div"], "clock": "clk_div", "attempts_left": 10, "sva_result": "@(posedge clk_div)     $rose(div_valid) |-> $past(ref_count, 3) == $past(div_factor, 5);", "sva_name": "p_div_valid_ref_count_div_factor_match", "full_property": "property past_clock_division_47;\n@(posedge clk_div)     $rose(div_valid) |-> $past(ref_count, 3) == $past(div_factor, 5);\nendproperty\nassert_past_clock_division_47:assert property (past_clock_division_47) else $error(\"\");", "task_id": "4_5958", "predict_sva": "@(posedge clk_div)         $rose(div_valid) |-> ($past(ref_count, 3) == $past(div_factor, 5))"}
{"id": "12_41_0596", "name": "dma_pause_or_abort_check_41", "sva": "@(posedge clk_dma_master)     (dma_pause_req || dma_abort) |-> ##1 $fell(dma_active)", "ori_sva": "property dma_pause_or_abort_check_41;\n@(posedge clk_dma_master)     (dma_pause_req || dma_abort) |-> ##1 $fell(dma_active)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dma_pause_or_abort_check_41  \n**Trigger Condition**: At every rising edge of the `clk_dma_master`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(dma_pause_req || dma_abort)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(dma_active)`  ", "sva_signals": ["clk_dma_master", "dma_pause_req", "dma_abort", "dma_active"], "clock": "clk_dma_master", "attempts_left": 10, "sva_result": "@(posedge clk_dma_master)     (dma_pause_req || dma_abort) |-> ##1 $fell(dma_active);", "sva_name": "p_dma_deactivate_on_pause_or_abort", "full_property": "property dma_pause_or_abort_check_41;\n@(posedge clk_dma_master)     (dma_pause_req || dma_abort) |-> ##1 $fell(dma_active);\nendproperty\nassert_dma_pause_or_abort_check_41:assert property (dma_pause_or_abort_check_41) else $error(\"\");", "task_id": "4_5993", "predict_sva": "@(posedge clk_dma_master)         (dma_pause_req == 1 || dma_abort == 1) |-> ##1 $fell(dma_active)"}
{"id": "1_35_0041", "name": "proximity_sensor_detect_check", "sva": "@(posedge clk_proximity)     proximity_enable |-> ##3 proximity_detected ##1 $stable(proximity_distance)", "ori_sva": "property proximity_sensor_detect_check;\n@(posedge clk_proximity)     proximity_enable |-> ##3 proximity_detected ##1 $stable(proximity_distance)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: proximity_sensor_detect_check  \n**Trigger Condition**: At every rising edge of the `clk_proximity`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `proximity_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 proximity_detected ##1 $stable(proximity_distance)`  ", "sva_signals": ["clk_proximity", "proximity_enable", "proximity_detected", "proximity_distance"], "clock": "clk_proximity", "attempts_left": 10, "sva_result": "@(posedge clk_proximity)     proximity_enable == 1'b1 |-> ##3 proximity_detected ##1 $stable(proximity_distance);", "sva_name": "p_proximity_detected_and_distance_stability", "full_property": "property proximity_sensor_detect_check;\n@(posedge clk_proximity)     proximity_enable == 1'b1 |-> ##3 proximity_detected ##1 $stable(proximity_distance);\nendproperty\nassert_proximity_sensor_detect_check:assert property (proximity_sensor_detect_check) else $error(\"\");", "task_id": "4_6084", "predict_sva": "@(posedge clk_proximity)         proximity_enable == 1'b1 |-> ##3 proximity_detected == 1'b1 ##1 $stable(proximity_distance)"}
{"id": "1_8_0026", "name": "can_bus_error_flag_check", "sva": "@(posedge clk_can)     can_error_active |-> ##6 can_error_flag ##2 can_error_passive", "ori_sva": "property can_bus_error_flag_check;\n@(posedge clk_can)     can_error_active |-> ##6 can_error_flag ##2 can_error_passive\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_bus_error_flag_check  \n**Trigger Condition**: At every rising edge of the `clk_can`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_active == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 6 clock cycles (`##6`), `can_error_flag` must be asserted (`== 1'b1`).  \n- After an additional 2 clock cycles (`##2`), `can_error_passive` must be asserted (`== 1'b1`).  \n\n(Note: The consequent describes a sequence where `can_error_flag` is checked 6 cycles after the antecedent, followed by `can_error_passive` 2 cycles after `can_error_flag`.)", "sva_signals": ["clk_can", "rst_n", "[0:0] can_error_active", "[0:0] can_error_flag", "[0:0] can_error_passive"], "clock": "clk_can", "attempts_left": 10, "sva_result": "@(posedge clk_can)     can_error_active == 1'b1 |-> ##6 (can_error_flag == 1'b1) ##2 (can_error_passive == 1'b1);", "sva_name": "p_can_error_active_to_flag_and_passive", "full_property": "property can_bus_error_flag_check;\n@(posedge clk_can)     can_error_active == 1'b1 |-> ##6 (can_error_flag == 1'b1) ##2 (can_error_passive == 1'b1);\nendproperty\nassert_can_bus_error_flag_check:assert property (can_bus_error_flag_check) else $error(\"\");", "task_id": "4_6105", "predict_sva": "@(posedge clk_can)         can_error_active |-> ##6 can_error_flag ##2 can_error_passive"}
{"id": "3_14_0111", "name": "temperature_alert_check", "sva": "@(posedge clk_sensor)     temp_alert |-> ##1 temp_shutdown ##0 (fan_speed == max_fan_speed)", "ori_sva": "property temperature_alert_check;\n@(posedge clk_sensor)     temp_alert |-> ##1 temp_shutdown ##0 (fan_speed == max_fan_speed)\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: temperature_alert_check  \n**Trigger Condition**: At every rising edge of the `clk_sensor`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_alert == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 temp_shutdown ##0 (fan_speed == max_fan_speed)`  ", "sva_signals": ["clk_sensor", "[0:0] temp_alert", "[0:0] temp_shutdown", "[0:0] fan_speed", "[0:0] max_fan_speed"], "clock": "clk_sensor", "attempts_left": 10, "sva_result": "@(posedge clk_sensor)     temp_alert == 1'b1 |-> ##1 temp_shutdown ##0 (fan_speed == max_fan_speed);", "sva_name": "p_temp_alert_shutdown_fan_speed", "full_property": "property temperature_alert_check;\n@(posedge clk_sensor)     temp_alert == 1'b1 |-> ##1 temp_shutdown ##0 (fan_speed == max_fan_speed);\nendproperty\nassert_temperature_alert_check:assert property (temperature_alert_check) else $error(\"\");", "task_id": "4_6160", "predict_sva": "@(posedge clk_sensor)         temp_alert == 1'b1 |-> ##1 (temp_shutdown == 1'b1 && fan_speed == max_fan_speed)"}
{"id": "3_15_0126", "name": "bus_arbitration_check", "sva": "@(posedge clk_bus)     bus_request |-> ##[0:2] bus_grant ##1 (bus_owner == requestor_id)", "ori_sva": "property bus_arbitration_check;\n@(posedge clk_bus)     bus_request |-> ##[0:2] bus_grant ##1 (bus_owner == requestor_id)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: bus_arbitration_check  \n**Trigger Condition**: At every rising edge of the `clk_bus`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `bus_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] bus_grant ##1 (bus_owner == requestor_id)`  ", "sva_signals": ["clk_bus", "[0:0] bus_request", "[0:0] bus_grant", "[0:0] bus_owner", "[0:0] requestor_id"], "clock": "clk_bus", "attempts_left": 10, "sva_result": "@(posedge clk_bus)     bus_request == 1'b1 |-> ##[0:2] bus_grant ##1 (bus_owner == requestor_id);", "sva_name": "p_bus_grant_and_owner_set", "full_property": "property bus_arbitration_check;\n@(posedge clk_bus)     bus_request == 1'b1 |-> ##[0:2] bus_grant ##1 (bus_owner == requestor_id);\nendproperty\nassert_bus_arbitration_check:assert property (bus_arbitration_check) else $error(\"\");", "task_id": "4_6161", "predict_sva": "@(posedge clk_bus)         bus_request == 1'b1 |-> ##[0:2] (bus_grant == 1'b1) ##1 (bus_owner == requestor_id)"}
{"id": "3_1_0101", "name": "req_grant_immediate_check", "sva": "@(posedge clk_sys)      req_valid |-> grant_ack ##0 (req_id == grant_id)", "ori_sva": "property req_grant_immediate_check;\n@(posedge clk_sys)      req_valid |-> grant_ack ##0 (req_id == grant_id)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: req_grant_immediate_check  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `req_valid == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `grant_ack ##0 (req_id == grant_id)`  \n\n**Explanation of Consequent**:  \nThe assertion checks that in the same clock cycle (`##0`), when `req_valid` is high, both `grant_ack` must be high and the `req_id` must match the `grant_id`. The `##0` operator ensures the check is performed immediately (same cycle) after the antecedent is true.", "sva_signals": ["clk_sys", "[0:0] req_valid", "[0:0] grant_ack", "[0:0] req_id", "[0:0] grant_id"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     req_valid == 1'b1 |-> grant_ack ##0 (req_id == grant_id);", "sva_name": "p_req_valid_grant_ack_id_match", "full_property": "property req_grant_immediate_check;\n@(posedge clk_sys)     req_valid == 1'b1 |-> grant_ack ##0 (req_id == grant_id);\nendproperty\nassert_req_grant_immediate_check:assert property (req_grant_immediate_check) else $error(\"\");", "task_id": "4_6166", "predict_sva": "@(posedge clk_sys)         req_valid == 1'b1 |-> grant_ack == 1'b1 && req_id == grant_id"}
{"id": "3_2_0131", "name": "error_abort_sequence_check", "sva": "@(posedge clk_core)      error_detected |-> ##[1:3] abort_triggered", "ori_sva": "property error_abort_sequence_check;\n@(posedge clk_core)      error_detected |-> ##[1:3] abort_triggered\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: error_abort_sequence_check  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `error_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] abort_triggered == 1'b1`  \n\n(Note: The consequent means that within 1 to 3 clock cycles after the antecedent is true, `abort_triggered` must become true.)", "sva_signals": ["clk", "rst_n", "[0:0] error_detected", "[0:0] abort_triggered", "[0:0] clk_core"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     error_detected == 1'b1 |-> ##[1:3] abort_triggered == 1'b1;", "sva_name": "p_abort_triggered_on_error_detected", "full_property": "property error_abort_sequence_check;\n@(posedge clk_core)     error_detected == 1'b1 |-> ##[1:3] abort_triggered == 1'b1;\nendproperty\nassert_error_abort_sequence_check:assert property (error_abort_sequence_check) else $error(\"\");", "task_id": "4_6177", "predict_sva": "@(posedge clk_core)         error_detected == 1'b1 |-> ##[1:3] abort_triggered == 1'b1"}
{"id": "3_50_0149", "name": "touch_sensor_check", "sva": "@(posedge clk_touch)     touch_detected |-> ##[1:3] touch_processed ##1 (coordinates_valid)", "ori_sva": "property touch_sensor_check;\n@(posedge clk_touch)     touch_detected |-> ##[1:3] touch_processed ##1 (coordinates_valid)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: touch_sensor_check  \n**Trigger Condition**: At every rising edge of the `clk_touch`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `touch_detected == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] touch_processed ##1 coordinates_valid`  ", "sva_signals": ["clk_touch", "[0:0] touch_detected", "[0:0] touch_processed", "[0:0] coordinates_valid"], "clock": "clk_touch", "attempts_left": 10, "sva_result": "@(posedge clk_touch)     touch_detected == 1'b1 |-> ##[1:3] touch_processed ##1 coordinates_valid;", "sva_name": "p_touch_processed_and_coordinates_valid", "full_property": "property touch_sensor_check;\n@(posedge clk_touch)     touch_detected == 1'b1 |-> ##[1:3] touch_processed ##1 coordinates_valid;\nendproperty\nassert_touch_sensor_check:assert property (touch_sensor_check) else $error(\"\");", "task_id": "4_6196", "predict_sva": "@(posedge clk_touch)         touch_detected == 1'b1 |-> ##[1:3] (touch_processed == 1'b1) ##1 (coordinates_valid == 1'b1)"}
{"id": "10_43_0481", "name": "past_with_pipeline_43", "sva": "@(posedge clk_dsp)      $past(stage1_valid, 3) |-> $past(stage2_valid, 2) |-> $past(stage3_valid, 1)", "ori_sva": "property past_with_pipeline_43;\n@(posedge clk_dsp)      $past(stage1_valid, 3) |-> $past(stage2_valid, 2) |-> $past(stage3_valid, 1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: past_with_pipeline_43  \n**Trigger Condition**: At every rising edge of the `clk_dsp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(stage1_valid, 3)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(stage2_valid, 2) |-> $past(stage3_valid, 1)`  \n\n**Note**: This is a nested implication assertion. The property checks that if `stage1_valid` was true 3 clock cycles ago (`$past(stage1_valid, 3)`), then it implies that `stage2_valid` must have been true 2 clock cycles ago (`$past(stage2_valid, 2)`), which in turn implies that `stage3_valid` must have been true 1 clock cycle ago (`$past(stage3_valid, 1)`). The assertion verifies a pipelined validity propagation pattern.", "sva_signals": ["clk_dsp", "[0:0] stage1_valid", "[0:0] stage2_valid", "[0:0] stage3_valid"], "clock": "clk_dsp", "attempts_left": 10, "sva_result": "@(posedge clk_dsp)         $past(stage1_valid, 3) |-> ($past(stage2_valid, 2) |-> $past(stage3_valid, 1));", "sva_name": "p_pipeline_validity_propagation", "full_property": "property past_with_pipeline_43;\n@(posedge clk_dsp)         $past(stage1_valid, 3) |-> ($past(stage2_valid, 2) |-> $past(stage3_valid, 1));\nendproperty\nassert_past_with_pipeline_43:assert property (past_with_pipeline_43) else $error(\"\");", "task_id": "4_6435", "predict_sva": "@(posedge clk_dsp)         ($past(stage1_valid, 3) && $past(stage2_valid, 2)) |-> $past(stage3_valid, 1)"}
{"id": "10_42_0485", "name": "past_with_fifo_level_42", "sva": "@(posedge clk_fifo)      $past(wr_count, 2) - $past(rd_count, 2) == $past(fifo_level, 1) |-> !$past(fifo_full, 1)", "ori_sva": "property past_with_fifo_level_42;\n@(posedge clk_fifo)      $past(wr_count, 2) - $past(rd_count, 2) == $past(fifo_level, 1) |-> !$past(fifo_full, 1)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: past_with_fifo_level_42  \n**Trigger Condition**: At every rising edge of the `clk_fifo`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(wr_count, 2) - $past(rd_count, 2) == $past(fifo_level, 1)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `!$past(fifo_full, 1)`  \n\n", "sva_signals": ["clk_fifo", "[0:0] fifo_full", "[0:0] fifo_level", "[0:0] rd_count", "[0:0] wr_count"], "clock": "clk_fifo", "attempts_left": 10, "sva_result": "@(posedge clk_fifo)         ($past(wr_count, 2) - $past(rd_count, 2) == $past(fifo_level, 1)) |-> !$past(fifo_full, 1);", "sva_name": "p_fifo_full_check", "full_property": "property past_with_fifo_level_42;\n@(posedge clk_fifo)         ($past(wr_count, 2) - $past(rd_count, 2) == $past(fifo_level, 1)) |-> !$past(fifo_full, 1);\nendproperty\nassert_past_with_fifo_level_42:assert property (past_with_fifo_level_42) else $error(\"\");", "task_id": "4_6436", "predict_sva": "@(posedge clk_fifo)         ($past(wr_count, 2) - $past(rd_count, 2)) == $past(fifo_level, 1) |-> !$past(fifo_full, 1)"}
{"id": "11_44_0543", "name": "i2c_start_detect_44", "sva": "@(posedge i2c_clk)     $rose(start_cond) && $fell(sda_high) |-> ##1 scl_low ##0 !sda_high", "ori_sva": "property i2c_start_detect_44;\n@(posedge i2c_clk)     $rose(start_cond) && $fell(sda_high) |-> ##1 scl_low ##0 !sda_high\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: i2c_start_detect_44  \n**Trigger Condition**: At every rising edge of the `i2c_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(start_cond) && $fell(sda_high)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 scl_low ##0 !sda_high`  ", "sva_signals": ["i2c_clk", "sda_high", "start_cond", "scl_low"], "clock": "i2c_clk", "attempts_left": 10, "sva_result": "@(posedge i2c_clk)     ($rose(start_cond) && $fell(sda_high)) |-> ##1 scl_low ##0 !sda_high;", "sva_name": "p_start_condition_check", "full_property": "property i2c_start_detect_44;\n@(posedge i2c_clk)     ($rose(start_cond) && $fell(sda_high)) |-> ##1 scl_low ##0 !sda_high;\nendproperty\nassert_i2c_start_detect_44:assert property (i2c_start_detect_44) else $error(\"\");", "task_id": "4_6479", "predict_sva": "@(posedge i2c_clk)    ($rose(start_cond) && $fell(sda_high)) |-> ##1 (scl_low && !sda_high)"}
{"id": "11_7_0490", "name": "fifo_overflow_protect_7", "sva": "@(posedge clk_fifo)     (wr_en && fifo_almost_full) && !fifo_reset |-> ##1 !wr_en || fifo_full", "ori_sva": "property fifo_overflow_protect_7;\n@(posedge clk_fifo)     (wr_en && fifo_almost_full) && !fifo_reset |-> ##1 !wr_en || fifo_full\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: fifo_overflow_protect_7  \n**Trigger Condition**: At every rising edge of the `clk_fifo`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(wr_en && fifo_almost_full) && !fifo_reset`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 !wr_en || fifo_full`", "sva_signals": ["clk_fifo", "fifo_reset", "[0:0] wr_en", "[0:0] fifo_almost_full", "[0:0] fifo_full"], "clock": "clk_fifo", "attempts_left": 10, "sva_result": "@(posedge clk_fifo)         (wr_en && fifo_almost_full && !fifo_reset) |-> ##1 (!wr_en || fifo_full);", "sva_name": "p_fifo_almost_full_write_response", "full_property": "property fifo_overflow_protect_7;\n@(posedge clk_fifo)         (wr_en && fifo_almost_full && !fifo_reset) |-> ##1 (!wr_en || fifo_full);\nendproperty\nassert_fifo_overflow_protect_7:assert property (fifo_overflow_protect_7) else $error(\"\");", "task_id": "4_6488", "predict_sva": "@(posedge clk_fifo)         (wr_en == 1 && fifo_almost_full == 1 && fifo_reset == 0) |-> ##1 (wr_en == 0 || fifo_full == 1)"}
{"id": "12_19_0563", "name": "battery_low_or_charger_disconnect_check", "sva": "@(posedge clk_pmu)      battery_low_warning || charger_disconnected |-> ##1 $rose(power_save_mode)", "ori_sva": "property battery_low_or_charger_disconnect_check;\n@(posedge clk_pmu)      battery_low_warning || charger_disconnected |-> ##1 $rose(power_save_mode)\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: battery_low_or_charger_disconnect_check  \n**Trigger Condition**: At every rising edge of the `clk_pmu`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `battery_low_warning || charger_disconnected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $rose(power_save_mode)`  \n\n(Note: The assertion checks that if either the battery low warning is active or the charger is disconnected, then in the next clock cycle, the power save mode should be activated (transition from low to high).)", "sva_signals": ["clk_pmu", "[0:0] battery_low_warning", "[0:0] charger_disconnected", "[0:0] power_save_mode"], "clock": "clk_pmu", "attempts_left": 10, "sva_result": "@(posedge clk_pmu)         (battery_low_warning || charger_disconnected) |-> ##1 $rose(power_save_mode);", "sva_name": "p_power_save_mode_rise_on_warning_or_disconnect", "full_property": "property battery_low_or_charger_disconnect_check;\n@(posedge clk_pmu)         (battery_low_warning || charger_disconnected) |-> ##1 $rose(power_save_mode);\nendproperty\nassert_battery_low_or_charger_disconnect_check:assert property (battery_low_or_charger_disconnect_check) else $error(\"\");", "task_id": "4_6497", "predict_sva": "@(posedge clk_pmu)         (battery_low_warning == 1 || charger_disconnected == 1) |-> ##1 ($rose(power_save_mode))"}
{"id": "12_25_0574", "name": "freq_error_or_pll_unlock_check", "sva": "@(posedge clk_rf)      freq_error_detected || pll_unlock_event |-> ##1 $fell(tx_enable)", "ori_sva": "property freq_error_or_pll_unlock_check;\n@(posedge clk_rf)      freq_error_detected || pll_unlock_event |-> ##1 $fell(tx_enable)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: freq_error_or_pll_unlock_check  \n**Trigger Condition**: At every rising edge of the `clk_rf`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `freq_error_detected || pll_unlock_event`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 $fell(tx_enable)`  ", "sva_signals": ["clk_rf", "[0:0] freq_error_detected", "[0:0] pll_unlock_event", "[0:0] tx_enable"], "clock": "clk_rf", "attempts_left": 10, "sva_result": "@(posedge clk_rf)     (freq_error_detected || pll_unlock_event) |-> ##1 $fell(tx_enable);", "sva_name": "p_tx_enable_fall_on_error_or_unlock", "full_property": "property freq_error_or_pll_unlock_check;\n@(posedge clk_rf)     (freq_error_detected || pll_unlock_event) |-> ##1 $fell(tx_enable);\nendproperty\nassert_freq_error_or_pll_unlock_check:assert property (freq_error_or_pll_unlock_check) else $error(\"\");", "task_id": "4_6503", "predict_sva": "@(posedge clk_rf)         (freq_error_detected == 1 || pll_unlock_event == 1) |-> ##1 $fell(tx_enable)"}
{"id": "13_38_0617", "name": "not_crosstalk_data_integrity", "sva": "@(posedge clk_xtalk)      !crosstalk_detected |-> ##2 data_integrity_ok", "ori_sva": "property not_crosstalk_data_integrity;\n@(posedge clk_xtalk)      !crosstalk_detected |-> ##2 data_integrity_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: not_crosstalk_data_integrity  \n**Trigger Condition**: At every rising edge of the `clk_xtalk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!crosstalk_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 data_integrity_ok`  \n\nThe assertion checks that if no crosstalk is detected (`!crosstalk_detected`), then two clock cycles later (`##2`), the signal `data_integrity_ok` must be true. This ensures data integrity is maintained when no crosstalk is detected.", "sva_signals": ["clk", "rst_n", "[0:0] crosstalk_detected", "[0:0] data_integrity_ok", "[0:0] clk_xtalk"], "clock": "clk_xtalk", "attempts_left": 10, "sva_result": "@(posedge clk_xtalk)     !crosstalk_detected |-> ##2 data_integrity_ok;", "sva_name": "p_data_integrity_ok_after_no_crosstalk", "full_property": "property not_crosstalk_data_integrity;\n@(posedge clk_xtalk)     !crosstalk_detected |-> ##2 data_integrity_ok;\nendproperty\nassert_not_crosstalk_data_integrity:assert property (not_crosstalk_data_integrity) else $error(\"\");", "task_id": "4_6558", "predict_sva": "@(posedge clk_xtalk)         crosstalk_detected == 0 |-> ##2 data_integrity_ok == 1"}
{"id": "13_44_0641", "name": "not_esd_event_io_cell", "sva": "@(posedge clk_esd)      !esd_event |-> ##1 io_cell_ok", "ori_sva": "property not_esd_event_io_cell;\n@(posedge clk_esd)      !esd_event |-> ##1 io_cell_ok\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: not_esd_event_io_cell  \n**Trigger Condition**: At every rising edge of the `clk_esd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `!esd_event`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 io_cell_ok`", "sva_signals": ["clk_esd", "[0:0] esd_event", "[0:0] io_cell_ok"], "clock": "clk_esd", "attempts_left": 10, "sva_result": "@(posedge clk_esd)     !esd_event |-> ##1 io_cell_ok;", "sva_name": "p_io_cell_ok_no_esd_event", "full_property": "property not_esd_event_io_cell;\n@(posedge clk_esd)     !esd_event |-> ##1 io_cell_ok;\nendproperty\nassert_not_esd_event_io_cell:assert property (not_esd_event_io_cell) else $error(\"\");", "task_id": "4_6565", "predict_sva": "@(posedge clk_esd)         esd_event == 0 |-> ##1 io_cell_ok == 1"}
{"id": "15_24_0715", "name": "voltage_monitor_undervoltage_detect", "sva": "@(posedge monitor_clk) disable iff(!monitor_enable)     (vcc_value < min_voltage) |-> ##1 power_good==0 or $fell(monitor_enable)", "ori_sva": "property voltage_monitor_undervoltage_detect;\n@(posedge monitor_clk) disable iff(!monitor_enable)     (vcc_value < min_voltage) |-> ##1 power_good==0 or $fell(monitor_enable)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: voltage_monitor_undervoltage_detect  \n**Trigger Condition**: At every rising edge of the `monitor_clk`  \n**Disable Condition**: disable iff (!monitor_enable)  \n**Antecedent (LHS of Implication)**: `(vcc_value < min_voltage)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 power_good == 0 or $fell(monitor_enable)`", "sva_signals": ["monitor_clk", "monitor_enable", "[0:0] vcc_value", "[0:0] min_voltage", "[0:0] power_good"], "clock": "monitor_clk", "attempts_left": 10, "sva_result": "@(posedge monitor_clk) disable iff (!monitor_enable)     (vcc_value < min_voltage) |-> ##1 (power_good == 0 || $fell(monitor_enable));", "sva_name": "p_power_good_deassert_on_min_voltage_drop", "full_property": "property voltage_monitor_undervoltage_detect;\n@(posedge monitor_clk) disable iff (!monitor_enable)     (vcc_value < min_voltage) |-> ##1 (power_good == 0 || $fell(monitor_enable));\nendproperty\nassert_voltage_monitor_undervoltage_detect:assert property (voltage_monitor_undervoltage_detect) else $error(\"\");", "task_id": "4_6604", "predict_sva": "@(posedge monitor_clk) disable iff (!monitor_enable)         (monitor_enable == 1 && vcc_value < min_voltage) |-> ##1 (power_good == 0)"}
{"id": "15_48_0747", "name": "dsp_processor_interrupt_latency_check", "sva": "@(posedge dsp_clk) disable iff(!dsp_reset)     $rose(irq_line) |-> ##[1:10] irq_ack or $fell(dsp_reset)", "ori_sva": "property dsp_processor_interrupt_latency_check;\n@(posedge dsp_clk) disable iff(!dsp_reset)     $rose(irq_line) |-> ##[1:10] irq_ack or $fell(dsp_reset)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: dsp_processor_interrupt_latency_check  \n**Trigger Condition**: At every rising edge of the `dsp_clk`  \n**Disable Condition**: `disable iff (!dsp_reset)`  \n**Antecedent (LHS of Implication)**: `$rose(irq_line)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:10] irq_ack or $fell(dsp_reset)`  ", "sva_signals": ["dsp_clk", "dsp_reset", "[0:0] irq_line", "[0:0] irq_ack"], "clock": "dsp_clk", "attempts_left": 10, "sva_result": "@(posedge dsp_clk) disable iff (!dsp_reset)         $rose(irq_line) |-> ##[1:10] irq_ack or $fell(dsp_reset);", "sva_name": "p_irq_ack_or_reset_within_10_cycles", "full_property": "property dsp_processor_interrupt_latency_check;\n@(posedge dsp_clk) disable iff (!dsp_reset)         $rose(irq_line) |-> ##[1:10] irq_ack or $fell(dsp_reset);\nendproperty\nassert_dsp_processor_interrupt_latency_check:assert property (dsp_processor_interrupt_latency_check) else $error(\"\");", "task_id": "4_6623", "predict_sva": "@(posedge dsp_clk) disable iff (!dsp_reset)         (dsp_reset == 1 && $rose(irq_line)) |-> ##[1:10] (irq_ack == 1 || dsp_reset == 0)"}
{"id": "1_24_0019", "name": "ddr_training_check", "sva": "@(posedge clk_ddr_phy)      training_start |-> ##10 training_complete ##3 ddr_ready", "ori_sva": "property ddr_training_check;\n@(posedge clk_ddr_phy)      training_start |-> ##10 training_complete ##3 ddr_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: ddr_training_check  \n**Trigger Condition**: At every rising edge of the `clk_ddr_phy`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `training_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##10 training_complete ##3 ddr_ready`  ", "sva_signals": ["clk_ddr_phy", "training_start", "[0:0] training_complete", "[0:0] ddr_ready"], "clock": "clk_ddr_phy", "attempts_left": 10, "sva_result": "@(posedge clk_ddr_phy)     training_start == 1'b1 |-> ##10 training_complete ##3 ddr_ready;", "sva_name": "p_training_start_to_training_complete_and_ddr_ready", "full_property": "property ddr_training_check;\n@(posedge clk_ddr_phy)     training_start == 1'b1 |-> ##10 training_complete ##3 ddr_ready;\nendproperty\nassert_ddr_training_check:assert property (ddr_training_check) else $error(\"\");", "task_id": "4_6644", "predict_sva": "@(posedge clk_ddr_phy)         training_start == 1'b1 |-> ##10 (training_complete == 1'b1) ##3 (ddr_ready == 1'b1)"}
{"id": "1_32_0045", "name": "video_frame_check", "sva": "@(posedge clk_video)      frame_start |-> ##4 hsync_active ##2 vsync_active", "ori_sva": "property video_frame_check;\n@(posedge clk_video)      frame_start |-> ##4 hsync_active ##2 vsync_active\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: video_frame_check  \n**Trigger Condition**: At every rising edge of the `clk_video`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 hsync_active ##2 vsync_active`  ", "sva_signals": ["clk_video", "[0:0] frame_start", "[0:0] hsync_active", "[0:0] vsync_active"], "clock": "clk_video", "attempts_left": 10, "sva_result": "@(posedge clk_video)     frame_start == 1'b1 |-> ##4 hsync_active ##2 vsync_active;", "sva_name": "p_frame_start_hsync_vsync_sequence", "full_property": "property video_frame_check;\n@(posedge clk_video)     frame_start == 1'b1 |-> ##4 hsync_active ##2 vsync_active;\nendproperty\nassert_video_frame_check:assert property (video_frame_check) else $error(\"\");", "task_id": "4_6653", "predict_sva": "@(posedge clk_video)         frame_start == 1'b1 |-> ##4 hsync_active == 1'b1 ##2 vsync_active == 1'b1"}
{"id": "1_33_0017", "name": "audio_sample_check", "sva": "@(posedge clk_audio)      sample_request |-> ##5 data_ready ##1 fifo_not_empty", "ori_sva": "property audio_sample_check;\n@(posedge clk_audio)      sample_request |-> ##5 data_ready ##1 fifo_not_empty\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: audio_sample_check  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `sample_request == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##5 data_ready ##1 fifo_not_empty`  ", "sva_signals": ["clk_audio", "[0:0] sample_request", "[0:0] data_ready", "[0:0] fifo_not_empty"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     sample_request == 1'b1 |-> ##5 data_ready ##1 fifo_not_empty;", "sva_name": "p_sample_request_data_ready_fifo_not_empty", "full_property": "property audio_sample_check;\n@(posedge clk_audio)     sample_request == 1'b1 |-> ##5 data_ready ##1 fifo_not_empty;\nendproperty\nassert_audio_sample_check:assert property (audio_sample_check) else $error(\"\");", "task_id": "4_6654", "predict_sva": "@(posedge clk_audio)         sample_request == 1'b1 |-> ##5 data_ready == 1'b1 ##1 fifo_not_empty == 1'b1"}
{"id": "1_39_0075", "name": "pwm_generation_check", "sva": "@(posedge clk_pwm)      pwm_enable |-> ##4 period_counter_reset ##2 duty_cycle_set", "ori_sva": "property pwm_generation_check;\n@(posedge clk_pwm)      pwm_enable |-> ##4 period_counter_reset ##2 duty_cycle_set\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pwm_generation_check  \n**Trigger Condition**: At every rising edge of the `clk_pwm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pwm_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 period_counter_reset ##2 duty_cycle_set`  ", "sva_signals": ["clk_pwm", "pwm_enable", "period_counter_reset", "duty_cycle_set"], "clock": "clk_pwm", "attempts_left": 10, "sva_result": "@(posedge clk_pwm)         pwm_enable == 1'b1 |-> ##4 period_counter_reset ##2 duty_cycle_set;", "sva_name": "p_pwm_enable_period_duty_sequence", "full_property": "property pwm_generation_check;\n@(posedge clk_pwm)         pwm_enable == 1'b1 |-> ##4 period_counter_reset ##2 duty_cycle_set;\nendproperty\nassert_pwm_generation_check:assert property (pwm_generation_check) else $error(\"\");", "task_id": "4_6660", "predict_sva": "@(posedge clk_pwm)         pwm_enable == 1'b1 |-> ##4 period_counter_reset == 1'b1 ##2 duty_cycle_set == 1'b1"}
{"id": "1_8_0043", "name": "fifo_overflow_protection_check", "sva": "@(posedge clk_uart)      fifo_full |-> ##2 !write_enable ##1 overflow_flag", "ori_sva": "property fifo_overflow_protection_check;\n@(posedge clk_uart)      fifo_full |-> ##2 !write_enable ##1 overflow_flag\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: fifo_overflow_protection_check  \n**Trigger Condition**: At every rising edge of the `clk_uart`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `fifo_full == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 !write_enable ##1 overflow_flag`  ", "sva_signals": ["clk_uart", "[0:0] fifo_full", "[0:0] write_enable", "[0:0] overflow_flag"], "clock": "clk_uart", "attempts_left": 10, "sva_result": "@(posedge clk_uart)     fifo_full == 1'b1 |-> ##2 !write_enable ##1 overflow_flag;", "sva_name": "p_fifo_full_no_write_and_overflow", "full_property": "property fifo_overflow_protection_check;\n@(posedge clk_uart)     fifo_full == 1'b1 |-> ##2 !write_enable ##1 overflow_flag;\nendproperty\nassert_fifo_overflow_protection_check:assert property (fifo_overflow_protection_check) else $error(\"\");", "task_id": "4_6677", "predict_sva": "@(posedge clk_uart)         fifo_full == 1'b1 |-> ##2 (write_enable == 1'b0) ##1 (overflow_flag == 1'b1)"}
{"id": "1_9_0048", "name": "clock_switch_verify", "sva": "@(posedge clk_primary)      clock_switch_req |-> ##9 clk_secondary_stable ##3 clk_primary_stopped", "ori_sva": "property clock_switch_verify;\n@(posedge clk_primary)      clock_switch_req |-> ##9 clk_secondary_stable ##3 clk_primary_stopped\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: clock_switch_verify  \n**Trigger Condition**: At every rising edge of `clk_primary`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `clock_switch_req == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##9 clk_secondary_stable ##3 clk_primary_stopped`  ", "sva_signals": ["clk_primary", "clk_secondary_stable", "clk_primary_stopped", "[0:0] clock_switch_req"], "clock": "clk_primary", "attempts_left": 10, "sva_result": "@(posedge clk_primary)     clock_switch_req == 1'b1 |-> ##9 clk_secondary_stable ##3 clk_primary_stopped;", "sva_name": "p_clock_switch_sequence", "full_property": "property clock_switch_verify;\n@(posedge clk_primary)     clock_switch_req == 1'b1 |-> ##9 clk_secondary_stable ##3 clk_primary_stopped;\nendproperty\nassert_clock_switch_verify:assert property (clock_switch_verify) else $error(\"\");", "task_id": "4_6678", "predict_sva": "@(posedge clk_primary)         clock_switch_req == 1'b1 |-> ##9 clk_secondary_stable == 1'b1 ##3 clk_primary_stopped == 1'b1"}
{"id": "2_12_0002", "name": "packet_start_to_end", "sva": "@(posedge clk_net)     pkt_start |-> ##[16:256] pkt_end", "ori_sva": "property packet_start_to_end;\n@(posedge clk_net)     pkt_start |-> ##[16:256] pkt_end\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: packet_start_to_end  \n**Trigger Condition**: At every rising edge of the `clk_net`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `pkt_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:256] pkt_end == 1'b1`  ", "sva_signals": ["clk", "rst_n", "[0:0] pkt_start", "[0:0] pkt_end", "clk_net"], "clock": "clk_net", "attempts_left": 10, "sva_result": "@(posedge clk_net)         pkt_start == 1'b1 |-> ##[16:256] pkt_end == 1'b1;", "sva_name": "p_pkt_end_within_16_to_256_cycles_after_pkt_start", "full_property": "property packet_start_to_end;\n@(posedge clk_net)         pkt_start == 1'b1 |-> ##[16:256] pkt_end == 1'b1;\nendproperty\nassert_packet_start_to_end:assert property (packet_start_to_end) else $error(\"\");", "task_id": "4_6680", "predict_sva": "@(posedge clk_net)         pkt_start == 1'b1 |-> ##[16:256] pkt_end == 1'b1"}
{"id": "2_1_0062", "name": "data_valid_stable_after_fall", "sva": "@(posedge clk_sys)      $fell(data_valid) |-> ##[3:8] $stable(payload_data)", "ori_sva": "property data_valid_stable_after_fall;\n@(posedge clk_sys)      $fell(data_valid) |-> ##[3:8] $stable(payload_data)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: data_valid_stable_after_fall  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(data_valid)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:8] $stable(payload_data)`  ", "sva_signals": ["clk_sys", "[0:0] data_valid", "payload_data", "[0:0] clk", "[0:0] rst_n"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     $fell(data_valid) |-> ##[3:8] $stable(payload_data);", "sva_name": "p_payload_data_stable_after_data_valid_fall", "full_property": "property data_valid_stable_after_fall;\n@(posedge clk_sys)     $fell(data_valid) |-> ##[3:8] $stable(payload_data);\nendproperty\nassert_data_valid_stable_after_fall:assert property (data_valid_stable_after_fall) else $error(\"\");", "task_id": "4_6687", "predict_sva": "@(posedge clk_sys)         $fell(data_valid) |-> ##[3:8] $stable(payload_data)"}
{"id": "2_31_0071", "name": "audio_sample_ready", "sva": "@(posedge clk_audio)     audio_start |-> ##[4:32] audio_ready", "ori_sva": "property audio_sample_ready;\n@(posedge clk_audio)     audio_start |-> ##[4:32] audio_ready\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: audio_sample_ready  \n**Trigger Condition**: At every rising edge of the `clk_audio`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `audio_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[4:32] audio_ready == 1'b1`  ", "sva_signals": ["clk_audio", "rst_n", "[0:0] audio_start", "[0:0] audio_ready"], "clock": "clk_audio", "attempts_left": 10, "sva_result": "@(posedge clk_audio)     audio_start == 1'b1 |-> ##[4:32] audio_ready == 1'b1;", "sva_name": "p_audio_ready_within_4_to_32_cycles_after_start", "full_property": "property audio_sample_ready;\n@(posedge clk_audio)     audio_start == 1'b1 |-> ##[4:32] audio_ready == 1'b1;\nendproperty\nassert_audio_sample_ready:assert property (audio_sample_ready) else $error(\"\");", "task_id": "4_6699", "predict_sva": "@(posedge clk_audio)         audio_start == 1'b1 |-> ##[4:32] audio_ready == 1'b1"}
{"id": "2_30_0053", "name": "video_frame_sync_delay", "sva": "@(posedge clk_video)     frame_start |-> ##[16:64] frame_end", "ori_sva": "property video_frame_sync_delay;\n@(posedge clk_video)     frame_start |-> ##[16:64] frame_end\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: video_frame_sync_delay  \n**Trigger Condition**: At every posedge of the `clk_video`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `frame_start`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:64] frame_end`  ", "sva_signals": ["clk_video", "[0:0] frame_start", "[0:0] frame_end"], "clock": "clk_video", "attempts_left": 10, "sva_result": "@(posedge clk_video)         frame_start |-> ##[16:64] frame_end;", "sva_name": "p_frame_end_within_16_to_64_cycles_after_frame_start", "full_property": "property video_frame_sync_delay;\n@(posedge clk_video)         frame_start |-> ##[16:64] frame_end;\nendproperty\nassert_video_frame_sync_delay:assert property (video_frame_sync_delay) else $error(\"\");", "task_id": "4_6700", "predict_sva": "@(posedge clk_video)         frame_start == 1 |-> ##[16:64] frame_end == 1"}
{"id": "2_3_0056", "name": "interrupt_pending_to_ack", "sva": "@(posedge clk_core)     (int_pend && !int_mask) |-> ##[2:32] int_ack", "ori_sva": "property interrupt_pending_to_ack;\n@(posedge clk_core)     (int_pend && !int_mask) |-> ##[2:32] int_ack\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: interrupt_pending_to_ack  \n**Trigger Condition**: At every rising edge of the `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `int_pend && !int_mask`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:32] int_ack`  \n\n", "sva_signals": ["clk_core", "rst_n", "[0:0] int_pend", "[0:0] int_mask", "[0:0] int_ack"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)         (int_pend && !int_mask) |-> ##[2:32] int_ack;", "sva_name": "p_int_ack_within_2_to_32_cycles_after_pending_unmasked", "full_property": "property interrupt_pending_to_ack;\n@(posedge clk_core)         (int_pend && !int_mask) |-> ##[2:32] int_ack;\nendproperty\nassert_interrupt_pending_to_ack:assert property (interrupt_pending_to_ack) else $error(\"\");", "task_id": "4_6708", "predict_sva": "@(posedge clk_core)         (int_pend == 1 && int_mask == 0) |-> ##[2:32] int_ack == 1"}
{"id": "2_43_0083", "name": "gps_fix_acquired", "sva": "@(posedge clk_gps)     gps_start |-> ##[30:180] gps_fix", "ori_sva": "property gps_fix_acquired;\n@(posedge clk_gps)     gps_start |-> ##[30:180] gps_fix\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: gps_fix_acquired  \n**Trigger Condition**: At every rising edge of the `clk_gps`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `gps_start == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[30:180] gps_fix == 1'b1`  \n\n(Note: The consequent specifies that within 30 to 180 clock cycles after the antecedent is true, `gps_fix` must be asserted (`1'b1`).)", "sva_signals": ["clk_gps", "[0:0] gps_start", "[0:0] gps_fix"], "clock": "clk_gps", "attempts_left": 10, "sva_result": "@(posedge clk_gps)     gps_start == 1'b1 |-> ##[30:180] gps_fix == 1'b1;", "sva_name": "p_gps_fix_within_30_to_180_cycles_after_start", "full_property": "property gps_fix_acquired;\n@(posedge clk_gps)     gps_start == 1'b1 |-> ##[30:180] gps_fix == 1'b1;\nendproperty\nassert_gps_fix_acquired:assert property (gps_fix_acquired) else $error(\"\");", "task_id": "4_6713", "predict_sva": "@(posedge clk_gps)         gps_start == 1'b1 |-> ##[30:180] gps_fix == 1'b1"}
{"id": "3_22_0120", "name": "audio_sample_sync_check", "sva": "@(posedge audio_bclk)     audio_lrclk_change |-> ##[16:32] audio_data_valid", "ori_sva": "property audio_sample_sync_check;\n@(posedge audio_bclk)     audio_lrclk_change |-> ##[16:32] audio_data_valid\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: audio_sample_sync_check  \n**Trigger Condition**: At every rising edge of `audio_bclk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `audio_lrclk_change`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[16:32] audio_data_valid`  ", "sva_signals": ["audio_bclk", "audio_lrclk", "[0:0] audio_lrclk_change", "[0:0] audio_data_valid"], "clock": "audio_bclk", "attempts_left": 10, "sva_result": "@(posedge audio_bclk)     audio_lrclk_change |-> ##[16:32] audio_data_valid;", "sva_name": "p_audio_data_valid_after_lrclk_change", "full_property": "property audio_sample_sync_check;\n@(posedge audio_bclk)     audio_lrclk_change |-> ##[16:32] audio_data_valid;\nendproperty\nassert_audio_sample_sync_check:assert property (audio_sample_sync_check) else $error(\"\");", "task_id": "4_6738", "predict_sva": "@(posedge audio_bclk)         audio_lrclk_change == 1 |-> ##[16:32] audio_data_valid == 1"}
{"id": "3_3_0103", "name": "axi4_awaddr_burst_len_consistency", "sva": "@(posedge axi_clk)     (awvalid && awready) |-> ##[2:4] ($countones(awlen) == (awburst == 2'b01))", "ori_sva": "property axi4_awaddr_burst_len_consistency;\n@(posedge axi_clk)     (awvalid && awready) |-> ##[2:4] ($countones(awlen) == (awburst == 2'b01))\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: axi4_awaddr_burst_len_consistency  \n**Trigger Condition**: At every rising edge of the `axi_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `awvalid && awready`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] ($countones(awlen) == (awburst == 2'b01))`  ", "sva_signals": ["axi_clk", "[0:0] awvalid", "[0:0] awready", "[7:0] awlen", "[1:0] awburst"], "clock": "axi_clk", "attempts_left": 10, "sva_result": "@(posedge axi_clk)     (awvalid && awready) |-> ##[2:4] ($countones(awlen) == (awburst == 2'b01));", "sva_name": "p_aw_channel_handshake_awlen_countones", "full_property": "property axi4_awaddr_burst_len_consistency;\n@(posedge axi_clk)     (awvalid && awready) |-> ##[2:4] ($countones(awlen) == (awburst == 2'b01));\nendproperty\nassert_axi4_awaddr_burst_len_consistency:assert property (axi4_awaddr_burst_len_consistency) else $error(\"\");", "task_id": "4_6756", "predict_sva": "@(posedge axi_clk)         (awvalid == 1 && awready == 1) |-> ##[2:4] ($countones(awlen) == (awburst == 2'b01))"}
{"id": "3_8_0127", "name": "can_bus_error_frame_detection", "sva": "@(posedge can_clk)     can_error_flag |-> ##[6:7] can_error_counter > 8'h7f", "ori_sva": "property can_bus_error_frame_detection;\n@(posedge can_clk)     can_error_flag |-> ##[6:7] can_error_counter > 8'h7f\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: can_bus_error_frame_detection  \n**Trigger Condition**: At every rising edge of the `can_clk`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `can_error_flag == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: Within 6 to 7 clock cycles (`##[6:7]`), `can_error_counter` must be greater than `8'h7f` (`can_error_counter > 8'h7f`)", "sva_signals": ["can_clk", "[0:0] can_error_flag", "[7:0] can_error_counter"], "clock": "can_clk", "attempts_left": 10, "sva_result": "@(posedge can_clk)     can_error_flag == 1'b1 |-> ##[6:7] (can_error_counter > 8'h7f);", "sva_name": "p_can_error_counter_exceeds_7f_within_6_7_cycles", "full_property": "property can_bus_error_frame_detection;\n@(posedge can_clk)     can_error_flag == 1'b1 |-> ##[6:7] (can_error_counter > 8'h7f);\nendproperty\nassert_can_bus_error_frame_detection:assert property (can_bus_error_frame_detection) else $error(\"\");", "task_id": "4_6768", "predict_sva": "@(posedge can_clk)         can_error_flag == 1'b1 |-> ##[6:7] can_error_counter > 8'h7f"}
{"id": "10_7_0454", "name": "interrupt_past_sequence_7", "sva": "@(posedge clk_intr)     intr_pending |-> $past(intr_enable, 5) ##[2:4] $past(intr_source, 3) == IRQ_TIMER", "ori_sva": "property interrupt_past_sequence_7;\n@(posedge clk_intr)     intr_pending |-> $past(intr_enable, 5) ##[2:4] $past(intr_source, 3) == IRQ_TIMER\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: interrupt_past_sequence_7  \n**Trigger Condition**: At every rising edge of `clk_intr`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `intr_pending == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `$past(intr_enable, 5) ##[2:4] $past(intr_source, 3) == IRQ_TIMER`  \n\n**Explanation of Consequent**:  \nThe consequent checks that:  \n1. The value of `intr_enable` **5 clock cycles ago** was true (`$past(intr_enable, 5)`), **followed by**  \n2. The value of `intr_source` **3 clock cycles ago** equals `IRQ_TIMER` (`$past(intr_source, 3) == IRQ_TIMER`), with a **delay of 2 to 4 clock cycles** (`##[2:4]`) between the two past conditions.  \n\nThis assertion ensures that when an interrupt is pending (`intr_pending`), the interrupt enable signal was active 5 cycles prior, and the interrupt source was `IRQ_TIMER` 3 cycles prior, with a variable delay (2-4 cycles) between these two past events.", "sva_signals": ["clk_intr", "intr_pending", "intr_enable", "[2:0] intr_source", "IRQ_TIMER"], "clock": "clk_intr", "attempts_left": 10, "sva_result": "@(posedge clk_intr)     intr_pending == 1'b1 |->      $past(intr_enable, 5) ##[2:4] $past(intr_source, 3) == IRQ_TIMER;", "sva_name": "p_intr_pending_sequence_check", "full_property": "property interrupt_past_sequence_7;\n@(posedge clk_intr)     intr_pending == 1'b1 |->      $past(intr_enable, 5) ##[2:4] $past(intr_source, 3) == IRQ_TIMER;\nendproperty\nassert_interrupt_past_sequence_7:assert property (interrupt_past_sequence_7) else $error(\"\");", "task_id": "4_7082", "predict_sva": "@(posedge clk_intr)         intr_pending == 1'b1 |->          ($past(intr_enable, 5) == 1'b1) ##[2:4] ($past(intr_source, 3) == IRQ_TIMER)"}
{"id": "11_13_0512", "name": "adc_conversion_complete", "sva": "@(posedge clk_adc)     (conv_start && ref_volt_stable) |-> ##8 (data_ready && !conv_busy)", "ori_sva": "property adc_conversion_complete;\n@(posedge clk_adc)     (conv_start && ref_volt_stable) |-> ##8 (data_ready && !conv_busy)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: adc_conversion_complete  \n**Trigger Condition**: At every rising edge of the `clk_adc`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `conv_start && ref_volt_stable`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##8 (data_ready && !conv_busy)`  ", "sva_signals": ["clk_adc", "[0:0] conv_start", "[0:0] ref_volt_stable", "[0:0] data_ready", "[0:0] conv_busy"], "clock": "clk_adc", "attempts_left": 10, "sva_result": "@(posedge clk_adc)     (conv_start && ref_volt_stable) |-> ##8 (data_ready && !conv_busy);", "sva_name": "p_adc_conversion_data_ready_busy", "full_property": "property adc_conversion_complete;\n@(posedge clk_adc)     (conv_start && ref_volt_stable) |-> ##8 (data_ready && !conv_busy);\nendproperty\nassert_adc_conversion_complete:assert property (adc_conversion_complete) else $error(\"\");", "task_id": "4_7086", "predict_sva": "@(posedge clk_adc)         (conv_start == 1 && ref_volt_stable == 1) |-> ##8 (data_ready == 1 && conv_busy == 0)"}
{"id": "11_21_0526", "name": "flash_write_protection", "sva": "@(posedge clk_flash)     (write_cmd && !wp_n) |-> ##4 write_error", "ori_sva": "property flash_write_protection;\n@(posedge clk_flash)     (write_cmd && !wp_n) |-> ##4 write_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: flash_write_protection  \n**Trigger Condition**: At every rising edge of the `clk_flash`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_cmd && !wp_n`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 write_error`", "sva_signals": ["clk_flash", "wp_n", "[0:0] write_cmd", "[0:0] write_error"], "clock": "clk_flash", "attempts_left": 10, "sva_result": "@(posedge clk_flash)         (write_cmd && !wp_n) |-> ##4 write_error;", "sva_name": "p_write_error_after_protected_write", "full_property": "property flash_write_protection;\n@(posedge clk_flash)         (write_cmd && !wp_n) |-> ##4 write_error;\nendproperty\nassert_flash_write_protection:assert property (flash_write_protection) else $error(\"\");", "task_id": "4_7095", "predict_sva": "@(posedge clk_flash)         (write_cmd == 1 && wp_n == 0) |-> ##4 (write_error == 1)"}
{"id": "11_24_0521", "name": "voltage_monitor_alert", "sva": "@(posedge clk_vmon)     (vcc_high || vcc_low) && !test_mode |-> ##2 power_alert", "ori_sva": "property voltage_monitor_alert;\n@(posedge clk_vmon)     (vcc_high || vcc_low) && !test_mode |-> ##2 power_alert\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: voltage_monitor_alert  \n**Trigger Condition**: At every rising edge of the `clk_vmon`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(vcc_high || vcc_low) && !test_mode`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 power_alert`  ", "sva_signals": ["clk_vmon", "[0:0] vcc_high", "[0:0] vcc_low", "[0:0] test_mode", "[0:0] power_alert"], "clock": "clk_vmon", "attempts_left": 10, "sva_result": "@(posedge clk_vmon)     ((vcc_high || vcc_low) && !test_mode) |-> ##2 power_alert;", "sva_name": "p_power_alert_after_vcc_event", "full_property": "property voltage_monitor_alert;\n@(posedge clk_vmon)     ((vcc_high || vcc_low) && !test_mode) |-> ##2 power_alert;\nendproperty\nassert_voltage_monitor_alert:assert property (voltage_monitor_alert) else $error(\"\");", "task_id": "4_7098", "predict_sva": "@(posedge clk_vmon)         (vcc_high == 1 || vcc_low == 1) && test_mode == 0 |-> ##2 power_alert == 1"}
{"id": "11_30_0531", "name": "rfid_tag_detected", "sva": "@(posedge clk_rfid)     (carrier_on && modulation_detected) |-> ##[5:20] tag_present", "ori_sva": "property rfid_tag_detected;\n@(posedge clk_rfid)     (carrier_on && modulation_detected) |-> ##[5:20] tag_present\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: rfid_tag_detected  \n**Trigger Condition**: At every rising edge of the `clk_rfid`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `carrier_on && modulation_detected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:20] tag_present`  ", "sva_signals": ["clk_rfid", "carrier_on", "modulation_detected", "tag_present"], "clock": "clk_rfid", "attempts_left": 10, "sva_result": "@(posedge clk_rfid)     (carrier_on && modulation_detected) |-> ##[5:20] tag_present;", "sva_name": "p_tag_present_within_5_to_20_cycles", "full_property": "property rfid_tag_detected;\n@(posedge clk_rfid)     (carrier_on && modulation_detected) |-> ##[5:20] tag_present;\nendproperty\nassert_rfid_tag_detected:assert property (rfid_tag_detected) else $error(\"\");", "task_id": "4_7105", "predict_sva": "@(posedge clk_rfid)         (carrier_on == 1 && modulation_detected == 1) |-> ##[5:20] tag_present == 1"}
{"id": "11_44_0537", "name": "fan_speed_adjust", "sva": "@(posedge clk_fan)     (temp_change && !manual_override) |-> ##[3:6] pwm_duty_updated", "ori_sva": "property fan_speed_adjust;\n@(posedge clk_fan)     (temp_change && !manual_override) |-> ##[3:6] pwm_duty_updated\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: fan_speed_adjust  \n**Trigger Condition**: At every rising edge of the `clk_fan`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_change && !manual_override`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:6] pwm_duty_updated`  ", "sva_signals": ["clk_fan", "[0:0] temp_change", "[0:0] manual_override", "pwm_duty_updated"], "clock": "clk_fan", "attempts_left": 10, "sva_result": "@(posedge clk_fan)     (temp_change && !manual_override) |-> ##[3:6] pwm_duty_updated;", "sva_name": "p_pwm_duty_update_on_temp_change", "full_property": "property fan_speed_adjust;\n@(posedge clk_fan)     (temp_change && !manual_override) |-> ##[3:6] pwm_duty_updated;\nendproperty\nassert_fan_speed_adjust:assert property (fan_speed_adjust) else $error(\"\");", "task_id": "4_7118", "predict_sva": "@(posedge clk_fan)         (temp_change == 1 && manual_override == 0) |-> ##[3:6] pwm_duty_updated == 1"}
{"id": "11_4_0497", "name": "irq_edge_status_update", "sva": "@(negedge clk_irq_ctrl)     $fell(irq_mask[3]) && $rose(irq_status[3]) |-> ##1 irq_pending[3] && !irq_serviced[3]", "ori_sva": "property irq_edge_status_update;\n@(negedge clk_irq_ctrl)     $fell(irq_mask[3]) && $rose(irq_status[3]) |-> ##1 irq_pending[3] && !irq_serviced[3]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: irq_edge_status_update  \n**Trigger Condition**: At every falling edge of the `clk_irq_ctrl`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(irq_mask[3]) && $rose(irq_status[3])`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 irq_pending[3] && !irq_serviced[3]`  ", "sva_signals": ["clk_irq_ctrl", "irq_mask[3:0]", "irq_status[3:0]", "irq_pending[3:0]", "irq_serviced[3:0]"], "clock": "clk_irq_ctrl", "attempts_left": 10, "sva_result": "@(negedge clk_irq_ctrl)     $fell(irq_mask[3]) && $rose(irq_status[3]) |-> ##1 (irq_pending[3] && !irq_serviced[3]);", "sva_name": "p_irq_pending_serviced_on_irq_mask_fall_and_status_rise", "full_property": "property irq_edge_status_update;\n@(negedge clk_irq_ctrl)     $fell(irq_mask[3]) && $rose(irq_status[3]) |-> ##1 (irq_pending[3] && !irq_serviced[3]);\nendproperty\nassert_irq_edge_status_update:assert property (irq_edge_status_update) else $error(\"\");", "task_id": "4_7124", "predict_sva": "@(negedge clk_irq_ctrl)         ($fell(irq_mask[3]) && $rose(irq_status[3])) |-> ##1 (irq_pending[3] == 1 && irq_serviced[3] == 0)"}
{"id": "12_4_0572", "name": "irq_or_wdog_check_4", "sva": "@(posedge clk_core)      $fell(irq_mask_n) || $rose(wdog_timer_expire) |-> ##[2:5] $onehot(irq_vector)", "ori_sva": "property irq_or_wdog_check_4;\n@(posedge clk_core)      $fell(irq_mask_n) || $rose(wdog_timer_expire) |-> ##[2:5] $onehot(irq_vector)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: irq_or_wdog_check_4  \n**Trigger Condition**: At every rising edge of `clk_core`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(irq_mask_n) || $rose(wdog_timer_expire)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:5] $onehot(irq_vector)`  ", "sva_signals": ["clk_core", "irq_mask_n", "[0:0] wdog_timer_expire", "irq_vector"], "clock": "clk_core", "attempts_left": 10, "sva_result": "@(posedge clk_core)     ($fell(irq_mask_n) || $rose(wdog_timer_expire)) |-> ##[2:5] $onehot(irq_vector);", "sva_name": "p_irq_vector_one_hot_after_irq_mask_or_wdog", "full_property": "property irq_or_wdog_check_4;\n@(posedge clk_core)     ($fell(irq_mask_n) || $rose(wdog_timer_expire)) |-> ##[2:5] $onehot(irq_vector);\nendproperty\nassert_irq_or_wdog_check_4:assert property (irq_or_wdog_check_4) else $error(\"\");", "task_id": "4_7164", "predict_sva": "@(posedge clk_core)         ($fell(irq_mask_n) || $rose(wdog_timer_expire)) |-> ##[2:5] ($onehot(irq_vector))"}
{"id": "15_22_0727", "name": "pll_lock_check_22", "sva": "@(posedge clk_ref) disable iff(!pll_reset_n)     pll_enable |-> ##[5:20] pll_locked ##1 clock_output_stable", "ori_sva": "property pll_lock_check_22;\n@(posedge clk_ref) disable iff(!pll_reset_n)     pll_enable |-> ##[5:20] pll_locked ##1 clock_output_stable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: pll_lock_check_22  \n**Trigger Condition**: At every rising edge of the `clk_ref`  \n**Disable Condition**: disable iff (!pll_reset_n)  \n**Antecedent (LHS of Implication)**: `pll_enable == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[5:20] pll_locked ##1 clock_output_stable`  ", "sva_signals": ["clk", "pll_reset_n", "[0:0] pll_enable", "[0:0] pll_locked", "[0:0] clock_output_stable", "clk_ref"], "clock": "clk_ref", "attempts_left": 10, "sva_result": "@(posedge clk_ref) disable iff (!pll_reset_n)     pll_enable == 1'b1 |-> ##[5:20] pll_locked ##1 clock_output_stable;", "sva_name": "p_pll_locked_and_clock_output_stable_sequence", "full_property": "property pll_lock_check_22;\n@(posedge clk_ref) disable iff (!pll_reset_n)     pll_enable == 1'b1 |-> ##[5:20] pll_locked ##1 clock_output_stable;\nendproperty\nassert_pll_lock_check_22:assert property (pll_lock_check_22) else $error(\"\");", "task_id": "4_7256", "predict_sva": "@(posedge clk_ref) disable iff (!pll_reset_n)         (pll_enable == 1'b1 && pll_reset_n == 1'b1) |-> ##[5:20] (pll_locked == 1'b1) ##1 (clock_output_stable == 1'b1)"}
{"id": "15_50_0749", "name": "sonar_check_50", "sva": "@(posedge clk_sonar) disable iff(sonar_reset)     ping_sent |-> ##[3:8] echo_detected ##1 (time_diff == calculated_distance)", "ori_sva": "property sonar_check_50;\n@(posedge clk_sonar) disable iff(sonar_reset)     ping_sent |-> ##[3:8] echo_detected ##1 (time_diff == calculated_distance)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: sonar_check_50  \n**Trigger Condition**: At every rising edge of the `clk_sonar`  \n**Disable Condition**: `disable iff (sonar_reset)`  \n**Antecedent (LHS of Implication)**: `ping_sent == 1'b1`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[3:8] echo_detected ##1 (time_diff == calculated_distance)`  ", "sva_signals": ["clk_sonar", "sonar_reset", "[0:0] ping_sent", "[0:0] echo_detected", "[0:0] time_diff", "[0:0] calculated_distance"], "clock": "clk_sonar", "attempts_left": 10, "sva_result": "@(posedge clk_sonar) disable iff (sonar_reset)     ping_sent == 1'b1 |-> ##[3:8] echo_detected ##1 (time_diff == calculated_distance);", "sva_name": "p_echo_detected_and_time_diff_after_ping", "full_property": "property sonar_check_50;\n@(posedge clk_sonar) disable iff (sonar_reset)     ping_sent == 1'b1 |-> ##[3:8] echo_detected ##1 (time_diff == calculated_distance);\nendproperty\nassert_sonar_check_50:assert property (sonar_check_50) else $error(\"\");", "task_id": "4_7279", "predict_sva": "@(posedge clk_sonar) disable iff (sonar_reset)         (sonar_reset == 0 && ping_sent == 1'b1) |-> ##[3:8] (echo_detected == 1'b1) ##1 (time_diff == calculated_distance)"}
{"id": "2_39_0087", "name": "nand_ecc_check_39", "sva": "@(posedge clk_nand)      $rose(ecc_start) |-> ##[8:32] $fell(ecc_done)", "ori_sva": "property nand_ecc_check_39;\n@(posedge clk_nand)      $rose(ecc_start) |-> ##[8:32] $fell(ecc_done)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: nand_ecc_check_39  \n**Trigger Condition**: At every rising edge of the `clk_nand`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(ecc_start)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[8:32] $fell(ecc_done)`  ", "sva_signals": ["clk_nand", "ecc_start", "ecc_done"], "clock": "clk_nand", "attempts_left": 10, "sva_result": "@(posedge clk_nand)         $rose(ecc_start) |-> ##[8:32] $fell(ecc_done);", "sva_name": "p_ecc_done_fall_after_ecc_start_rise", "full_property": "property nand_ecc_check_39;\n@(posedge clk_nand)         $rose(ecc_start) |-> ##[8:32] $fell(ecc_done);\nendproperty\nassert_nand_ecc_check_39:assert property (nand_ecc_check_39) else $error(\"\");", "task_id": "4_7360", "predict_sva": "@(posedge clk_nand)         $rose(ecc_start) |-> ##[8:32] $fell(ecc_done)"}
{"id": "3_5_0090", "name": "interrupt_sequence_5", "sva": "@(posedge clk_periph)     $rose(irq_line) |-> (##[0:2] irq_ack ##1 irq_service)", "ori_sva": "property interrupt_sequence_5;\n@(posedge clk_periph)     $rose(irq_line) |-> (##[0:2] irq_ack ##1 irq_service)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: interrupt_sequence_5  \n**Trigger Condition**: At every rising edge of `clk_periph`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(irq_line)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] irq_ack ##1 irq_service`  ", "sva_signals": ["clk", "rst_n", "[0:0] irq_line", "[0:0] irq_ack", "[0:0] irq_service", "clk_periph"], "clock": "clk_periph", "attempts_left": 10, "sva_result": "@(posedge clk_periph)     $rose(irq_line) |-> ##[0:2] irq_ack ##1 irq_service;", "sva_name": "p_irq_ack_and_service_after_irq_line_rise", "full_property": "property interrupt_sequence_5;\n@(posedge clk_periph)     $rose(irq_line) |-> ##[0:2] irq_ack ##1 irq_service;\nendproperty\nassert_interrupt_sequence_5:assert property (interrupt_sequence_5) else $error(\"\");", "task_id": "4_7416", "predict_sva": "@(posedge clk_periph)         $rose(irq_line) |-> ##[0:2] irq_ack ##1 irq_service"}
{"id": "6_13_0248", "name": "thermal_throttle_check_13", "sva": "@(posedge clk_temp)      temp_high[*4:8] |-> ##[2:4] throttle_en[*3:6] ##1 $fell(clock_freq)", "ori_sva": "property thermal_throttle_check_13;\n@(posedge clk_temp)      temp_high[*4:8] |-> ##[2:4] throttle_en[*3:6] ##1 $fell(clock_freq)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: thermal_throttle_check_13  \n**Trigger Condition**: At every rising edge of `clk_temp`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `temp_high` is true for 4 to 8 consecutive clock cycles (`temp_high[*4:8]`)  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**:  \n- After 2 to 4 clock cycles (`##[2:4]`), `throttle_en` must be true for 3 to 6 consecutive clock cycles (`throttle_en[*3:6]`),  \n- Followed by a falling edge of `clock_freq` on the next clock cycle (`##1 $fell(clock_freq)`).", "sva_signals": ["clk_temp", "[0:0] temp_high", "[0:0] throttle_en", "[0:0] clock_freq"], "clock": "clk_temp", "attempts_left": 10, "sva_result": "@(posedge clk_temp)     temp_high[*4:8] |-> ##[2:4] (throttle_en[*3:6] ##1 $fell(clock_freq));", "sva_name": "p_temp_high_throttle_clock_freq_fall", "full_property": "property thermal_throttle_check_13;\n@(posedge clk_temp)     temp_high[*4:8] |-> ##[2:4] (throttle_en[*3:6] ##1 $fell(clock_freq));\nendproperty\nassert_thermal_throttle_check_13:assert property (thermal_throttle_check_13) else $error(\"\");", "task_id": "4_7505", "predict_sva": "@(posedge clk_temp)         (temp_high [*4:8]) |-> ##[2:4] (throttle_en [*3:6]) ##1 $fell(clock_freq)"}
{"id": "7_21_0305", "name": "lcd_power_on_init", "sva": "@(posedge clk_lcd_controller)      $rose(lcd_power_on) |-> ##3 lcd_init_start", "ori_sva": "property lcd_power_on_init;\n@(posedge clk_lcd_controller)      $rose(lcd_power_on) |-> ##3 lcd_init_start\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: lcd_power_on_init  \n**Trigger Condition**: At every rising edge of the `clk_lcd_controller`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(lcd_power_on)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 lcd_init_start`  ", "sva_signals": ["clk_lcd_controller", "[0:0] lcd_power_on", "[0:0] lcd_init_start"], "clock": "clk_lcd_controller", "attempts_left": 10, "sva_result": "@(posedge clk_lcd_controller)         $rose(lcd_power_on) |-> ##3 lcd_init_start;", "sva_name": "p_lcd_init_start_after_power_on_rise", "full_property": "property lcd_power_on_init;\n@(posedge clk_lcd_controller)         $rose(lcd_power_on) |-> ##3 lcd_init_start;\nendproperty\nassert_lcd_power_on_init:assert property (lcd_power_on_init) else $error(\"\");", "task_id": "4_7552", "predict_sva": "@(posedge clk_lcd_controller)         $rose(lcd_power_on) |-> ##3 lcd_init_start"}
{"id": "7_25_0323", "name": "jtag_tms_rise_shift", "sva": "@(posedge clk_jtag_tap)      $rose(jtag_tms) |-> ##[1:4] jtag_shift_state", "ori_sva": "property jtag_tms_rise_shift;\n@(posedge clk_jtag_tap)      $rose(jtag_tms) |-> ##[1:4] jtag_shift_state\nendproperty", "sva_description": "### Assertion description:\n**Property Name**: jtag_tms_rise_shift  \n**Trigger Condition**: At every posedge of the `clk_jtag_tap`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(jtag_tms)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] jtag_shift_state`  \n\nThe assertion checks that whenever there is a rising edge on `jtag_tms` (indicating the start of a JTAG TMS signal transition), within 1 to 4 clock cycles of `clk_jtag_tap`, the `jtag_shift_state` signal should become active. This ensures proper timing behavior between the TMS signal transition and the shift state activation in a JTAG TAP controller.", "sva_signals": ["clk_jtag_tap", "jtag_tms", "[0:0] jtag_shift_state"], "clock": "clk_jtag_tap", "attempts_left": 10, "sva_result": "@(posedge clk_jtag_tap)     $rose(jtag_tms) |-> ##[1:4] jtag_shift_state;", "sva_name": "p_jtag_shift_state_activation_after_tms_rise", "full_property": "property jtag_tms_rise_shift;\n@(posedge clk_jtag_tap)     $rose(jtag_tms) |-> ##[1:4] jtag_shift_state;\nendproperty\nassert_jtag_tms_rise_shift:assert property (jtag_tms_rise_shift) else $error(\"\");", "task_id": "4_7554", "predict_sva": "@(posedge clk_jtag_tap)         $rose(jtag_tms) |-> ##[1:4] jtag_shift_state"}
{"id": "8_16_0377", "name": "fall_edge_detection_16", "sva": "@(posedge clk_dac)     $fell(output_enable) |-> ##2 $past(analog_value,2) inside {[0:4095]}", "ori_sva": "property fall_edge_detection_16;\n@(posedge clk_dac)     $fell(output_enable) |-> ##2 $past(analog_value,2) inside {[0:4095]}\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: fall_edge_detection_16  \n**Trigger Condition**: At every rising edge of the `clk_dac`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(output_enable)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 $past(analog_value,2) inside {[0:4095]}`  ", "sva_signals": ["clk_dac", "output_enable", "[11:0] analog_value"], "clock": "clk_dac", "attempts_left": 10, "sva_result": "@(posedge clk_dac)     $fell(output_enable) |-> ##2 $past(analog_value,2) inside {[0:4095]};", "sva_name": "p_analog_value_range_after_output_enable_fall", "full_property": "property fall_edge_detection_16;\n@(posedge clk_dac)     $fell(output_enable) |-> ##2 $past(analog_value,2) inside {[0:4095]};\nendproperty\nassert_fall_edge_detection_16:assert property (fall_edge_detection_16) else $error(\"\");", "task_id": "4_7593", "predict_sva": "@(posedge clk_dac)         $fell(output_enable) |-> ##2 (0 <= analog_value <= 4095)"}
{"id": "8_31_0363", "name": "fall_edge_detection_31", "sva": "@(posedge clk_gsm)     $fell(power_amp_enable) |=> ##[3:7] $past(timing_advance,4) inside {[0:63]}", "ori_sva": "property fall_edge_detection_31;\n@(posedge clk_gsm)     $fell(power_amp_enable) |=> ##[3:7] $past(timing_advance,4) inside {[0:63]}\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: fall_edge_detection_31  \n**Trigger Condition**: At every rising edge of the `clk_gsm`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$fell(power_amp_enable)`  \n**Implication Operator**: `|=>`  \n**Consequent (RHS of Implication)**: `##[3:7] $past(timing_advance,4) inside {[0:63]}`  ", "sva_signals": ["clk_gsm", "power_amp_enable", "[5:0] timing_advance"], "clock": "clk_gsm", "attempts_left": 10, "sva_result": "@(posedge clk_gsm)     $fell(power_amp_enable) |=> ##[3:7] $past(timing_advance,4) inside {[0:63]};", "sva_name": "p_timing_advance_range_on_power_amp_enable_fall", "full_property": "property fall_edge_detection_31;\n@(posedge clk_gsm)     $fell(power_amp_enable) |=> ##[3:7] $past(timing_advance,4) inside {[0:63]};\nendproperty\nassert_fall_edge_detection_31:assert property (fall_edge_detection_31) else $error(\"\");", "task_id": "4_7610", "predict_sva": "@(posedge clk_gsm)         $fell(power_amp_enable) |-> ##[3:7] ($past(timing_advance, 4) >= 0 && $past(timing_advance, 4) <= 63)"}
{"id": "10_18_0475", "name": "conditional_past_check_with_variable_delay", "sva": "@(posedge clk_network)      $past(packet_received, 2) |-> ##[1:4] $past(packet_length, 2) == bytes_remaining", "ori_sva": "property conditional_past_check_with_variable_delay;\n@(posedge clk_network)      $past(packet_received, 2) |-> ##[1:4] $past(packet_length, 2) == bytes_remaining\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Conditional_Past_Check_With_Variable_Delay  \n**Trigger Condition**: At every rising edge of the `clk_network`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(packet_received, 2)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:4] $past(packet_length, 2) == bytes_remaining`", "sva_signals": ["clk", "rst_n", "[0:0] packet_received", "[0:0] packet_length", "[0:0] bytes_remaining", "clk_network"], "clock": "clk_network", "attempts_left": 10, "sva_result": "@(posedge clk_network)     $past(packet_received, 2) |-> ##[1:4] ($past(packet_length, 2) == bytes_remaining);", "sva_name": "p_packet_received_bytes_remaining_length_match", "full_property": "property p_Conditional_Past_Check_With_Variable_Delay;\n@(posedge clk_network)     $past(packet_received, 2) |-> ##[1:4] ($past(packet_length, 2) == bytes_remaining);\nendproperty\nassert_p_Conditional_Past_Check_With_Variable_Delay:assert property (p_Conditional_Past_Check_With_Variable_Delay) else $error(\"\");", "task_id": "4_7681", "predict_sva": "@(posedge clk_network)         $past(packet_received, 2) |-> ##[1:4] ($past(packet_length, 2) == bytes_remaining)"}
{"id": "10_42_0484", "name": "past_value_range_check_with_4_cycle_window", "sva": "@(posedge clk_analog_frontend)      $past(adc_calibrate, 4) |-> ##[2:4] $past(offset_value, 4) inside {[12'h000:12'h0FF]}", "ori_sva": "property past_value_range_check_with_4_cycle_window;\n@(posedge clk_analog_frontend)      $past(adc_calibrate, 4) |-> ##[2:4] $past(offset_value, 4) inside {[12'h000:12'h0FF]}\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_past_value_range_check_with_4_cycle_window  \n**Trigger Condition**: At every rising edge of the `clk_analog_frontend`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$past(adc_calibrate, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[2:4] $past(offset_value, 4) inside {[12'h000:12'h0FF]}`  \n\n", "sva_signals": ["clk_analog_frontend", "[11:0] adc_calibrate", "[11:0] offset_value"], "clock": "clk_analog_frontend", "attempts_left": 10, "sva_result": "@(posedge clk_analog_frontend)     $past(adc_calibrate, 4) |-> ##[2:4] $past(offset_value, 4) inside {[12'h000:12'h0FF]};", "sva_name": "p_offset_value_range_after_adc_calibrate", "full_property": "property p_past_value_range_check_with_4_cycle_window;\n@(posedge clk_analog_frontend)     $past(adc_calibrate, 4) |-> ##[2:4] $past(offset_value, 4) inside {[12'h000:12'h0FF]};\nendproperty\nassert_p_past_value_range_check_with_4_cycle_window:assert property (p_past_value_range_check_with_4_cycle_window) else $error(\"\");", "task_id": "4_7703", "predict_sva": "@(posedge clk_analog_frontend)         $past(adc_calibrate, 4) |-> ##[2:4] ($past(offset_value, 4) >= 12'h000 && $past(offset_value, 4) <= 12'h0FF)"}
{"id": "10_8_0441", "name": "conditional_past_check_with_4_cycle_delay", "sva": "@(posedge clk_mem)      write_enable && $past(address_valid, 4) |-> ##4 $past(write_data, 4) == mem_array[address_reg]", "ori_sva": "property conditional_past_check_with_4_cycle_delay;\n@(posedge clk_mem)      write_enable && $past(address_valid, 4) |-> ##4 $past(write_data, 4) == mem_array[address_reg]\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_Conditional_Past_Check_With_4_Cycle_Delay  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `write_enable && $past(address_valid, 4)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##4 $past(write_data, 4) == mem_array[address_reg]`  ", "sva_signals": ["clk_mem", "rst_n", "[0:0] write_enable", "[0:0] address_valid", "[0:0] write_data", "[0:0] address_reg", "[0:0] mem_array"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)     (write_enable && $past(address_valid, 4)) |-> ##4 ($past(write_data, 4) == mem_array[address_reg]);", "sva_name": "p_write_data_mem_array_delay4", "full_property": "property p_Conditional_Past_Check_With_4_Cycle_Delay;\n@(posedge clk_mem)     (write_enable && $past(address_valid, 4)) |-> ##4 ($past(write_data, 4) == mem_array[address_reg]);\nendproperty\nassert_p_Conditional_Past_Check_With_4_Cycle_Delay:assert property (p_Conditional_Past_Check_With_4_Cycle_Delay) else $error(\"\");", "task_id": "4_7716", "predict_sva": "@(posedge clk_mem)         (write_enable == 1 && $past(address_valid, 4) == 1) |-> ##4 ($past(write_data, 4) == mem_array[$past(address_reg, 4)])"}
{"id": "11_19_0524", "name": "encrypt_ready_data_valid_19", "sva": "@(posedge clk_crypto)     encrypt_ready && plaintext_valid |-> ##3 ciphertext_out", "ori_sva": "property encrypt_ready_data_valid_19;\n@(posedge clk_crypto)     encrypt_ready && plaintext_valid |-> ##3 ciphertext_out\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_encrypt_ready_data_valid  \n**Trigger Condition**: At every rising edge of the `clk_crypto`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `encrypt_ready && plaintext_valid`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 ciphertext_out`", "sva_signals": ["clk_crypto", "[0:0] encrypt_ready", "[0:0] plaintext_valid", "ciphertext_out"], "clock": "clk_crypto", "attempts_left": 10, "sva_result": "@(posedge clk_crypto)         (encrypt_ready && plaintext_valid) |-> ##3 ciphertext_out;", "sva_name": "p_ciphertext_out_after_encrypt_ready_and_plaintext_valid", "full_property": "property p_encrypt_ready_data_valid;\n@(posedge clk_crypto)         (encrypt_ready && plaintext_valid) |-> ##3 ciphertext_out;\nendproperty\nassert_p_encrypt_ready_data_valid:assert property (p_encrypt_ready_data_valid) else $error(\"\");", "task_id": "4_7725", "predict_sva": "@(posedge clk_crypto)         (encrypt_ready == 1 && plaintext_valid == 1) |-> ##3 (ciphertext_out == 1)"}
{"id": "11_1_0487", "name": "req_busy_grant_check_1", "sva": "@(posedge clk_sys)      $rose(req_main) && $fell(busy_arbiter) |-> ##[1:3] grant_controller", "ori_sva": "property req_busy_grant_check_1;\n@(posedge clk_sys)      $rose(req_main) && $fell(busy_arbiter) |-> ##[1:3] grant_controller\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_req_busy_grant_check_1  \n**Trigger Condition**: At every rising edge of the `clk_sys`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(req_main) && $fell(busy_arbiter)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[1:3] grant_controller`  ", "sva_signals": ["clk_sys", "busy_arbiter", "req_main", "grant_controller"], "clock": "clk_sys", "attempts_left": 10, "sva_result": "@(posedge clk_sys)     ($rose(req_main) && $fell(busy_arbiter)) |-> ##[1:3] grant_controller;", "sva_name": "p_grant_controller_after_req_main_busy_arbiter", "full_property": "property p_req_busy_grant_check_1;\n@(posedge clk_sys)     ($rose(req_main) && $fell(busy_arbiter)) |-> ##[1:3] grant_controller;\nendproperty\nassert_p_req_busy_grant_check_1:assert property (p_req_busy_grant_check_1) else $error(\"\");", "task_id": "4_7726", "predict_sva": "@(posedge clk_sys)         ($rose(req_main) && $fell(busy_arbiter)) |-> ##[1:3] grant_controller"}
{"id": "11_29_0527", "name": "lcd_fifo_underflow_29", "sva": "@(posedge clk_lcd)     lcd_fifo_empty && pixel_fetch |-> ##1 underflow_error", "ori_sva": "property lcd_fifo_underflow_29;\n@(posedge clk_lcd)     lcd_fifo_empty && pixel_fetch |-> ##1 underflow_error\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_lcd_fifo_underflow_29  \n**Trigger Condition**: At every rising edge of the `clk_lcd`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `lcd_fifo_empty && pixel_fetch`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##1 underflow_error`", "sva_signals": ["clk_lcd", "[0:0] lcd_fifo_empty", "[0:0] pixel_fetch", "[0:0] underflow_error"], "clock": "clk_lcd", "attempts_left": 10, "sva_result": "@(posedge clk_lcd)         lcd_fifo_empty && pixel_fetch |-> ##1 underflow_error;", "sva_name": "p_lcd_fifo_underflow_on_pixel_fetch", "full_property": "property p_lcd_fifo_underflow_29;\n@(posedge clk_lcd)         lcd_fifo_empty && pixel_fetch |-> ##1 underflow_error;\nendproperty\nassert_p_lcd_fifo_underflow_29:assert property (p_lcd_fifo_underflow_29) else $error(\"\");", "task_id": "4_7736", "predict_sva": "@(posedge clk_lcd)         (lcd_fifo_empty == 1 && pixel_fetch == 1) |-> ##1 (underflow_error == 1)"}
{"id": "11_32_0536", "name": "battery_low_charge_start_32", "sva": "@(posedge clk_power)     battery_low && charger_connected |-> ##3 charge_enable", "ori_sva": "property battery_low_charge_start_32;\n@(posedge clk_power)     battery_low && charger_connected |-> ##3 charge_enable\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_battery_low_charge_start_32  \n**Trigger Condition**: At every rising edge of the `clk_power`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `battery_low && charger_connected`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 charge_enable`", "sva_signals": ["clk_power", "[0:0] battery_low", "[0:0] charger_connected", "[0:0] charge_enable"], "clock": "clk_power", "attempts_left": 10, "sva_result": "@(posedge clk_power)         (battery_low && charger_connected) |-> ##3 charge_enable;", "sva_name": "p_charge_enable_after_battery_low_and_charger_connected", "full_property": "property p_battery_low_charge_start_32;\n@(posedge clk_power)         (battery_low && charger_connected) |-> ##3 charge_enable;\nendproperty\nassert_p_battery_low_charge_start_32:assert property (p_battery_low_charge_start_32) else $error(\"\");", "task_id": "4_7739", "predict_sva": "@(posedge clk_power)         (battery_low == 1 && charger_connected == 1) |-> ##3 (charge_enable == 1)"}
{"id": "11_4_0493", "name": "cache_hit_tag_match_4", "sva": "@(posedge clk_mem)     cache_hit_flag && (current_tag == stored_tag) |-> ##3 data_valid_out", "ori_sva": "property cache_hit_tag_match_4;\n@(posedge clk_mem)     cache_hit_flag && (current_tag == stored_tag) |-> ##3 data_valid_out\nendproperty", "sva_description": "### Assertion description: \n**Property Name**: p_cache_hit_tag_match_4  \n**Trigger Condition**: At every rising edge of the `clk_mem`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `cache_hit_flag && (current_tag == stored_tag)`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##3 data_valid_out`", "sva_signals": ["clk_mem", "[0:0] cache_hit_flag", "[0:0] current_tag", "[0:0] stored_tag", "[0:0] data_valid_out"], "clock": "clk_mem", "attempts_left": 10, "sva_result": "@(posedge clk_mem)         (cache_hit_flag && (current_tag == stored_tag)) |-> ##3 data_valid_out;", "sva_name": "p_cache_hit_data_valid_out_delay3", "full_property": "property p_cache_hit_tag_match_4;\n@(posedge clk_mem)         (cache_hit_flag && (current_tag == stored_tag)) |-> ##3 data_valid_out;\nendproperty\nassert_p_cache_hit_tag_match_4:assert property (p_cache_hit_tag_match_4) else $error(\"\");", "task_id": "4_7757", "predict_sva": "@(posedge clk_mem)         (cache_hit_flag == 1 && current_tag == stored_tag) |-> ##3 (data_valid_out == 1)"}
{"id": "12_30_0585", "name": "pattern_match_or_force_check_30", "sva": "@(posedge clk_pattern)      (data_in == 32'hDEADBEEF) || force_pattern |-> ##2 $rose(match_flag)", "ori_sva": "property pattern_match_or_force_check_30;\n@(posedge clk_pattern)      (data_in == 32'hDEADBEEF) || force_pattern |-> ##2 $rose(match_flag)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_pattern_match_or_force_check_30  \n**Trigger Condition**: At every rising edge of the `clk_pattern`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `(data_in == 32'hDEADBEEF) || force_pattern`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##2 $rose(match_flag)`", "sva_signals": ["clk_pattern", "[31:0] data_in", "[0:0] force_pattern", "[0:0] match_flag"], "clock": "clk_pattern", "attempts_left": 10, "sva_result": "@(posedge clk_pattern)     ((data_in == 32'hDEADBEEF) || force_pattern) |-> ##2 $rose(match_flag);", "sva_name": "p_match_flag_rise_after_pattern_or_force", "full_property": "property p_pattern_match_or_force_check_30;\n@(posedge clk_pattern)     ((data_in == 32'hDEADBEEF) || force_pattern) |-> ##2 $rose(match_flag);\nendproperty\nassert_p_pattern_match_or_force_check_30:assert property (p_pattern_match_or_force_check_30) else $error(\"\");", "task_id": "4_7778", "predict_sva": "@(posedge clk_pattern)         (data_in == 32'hDEADBEEF || force_pattern == 1) |-> ##2 ($rose(match_flag))"}
{"id": "12_38_0577", "name": "parity_ok_or_force_check_38", "sva": "@(posedge clk_parity)      $rose(parity_ok) || force_parity_ok |-> ##[0:2] $fell(parity_err)", "ori_sva": "property parity_ok_or_force_check_38;\n@(posedge clk_parity)      $rose(parity_ok) || force_parity_ok |-> ##[0:2] $fell(parity_err)\nendproperty", "sva_description": "### Assertion description:  \n**Property Name**: p_parity_ok_or_force_check_38  \n**Trigger Condition**: At every rising edge of the `clk_parity`  \n**Disable Condition**: None  \n**Antecedent (LHS of Implication)**: `$rose(parity_ok) || force_parity_ok`  \n**Implication Operator**: `|->`  \n**Consequent (RHS of Implication)**: `##[0:2] $fell(parity_err)`  ", "sva_signals": ["clk_parity", "force_parity_ok", "[0:0] parity_ok", "[0:0] parity_err"], "clock": "clk_parity", "attempts_left": 10, "sva_result": "@(posedge clk_parity)     ($rose(parity_ok) || force_parity_ok) |-> ##[0:2] $fell(parity_err);", "sva_name": "p_parity_err_fall_after_parity_ok", "full_property": "property p_parity_ok_or_force_check_38;\n@(posedge clk_parity)     ($rose(parity_ok) || force_parity_ok) |-> ##[0:2] $fell(parity_err);\nendproperty\nassert_p_parity_ok_or_force_check_38:assert property (p_parity_ok_or_force_check_38) else $error(\"\");", "task_id": "4_7784", "predict_sva": "@(posedge clk_parity)         ($rose(parity_ok) || force_parity_ok) |-> ##[0:2] $fell(parity_err)"}
