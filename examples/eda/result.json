[
  {
    "id": "119_10_0884",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_frd9c6n9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_maxz9hct/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.process_mon) |-> $past(sva_checker.adapt_time) > 0): PROVED\n"
  },
  {
    "id": "120_7_0893",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p2t8w6_t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) == 1 |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d6ol_uy7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) == 1 |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 1) == 1 |-> (##1 sva_checker.data_in >= $past(sva_checker.hold_time) >> 1)): PROVED\n"
  },
  {
    "id": "12_2_0092",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_3b863fkb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "155_12_1196",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3mrzqbzr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_29x46ne5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.interrupt_request == 1'b1 |-> (##2 sva_checker.interrupt_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "157_2_1203",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8cevfh3p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xuju5wy4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.req_signal == 1'b1 |-> (##[1:4] sva_checker.ack_signal == 1'b1)): PROVED\n"
  },
  {
    "id": "159_7_1263",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_fxjrjcdg/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_fxjrjcdg/sva_checker.sv\nfile /tmp/sva_check_fxjrjcdg/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "160_5_1246",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_50t07ulz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1'b1 |-> !sva_checker.fifo_full): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst == 0 && sva_checker.wr_en == 1 |-> sva_checker.fifo_full == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1'b1 |-> !sva_checker.fifo_full): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u6j4qs2o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst == 0 && sva_checker.wr_en == 1 |-> sva_checker.fifo_full == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1'b1 |-> !sva_checker.fifo_full): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.async_rst == 0 && sva_checker.wr_en == 1 |-> sva_checker.fifo_full == 0): PROVED\n"
  },
  {
    "id": "165_8_1288",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_th76hn49/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crc_reset == 0 && sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8zfn19dr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crc_reset == 0 && sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crc_reset == 0 && sva_checker.data_valid == 1'b1 |-> sva_checker.crc_match == 1'b1): PROVED\n"
  },
  {
    "id": "166_6_1320",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8zb835c3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yhipj0w4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correct == 1'b1 |-> sva_checker.prev_error_detected == 1'b1): PROVED\n"
  },
  {
    "id": "167_9_1307",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_z2wri75v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y3inxlsp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && $changed(sva_checker.wr_ptr_gray) |-> (##[1:3] $changed(sva_checker.wr_ptr_sync))): PROVED\n"
  },
  {
    "id": "198_9_1637",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p4wrtd9b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rflmpdcl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.auth_complete == 1'b1 |-> (##[2:10] !sva_checker.auth_start_trigger)): PROVED\n"
  },
  {
    "id": "168_3_1321",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_v_f_uuwz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bist_done_ack == 1'b1 |-> $past(sva_checker.bist_run_active, 1) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.manual_mode_en == 0 && sva_checker.bist_done_ack == 1 |-> $past(sva_checker.bist_run_active) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bist_done_ack == 1'b1 |-> $past(sva_checker.bist_run_active, 1) == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q6eaiic7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.manual_mode_en == 0 && sva_checker.bist_done_ack == 1 |-> $past(sva_checker.bist_run_active) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bist_done_ack == 1'b1 |-> $past(sva_checker.bist_run_active, 1) == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.manual_mode_en == 0 && sva_checker.bist_done_ack == 1 |-> $past(sva_checker.bist_run_active) == 1): PROVED\n"
  },
  {
    "id": "207_9_1705",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ovtc7n3v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && !sva_checker.bus_gnt |-> (##32 $fell(sva_checker.bus_req))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && sva_checker.bus_gnt == 0 |-> (##32 $fell(sva_checker.bus_req))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && !sva_checker.bus_gnt |-> (##32 $fell(sva_checker.bus_req))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_71go5oir/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && sva_checker.bus_gnt == 0 |-> (##32 $fell(sva_checker.bus_req))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && !sva_checker.bus_gnt |-> (##32 $fell(sva_checker.bus_req))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.bus_req) && sva_checker.bus_gnt == 0 |-> (##32 $fell(sva_checker.bus_req))): PROVED\n"
  },
  {
    "id": "208_7_1714",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cr54lnui/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zhlhpg1j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.sel) |-> $stable(sva_checker.out)): PROVED\n"
  },
  {
    "id": "21_4_0173",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_75rngd0w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "222_8_1866",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3pmtx4lw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8el0wd3o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.req_grant_ == 1'b1 |-> $past(sva_checker.req_, 2) == 1'b1): PROVED\n"
  },
  {
    "id": "240_9_2066",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_gpuu6ow9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) ##0 $rose(sva_checker.clk_secondary))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) && $rose(sva_checker.clk_secondary))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) ##0 $rose(sva_checker.clk_secondary))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_exhk5zy0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) && $rose(sva_checker.clk_secondary))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) ##0 $rose(sva_checker.clk_secondary))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.clk_switch_req) |-> (##1 $fell(sva_checker.clk_primary) && $rose(sva_checker.clk_secondary))): PROVED\n"
  },
  {
    "id": "24_4_0190",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lshznkz1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q84ok9tq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.state) && $past(sva_checker.state) == 4'b0000 |-> !$onehot(sva_checker.state)): PROVED\n"
  },
  {
    "id": "281_1_2379",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v8q7mlso/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_khbfqrwu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_blanking) |-> (##[1:4] $rose(sva_checker.data_island_period))): PROVED\n"
  },
  {
    "id": "287_1_2447",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__009eacj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start == 1 |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nq7mftdk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start == 1 |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csi2_valid_packet_start == 1 |-> (##[1:16] sva_checker.csi2_checksum == sva_checker.csi2_header_payload_len)): PROVED\n"
  },
  {
    "id": "287_5_2435",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7510ilpl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end |=> $stable(sva_checker.csi2_checksum)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end == 1 |-> (##1 sva_checker.csi2_checksum == $past(sva_checker.csi2_checksum))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end |=> $stable(sva_checker.csi2_checksum)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tpwtktm_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end == 1 |-> (##1 sva_checker.csi2_checksum == $past(sva_checker.csi2_checksum))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end |=> $stable(sva_checker.csi2_checksum)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csi2_packet_end == 1 |-> (##1 sva_checker.csi2_checksum == $past(sva_checker.csi2_checksum))): PROVED\n"
  },
  {
    "id": "69_4_0487",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ds6w2tjn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> !sva_checker.lock_stable): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> sva_checker.lock_stable == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> !sva_checker.lock_stable): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cj81khhv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> sva_checker.lock_stable == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> !sva_checker.lock_stable): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bypass_en == 1'b1 |-> sva_checker.lock_stable == 1'b0): PROVED\n"
  },
  {
    "id": "7_5_0038",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oxnnbioj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start, 1) && !$past(sva_checker.burst_abort, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start) && !$past(sva_checker.burst_abort)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start, 1) && !$past(sva_checker.burst_abort, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bfclhfrc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start) && !$past(sva_checker.burst_abort)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start, 1) && !$past(sva_checker.burst_abort, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> $past(sva_checker.burst_start) && !$past(sva_checker.burst_abort)): PROVED\n"
  },
  {
    "id": "96_4_0720",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s_waws3q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yumloiic/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.return_signal) |-> $past(sva_checker.pulse_signal)): PROVED\n"
  },
  {
    "id": "10_17_0322",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8xkc40bp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.config_reg) |-> !sva_checker.config_update): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && $stable(sva_checker.config_reg) |-> sva_checker.config_update == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.config_reg) |-> !sva_checker.config_update): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q2lp0yz8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && $stable(sva_checker.config_reg) |-> sva_checker.config_update == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.config_reg) |-> !sva_checker.config_update): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && $stable(sva_checker.config_reg) |-> sva_checker.config_update == 0): PROVED\n"
  },
  {
    "id": "10_9_0320",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_dbjfjcix/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.first_phase && sva_checker.second_phase |-> (##1 sva_checker.third_phase)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.first_phase == 1 && sva_checker.second_phase == 1 |-> (##1 sva_checker.third_phase == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.first_phase && sva_checker.second_phase |-> (##1 sva_checker.third_phase)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q8goo9vo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.first_phase == 1 && sva_checker.second_phase == 1 |-> (##1 sva_checker.third_phase == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.first_phase && sva_checker.second_phase |-> (##1 sva_checker.third_phase)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.first_phase == 1 && sva_checker.second_phase == 1 |-> (##1 sva_checker.third_phase == 1)): PROVED\n"
  },
  {
    "id": "1_25_0025",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9llk_z31/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout && !sva_checker.debug_mode |-> (##1 sva_checker.system_reset)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout == 1 && sva_checker.debug_mode == 0 |-> (##1 sva_checker.system_reset == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout && !sva_checker.debug_mode |-> (##1 sva_checker.system_reset)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dczlw43z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout == 1 && sva_checker.debug_mode == 0 |-> (##1 sva_checker.system_reset == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout && !sva_checker.debug_mode |-> (##1 sva_checker.system_reset)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.watchdog_timeout == 1 && sva_checker.debug_mode == 0 |-> (##1 sva_checker.system_reset == 1)): PROVED\n"
  },
  {
    "id": "2_19_0057",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_br6rlx6w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |-> (##[8:24] sva_checker.voltage_stable == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |=> (##[8:24] sva_checker.voltage_stable == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |-> (##[8:24] sva_checker.voltage_stable == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bspr4n3s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |=> (##[8:24] sva_checker.voltage_stable == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |-> (##[8:24] sva_checker.voltage_stable == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1'b1 |=> (##[8:24] sva_checker.voltage_stable == 1'b1)): PROVED\n"
  },
  {
    "id": "3_30_0100",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_808iy0v8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration && sva_checker.reference_available |-> (##15 sva_checker.calibration_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration == 1 && sva_checker.reference_available == 1 |-> (##15 sva_checker.calibration_complete == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration && sva_checker.reference_available |-> (##15 sva_checker.calibration_complete)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_31lbofbe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration == 1 && sva_checker.reference_available == 1 |-> (##15 sva_checker.calibration_complete == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration && sva_checker.reference_available |-> (##15 sva_checker.calibration_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_calibration == 1 && sva_checker.reference_available == 1 |-> (##15 sva_checker.calibration_complete == 1)): PROVED\n"
  },
  {
    "id": "5_23_0176",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8h85scxe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush && !sva_checker.stall_condition |-> (##2 sva_checker.pipeline_clear)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1 && sva_checker.stall_condition == 0 |-> (##2 sva_checker.pipeline_clear == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush && !sva_checker.stall_condition |-> (##2 sva_checker.pipeline_clear)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sldf7wx0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1 && sva_checker.stall_condition == 0 |-> (##2 sva_checker.pipeline_clear == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush && !sva_checker.stall_condition |-> (##2 sva_checker.pipeline_clear)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1 && sva_checker.stall_condition == 0 |-> (##2 sva_checker.pipeline_clear == 1)): PROVED\n"
  },
  {
    "id": "5_25_0199",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4ile5t1f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_match && sva_checker.pattern_enable |-> (##1 sva_checker.match_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_match == 1 && sva_checker.pattern_enable == 1 |-> (##1 sva_checker.match_interrupt == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_match && sva_checker.pattern_enable |-> (##1 sva_checker.match_interrupt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4qedh37i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_match == 1 && sva_checker.pattern_enable == 1 |-> (##1 sva_checker.match_interrupt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_match && sva_checker.pattern_enable |-> (##1 sva_checker.match_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_match == 1 && sva_checker.pattern_enable == 1 |-> (##1 sva_checker.match_interrupt == 1)): PROVED\n"
  },
  {
    "id": "5_27_0165",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ymotuyhr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start && sva_checker.key_loaded |-> (##[1:8] sva_checker.encryption_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1 && sva_checker.key_loaded == 1 |-> (##[1:8] sva_checker.encryption_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encryption_start && sva_checker.key_loaded |-> (##[1:8] sva_checker.encryption_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jg1vrx6q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1 && sva_checker.key_loaded == 1 |-> (##[1:8] sva_checker.encryption_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start && sva_checker.key_loaded |-> (##[1:8] sva_checker.encryption_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1 && sva_checker.key_loaded == 1 |-> (##[1:8] sva_checker.encryption_done == 1)): PROVED\n"
  },
  {
    "id": "8_18_0258",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f13_yq19/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) |-> $past(sva_checker.burst_cnt, 1) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) == 1 |-> $past(sva_checker.burst_cnt, 1) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) |-> $past(sva_checker.burst_cnt, 1) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bjtu20xf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) == 1 |-> $past(sva_checker.burst_cnt, 1) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) |-> $past(sva_checker.burst_cnt, 1) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_term, 1) == 1 |-> $past(sva_checker.burst_cnt, 1) == 0): PROVED\n"
  },
  {
    "id": "8_21_0252",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s16mu188/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1bpn42mm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ram_we, 1) |-> $past(sva_checker.ram_addr, 2) != sva_checker.ram_addr): PROVED\n"
  },
  {
    "id": "2_23_0001",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9vjuluq4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ow3z_tt3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) not (sva_checker.pattern ##1 sva_checker.pattern ##1 sva_checker.pattern)): PROVED\n"
  },
  {
    "id": "2_21_0225",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_yudalsl5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss && !sva_checker.cache_busy |-> (##3 sva_checker.cache_fill)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1 && sva_checker.cache_busy == 0 |-> (##3 sva_checker.cache_fill == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_miss && !sva_checker.cache_busy |-> (##3 sva_checker.cache_fill)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jykhtm4z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1 && sva_checker.cache_busy == 0 |-> (##3 sva_checker.cache_fill == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss && !sva_checker.cache_busy |-> (##3 sva_checker.cache_fill)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1 && sva_checker.cache_busy == 0 |-> (##3 sva_checker.cache_fill == 1)): PROVED\n"
  },
  {
    "id": "3_21_0257",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tfay7lnf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lim6bye2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> (##[1:8] $rose(sva_checker.ack) ##1 $fell(sva_checker.req))): PROVED\n"
  },
  {
    "id": "5_10_0315",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9rqjev43/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_busy |-> (##7 sva_checker.dma_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_busy == 0 |-> (##7 sva_checker.dma_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_busy |-> (##7 sva_checker.dma_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3t2t5e_f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_busy == 0 |-> (##7 sva_checker.dma_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_busy |-> (##7 sva_checker.dma_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_busy == 0 |-> (##7 sva_checker.dma_ack == 1)): PROVED\n"
  },
  {
    "id": "5_12_0310",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_b4qydegg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger && sva_checker.calibration_done |-> (##9 sva_checker.sensor_data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1 && sva_checker.calibration_done == 1 |-> (##9 sva_checker.sensor_data_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger && sva_checker.calibration_done |-> (##9 sva_checker.sensor_data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ymg7ce_m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1 && sva_checker.calibration_done == 1 |-> (##9 sva_checker.sensor_data_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger && sva_checker.calibration_done |-> (##9 sva_checker.sensor_data_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1 && sva_checker.calibration_done == 1 |-> (##9 sva_checker.sensor_data_valid == 1)): PROVED\n"
  },
  {
    "id": "5_30_0319",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4r5t1bc7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.security_check && sva_checker.policy_loaded |-> (##5 sva_checker.access_granted)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.security_check == 1 && sva_checker.policy_loaded == 1 |-> (##5 sva_checker.access_granted == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.security_check && sva_checker.policy_loaded |-> (##5 sva_checker.access_granted)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ulotlslu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.security_check == 1 && sva_checker.policy_loaded == 1 |-> (##5 sva_checker.access_granted == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.security_check && sva_checker.policy_loaded |-> (##5 sva_checker.access_granted)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.security_check == 1 && sva_checker.policy_loaded == 1 |-> (##5 sva_checker.access_granted == 1)): PROVED\n"
  },
  {
    "id": "5_9_0308",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jfb6ypjq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start && sva_checker.baud_locked |-> (##12 sva_checker.tx_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1 && sva_checker.baud_locked == 1 |-> (##12 sva_checker.tx_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_start && sva_checker.baud_locked |-> (##12 sva_checker.tx_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j_dt0z6p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1 && sva_checker.baud_locked == 1 |-> (##12 sva_checker.tx_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start && sva_checker.baud_locked |-> (##12 sva_checker.tx_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1 && sva_checker.baud_locked == 1 |-> (##12 sva_checker.tx_done == 1)): PROVED\n"
  },
  {
    "id": "6_24_0340",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_c64_qjl8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed && sva_checker.monitoring_en |-> (##[5:10] sva_checker.alert_triggered)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed == 1 && sva_checker.monitoring_en == 1 |-> (##[5:10] sva_checker.alert_triggered == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed && sva_checker.monitoring_en |-> (##[5:10] sva_checker.alert_triggered)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sw4dhb26/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed == 1 && sva_checker.monitoring_en == 1 |-> (##[5:10] sva_checker.alert_triggered == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed && sva_checker.monitoring_en |-> (##[5:10] sva_checker.alert_triggered)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_threshold_crossed == 1 && sva_checker.monitoring_en == 1 |-> (##[5:10] sva_checker.alert_triggered == 1)): PROVED\n"
  },
  {
    "id": "6_5_0360",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2s3c74cw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_up && !sva_checker.reset |-> (##[5:10] sva_checker.initialization_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_up == 1 && sva_checker.reset == 0 |-> (##[5:10] sva_checker.initialization_complete == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_up && !sva_checker.reset |-> (##[5:10] sva_checker.initialization_complete)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e_e6_8wq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_up == 1 && sva_checker.reset == 0 |-> (##[5:10] sva_checker.initialization_complete == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_up && !sva_checker.reset |-> (##[5:10] sva_checker.initialization_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_up == 1 && sva_checker.reset == 0 |-> (##[5:10] sva_checker.initialization_complete == 1)): PROVED\n"
  },
  {
    "id": "7_26_0380",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9cm_e3lt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && !sva_checker.arb_active |-> (##1 sva_checker.arb_reset)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && sva_checker.arb_active == 0 && sva_checker.rst_n == 1 |-> (##1 sva_checker.arb_reset == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && !sva_checker.arb_active |-> (##1 sva_checker.arb_reset)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p7xvbn67/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && sva_checker.arb_active == 0 && sva_checker.rst_n == 1 |-> (##1 sva_checker.arb_reset == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && !sva_checker.arb_active |-> (##1 sva_checker.arb_reset)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.bus_priority) && sva_checker.arb_active == 0 && sva_checker.rst_n == 1 |-> (##1 sva_checker.arb_reset == 1)): PROVED\n"
  },
  {
    "id": "9_10_0421",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xeiyfbt8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eg4_ol81/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> $past(sva_checker.pkt_sync, 3) == 1'b1 && $past(sva_checker.pkt_sync, 2) == 1'b0): PROVED\n"
  },
  {
    "id": "9_28_0437",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_n7hm7ucx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zbghg4e9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ram_wr_en == 1'b1 |-> $past(sva_checker.ram_wr_pending, 1) == 1'b1): PROVED\n"
  },
  {
    "id": "10_34_0802",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a4w2bv7j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |=> $onehot0(sva_checker.sensor_select)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##1 $onehot0(sva_checker.sensor_select))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |=> $onehot0(sva_checker.sensor_select)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jfubrfol/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##1 $onehot0(sva_checker.sensor_select))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |=> $onehot0(sva_checker.sensor_select)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##1 $onehot0(sva_checker.sensor_select))): PROVED\n"
  },
  {
    "id": "10_58_0818",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ednos5ch/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |=> $onehot0(sva_checker.gps_satellites)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |-> (##1 $onehot0(sva_checker.gps_satellites))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |=> $onehot0(sva_checker.gps_satellites)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1f2ezt8h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |-> (##1 $onehot0(sva_checker.gps_satellites))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |=> $onehot0(sva_checker.gps_satellites)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_fix == 1'b1 |-> (##1 $onehot0(sva_checker.gps_satellites))): PROVED\n"
  },
  {
    "id": "10_68_0823",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping == 1 |-> (##1 $onehot0($past(sva_checker.ultrasonic_sensors)))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping |=> $onehot0(sva_checker.ultrasonic_sensors)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_0thbjca9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping |=> $onehot0(sva_checker.ultrasonic_sensors)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping == 1 |-> (##1 $onehot0($past(sva_checker.ultrasonic_sensors)))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping |=> $onehot0(sva_checker.ultrasonic_sensors)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iuve004t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping == 1 |-> (##1 $onehot0($past(sva_checker.ultrasonic_sensors)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping |=> $onehot0(sva_checker.ultrasonic_sensors)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_ping == 1 |-> (##1 $onehot0($past(sva_checker.ultrasonic_sensors)))): PROVED\n"
  },
  {
    "id": "10_72_0841",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_eqwnyz1o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer |=> $onehot0(sva_checker.probe_points)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer == 1 |-> (##1 $onehot0(sva_checker.probe_points))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer |=> $onehot0(sva_checker.probe_points)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iibg5aml/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer == 1 |-> (##1 $onehot0(sva_checker.probe_points))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer |=> $onehot0(sva_checker.probe_points)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.logic_analyzer == 1 |-> (##1 $onehot0(sva_checker.probe_points))): PROVED\n"
  },
  {
    "id": "1_35_0129",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1pxq4ld_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |=> $fell(sva_checker.sig_b)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |-> (##1 $fell(sva_checker.sig_b))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |=> $fell(sva_checker.sig_b)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__ycgxm6_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |-> (##1 $fell(sva_checker.sig_b))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |=> $fell(sva_checker.sig_b)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.sig_a) |-> (##1 $fell(sva_checker.sig_b))): PROVED\n"
  },
  {
    "id": "0003",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_il8wmwzf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max |-> sva_checker.overflow_detect ? sva_checker.reset_counter : sva_checker.increment_counter): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.counter_max == 1 |-> sva_checker.overflow_detect == 1 ? sva_checker.reset_counter == 1 : sva_checker.increment_counter == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_max |-> sva_checker.overflow_detect ? sva_checker.reset_counter : sva_checker.increment_counter): PROVED\n\n\nBackward: Parsing /tmp/sva_check_htd54qu7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.counter_max == 1 |-> sva_checker.overflow_detect == 1 ? sva_checker.reset_counter == 1 : sva_checker.increment_counter == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max |-> sva_checker.overflow_detect ? sva_checker.reset_counter : sva_checker.increment_counter): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.counter_max == 1 |-> sva_checker.overflow_detect == 1 ? sva_checker.reset_counter == 1 : sv"
  },
  {
    "id": "0008",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z8kh48gs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wh6_jboq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flow_control |-> sva_checker.buffer_threshold ? sva_checker.pause_transmission : sva_checker.resume_flow): PROVED\n"
  },
  {
    "id": "0024",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8pzn37ds/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.branch_predict |-> sva_checker.prediction_correct ? sva_checker.update_predictor : sva_checker.flush_pipeline): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset == 0 && sva_checker.branch_predict == 1 |-> sva_checker.prediction_correct == 1 ? sva_checker.update_predictor == 1 : sva_checker.flush_pipeline == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.branch_predict |-> sva_checker.prediction_correct ? sva_checker.update_predictor : sva_checker.flush_pipeline): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oog8bmj8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset == 0 && sva_checker.branch_predict == 1 |-> sva_checker.prediction_correct == 1 ? sva_checker.update_predictor == 1 : sva_checker.flush_pipeline == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.branch_predict |-> sva_checker.prediction_correct ? sva_checker.update_predictor : sva_checker.flush_pipeline): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset == 0 && sva_checker.branch_predict == 1 |-> sva_checker.prediction_correct == 1 ? sv"
  },
  {
    "id": "0037",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_qyubpe8r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_reading |-> sva_checker.threshold_exceeded ? sva_checker.alarm_active : sva_checker.normal_status): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_good == 1 && sva_checker.sensor_reading == 1 |-> sva_checker.threshold_exceeded == 1 ? sva_checker.alarm_active == 1 : sva_checker.normal_status == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_reading |-> sva_checker.threshold_exceeded ? sva_checker.alarm_active : sva_checker.normal_status): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vw6b5px0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_good == 1 && sva_checker.sensor_reading == 1 |-> sva_checker.threshold_exceeded == 1 ? sva_checker.alarm_active == 1 : sva_checker.normal_status == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_reading |-> sva_checker.threshold_exceeded ? sva_checker.alarm_active : sva_checker.normal_status): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_good == 1 && sva_checker.sensor_reading == 1 |-> sva_checker.threshold_exceeded == 1 ? sva_checker."
  },
  {
    "id": "0055",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_03fsy8kl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> sva_checker.tx_buf_empty ? sva_checker.send_data : sva_checker.wait_buf): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> (if(sva_checker.tx_buf_empty == 1'b1) sva_checker.send_data == 1'b1 else sva_checker.wait_buf == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> sva_checker.tx_buf_empty ? sva_checker.send_data : sva_checker.wait_buf): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7270pg3d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> (if(sva_checker.tx_buf_empty == 1'b1) sva_checker.send_data == 1'b1 else sva_checker.wait_buf == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> sva_checker.tx_buf_empty ? sva_checker.send_data : sva_checker.wait_buf): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_ready == 1'b1 |-> (if(sva_checker.tx_buf_empty == 1'b1) sva_checker.send_data == 1'b1 else sva_checker.wait_buf == 1'b1)): PROVED\n"
  },
  {
    "id": "0152",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_9q2dzq7h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.weight_update |-> sva_checker.gradient_magnitude[15:0] > 16'h1000 ? sva_checker.large_step : sva_checker.small_step): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.learning_enable == 1 && sva_checker.weight_update == 1 |-> sva_checker.gradient_magnitude[15:0] > 16'h1000 ? sva_checker.large_step : sva_checker.small_step): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.weight_update |-> sva_checker.gradient_magnitude[15:0] > 16'h1000 ? sva_checker.large_step : sva_checker.small_step): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tmq80heh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.learning_enable == 1 && sva_checker.weight_update == 1 |-> sva_checker.gradient_magnitude[15:0] > 16'h1000 ? sva_checker.large_step : sva_checker.small_step): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.weight_update |-> sva_checker.gradient_magnitude[15:0] > 16'h1000 ? sva_checker.large_step : sva_checker.small_step): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.learning_enable == 1 && sva_checker.weight_update == 1 |-> sva_checker"
  },
  {
    "id": "0197",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wxez2vrm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> sva_checker.substrate_level[7:0] ? sva_checker.enzymatic_reaction : sva_checker.inhibited_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> (if(sva_checker.substrate_level[7:0] != 0) sva_checker.enzymatic_reaction else sva_checker.inhibited_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> sva_checker.substrate_level[7:0] ? sva_checker.enzymatic_reaction : sva_checker.inhibited_state): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2ndypaqq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> (if(sva_checker.substrate_level[7:0] != 0) sva_checker.enzymatic_reaction else sva_checker.inhibited_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> sva_checker.substrate_level[7:0] ? sva_checker.enzymatic_reaction : sva_checker.inhibited_state): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.biochemical_reactor |-> (if(sva_checker.substrate_level[7:0] != 0) sva_checker.enzymatic_react"
  },
  {
    "id": "0166",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_vgj7bwo4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.motion_recognition |-> sva_checker.confidence_score[7:0] > 180 ? sva_checker.gesture_detected : sva_checker.false_positive): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_needed == 0 && sva_checker.motion_recognition == 1 |-> sva_checker.confidence_score[7:0] > 180 ? sva_checker.gesture_detected == 1 : sva_checker.false_positive == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.motion_recognition |-> sva_checker.confidence_score[7:0] > 180 ? sva_checker.gesture_detected : sva_checker.false_positive): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9e2wgg24/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_needed == 0 && sva_checker.motion_recognition == 1 |-> sva_checker.confidence_score[7:0] > 180 ? sva_checker.gesture_detected == 1 : sva_checker.false_positive == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.motion_recognition |-> sva_checker.confidence_score[7:0] > 180 ? sva_checker.gesture_detected : sva_checker.false_positive): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calibrati"
  },
  {
    "id": "0214",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tamdlxrd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> sva_checker.hot_path_detected ? sva_checker.inline_function : sva_checker.call_overhead): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> (if(sva_checker.hot_path_detected) sva_checker.inline_function else sva_checker.call_overhead)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> sva_checker.hot_path_detected ? sva_checker.inline_function : sva_checker.call_overhead): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kalrz256/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> (if(sva_checker.hot_path_detected) sva_checker.inline_function else sva_checker.call_overhead)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> sva_checker.hot_path_detected ? sva_checker.inline_function : sva_checker.call_overhead): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.code_transformer |-> (if(sva_checker.hot_path_detected) sva_checker.inline_function else sva_checker.call_overhead)): PROVED\n"
  },
  {
    "id": "0204",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_3g4x8rfl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.branch_predictor |-> sva_checker.mispredict_rate[7:0] > 15 ? sva_checker.flush_frontend : sva_checker.continue_fetch): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.system_rst_n == 1 && sva_checker.branch_predictor == 1 |-> sva_checker.mispredict_rate[7:0] > 15 ? sva_checker.flush_frontend == 1 : sva_checker.continue_fetch == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.branch_predictor |-> sva_checker.mispredict_rate[7:0] > 15 ? sva_checker.flush_frontend : sva_checker.continue_fetch): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g6imfwkn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.system_rst_n == 1 && sva_checker.branch_predictor == 1 |-> sva_checker.mispredict_rate[7:0] > 15 ? sva_checker.flush_frontend == 1 : sva_checker.continue_fetch == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.branch_predictor |-> sva_checker.mispredict_rate[7:0] > 15 ? sva_checker.flush_frontend : sva_checker.continue_fetch): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.system_rst_n == 1 && sva_checker.branch_predictor ="
  },
  {
    "id": "0234",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_l3bpxflk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.microservice_mesh |-> sva_checker.load_balancer[7:0] != 0 ? sva_checker.distribute_request : sva_checker.circuit_breaker): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.service_degraded == 0 && sva_checker.microservice_mesh == 1 |-> sva_checker.load_balancer[7:0] != 0 ? sva_checker.distribute_request == 1 : sva_checker.circuit_breaker == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.microservice_mesh |-> sva_checker.load_balancer[7:0] != 0 ? sva_checker.distribute_request : sva_checker.circuit_breaker): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p1lsahew/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.service_degraded == 0 && sva_checker.microservice_mesh == 1 |-> sva_checker.load_balancer[7:0] != 0 ? sva_checker.distribute_request == 1 : sva_checker.circuit_breaker == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.microservice_mesh |-> sva_checker.load_balancer[7:0] != 0 ? sva_checker.distribute_request : sva_checker.circuit_breaker): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.service_degraded == 0 &"
  },
  {
    "id": "0265",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wgoplrb8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.submarine_control |-> |sva_checker.depth_limit[11:0] ? sva_checker.emergency_surface : sva_checker.continue_descent): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_hull_intact == 1 && sva_checker.submarine_control == 1 |-> |sva_checker.depth_limit[11:0] ? sva_checker.emergency_surface == 1 : sva_checker.continue_descent == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.submarine_control |-> |sva_checker.depth_limit[11:0] ? sva_checker.emergency_surface : sva_checker.continue_descent): PROVED\n\n\nBackward: Parsing /tmp/sva_check_smyv902o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_hull_intact == 1 && sva_checker.submarine_control == 1 |-> |sva_checker.depth_limit[11:0] ? sva_checker.emergency_surface == 1 : sva_checker.continue_descent == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.submarine_control |-> |sva_checker.depth_limit[11:0] ? sva_checker.emergency_surface : sva_checker.continue_descent): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pressure_hull_intact == 1 && sva_checker"
  },
  {
    "id": "0267",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ud_mtdgr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vessel_stability |-> sva_checker.list_angle[7:0] > 15 ? sva_checker.counter_ballast : sva_checker.maintain_trim): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ballast_system_ready == 1 && sva_checker.vessel_stability == 1 |-> sva_checker.list_angle[7:0] > 15 ? sva_checker.counter_ballast == 1 : sva_checker.maintain_trim == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vessel_stability |-> sva_checker.list_angle[7:0] > 15 ? sva_checker.counter_ballast : sva_checker.maintain_trim): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i4740zxs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ballast_system_ready == 1 && sva_checker.vessel_stability == 1 |-> sva_checker.list_angle[7:0] > 15 ? sva_checker.counter_ballast == 1 : sva_checker.maintain_trim == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vessel_stability |-> sva_checker.list_angle[7:0] > 15 ? sva_checker.counter_ballast : sva_checker.maintain_trim): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ballast_system_ready == 1 && sva_checker.vessel_stability =="
  },
  {
    "id": "0271",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ngdp56am/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_navigation |-> sva_checker.echo_return[15:0] ? sva_checker.object_detected : sva_checker.clear_water): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.acoustic_interference == 0 && sva_checker.underwater_navigation == 1 |-> sva_checker.echo_return[15:0] != 0 ? sva_checker.object_detected : sva_checker.clear_water): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.underwater_navigation |-> sva_checker.echo_return[15:0] ? sva_checker.object_detected : sva_checker.clear_water): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rpxpqh3a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.acoustic_interference == 0 && sva_checker.underwater_navigation == 1 |-> sva_checker.echo_return[15:0] != 0 ? sva_checker.object_detected : sva_checker.clear_water): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_navigation |-> sva_checker.echo_return[15:0] ? sva_checker.object_detected : sva_checker.clear_water): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.acoustic_interference == 0 && sva_checker.underwater_navigation == 1"
  },
  {
    "id": "0272",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_1n8yyf0b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flow_monitor == 1'b1 |-> sva_checker.pressure_differential[11:0] ? sva_checker.isolation_valve : sva_checker.maintain_flow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.leak_detected == 0 && sva_checker.flow_monitor == 1 |-> sva_checker.pressure_differential[11:0] != 0 ? sva_checker.isolation_valve : sva_checker.maintain_flow): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flow_monitor == 1'b1 |-> sva_checker.pressure_differential[11:0] ? sva_checker.isolation_valve : sva_checker.maintain_flow): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i93lya_0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.leak_detected == 0 && sva_checker.flow_monitor == 1 |-> sva_checker.pressure_differential[11:0] != 0 ? sva_checker.isolation_valve : sva_checker.maintain_flow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flow_monitor == 1'b1 |-> sva_checker.pressure_differential[11:0] ? sva_checker.isolation_valve : sva_checker.maintain_flow): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.leak_detected == 0 && sva_checker.flow_monito"
  },
  {
    "id": "0295",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check__i7jchbg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.friend_activity |-> sva_checker.online_status ? sva_checker.show_presence : sva_checker.appear_offline): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode_on == 0 && sva_checker.friend_activity == 1 |-> sva_checker.online_status == 1 ? sva_checker.show_presence == 1 : sva_checker.appear_offline == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.friend_activity |-> sva_checker.online_status ? sva_checker.show_presence : sva_checker.appear_offline): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zxvoui_v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode_on == 0 && sva_checker.friend_activity == 1 |-> sva_checker.online_status == 1 ? sva_checker.show_presence == 1 : sva_checker.appear_offline == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.friend_activity |-> sva_checker.online_status ? sva_checker.show_presence : sva_checker.appear_offline): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode_on == 0 && sva_checker.friend_activity == 1 |-> sva_checker.online_status == 1 ? sva_checker"
  },
  {
    "id": "0296",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_1w182nm5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.video_encoder |-> sva_checker.bandwidth_available[15:0] ? sva_checker.high_bitrate : sva_checker.adaptive_quality): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.network_stable == 1 && sva_checker.video_encoder == 1 |-> sva_checker.bandwidth_available[15:0] != 0 ? sva_checker.high_bitrate == 1 : sva_checker.adaptive_quality == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.video_encoder |-> sva_checker.bandwidth_available[15:0] ? sva_checker.high_bitrate : sva_checker.adaptive_quality): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hewl_3xa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.network_stable == 1 && sva_checker.video_encoder == 1 |-> sva_checker.bandwidth_available[15:0] != 0 ? sva_checker.high_bitrate == 1 : sva_checker.adaptive_quality == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.video_encoder |-> sva_checker.bandwidth_available[15:0] ? sva_checker.high_bitrate : sva_checker.adaptive_quality): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.network_stable == 1 && sva_checker.video_encoder == "
  },
  {
    "id": "0333",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_1nnsgtlu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.circadian_regulator |-> sva_checker.rem_sleep_detected ? sva_checker.preserve_cycle : sva_checker.optimize_deep_sleep): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sleep_stage_detection == 1 && sva_checker.circadian_regulator == 1 |-> sva_checker.rem_sleep_detected == 1 ? sva_checker.preserve_cycle == 1 : sva_checker.optimize_deep_sleep == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.circadian_regulator |-> sva_checker.rem_sleep_detected ? sva_checker.preserve_cycle : sva_checker.optimize_deep_sleep): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8krynj1f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sleep_stage_detection == 1 && sva_checker.circadian_regulator == 1 |-> sva_checker.rem_sleep_detected == 1 ? sva_checker.preserve_cycle == 1 : sva_checker.optimize_deep_sleep == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.circadian_regulator |-> sva_checker.rem_sleep_detected ? sva_checker.preserve_cycle : sva_checker.optimize_deep_sleep): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sleep_stage_detect"
  },
  {
    "id": "0339",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cz78i5dk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> sva_checker.user_consent_valid ? sva_checker.process_data : sva_checker.anonymize_records): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> (if(sva_checker.user_consent_valid) sva_checker.process_data else sva_checker.anonymize_records)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> sva_checker.user_consent_valid ? sva_checker.process_data : sva_checker.anonymize_records): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wdja1owg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> (if(sva_checker.user_consent_valid) sva_checker.process_data else sva_checker.anonymize_records)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> sva_checker.user_consent_valid ? sva_checker.process_data : sva_checker.anonymize_records): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_processing |-> (if(sva_checker.user_consent_valid) sva_checker.process_data else sva_checker.anonymize_records)): PROVED\n"
  },
  {
    "id": "0334",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_v4qno1rl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.exercise_tracker |-> sva_checker.target_zone_reached ? sva_checker.maintain_intensity : sva_checker.increase_effort): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.heart_rate_monitor_connected == 1 && sva_checker.exercise_tracker == 1 |-> sva_checker.target_zone_reached == 1 ? sva_checker.maintain_intensity == 1 : sva_checker.increase_effort == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.exercise_tracker |-> sva_checker.target_zone_reached ? sva_checker.maintain_intensity : sva_checker.increase_effort): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1jxpy188/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.heart_rate_monitor_connected == 1 && sva_checker.exercise_tracker == 1 |-> sva_checker.target_zone_reached == 1 ? sva_checker.maintain_intensity == 1 : sva_checker.increase_effort == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.exercise_tracker |-> sva_checker.target_zone_reached ? sva_checker.maintain_intensity : sva_checker.increase_effort): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.heart_rate_mon"
  },
  {
    "id": "0341",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_sglmqgjz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crisis_management |-> sva_checker.evacuation_needed ? sva_checker.emergency_broadcast : sva_checker.shelter_in_place): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.communication_down == 0 && sva_checker.crisis_management == 1 |-> sva_checker.evacuation_needed == 1 ? sva_checker.emergency_broadcast == 1 : sva_checker.shelter_in_place == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crisis_management |-> sva_checker.evacuation_needed ? sva_checker.emergency_broadcast : sva_checker.shelter_in_place): PROVED\n\n\nBackward: Parsing /tmp/sva_check_khaqepp8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.communication_down == 0 && sva_checker.crisis_management == 1 |-> sva_checker.evacuation_needed == 1 ? sva_checker.emergency_broadcast == 1 : sva_checker.shelter_in_place == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crisis_management |-> sva_checker.evacuation_needed ? sva_checker.emergency_broadcast : sva_checker.shelter_in_place): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.communication_down == 0 && sv"
  },
  {
    "id": "0436",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pwt9oj1l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.musical_interface |-> sva_checker.system_exclusive ? sva_checker.manufacturer_id_valid ? sva_checker.device_specific_message : sva_checker.universal_sysex ? sva_checker.global_parameter : sva_checker.ignore_message : sva_checker.channel_message): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.musical_interface == 1 |-> (if(sva_checker.system_exclusive == 1) if(sva_checker.manufacturer_id_valid == 1) sva_checker.device_specific_message == 1 else if(sva_checker.universal_sysex == 1) sva_checker.global_parameter == 1 else sva_checker.ignore_message == 1 else sva_checker.channel_message == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.musical_interface |-> sva_checker.system_exclusive ? sva_checker.manufacturer_id_valid ? sva_checker.device_specific_message : sva_checker.universal_sysex ? sva_checker.global_parameter : sva_checker.ignore_message : sva_checker.channel_message): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gegsov0l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.musical_interface == 1 |-> (if(sva_checker.system_exclusive == 1) if(sva_checker.manufacturer_id_valid == 1) sva_checke"
  },
  {
    "id": "0410",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0yk7mo0u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.basestation_controller |-> sva_checker.handover_required ? sva_checker.target_cell_available ? sva_checker.execute_handover : sva_checker.call_drop : sva_checker.continue_service): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tower_maintenance == 0 && sva_checker.basestation_controller == 1 |-> sva_checker.handover_required == 1 && sva_checker.target_cell_available == 1 ? sva_checker.execute_handover == 1 : sva_checker.handover_required == 1 && sva_checker.target_cell_available == 0 ? sva_checker.call_drop == 1 : sva_checker.handover_required == 0 ? sva_checker.continue_service == 1 : 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.basestation_controller |-> sva_checker.handover_required ? sva_checker.target_cell_available ? sva_checker.execute_handover : sva_checker.call_drop : sva_checker.continue_service): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9h3cwgmf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tower_maintenance == 0 && sva_checker.basestation_controller == 1 |-> sva_checker.handover_required == 1 && sva_checker.target_cell_available == 1 ? sva_checker.execute_handover == 1 : "
  },
  {
    "id": "0467",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5hm1212h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_encoder |-> sva_checker.quality_priority ? sva_checker.bitrate_sufficient ? sva_checker.lossless_encoding : sva_checker.high_quality_lossy : sva_checker.low_bitrate_compression): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun == 0 && sva_checker.audio_encoder == 1 |-> sva_checker.quality_priority == 1 ? sva_checker.bitrate_sufficient == 1 ? sva_checker.lossless_encoding == 1 : sva_checker.high_quality_lossy == 1 : sva_checker.low_bitrate_compression == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_encoder |-> sva_checker.quality_priority ? sva_checker.bitrate_sufficient ? sva_checker.lossless_encoding : sva_checker.high_quality_lossy : sva_checker.low_bitrate_compression): PROVED\n\n\nBackward: Parsing /tmp/sva_check_toiumibg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun == 0 && sva_checker.audio_encoder == 1 |-> sva_checker.quality_priority == 1 ? sva_checker.bitrate_sufficient == 1 ? sva_checker.lossless_encoding == 1 : sva_checker.high_quality_lossy == 1 : sva_checker.low_bitrate_compression == 1): ASSUMED\n[sva_checker.assert.2] always (disabl"
  },
  {
    "id": "0521",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t4j2nms5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.stock_tracker |-> sva_checker.item_count[15:0] ? sva_checker.reorder_point_reached ? sva_checker.generate_purchase_order : sva_checker.update_database : sva_checker.count_discrepancy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.stock_tracker |-> (if(sva_checker.item_count[15:0] != 0) if(sva_checker.reorder_point_reached) sva_checker.generate_purchase_order else sva_checker.update_database else sva_checker.count_discrepancy)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.stock_tracker |-> sva_checker.item_count[15:0] ? sva_checker.reorder_point_reached ? sva_checker.generate_purchase_order : sva_checker.update_database : sva_checker.count_discrepancy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bm38_awi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.stock_tracker |-> (if(sva_checker.item_count[15:0] != 0) if(sva_checker.reorder_point_reached) sva_checker.generate_purchase_order else sva_checker.update_database else sva_checker.count_discrepancy)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.stock_tracker |-> sva_checker.item_count[15:0] ? sva_checke"
  },
  {
    "id": "0505",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0citgjis/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.function_approximation |-> sva_checker.linear_relationship ? sva_checker.least_squares_stable ? sva_checker.analytical_solution : sva_checker.regularized_regression : sva_checker.polynomial_features): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.training_samples_adequate == 1 && sva_checker.function_approximation == 1 |-> sva_checker.linear_relationship == 1 && sva_checker.least_squares_stable == 1 ? sva_checker.analytical_solution : sva_checker.linear_relationship == 1 && sva_checker.least_squares_stable == 0 ? sva_checker.regularized_regression : sva_checker.linear_relationship == 0 ? sva_checker.polynomial_features : 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.function_approximation |-> sva_checker.linear_relationship ? sva_checker.least_squares_stable ? sva_checker.analytical_solution : sva_checker.regularized_regression : sva_checker.polynomial_features): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0_h3gva3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.training_samples_adequate == 1 && sva_checker.function_approximation == 1 |-> sva_checker.linear_relationship == 1 && sva_checker"
  },
  {
    "id": "0551",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2vbj1rbe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cheese_maker |-> sva_checker.acidity_level[7:0] != 0 ? sva_checker.curd_formation_proper ? sva_checker.aging_process : sva_checker.adjust_culture : sva_checker.add_starter): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cheese_maker |-> (if(sva_checker.acidity_level[7:0] != 0) if(sva_checker.curd_formation_proper) sva_checker.aging_process else sva_checker.adjust_culture else sva_checker.add_starter)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cheese_maker |-> sva_checker.acidity_level[7:0] != 0 ? sva_checker.curd_formation_proper ? sva_checker.aging_process : sva_checker.adjust_culture : sva_checker.add_starter): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rdf_tiv5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cheese_maker |-> (if(sva_checker.acidity_level[7:0] != 0) if(sva_checker.curd_formation_proper) sva_checker.aging_process else sva_checker.adjust_culture else sva_checker.add_starter)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cheese_maker |-> sva_checker.acidity_level[7:0] != 0 ? sva_checker.curd_formation_proper ? sva_checker.aging_proc"
  },
  {
    "id": "0579",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7fo0lxay/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.historical_storage |-> sva_checker.digitization_priority[7:0] ? sva_checker.fragile_condition ? sva_checker.immediate_scanning : sva_checker.scheduled_digitization : sva_checker.physical_preservation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.historical_storage == 1'b1 |-> (if(sva_checker.digitization_priority[7:0] != 0) if(sva_checker.fragile_condition == 1'b1) sva_checker.immediate_scanning == 1'b1 else sva_checker.scheduled_digitization == 1'b1 else sva_checker.physical_preservation == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.historical_storage |-> sva_checker.digitization_priority[7:0] ? sva_checker.fragile_condition ? sva_checker.immediate_scanning : sva_checker.scheduled_digitization : sva_checker.physical_preservation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r5jntqk0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.historical_storage == 1'b1 |-> (if(sva_checker.digitization_priority[7:0] != 0) if(sva_checker.fragile_condition == 1'b1) sva_checker.immediate_scanning == 1'b1 else sva_checker.scheduled_digitization == 1'b1 else sva_checker.physical_preservation == 1'b"
  },
  {
    "id": "0603",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_waaehk31/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ieee1149_controller |-> sva_checker.instruction_register[3:0] == 4'b0001 ? sva_checker.bypass_mode ? sva_checker.single_bit_path : sva_checker.full_scan_chain : sva_checker.normal_operation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_disabled == 0 && sva_checker.ieee1149_controller == 1 |-> sva_checker.instruction_register[3:0] == 4'b0001 ? sva_checker.bypass_mode == 1 ? sva_checker.single_bit_path : sva_checker.full_scan_chain : sva_checker.normal_operation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ieee1149_controller |-> sva_checker.instruction_register[3:0] == 4'b0001 ? sva_checker.bypass_mode ? sva_checker.single_bit_path : sva_checker.full_scan_chain : sva_checker.normal_operation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2dxl4v1i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_disabled == 0 && sva_checker.ieee1149_controller == 1 |-> sva_checker.instruction_register[3:0] == 4'b0001 ? sva_checker.bypass_mode == 1 ? sva_checker.single_bit_path : sva_checker.full_scan_chain : sva_checker.normal_operation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_chec"
  },
  {
    "id": "0664",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check__hmsha3b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.analog_to_digital |-> sva_checker.reference_voltage[11:0] == 12'hFFF ? sva_checker.overrange_condition ? sva_checker.clamp_output : sva_checker.saturated_conversion : sva_checker.linear_conversion): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adc_powered == 1 && sva_checker.analog_to_digital == 1 |-> sva_checker.reference_voltage[11:0] == 12'hFFF ? sva_checker.overrange_condition ? sva_checker.clamp_output : sva_checker.saturated_conversion : sva_checker.linear_conversion): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.analog_to_digital |-> sva_checker.reference_voltage[11:0] == 12'hFFF ? sva_checker.overrange_condition ? sva_checker.clamp_output : sva_checker.saturated_conversion : sva_checker.linear_conversion): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2j8qpn5i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adc_powered == 1 && sva_checker.analog_to_digital == 1 |-> sva_checker.reference_voltage[11:0] == 12'hFFF ? sva_checker.overrange_condition ? sva_checker.clamp_output : sva_checker.saturated_conversion : sva_checker.linear_conversion): ASSUMED\n[sva_checker.assert.2] always (disable "
  },
  {
    "id": "0731",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3cffs2fx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cognitive_architecture |-> sva_checker.attention_focus[9:0] ? sva_checker.working_memory_active ? sva_checker.conscious_processing : sva_checker.implicit_processing ? sva_checker.unconscious_computation : sva_checker.dormant_state : sva_checker.distributed_processing): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cognitive_architecture |-> (if(sva_checker.attention_focus[9:0] != 0) if(sva_checker.working_memory_active) sva_checker.conscious_processing else if(sva_checker.implicit_processing) sva_checker.unconscious_computation else sva_checker.dormant_state else sva_checker.distributed_processing)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cognitive_architecture |-> sva_checker.attention_focus[9:0] ? sva_checker.working_memory_active ? sva_checker.conscious_processing : sva_checker.implicit_processing ? sva_checker.unconscious_computation : sva_checker.dormant_state : sva_checker.distributed_processing): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cz2wjsuv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cognitive_architecture |-> (if(sva_checker.attention_focus[9:0] != 0) if(sva_checker."
  },
  {
    "id": "0732",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zenz_bbp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.complex_system |-> sva_checker.phase_transition_indicator[11:0] ? sva_checker.critical_point_reached ? sva_checker.emergent_behavior : sva_checker.self_organization ? sva_checker.pattern_formation : sva_checker.random_dynamics : sva_checker.simple_behavior): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.complex_system |-> (if(sva_checker.phase_transition_indicator[11:0] != 0) if(sva_checker.critical_point_reached) sva_checker.emergent_behavior else if(sva_checker.self_organization) sva_checker.pattern_formation else sva_checker.random_dynamics else sva_checker.simple_behavior)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.complex_system |-> sva_checker.phase_transition_indicator[11:0] ? sva_checker.critical_point_reached ? sva_checker.emergent_behavior : sva_checker.self_organization ? sva_checker.pattern_formation : sva_checker.random_dynamics : sva_checker.simple_behavior): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8ftxml5v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.complex_system |-> (if(sva_checker.phase_transition_indicator[11:0] != 0) if(sva_checker.critical_point_reached) sva_c"
  },
  {
    "id": "0894",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_22hov0t6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_monitor |-> sva_checker.measurement_complete ? sva_checker.within_tolerance ? sva_checker.voltage_ok : sva_checker.voltage_fault : sva_checker.measuring): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.regulator_stable == 1 && sva_checker.voltage_monitor == 1 |-> sva_checker.measurement_complete == 1 ? sva_checker.within_tolerance == 1 ? sva_checker.voltage_ok == 1 : sva_checker.voltage_fault == 1 : sva_checker.measuring == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_monitor |-> sva_checker.measurement_complete ? sva_checker.within_tolerance ? sva_checker.voltage_ok : sva_checker.voltage_fault : sva_checker.measuring): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hnuruiqb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.regulator_stable == 1 && sva_checker.voltage_monitor == 1 |-> sva_checker.measurement_complete == 1 ? sva_checker.within_tolerance == 1 ? sva_checker.voltage_ok == 1 : sva_checker.voltage_fault == 1 : sva_checker.measuring == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_monitor |-> sva_checker.measurement_com"
  },
  {
    "id": "0953",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_kfy17g5o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.particle_swarm |-> sva_checker.velocity_update[15:0] && sva_checker.position_bounds ? sva_checker.global_best_found ? sva_checker.exploitation_phase : sva_checker.exploration_phase : sva_checker.swarm_convergence): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.communication_lost == 0 && sva_checker.particle_swarm == 1 |-> sva_checker.velocity_update[15:0] != 0 && sva_checker.position_bounds == 1 ? sva_checker.global_best_found ? sva_checker.exploitation_phase : sva_checker.exploration_phase : sva_checker.swarm_convergence): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.particle_swarm |-> sva_checker.velocity_update[15:0] && sva_checker.position_bounds ? sva_checker.global_best_found ? sva_checker.exploitation_phase : sva_checker.exploration_phase : sva_checker.swarm_convergence): PROVED\n\n\nBackward: Parsing /tmp/sva_check_paqg6otn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.communication_lost == 0 && sva_checker.particle_swarm == 1 |-> sva_checker.velocity_update[15:0] != 0 && sva_checker.position_bounds == 1 ? sva_checker.global_best_found ? sva_checker.exploitation_phase : sva_checker.e"
  },
  {
    "id": "0012",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_clmc71u3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) && $past(sva_checker.reload_value) > 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 1 && sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) == 1 && $past(sva_checker.reload_value) > 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) && $past(sva_checker.reload_value) > 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0z52s2k4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 1 && sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) == 1 && $past(sva_checker.reload_value) > 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) && $past(sva_checker.reload_value) > 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst == 1 && sva_checker.timer_expired == 1'b1 |-> $past(sva_checker.counter_enable) == 1 && $past(sva_checker.reload_value) > 0): PROVED\n"
  },
  {
    "id": "0906",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ep_90vje/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pump_controller |-> sva_checker.flow_request ? sva_checker.pressure_ok ? sva_checker.maintain_flow : sva_checker.pressure_fault : sva_checker.pump_standby): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dry_run_protection == 0 && sva_checker.pump_controller == 1 |-> sva_checker.flow_request == 1 && sva_checker.pressure_ok == 1 ? sva_checker.maintain_flow == 1 : sva_checker.flow_request == 1 && sva_checker.pressure_ok == 0 ? sva_checker.pressure_fault == 1 : sva_checker.flow_request == 0 ? sva_checker.pump_standby == 1 : 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pump_controller |-> sva_checker.flow_request ? sva_checker.pressure_ok ? sva_checker.maintain_flow : sva_checker.pressure_fault : sva_checker.pump_standby): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p_2f9yih/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dry_run_protection == 0 && sva_checker.pump_controller == 1 |-> sva_checker.flow_request == 1 && sva_checker.pressure_ok == 1 ? sva_checker.maintain_flow == 1 : sva_checker.flow_request == 1 && sva_checker.pressure_ok == 0 ? sva_checker.pressure_fault == 1 : sva_checker.flow_"
  },
  {
    "id": "0061",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_m9fu6bgr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transaction |-> ($past(sva_checker.cs_active) && $past(sva_checker.clock_ready, 1) |=> $past(sva_checker.data_setup))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.chip_enable == 1 && sva_checker.spi_transaction == 1 && $past(sva_checker.cs_active) == 1 && $past(sva_checker.clock_ready) == 1 |-> (##1 $past(sva_checker.data_setup) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spi_transaction |-> ($past(sva_checker.cs_active) && $past(sva_checker.clock_ready, 1) |=> $past(sva_checker.data_setup))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wja23ua9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.chip_enable == 1 && sva_checker.spi_transaction == 1 && $past(sva_checker.cs_active) == 1 && $past(sva_checker.clock_ready) == 1 |-> (##1 $past(sva_checker.data_setup) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transaction |-> ($past(sva_checker.cs_active) && $past(sva_checker.clock_ready, 1) |=> $past(sva_checker.data_setup))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.chip_enable == 1 &"
  },
  {
    "id": "0104",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zsvzqv2t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) && $past(sva_checker.state_reg) == 4'b0101): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) == 1'b1 && $past(sva_checker.state_reg) == 4'b0101): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) && $past(sva_checker.state_reg) == 4'b0101): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eal72pay/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) == 1'b1 && $past(sva_checker.state_reg) == 4'b0101): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) && $past(sva_checker.state_reg) == 4'b0101): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.request_active == 1'b1 |-> $past(sva_checker.acknowledge_pending) == 1'b1 && $past(sva_checker.state_reg) == 4'b0101): PROVED\n"
  },
  {
    "id": "0095",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xrjks6r_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_message_tx == 1'b1 |-> $past(sva_checker.arbitration_won) && $past(sva_checker.bus_idle, 1) && !$past(sva_checker.error_passive_mode, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error == 0 && sva_checker.can_message_tx == 1'b1 |-> $past(sva_checker.arbitration_won, 1) == 1'b1 && $past(sva_checker.bus_idle, 1) == 1'b1 && $past(sva_checker.error_passive_mode, 2) == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_message_tx == 1'b1 |-> $past(sva_checker.arbitration_won) && $past(sva_checker.bus_idle, 1) && !$past(sva_checker.error_passive_mode, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0da51qk7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error == 0 && sva_checker.can_message_tx == 1'b1 |-> $past(sva_checker.arbitration_won, 1) == 1'b1 && $past(sva_checker.bus_idle, 1) == 1'b1 && $past(sva_checker.error_passive_mode, 2) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_message_tx == 1'b1 |-> $past(sva_checker.arbitration_won) && $past(sva_checker.bus_idle, 1) && !$past(sva_checker.error_passive_mode, 2)): REFUTE"
  },
  {
    "id": "0183",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_08hevwn9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.message_send == 1'b1 |-> $past(sva_checker.bus_arbitration) && $past(sva_checker.dominant_bit, 1) && !$past(sva_checker.error_passive, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_bus_off == 0 && sva_checker.message_send == 1'b1 |-> $past(sva_checker.bus_arbitration, 1) == 1 && $past(sva_checker.dominant_bit, 1) == 1 && $past(sva_checker.error_passive, 2) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.message_send == 1'b1 |-> $past(sva_checker.bus_arbitration) && $past(sva_checker.dominant_bit, 1) && !$past(sva_checker.error_passive, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eov88_jv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_bus_off == 0 && sva_checker.message_send == 1'b1 |-> $past(sva_checker.bus_arbitration, 1) == 1 && $past(sva_checker.dominant_bit, 1) == 1 && $past(sva_checker.error_passive, 2) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.message_send == 1'b1 |-> $past(sva_checker.bus_arbitration) && $past(sva_checker.dominant_bit, 1) && !$past(sva_checker.error_passive, 2)): REFUTED\n[sva_checker.cover_antecede"
  },
  {
    "id": "0184",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_awfj1ped/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_establishment |-> $past(sva_checker.signal_detect, 2) && $past(sva_checker.training_complete) && !$past(sva_checker.symbol_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phy_fault == 0 && sva_checker.link_establishment == 1 |-> $past(sva_checker.signal_detect, 2) == 1 && $past(sva_checker.training_complete, 1) == 1 && $past(sva_checker.symbol_error, 1) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_establishment |-> $past(sva_checker.signal_detect, 2) && $past(sva_checker.training_complete) && !$past(sva_checker.symbol_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_je3kp15o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phy_fault == 0 && sva_checker.link_establishment == 1 |-> $past(sva_checker.signal_detect, 2) == 1 && $past(sva_checker.training_complete, 1) == 1 && $past(sva_checker.symbol_error, 1) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_establishment |-> $past(sva_checker.signal_detect, 2) && $past(sva_checker.training_complete) && !$past(sva_checker.symbol_error)): REFUTED\n[sva_checker.cover_antecedent]"
  },
  {
    "id": "0217",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_c5lpvfcy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cpu_pipeline == 1'b1 |-> $past(sva_checker.pc_increment) && (!$past(sva_checker.pipeline_stall, 2) || $past(sva_checker.exception_flush))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_rst == 0 && sva_checker.cpu_pipeline == 1 |-> $past(sva_checker.pc_increment) == 1 && ($past(sva_checker.pipeline_stall, 2) == 0 || $past(sva_checker.exception_flush) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cpu_pipeline == 1'b1 |-> $past(sva_checker.pc_increment) && (!$past(sva_checker.pipeline_stall, 2) || $past(sva_checker.exception_flush))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i4v5jjfg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_rst == 0 && sva_checker.cpu_pipeline == 1 |-> $past(sva_checker.pc_increment) == 1 && ($past(sva_checker.pipeline_stall, 2) == 0 || $past(sva_checker.exception_flush) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cpu_pipeline == 1'b1 |-> $past(sva_checker.pc_increment) && (!$past(sva_checker.pipeline_stall, 2) || $past(sva_checker.exception_flush))): REFUTED\n[sva_checker.cover_antecedent] cover "
  },
  {
    "id": "0218",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n5f8j82y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adc_sample == 1'b1 |-> $past(sva_checker.input_stable) && $past(sva_checker.reference_voltage, 2) && $past(sva_checker.converter_ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_async == 1 && sva_checker.adc_sample == 1 |-> $past(sva_checker.input_stable, 1) == 1 && $past(sva_checker.reference_voltage, 2) == 1 && $past(sva_checker.converter_ready, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adc_sample == 1'b1 |-> $past(sva_checker.input_stable) && $past(sva_checker.reference_voltage, 2) && $past(sva_checker.converter_ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m69_ejr0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_async == 1 && sva_checker.adc_sample == 1 |-> $past(sva_checker.input_stable, 1) == 1 && $past(sva_checker.reference_voltage, 2) == 1 && $past(sva_checker.converter_ready, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adc_sample == 1'b1 |-> $past(sva_checker.input_stable) && $past(sva_checker.reference_voltage, 2) && $past(sva_checker.converter_ready)): REFUTED\n[sva_checker.cover_antecedent] cover (d"
  },
  {
    "id": "0259",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_eehq1g9l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bank_precharge == 1'b1 |-> $past(sva_checker.row_active_time, 1) > $past(sva_checker.minimum_ras, 1) && $past(sva_checker.no_pending_access, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_power_down == 0 && sva_checker.bank_precharge == 1'b1 |-> $past(sva_checker.row_active_time) > $past(sva_checker.minimum_ras) && $past(sva_checker.no_pending_access) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bank_precharge == 1'b1 |-> $past(sva_checker.row_active_time, 1) > $past(sva_checker.minimum_ras, 1) && $past(sva_checker.no_pending_access, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_06729bjc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_power_down == 0 && sva_checker.bank_precharge == 1'b1 |-> $past(sva_checker.row_active_time) > $past(sva_checker.minimum_ras) && $past(sva_checker.no_pending_access) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bank_precharge == 1'b1 |-> $past(sva_checker.row_active_time, 1) > $past(sva_checker.minimum_ras, 1) && $past(sva_checker.no_pending_access, 1)): REFUTED\n[sva_checker.cover_antecede"
  },
  {
    "id": "0284",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2994xqvp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_engine == 1'b1 |-> ($past(sva_checker.descriptor_valid, 1) |=> $past(sva_checker.source_ready) && $past(sva_checker.destination_ready) && !$past(sva_checker.bus_error))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_engine == 1'b1 |-> ($past(sva_checker.descriptor_valid) |=> $past(sva_checker.source_ready) && $past(sva_checker.destination_ready) && !$past(sva_checker.bus_error))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.transfer_engine == 1'b1 |-> ($past(sva_checker.descriptor_valid, 1) |=> $past(sva_checker.source_ready) && $past(sva_checker.destination_ready) && !$past(sva_checker.bus_error))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_60um4fb9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_engine == 1'b1 |-> ($past(sva_checker.descriptor_valid) |=> $past(sva_checker.source_ready) && $past(sva_checker.destination_ready) && !$past(sva_checker.bus_error))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_engine == 1'b1 |-> ($past(sva_checker.descriptor_valid, 1) |=> $past(sva_checker.source_ready) && $past(sva_ch"
  },
  {
    "id": "0263",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_d6a4e17z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.routing_table |-> $past(sva_checker.topology_update, 1) && $past(sva_checker.convergence_timer) && !$past(sva_checker.loop_detection, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.network_reset_n == 1 && sva_checker.routing_table == 1 |-> $past(sva_checker.topology_update, 1) == 1 && $past(sva_checker.convergence_timer, 1) == 1 && $past(sva_checker.loop_detection, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.routing_table |-> $past(sva_checker.topology_update, 1) && $past(sva_checker.convergence_timer) && !$past(sva_checker.loop_detection, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ezl4dvq1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.network_reset_n == 1 && sva_checker.routing_table == 1 |-> $past(sva_checker.topology_update, 1) == 1 && $past(sva_checker.convergence_timer, 1) == 1 && $past(sva_checker.loop_detection, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.routing_table |-> $past(sva_checker.topology_update, 1) && $past(sva_checker.convergence_timer) && !$past(sva_checker.loop_detection, 3)): REFUTED\n[sva_checker.c"
  },
  {
    "id": "0285",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_6npei55e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_detection |-> $past(sva_checker.input_signal, 1) && $past(sva_checker.hysteresis_band, 1) && !$past(sva_checker.noise_filter_active, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.comparator_on == 1 && sva_checker.threshold_detection == 1 |-> $past(sva_checker.input_signal, 1) == 1 && $past(sva_checker.hysteresis_band, 1) == 1 && $past(sva_checker.noise_filter_active, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.threshold_detection |-> $past(sva_checker.input_signal, 1) && $past(sva_checker.hysteresis_band, 1) && !$past(sva_checker.noise_filter_active, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rp8hdd9v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.comparator_on == 1 && sva_checker.threshold_detection == 1 |-> $past(sva_checker.input_signal, 1) == 1 && $past(sva_checker.hysteresis_band, 1) == 1 && $past(sva_checker.noise_filter_active, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_detection |-> $past(sva_checker.input_signal, 1) && $past(sva_checker.hysteresis_band, 1) && !$past(sva_checker.noise_filter_"
  },
  {
    "id": "0318",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n925xkb8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.iterative_decode == 1'b1 |-> $past(sva_checker.extrinsic_information, 1) && $past(sva_checker.interleaver, 3) && $past(sva_checker.stopping_criterion)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.turbo_disable == 0 && sva_checker.iterative_decode == 1'b1 |-> $past(sva_checker.extrinsic_information, 1) == 1'b1 && $past(sva_checker.interleaver, 3) == 1'b1 && $past(sva_checker.stopping_criterion, 1) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.iterative_decode == 1'b1 |-> $past(sva_checker.extrinsic_information, 1) && $past(sva_checker.interleaver, 3) && $past(sva_checker.stopping_criterion)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_43rl0ic1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.turbo_disable == 0 && sva_checker.iterative_decode == 1'b1 |-> $past(sva_checker.extrinsic_information, 1) == 1'b1 && $past(sva_checker.interleaver, 3) == 1'b1 && $past(sva_checker.stopping_criterion, 1) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.iterative_decode == 1'b1 |-> $past(sva_checker.extrinsic_information, 1) && $past(sva_checker.inter"
  },
  {
    "id": "0328",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_z18hu1m8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_filter == 1'b1 |-> ($past(sva_checker.error_signal, 2) && $past(sva_checker.tap_weight_update) |=> !$past(sva_checker.filter_instability))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eq_bypass == 0 && sva_checker.adaptive_filter == 1'b1 && $past(sva_checker.error_signal, 2) == 1'b1 && $past(sva_checker.tap_weight_update, 1) == 1'b1 |-> (##1 $past(sva_checker.filter_instability, 1) == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adaptive_filter == 1'b1 |-> ($past(sva_checker.error_signal, 2) && $past(sva_checker.tap_weight_update) |=> !$past(sva_checker.filter_instability))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ho5qrdrk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eq_bypass == 0 && sva_checker.adaptive_filter == 1'b1 && $past(sva_checker.error_signal, 2) == 1'b1 && $past(sva_checker.tap_weight_update, 1) == 1'b1 |-> (##1 $past(sva_checker.filter_instability, 1) == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_filter == 1'b1 |-> ($past(sva_checker.error_signal, 2) && $past(sva_checker.tap_weight_update) |=> !"
  },
  {
    "id": "0422",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_f24almyj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.brownian_motor == 1'b1 |-> $past(sva_checker.ratchet_potential, 2) && $past(sva_checker.thermal_noise) && $past(sva_checker.directional_motion, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_fluctuation == 0 && sva_checker.brownian_motor == 1 |-> $past(sva_checker.ratchet_potential, 2) == 1 && $past(sva_checker.thermal_noise, 1) == 1 && $past(sva_checker.directional_motion, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.brownian_motor == 1'b1 |-> $past(sva_checker.ratchet_potential, 2) && $past(sva_checker.thermal_noise) && $past(sva_checker.directional_motion, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nwqwu31a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_fluctuation == 0 && sva_checker.brownian_motor == 1 |-> $past(sva_checker.ratchet_potential, 2) == 1 && $past(sva_checker.thermal_noise, 1) == 1 && $past(sva_checker.directional_motion, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.brownian_motor == 1'b1 |-> $past(sva_checker.ratchet_potential, 2) && $past(sva_checker.thermal_noise) && $past(sva_checker.dir"
  },
  {
    "id": "0435",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ki0j5rrj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.memory_storage |-> ($past(sva_checker.polarization_reversal, 3) |=> $past(sva_checker.retention_time) && $past(sva_checker.endurance_cycles))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_switching == 1 && sva_checker.memory_storage == 1 && $past(sva_checker.polarization_reversal, 3) |-> (##1 $past(sva_checker.retention_time, 1) == 1 && $past(sva_checker.endurance_cycles, 1) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.memory_storage |-> ($past(sva_checker.polarization_reversal, 3) |=> $past(sva_checker.retention_time) && $past(sva_checker.endurance_cycles))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a1fr5d8x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_switching == 1 && sva_checker.memory_storage == 1 && $past(sva_checker.polarization_reversal, 3) |-> (##1 $past(sva_checker.retention_time, 1) == 1 && $past(sva_checker.endurance_cycles, 1) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.memory_storage |-> ($past(sva_checker.polarization_reversal, 3) |=> $past(sva_checker.retention_time) && $past(sva_checke"
  },
  {
    "id": "0468",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_hvp1o0v1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.human_robot_interaction == 1'b1 |-> $past(sva_checker.hand_tracking, 1) && $past(sva_checker.gesture_vocabulary, 2) && $past(sva_checker.intent_recognition, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gesture_sensor_fault == 0 && sva_checker.human_robot_interaction == 1'b1 |-> $past(sva_checker.hand_tracking, 1) == 1'b1 && $past(sva_checker.gesture_vocabulary, 2) == 1'b1 && $past(sva_checker.intent_recognition, 3) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.human_robot_interaction == 1'b1 |-> $past(sva_checker.hand_tracking, 1) && $past(sva_checker.gesture_vocabulary, 2) && $past(sva_checker.intent_recognition, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vbji_19_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gesture_sensor_fault == 0 && sva_checker.human_robot_interaction == 1'b1 |-> $past(sva_checker.hand_tracking, 1) == 1'b1 && $past(sva_checker.gesture_vocabulary, 2) == 1'b1 && $past(sva_checker.intent_recognition, 3) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.human_robot_interaction == 1'b1 |-> $past(sva_checker.h"
  },
  {
    "id": "0469",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_diozc9d7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dna_computing |-> $past(sva_checker.hybridization_reaction, 1) && $past(sva_checker.strand_displacement, 2) && !$past(sva_checker.cross_hybridization, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.enzyme_inhibition == 0 && sva_checker.dna_computing == 1 |-> $past(sva_checker.hybridization_reaction, 1) == 1 && $past(sva_checker.strand_displacement, 2) == 1 && $past(sva_checker.cross_hybridization, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dna_computing |-> $past(sva_checker.hybridization_reaction, 1) && $past(sva_checker.strand_displacement, 2) && !$past(sva_checker.cross_hybridization, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xlwfkon_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.enzyme_inhibition == 0 && sva_checker.dna_computing == 1 |-> $past(sva_checker.hybridization_reaction, 1) == 1 && $past(sva_checker.strand_displacement, 2) == 1 && $past(sva_checker.cross_hybridization, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dna_computing |-> $past(sva_checker.hybridization_reaction, 1) && $past(sva_checker.strand_disp"
  },
  {
    "id": "0538",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_koxtg32x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thought_controlled_computing |-> $past(sva_checker.eeg_signal_processing, 1) && $past(sva_checker.motor_imagery, 3) && $past(sva_checker.classification_accuracy)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.neural_noise_high == 0 && sva_checker.thought_controlled_computing == 1 |-> $past(sva_checker.eeg_signal_processing, 1) == 1 && $past(sva_checker.motor_imagery, 3) == 1 && $past(sva_checker.classification_accuracy, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thought_controlled_computing |-> $past(sva_checker.eeg_signal_processing, 1) && $past(sva_checker.motor_imagery, 3) && $past(sva_checker.classification_accuracy)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qadgbxj9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.neural_noise_high == 0 && sva_checker.thought_controlled_computing == 1 |-> $past(sva_checker.eeg_signal_processing, 1) == 1 && $past(sva_checker.motor_imagery, 3) == 1 && $past(sva_checker.classification_accuracy, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thought_controlled_computing |-> $past(sva_checker.eeg_"
  },
  {
    "id": "0584",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_e0hhdhey/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cosmological_structure |-> ($past(sva_checker.dark_matter_halo, 2) && $past(sva_checker.baryonic_matter_accretion) |=> !$past(sva_checker.galaxy_collision))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dark_energy_dominance == 0 && sva_checker.cosmological_structure == 1 && $past(sva_checker.baryonic_matter_accretion, 1) == 1 && $past(sva_checker.dark_matter_halo, 2) == 1 |-> (##1 $past(sva_checker.galaxy_collision, 1) == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cosmological_structure |-> ($past(sva_checker.dark_matter_halo, 2) && $past(sva_checker.baryonic_matter_accretion) |=> !$past(sva_checker.galaxy_collision))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7h86zdli/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dark_energy_dominance == 0 && sva_checker.cosmological_structure == 1 && $past(sva_checker.baryonic_matter_accretion, 1) == 1 && $past(sva_checker.dark_matter_halo, 2) == 1 |-> (##1 $past(sva_checker.galaxy_collision, 1) == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cosmological_structure |-> ($past(sva_checker.dark_matter"
  },
  {
    "id": "0642",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_2_a1rpbd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.automotive_biometrics == 1'b1 |-> $past(sva_checker.driver_face_recognition, 1) && $past(sva_checker.steering_wheel_grip, 2) && !$past(sva_checker.unauthorized_access, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vehicle_theft_attempt == 0 && sva_checker.automotive_biometrics == 1 |-> $past(sva_checker.driver_face_recognition, 1) == 1 && $past(sva_checker.steering_wheel_grip, 2) == 1 && $past(sva_checker.unauthorized_access, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.automotive_biometrics == 1'b1 |-> $past(sva_checker.driver_face_recognition, 1) && $past(sva_checker.steering_wheel_grip, 2) && !$past(sva_checker.unauthorized_access, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j2hgnn76/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vehicle_theft_attempt == 0 && sva_checker.automotive_biometrics == 1 |-> $past(sva_checker.driver_face_recognition, 1) == 1 && $past(sva_checker.steering_wheel_grip, 2) == 1 && $past(sva_checker.unauthorized_access, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.automotive_biometrics == 1'b1 |-> $"
  },
  {
    "id": "0663",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0ndo19yt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.claim_verification == 1'b1 |-> $past(sva_checker.claimant_identity_verification, 1) && $past(sva_checker.injury_assessment, 2) && !$past(sva_checker.fraudulent_claim, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.insurance_fraud_detected == 0 && sva_checker.claim_verification == 1 |-> $past(sva_checker.claimant_identity_verification, 1) == 1 && $past(sva_checker.injury_assessment, 2) == 1 && $past(sva_checker.fraudulent_claim, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.claim_verification == 1'b1 |-> $past(sva_checker.claimant_identity_verification, 1) && $past(sva_checker.injury_assessment, 2) && !$past(sva_checker.fraudulent_claim, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a43yb0vx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.insurance_fraud_detected == 0 && sva_checker.claim_verification == 1 |-> $past(sva_checker.claimant_identity_verification, 1) == 1 && $past(sva_checker.injury_assessment, 2) == 1 && $past(sva_checker.fraudulent_claim, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.claim_verification == 1'b1 |-> $p"
  },
  {
    "id": "0676",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ktagqzxx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gaming_security == 1'b1 |-> ($past(sva_checker.card_counter_identification, 2) && $past(sva_checker.collusion_detection) |=> !$past(sva_checker.cheating_activity))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gaming_security |-> ($past(sva_checker.card_counter_identification, 2) && $past(sva_checker.collusion_detection) |=> !$past(sva_checker.cheating_activity))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gaming_security == 1'b1 |-> ($past(sva_checker.card_counter_identification, 2) && $past(sva_checker.collusion_detection) |=> !$past(sva_checker.cheating_activity))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gyupqc6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gaming_security |-> ($past(sva_checker.card_counter_identification, 2) && $past(sva_checker.collusion_detection) |=> !$past(sva_checker.cheating_activity))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gaming_security == 1'b1 |-> ($past(sva_checker.card_counter_identification, 2) && $past(sva_checker.collusion_detection) |=> !$past(sva_checker.cheating_activity))): PROVED up to bound "
  },
  {
    "id": "0674",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_vok3ucmp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.freshwater_management == 1'b1 |-> ($past(sva_checker.precipitation_pattern, 2) && $past(sva_checker.groundwater_depletion) |=> !$past(sva_checker.water_scarcity_crisis))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hydrological_disruption == 0 && sva_checker.freshwater_management == 1 && $past(sva_checker.precipitation_pattern, 2) == 1 && $past(sva_checker.groundwater_depletion, 1) == 1 |-> (##1 $past(sva_checker.water_scarcity_crisis, 1) == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.freshwater_management == 1'b1 |-> ($past(sva_checker.precipitation_pattern, 2) && $past(sva_checker.groundwater_depletion) |=> !$past(sva_checker.water_scarcity_crisis))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3arm2d2y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hydrological_disruption == 0 && sva_checker.freshwater_management == 1 && $past(sva_checker.precipitation_pattern, 2) == 1 && $past(sva_checker.groundwater_depletion, 1) == 1 |-> (##1 $past(sva_checker.water_scarcity_crisis, 1) == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.freshwater_manage"
  },
  {
    "id": "0688",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n1km0l2q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.global_sustainability_index == 1'b1 |-> $past(sva_checker.poverty_reduction_rate, 1) && $past(sva_checker.education_access_improvement, 3) && $past(sva_checker.gender_equality_progress)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sustainable_development_goals_tracking == 1 && sva_checker.global_sustainability_index == 1 |-> $past(sva_checker.poverty_reduction_rate, 1) == 1 && $past(sva_checker.education_access_improvement, 3) == 1 && $past(sva_checker.gender_equality_progress, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.global_sustainability_index == 1'b1 |-> $past(sva_checker.poverty_reduction_rate, 1) && $past(sva_checker.education_access_improvement, 3) && $past(sva_checker.gender_equality_progress)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hv6kmwpw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sustainable_development_goals_tracking == 1 && sva_checker.global_sustainability_index == 1 |-> $past(sva_checker.poverty_reduction_rate, 1) == 1 && $past(sva_checker.education_access_improvement, 3) == 1 && $past(sva_checker.gender_equality_progress, 1) == 1): ASSUMED\n[sva_chec"
  },
  {
    "id": "0731",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bdusjmhv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.zoonotic_disease_prevention == 1'b1 |-> $past(sva_checker.animal_human_interface_surveillance, 2) && $past(sva_checker.environmental_reservoir_monitoring) && $past(sva_checker.cross_species_transmission_risk, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.one_health_approach_implemented == 1 && sva_checker.zoonotic_disease_prevention == 1 |-> $past(sva_checker.animal_human_interface_surveillance, 2) == 1 && $past(sva_checker.environmental_reservoir_monitoring, 1) == 1 && $past(sva_checker.cross_species_transmission_risk, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.zoonotic_disease_prevention == 1'b1 |-> $past(sva_checker.animal_human_interface_surveillance, 2) && $past(sva_checker.environmental_reservoir_monitoring) && $past(sva_checker.cross_species_transmission_risk, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nrneq44d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.one_health_approach_implemented == 1 && sva_checker.zoonotic_disease_prevention == 1 |-> $past(sva_checker.animal_human_interface_surveillance, 2) == 1 && $past(sva_checker.environmental_reservoir_monitoring,"
  },
  {
    "id": "0782",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_iq1tnbdw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.blockchain_gaming |-> $past(sva_checker.in_game_asset_ownership, 1) && $past(sva_checker.play_to_earn_mechanism, 3) && $past(sva_checker.economic_sustainability, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.game_economy_imbalance == 0 && sva_checker.blockchain_gaming == 1 |-> $past(sva_checker.in_game_asset_ownership, 1) == 1 && $past(sva_checker.play_to_earn_mechanism, 3) == 1 && $past(sva_checker.economic_sustainability, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.blockchain_gaming |-> $past(sva_checker.in_game_asset_ownership, 1) && $past(sva_checker.play_to_earn_mechanism, 3) && $past(sva_checker.economic_sustainability, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1ue0evtb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.game_economy_imbalance == 0 && sva_checker.blockchain_gaming == 1 |-> $past(sva_checker.in_game_asset_ownership, 1) == 1 && $past(sva_checker.play_to_earn_mechanism, 3) == 1 && $past(sva_checker.economic_sustainability, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.blockchain_gaming |-> $past(sva_checker"
  },
  {
    "id": "0831",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_i9rs8b6v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decentralized_treasury |-> $past(sva_checker.spending_proposal_evaluation, 1) && $past(sva_checker.multi_sig_approval, 2) && !$past(sva_checker.fund_misappropriation, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.treasury_governance_attack == 0 && sva_checker.decentralized_treasury == 1 |-> $past(sva_checker.spending_proposal_evaluation, 1) == 1 && $past(sva_checker.multi_sig_approval, 2) == 1 && $past(sva_checker.fund_misappropriation, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decentralized_treasury |-> $past(sva_checker.spending_proposal_evaluation, 1) && $past(sva_checker.multi_sig_approval, 2) && !$past(sva_checker.fund_misappropriation, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t2chh744/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.treasury_governance_attack == 0 && sva_checker.decentralized_treasury == 1 |-> $past(sva_checker.spending_proposal_evaluation, 1) == 1 && $past(sva_checker.multi_sig_approval, 2) == 1 && $past(sva_checker.fund_misappropriation, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decentralized"
  },
  {
    "id": "0924",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jit8oslp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spirit_production == 1'b1 |-> ($past(sva_checker.vapor_temperature_monitoring, 2) |=> $past(sva_checker.congener_separation_efficiency) && $past(sva_checker.product_purity_achievement))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spirit_production == 1'b1 |-> ($past(sva_checker.vapor_temperature_monitoring, 2) |=> $past(sva_checker.congener_separation_efficiency) && $past(sva_checker.product_purity_achievement))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spirit_production == 1'b1 |-> ($past(sva_checker.vapor_temperature_monitoring, 2) |=> $past(sva_checker.congener_separation_efficiency) && $past(sva_checker.product_purity_achievement))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iay35sr_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spirit_production == 1'b1 |-> ($past(sva_checker.vapor_temperature_monitoring, 2) |=> $past(sva_checker.congener_separation_efficiency) && $past(sva_checker.product_purity_achievement))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spirit_production == 1'b1 |-> ($past(sva_checker.vapor_temperature_monitoring, 2)"
  },
  {
    "id": "0855",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_4avqd3ga/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_logo_recognition |-> $past(sva_checker.acoustic_signature_extraction, 3) && ($past(sva_checker.brand_association_strength) || $past(sva_checker.memorability_index, 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.brand_identity_inconsistency == 0 && sva_checker.audio_logo_recognition == 1 |-> $past(sva_checker.acoustic_signature_extraction, 3) == 1 && ($past(sva_checker.brand_association_strength, 1) == 1 || $past(sva_checker.memorability_index, 1) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_logo_recognition |-> $past(sva_checker.acoustic_signature_extraction, 3) && ($past(sva_checker.brand_association_strength) || $past(sva_checker.memorability_index, 1))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_geqwv_hd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.brand_identity_inconsistency == 0 && sva_checker.audio_logo_recognition == 1 |-> $past(sva_checker.acoustic_signature_extraction, 3) == 1 && ($past(sva_checker.brand_association_strength, 1) == 1 || $past(sva_checker.memorability_index, 1) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_"
  },
  {
    "id": "1045",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lefs2dw7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.branch_taken && $past(sva_checker.condition_met) |-> $past(sva_checker.branch_predict) == sva_checker.prediction): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.branch_taken == 1 && $past(sva_checker.condition_met) == 1 |-> sva_checker.prediction == $past(sva_checker.branch_predict)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.branch_taken && $past(sva_checker.condition_met) |-> $past(sva_checker.branch_predict) == sva_checker.prediction): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kkf09kp9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.branch_taken == 1 && $past(sva_checker.condition_met) == 1 |-> sva_checker.prediction == $past(sva_checker.branch_predict)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.branch_taken && $past(sva_checker.condition_met) |-> $past(sva_checker.branch_predict) == sva_checker.prediction): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.branch_taken == 1 && $past(sva_checker.condition_met) == 1 |-> sva_checker.prediction == $past(sva_checker.branch_predict)): PROVED\n"
  },
  {
    "id": "0994",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xyu1i3wn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1'b1 |-> $past(sva_checker.addr_valid) && $past(sva_checker.data_setup)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.mem_access == 1 |-> $past(sva_checker.addr_valid) == 1 && $past(sva_checker.data_setup) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1'b1 |-> $past(sva_checker.addr_valid) && $past(sva_checker.data_setup)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3ky6jtk4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.mem_access == 1 |-> $past(sva_checker.addr_valid) == 1 && $past(sva_checker.data_setup) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1'b1 |-> $past(sva_checker.addr_valid) && $past(sva_checker.data_setup)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.mem_access == 1 |-> $past(sva_checker.addr_valid) == 1 && $past(sva_checker.data_setup) == 1): PROVED\n"
  },
  {
    "id": "1059",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n682qw31/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 && sva_checker.rst == 1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3ll1cyyc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 && sva_checker.rst == 1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.arbitration_grant == 1'b1 && sva_checker.rst == 1 |-> $past(sva_checker.request_priority) == sva_checker.highest_priority): PROVED\n"
  },
  {
    "id": "1070",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gro6_87s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.motor_control && $past(sva_checker.feedback_stable) && $past(sva_checker.pid_compute) |-> sva_checker.pwm_output_update): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.motor_control == 1 && $past(sva_checker.feedback_stable) == 1 && $past(sva_checker.pid_compute) == 1 |-> sva_checker.pwm_output_update == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.motor_control && $past(sva_checker.feedback_stable) && $past(sva_checker.pid_compute) |-> sva_checker.pwm_output_update): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lgep3dj4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.motor_control == 1 && $past(sva_checker.feedback_stable) == 1 && $past(sva_checker.pid_compute) == 1 |-> sva_checker.pwm_output_update == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.motor_control && $past(sva_checker.feedback_stable) && $past(sva_checker.pid_compute) |-> sva_checker.pwm_output_update): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.motor_control == 1 && $past(sva_checker.feedback_stable) == 1 && $past(sva_che"
  },
  {
    "id": "1097",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nadhq36f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lidar_point_cloud_gen && $past(sva_checker.laser_pulse_timing) |-> sva_checker.distance_calculation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_mode == 0 && sva_checker.lidar_point_cloud_gen == 1 && $past(sva_checker.laser_pulse_timing) == 1 |-> sva_checker.distance_calculation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lidar_point_cloud_gen && $past(sva_checker.laser_pulse_timing) |-> sva_checker.distance_calculation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2pmdbz_v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_mode == 0 && sva_checker.lidar_point_cloud_gen == 1 && $past(sva_checker.laser_pulse_timing) == 1 |-> sva_checker.distance_calculation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lidar_point_cloud_gen && $past(sva_checker.laser_pulse_timing) |-> sva_checker.distance_calculation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calibration_mode == 0 && sva_checker.lidar_point_cloud_gen == 1 && $past(sva_checker.laser_pulse_timing) == 1 |-> sva_checker.di"
  },
  {
    "id": "1102",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_674n477g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.automotive_ecu_diagnostic && $past(sva_checker.obd_request_received) |-> sva_checker.dtc_code_retrieval): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.automotive_ecu_diagnostic == 1'b1 && $past(sva_checker.obd_request_received) == 1'b1 |-> sva_checker.dtc_code_retrieval == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.automotive_ecu_diagnostic && $past(sva_checker.obd_request_received) |-> sva_checker.dtc_code_retrieval): PROVED\n\n\nBackward: Parsing /tmp/sva_check_l9wjmwj9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.automotive_ecu_diagnostic == 1'b1 && $past(sva_checker.obd_request_received) == 1'b1 |-> sva_checker.dtc_code_retrieval == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.automotive_ecu_diagnostic && $past(sva_checker.obd_request_received) |-> sva_checker.dtc_code_retrieval): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.automotive_ecu_diagnostic == 1'b1 && $past(sva_checker.obd_request_received) == 1'b1 |-> sva"
  },
  {
    "id": "1107",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_e5tsmuc2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.neural_network_backprop && $past(sva_checker.forward_pass_complete) |-> sva_checker.gradient_computation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.neural_network_backprop == 1 && $past(sva_checker.forward_pass_complete) == 1 |-> sva_checker.gradient_computation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.neural_network_backprop && $past(sva_checker.forward_pass_complete) |-> sva_checker.gradient_computation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ctjhv0cy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.neural_network_backprop == 1 && $past(sva_checker.forward_pass_complete) == 1 |-> sva_checker.gradient_computation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.neural_network_backprop && $past(sva_checker.forward_pass_complete) |-> sva_checker.gradient_computation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.neural_network_backprop == 1 && $past(sva_checker.forward_pass_complete) == 1 |-> sva_checker"
  },
  {
    "id": "1108",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ju0cms2u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voice_codec_encode && $past(sva_checker.audio_sample_ready, 4) && $past(sva_checker.bit_rate_config) |-> sva_checker.compression_algorithm_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voice_codec_encode == 1 && $past(sva_checker.audio_sample_ready, 4) == 1 && $past(sva_checker.bit_rate_config, 1) == 1 |-> sva_checker.compression_algorithm_start == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voice_codec_encode && $past(sva_checker.audio_sample_ready, 4) && $past(sva_checker.bit_rate_config) |-> sva_checker.compression_algorithm_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g6y422rn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voice_codec_encode == 1 && $past(sva_checker.audio_sample_ready, 4) == 1 && $past(sva_checker.bit_rate_config, 1) == 1 |-> sva_checker.compression_algorithm_start == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voice_codec_encode && $past(sva_checker.audio_sample_ready, 4) && $past(sva_checker.bit_rate_config) |-> sva_checker.compression_algorithm_start): PROVED up to bound 20\n[sva_checker.cover_antecedent]"
  },
  {
    "id": "1122",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_brsj0dmg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.magnetic_stripe_reader && $past(sva_checker.card_swipe_detect) |-> sva_checker.track_data_extraction): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hw_rst == 1 && sva_checker.magnetic_stripe_reader == 1 && $past(sva_checker.card_swipe_detect) == 1 |-> sva_checker.track_data_extraction == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.magnetic_stripe_reader && $past(sva_checker.card_swipe_detect) |-> sva_checker.track_data_extraction): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oqg1hb6y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hw_rst == 1 && sva_checker.magnetic_stripe_reader == 1 && $past(sva_checker.card_swipe_detect) == 1 |-> sva_checker.track_data_extraction == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.magnetic_stripe_reader && $past(sva_checker.card_swipe_detect) |-> sva_checker.track_data_extraction): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hw_rst == 1 && sva_checker.magnetic_stripe_reader == 1 && $past(sva_checker.card_swipe_detect) == 1 |-> sva_checker.track_data_extraction == 1)"
  },
  {
    "id": "1124",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_mnmvzt0g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_sonar_ping && $past(sva_checker.transducer_calibration) |-> sva_checker.acoustic_beam_formation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.underwater_sonar_ping == 1 && $past(sva_checker.transducer_calibration) == 1 |-> sva_checker.acoustic_beam_formation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.underwater_sonar_ping && $past(sva_checker.transducer_calibration) |-> sva_checker.acoustic_beam_formation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zznf0y2d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.underwater_sonar_ping == 1 && $past(sva_checker.transducer_calibration) == 1 |-> sva_checker.acoustic_beam_formation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_sonar_ping && $past(sva_checker.transducer_calibration) |-> sva_checker.acoustic_beam_formation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst == 0 && sva_checker.underwater_sonar_ping == 1 && $past(sva_checker.transducer_calibration) == 1 |-> sva_checker.ac"
  },
  {
    "id": "1134",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_jdacpei4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_distance_measure && $past(sva_checker.echo_time_capture) |-> sva_checker.range_calculation_complete): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hw_reset == 1 && sva_checker.ultrasonic_distance_measure == 1 && $past(sva_checker.echo_time_capture) == 1 |-> sva_checker.range_calculation_complete == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_distance_measure && $past(sva_checker.echo_time_capture) |-> sva_checker.range_calculation_complete): PROVED\n\n\nBackward: Parsing /tmp/sva_check_37he6_f8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hw_reset == 1 && sva_checker.ultrasonic_distance_measure == 1 && $past(sva_checker.echo_time_capture) == 1 |-> sva_checker.range_calculation_complete == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ultrasonic_distance_measure && $past(sva_checker.echo_time_capture) |-> sva_checker.range_calculation_complete): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hw_reset == 1 && sva_checker.ultrasonic_distance_measure == 1 && $past(sva_checker.echo_t"
  },
  {
    "id": "1149",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_epdbhys3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quantum_error_correction && $past(sva_checker.syndrome_measurement_complete, 8) |-> sva_checker.logical_qubit_recovery): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset_enable == 1 && sva_checker.quantum_error_correction == 1 && $past(sva_checker.syndrome_measurement_complete, 8) == 1 |-> sva_checker.logical_qubit_recovery == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.quantum_error_correction && $past(sva_checker.syndrome_measurement_complete, 8) |-> sva_checker.logical_qubit_recovery): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u7y03rb0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset_enable == 1 && sva_checker.quantum_error_correction == 1 && $past(sva_checker.syndrome_measurement_complete, 8) == 1 |-> sva_checker.logical_qubit_recovery == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quantum_error_correction && $past(sva_checker.syndrome_measurement_complete, 8) |-> sva_checker.logical_qubit_recovery): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset_enable == 1 && sva_checker.quantum_"
  },
  {
    "id": "1173",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_i7dcjp3h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_vector_multiply && $past(sva_checker.weight_buffer_loaded, 6) |-> sva_checker.dot_product_computation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_on_reset == 1 && sva_checker.matrix_vector_multiply == 1 && $past(sva_checker.weight_buffer_loaded, 6) == 1 |-> sva_checker.dot_product_computation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.matrix_vector_multiply && $past(sva_checker.weight_buffer_loaded, 6) |-> sva_checker.dot_product_computation): PROVED\n\n\nBackward: Parsing /tmp/sva_check__mmajn1n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_on_reset == 1 && sva_checker.matrix_vector_multiply == 1 && $past(sva_checker.weight_buffer_loaded, 6) == 1 |-> sva_checker.dot_product_computation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_vector_multiply && $past(sva_checker.weight_buffer_loaded, 6) |-> sva_checker.dot_product_computation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_on_reset == 1 && sva_checker.matrix_vector_multiply == 1 && $past(sva_checker.wei"
  },
  {
    "id": "1178",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0ygolubv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.biosensor_immunoassay && $past(sva_checker.antigen_binding_kinetics, 15) |-> sva_checker.concentration_measurement_output): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_control == 1 && sva_checker.biosensor_immunoassay == 1 && $past(sva_checker.antigen_binding_kinetics, 15) == 1 |-> sva_checker.concentration_measurement_output == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.biosensor_immunoassay && $past(sva_checker.antigen_binding_kinetics, 15) |-> sva_checker.concentration_measurement_output): PROVED\n\n\nBackward: Parsing /tmp/sva_check_djg6heu_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_control == 1 && sva_checker.biosensor_immunoassay == 1 && $past(sva_checker.antigen_binding_kinetics, 15) == 1 |-> sva_checker.concentration_measurement_output == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.biosensor_immunoassay && $past(sva_checker.antigen_binding_kinetics, 15) |-> sva_checker.concentration_measurement_output): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_control == 1 && sva_chec"
  },
  {
    "id": "1187",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nusgrrct/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.digital_signal_processing && $past(sva_checker.sample_rate_conversion, 8) |-> sva_checker.filter_bank_computation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_audio == 0 && sva_checker.digital_signal_processing == 1 && $past(sva_checker.sample_rate_conversion, 8) == 1 |-> sva_checker.filter_bank_computation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.digital_signal_processing && $past(sva_checker.sample_rate_conversion, 8) |-> sva_checker.filter_bank_computation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mi9ltcwk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_audio == 0 && sva_checker.digital_signal_processing == 1 && $past(sva_checker.sample_rate_conversion, 8) == 1 |-> sva_checker.filter_bank_computation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.digital_signal_processing && $past(sva_checker.sample_rate_conversion, 8) |-> sva_checker.filter_bank_computation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_audio == 0 && sva_checker.digital_signal_processing == 1 && $past(sv"
  },
  {
    "id": "1202",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ub2nuys8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_checker.power_state_transition): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_checker.power_state_transition): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_checker.power_state_transition): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n0d1l87i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_checker.power_state_transition): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_checker.power_state_transition): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dynamic_voltage_frequency_scaling |-> $past(sva_checker.workload_prediction_model, 9) && sva_check"
  },
  {
    "id": "1201",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bixu7los/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fir_filter_coefficient_update && $past(sva_checker.tap_weight_calculation, 7) |-> sva_checker.filter_response_reconfigure): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_domain == 0 && sva_checker.fir_filter_coefficient_update == 1 && $past(sva_checker.tap_weight_calculation, 7) == 1 |-> sva_checker.filter_response_reconfigure == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fir_filter_coefficient_update && $past(sva_checker.tap_weight_calculation, 7) |-> sva_checker.filter_response_reconfigure): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zbat6nzs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_domain == 0 && sva_checker.fir_filter_coefficient_update == 1 && $past(sva_checker.tap_weight_calculation, 7) == 1 |-> sva_checker.filter_response_reconfigure == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fir_filter_coefficient_update && $past(sva_checker.tap_weight_calculation, 7) |-> sva_checker.filter_response_reconfigure): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_domain == 0 && sva_checker"
  },
  {
    "id": "1203",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_rtx6tjdu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.telemetry_data_compression && $past(sva_checker.error_resilient_encoding, 18) |-> sva_checker.downlink_transmission_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ground_station_lock == 1 && sva_checker.telemetry_data_compression == 1 && $past(sva_checker.error_resilient_encoding, 18) == 1 |-> sva_checker.downlink_transmission_start == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.telemetry_data_compression && $past(sva_checker.error_resilient_encoding, 18) |-> sva_checker.downlink_transmission_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1elgigpn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ground_station_lock == 1 && sva_checker.telemetry_data_compression == 1 && $past(sva_checker.error_resilient_encoding, 18) == 1 |-> sva_checker.downlink_transmission_start == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.telemetry_data_compression && $past(sva_checker.error_resilient_encoding, 18) |-> sva_checker.downlink_transmission_start): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ground_stati"
  },
  {
    "id": "1226",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_6s15_bls/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.predictive_maintenance_analysis && $past(sva_checker.vibration_signature_learning, 14) |-> sva_checker.fault_prediction_output): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_emergency == 0 && sva_checker.predictive_maintenance_analysis == 1 && $past(sva_checker.vibration_signature_learning, 14) == 1 |-> sva_checker.fault_prediction_output == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.predictive_maintenance_analysis && $past(sva_checker.vibration_signature_learning, 14) |-> sva_checker.fault_prediction_output): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ajgjp1q8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_emergency == 0 && sva_checker.predictive_maintenance_analysis == 1 && $past(sva_checker.vibration_signature_learning, 14) == 1 |-> sva_checker.fault_prediction_output == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.predictive_maintenance_analysis && $past(sva_checker.vibration_signature_learning, 14) |-> sva_checker.fault_prediction_output): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker"
  },
  {
    "id": "1217",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_v0badfg9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wavelength_division_multiplexing == 1'b1 |-> $past(sva_checker.channel_spacing_optimization, 12) && sva_checker.optical_switch_control): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_photonic == 0 && sva_checker.wavelength_division_multiplexing == 1'b1 |-> $past(sva_checker.channel_spacing_optimization, 12) == 1'b1 && sva_checker.optical_switch_control == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wavelength_division_multiplexing == 1'b1 |-> $past(sva_checker.channel_spacing_optimization, 12) && sva_checker.optical_switch_control): PROVED\n\n\nBackward: Parsing /tmp/sva_check_plg5gf4a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_photonic == 0 && sva_checker.wavelength_division_multiplexing == 1'b1 |-> $past(sva_checker.channel_spacing_optimization, 12) == 1'b1 && sva_checker.optical_switch_control == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wavelength_division_multiplexing == 1'b1 |-> $past(sva_checker.channel_spacing_optimization, 12) && sva_checker.optical_switch_control): REFUTED\n[sva_checker.cover_antecedent] cover (disa"
  },
  {
    "id": "1244",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_qgiohrv1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.motion_compensation_unit && $past(sva_checker.reference_frame_available, 4) |-> sva_checker.interpolation_filter_apply): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_codec == 0 && sva_checker.motion_compensation_unit == 1 && $past(sva_checker.reference_frame_available, 4) == 1 |-> sva_checker.interpolation_filter_apply == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.motion_compensation_unit && $past(sva_checker.reference_frame_available, 4) |-> sva_checker.interpolation_filter_apply): PROVED\n\n\nBackward: Parsing /tmp/sva_check_v2ng008i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_codec == 0 && sva_checker.motion_compensation_unit == 1 && $past(sva_checker.reference_frame_available, 4) == 1 |-> sva_checker.interpolation_filter_apply == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.motion_compensation_unit && $past(sva_checker.reference_frame_available, 4) |-> sva_checker.interpolation_filter_apply): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_codec == 0 && sva_checker.motion_compensati"
  },
  {
    "id": "1247",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_jzjpttua/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.noise_reduction_adaptive && $past(sva_checker.spectral_subtraction_coefficients, 6) |-> sva_checker.enhanced_signal_reconstruction): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.codec_reset == 1 && sva_checker.noise_reduction_adaptive == 1 && $past(sva_checker.spectral_subtraction_coefficients, 6) == 1 |-> sva_checker.enhanced_signal_reconstruction == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.noise_reduction_adaptive && $past(sva_checker.spectral_subtraction_coefficients, 6) |-> sva_checker.enhanced_signal_reconstruction): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wzm06zf9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.codec_reset == 1 && sva_checker.noise_reduction_adaptive == 1 && $past(sva_checker.spectral_subtraction_coefficients, 6) == 1 |-> sva_checker.enhanced_signal_reconstruction == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.noise_reduction_adaptive && $past(sva_checker.spectral_subtraction_coefficients, 6) |-> sva_checker.enhanced_signal_reconstruction): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rs"
  },
  {
    "id": "1253",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wk6jtkzx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.josephson_junction_control && $past(sva_checker.microwave_pulse_calibration, 6) |-> sva_checker.quantum_gate_fidelity_measurement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_cryogenic == 0 && sva_checker.josephson_junction_control == 1 && $past(sva_checker.microwave_pulse_calibration, 6) == 1 |-> sva_checker.quantum_gate_fidelity_measurement == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.josephson_junction_control && $past(sva_checker.microwave_pulse_calibration, 6) |-> sva_checker.quantum_gate_fidelity_measurement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y9kxsjgp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_cryogenic == 0 && sva_checker.josephson_junction_control == 1 && $past(sva_checker.microwave_pulse_calibration, 6) == 1 |-> sva_checker.quantum_gate_fidelity_measurement == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.josephson_junction_control && $past(sva_checker.microwave_pulse_calibration, 6) |-> sva_checker.quantum_gate_fidelity_measurement): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst"
  },
  {
    "id": "1318",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_yzcw2npv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.port_conflict_arbitration |-> $past(sva_checker.read_write_port_scheduling, 8) && sva_checker.register_file_bandwidth_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_multi_port_register == 0 && sva_checker.port_conflict_arbitration == 1 |-> $past(sva_checker.read_write_port_scheduling, 8) == 1 && sva_checker.register_file_bandwidth_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.port_conflict_arbitration |-> $past(sva_checker.read_write_port_scheduling, 8) && sva_checker.register_file_bandwidth_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cgn4ddhf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_multi_port_register == 0 && sva_checker.port_conflict_arbitration == 1 |-> $past(sva_checker.read_write_port_scheduling, 8) == 1 && sva_checker.register_file_bandwidth_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.port_conflict_arbitration |-> $past(sva_checker.read_write_port_scheduling, 8) && sva_checker.register_file_bandwidth_optimization): REFUTED\n[sva_checker.cover_antecedent] cover (disa"
  },
  {
    "id": "1336",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_531psc5z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spatial_multiplexing_detection && $past(sva_checker.channel_matrix_decomposition, 6) |-> sva_checker.interference_cancellation_algorithm): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.multiple_antenna_reset == 1 && sva_checker.spatial_multiplexing_detection == 1 && $past(sva_checker.channel_matrix_decomposition, 6) == 1 |-> sva_checker.interference_cancellation_algorithm == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spatial_multiplexing_detection && $past(sva_checker.channel_matrix_decomposition, 6) |-> sva_checker.interference_cancellation_algorithm): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r5qlu_1t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.multiple_antenna_reset == 1 && sva_checker.spatial_multiplexing_detection == 1 && $past(sva_checker.channel_matrix_decomposition, 6) == 1 |-> sva_checker.interference_cancellation_algorithm == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spatial_multiplexing_detection && $past(sva_checker.channel_matrix_decomposition, 6) |-> sva_checker.interference_cancellation_algorithm): REFUTED\n[sva_checker.c"
  },
  {
    "id": "1344",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5mq3bcfh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.low_density_parity_check_decoder && $past(sva_checker.belief_propagation_iteration, 6) |-> sva_checker.bit_error_rate_improvement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.forward_error_correction_reset == 1 && sva_checker.low_density_parity_check_decoder == 1 && $past(sva_checker.belief_propagation_iteration, 6) == 1 |-> sva_checker.bit_error_rate_improvement == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.low_density_parity_check_decoder && $past(sva_checker.belief_propagation_iteration, 6) |-> sva_checker.bit_error_rate_improvement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xsrl07w0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.forward_error_correction_reset == 1 && sva_checker.low_density_parity_check_decoder == 1 && $past(sva_checker.belief_propagation_iteration, 6) == 1 |-> sva_checker.bit_error_rate_improvement == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.low_density_parity_check_decoder && $past(sva_checker.belief_propagation_iteration, 6) |-> sva_checker.bit_error_rate_improvement): REFUTED\n[sva_checker.cover_antecedent] co"
  },
  {
    "id": "1348",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_jv7ah7v8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.least_squares_channel_estimation && $past(sva_checker.pilot_symbol_interpolation, 6) |-> sva_checker.frequency_domain_equalization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_pilot_extraction == 0 && sva_checker.least_squares_channel_estimation == 1 && $past(sva_checker.pilot_symbol_interpolation, 6) == 1 |-> sva_checker.frequency_domain_equalization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.least_squares_channel_estimation && $past(sva_checker.pilot_symbol_interpolation, 6) |-> sva_checker.frequency_domain_equalization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wku5ogu8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_pilot_extraction == 0 && sva_checker.least_squares_channel_estimation == 1 && $past(sva_checker.pilot_symbol_interpolation, 6) == 1 |-> sva_checker.frequency_domain_equalization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.least_squares_channel_estimation && $past(sva_checker.pilot_symbol_interpolation, 6) |-> sva_checker.frequency_domain_equalization): REFUTED\n[sva_checker.cover_antecedent] cover (disable if"
  },
  {
    "id": "1357",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xrgyb_b0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.doppler_shift_compensation && $past(sva_checker.multipath_propagation_modeling, 11) |-> sva_checker.underwater_network_connectivity): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.marine_communication_reset == 1 && sva_checker.doppler_shift_compensation == 1 && $past(sva_checker.multipath_propagation_modeling, 11) == 1 |-> sva_checker.underwater_network_connectivity == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.doppler_shift_compensation && $past(sva_checker.multipath_propagation_modeling, 11) |-> sva_checker.underwater_network_connectivity): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b28vx81m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.marine_communication_reset == 1 && sva_checker.doppler_shift_compensation == 1 && $past(sva_checker.multipath_propagation_modeling, 11) == 1 |-> sva_checker.underwater_network_connectivity == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.doppler_shift_compensation && $past(sva_checker.multipath_propagation_modeling, 11) |-> sva_checker.underwater_network_connectivity): REFUTED\n[sva_checker.cover_antecedent] "
  },
  {
    "id": "1359",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_porh558i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ultra_low_latency_feedback && $past(sva_checker.force_feedback_encoding, 3) |-> sva_checker.immersive_remote_interaction): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_haptic_communication == 0 && sva_checker.ultra_low_latency_feedback == 1 && $past(sva_checker.force_feedback_encoding, 3) == 1 |-> sva_checker.immersive_remote_interaction == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ultra_low_latency_feedback && $past(sva_checker.force_feedback_encoding, 3) |-> sva_checker.immersive_remote_interaction): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eaao_1c6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_haptic_communication == 0 && sva_checker.ultra_low_latency_feedback == 1 && $past(sva_checker.force_feedback_encoding, 3) == 1 |-> sva_checker.immersive_remote_interaction == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ultra_low_latency_feedback && $past(sva_checker.force_feedback_encoding, 3) |-> sva_checker.immersive_remote_interaction): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_hap"
  },
  {
    "id": "1378",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8s_2p4_v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.intelligent_resource_management |-> $past(sva_checker.neural_network_inference_complete, 7) && sva_checker.autonomous_network_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_machine_learning == 0 && sva_checker.intelligent_resource_management == 1 |-> $past(sva_checker.neural_network_inference_complete, 7) == 1 && sva_checker.autonomous_network_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.intelligent_resource_management |-> $past(sva_checker.neural_network_inference_complete, 7) && sva_checker.autonomous_network_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d_4srgz3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_machine_learning == 0 && sva_checker.intelligent_resource_management == 1 |-> $past(sva_checker.neural_network_inference_complete, 7) == 1 && sva_checker.autonomous_network_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.intelligent_resource_management |-> $past(sva_checker.neural_network_inference_complete, 7) && sva_checker.autonomous_network_optimization): REFUTED\n[sva_che"
  },
  {
    "id": "1394",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_cdg7bbik/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.glucose_concentration_detection == 1'b1 |-> $past(sva_checker.enzyme_reaction_kinetics, 9) && sva_checker.current_signal_amplification): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_biosensor == 0 && sva_checker.glucose_concentration_detection == 1'b1 |-> sva_checker.current_signal_amplification == 1'b1 && $past(sva_checker.enzyme_reaction_kinetics, 9) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.glucose_concentration_detection == 1'b1 |-> $past(sva_checker.enzyme_reaction_kinetics, 9) && sva_checker.current_signal_amplification): PROVED\n\n\nBackward: Parsing /tmp/sva_check_77fq4li1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_biosensor == 0 && sva_checker.glucose_concentration_detection == 1'b1 |-> sva_checker.current_signal_amplification == 1'b1 && $past(sva_checker.enzyme_reaction_kinetics, 9) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.glucose_concentration_detection == 1'b1 |-> $past(sva_checker.enzyme_reaction_kinetics, 9) && sva_checker.current_signal_amplification): REFUTED\n[sva_checker.cover_antecedent] cover (di"
  },
  {
    "id": "1398",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_tswvy9g6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wheatstone_bridge_measurement && $past(sva_checker.temperature_compensation_applied, 7) |-> sva_checker.mechanical_stress_quantification): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.load_cell_reset == 1 && sva_checker.wheatstone_bridge_measurement == 1 && $past(sva_checker.temperature_compensation_applied, 7) == 1 |-> sva_checker.mechanical_stress_quantification == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wheatstone_bridge_measurement && $past(sva_checker.temperature_compensation_applied, 7) |-> sva_checker.mechanical_stress_quantification): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jqvsd6ep/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.load_cell_reset == 1 && sva_checker.wheatstone_bridge_measurement == 1 && $past(sva_checker.temperature_compensation_applied, 7) == 1 |-> sva_checker.mechanical_stress_quantification == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wheatstone_bridge_measurement && $past(sva_checker.temperature_compensation_applied, 7) |-> sva_checker.mechanical_stress_quantification): REFUTED\n[sva_checker.cover_anteceden"
  },
  {
    "id": "1426",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_a81_a_pz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.photoreceptor_response_measurement |-> $past(sva_checker.light_stimulus_standardization, 10) && sva_checker.visual_pathway_assessment): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_retinal_function == 0 && sva_checker.photoreceptor_response_measurement == 1 |-> sva_checker.visual_pathway_assessment == 1 && $past(sva_checker.light_stimulus_standardization, 10) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.photoreceptor_response_measurement |-> $past(sva_checker.light_stimulus_standardization, 10) && sva_checker.visual_pathway_assessment): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8c9s6bhs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_retinal_function == 0 && sva_checker.photoreceptor_response_measurement == 1 |-> sva_checker.visual_pathway_assessment == 1 && $past(sva_checker.light_stimulus_standardization, 10) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.photoreceptor_response_measurement |-> $past(sva_checker.light_stimulus_standardization, 10) && sva_checker.visual_pathway_assessment): REFUTED\n[sva_checker.cover_antecedent] co"
  },
  {
    "id": "1403",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_erlg5wgc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.alamouti_space_time_block_code && $past(sva_checker.orthogonal_design_matrix, 8) |-> sva_checker.transmit_diversity_gain_achievement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.diversity_coding_reset == 1 && sva_checker.alamouti_space_time_block_code == 1 && $past(sva_checker.orthogonal_design_matrix, 8) == 1 |-> sva_checker.transmit_diversity_gain_achievement == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.alamouti_space_time_block_code && $past(sva_checker.orthogonal_design_matrix, 8) |-> sva_checker.transmit_diversity_gain_achievement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7hm776tz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.diversity_coding_reset == 1 && sva_checker.alamouti_space_time_block_code == 1 && $past(sva_checker.orthogonal_design_matrix, 8) == 1 |-> sva_checker.transmit_diversity_gain_achievement == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.alamouti_space_time_block_code && $past(sva_checker.orthogonal_design_matrix, 8) |-> sva_checker.transmit_diversity_gain_achievement): REFUTED\n[sva_checker.cover_antecedent] cov"
  },
  {
    "id": "1490",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_vjo9p4cc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_relief_valve_testing && $past(sva_checker.overpressure_scenario_simulation, 10) |-> sva_checker.process_hazard_mitigation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.process_safety_reset == 1 && sva_checker.pressure_relief_valve_testing == 1 && $past(sva_checker.overpressure_scenario_simulation, 10) == 1 |-> sva_checker.process_hazard_mitigation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pressure_relief_valve_testing && $past(sva_checker.overpressure_scenario_simulation, 10) |-> sva_checker.process_hazard_mitigation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yl6a_702/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.process_safety_reset == 1 && sva_checker.pressure_relief_valve_testing == 1 && $past(sva_checker.overpressure_scenario_simulation, 10) == 1 |-> sva_checker.process_hazard_mitigation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_relief_valve_testing && $past(sva_checker.overpressure_scenario_simulation, 10) |-> sva_checker.process_hazard_mitigation): REFUTED\n[sva_checker.cover_antecedent] cover (disable if"
  },
  {
    "id": "1494",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_c5hwnxvk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reaction_temperature_control && $past(sva_checker.catalyst_activity_degradation, 9) |-> sva_checker.process_optimization_adjustment): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_process_control == 0 && sva_checker.reaction_temperature_control == 1 && $past(sva_checker.catalyst_activity_degradation, 9) == 1 |-> sva_checker.process_optimization_adjustment == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reaction_temperature_control && $past(sva_checker.catalyst_activity_degradation, 9) |-> sva_checker.process_optimization_adjustment): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fzch8vfe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_process_control == 0 && sva_checker.reaction_temperature_control == 1 && $past(sva_checker.catalyst_activity_degradation, 9) == 1 |-> sva_checker.process_optimization_adjustment == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reaction_temperature_control && $past(sva_checker.catalyst_activity_degradation, 9) |-> sva_checker.process_optimization_adjustment): REFUTED\n[sva_checker.cover_antecedent] cover (disable"
  },
  {
    "id": "1507",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nu6nicww/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.biometric_health_monitoring && $past(sva_checker.feed_conversion_efficiency, 3) |-> sva_checker.precision_livestock_farming): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_animal_welfare == 0 && sva_checker.biometric_health_monitoring == 1 && $past(sva_checker.feed_conversion_efficiency, 3) == 1 |-> sva_checker.precision_livestock_farming == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.biometric_health_monitoring && $past(sva_checker.feed_conversion_efficiency, 3) |-> sva_checker.precision_livestock_farming): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xun929_0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_animal_welfare == 0 && sva_checker.biometric_health_monitoring == 1 && $past(sva_checker.feed_conversion_efficiency, 3) == 1 |-> sva_checker.precision_livestock_farming == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.biometric_health_monitoring && $past(sva_checker.feed_conversion_efficiency, 3) |-> sva_checker.precision_livestock_farming): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_"
  },
  {
    "id": "1517",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bd6y7d9h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.concrete_deformation_measurement && $past(sva_checker.seepage_flow_monitoring, 5) |-> sva_checker.structural_stability_assessment): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_hydroelectric_structure == 0 && sva_checker.concrete_deformation_measurement == 1 && $past(sva_checker.seepage_flow_monitoring, 5) == 1 |-> sva_checker.structural_stability_assessment == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.concrete_deformation_measurement && $past(sva_checker.seepage_flow_monitoring, 5) |-> sva_checker.structural_stability_assessment): PROVED\n\n\nBackward: Parsing /tmp/sva_check_aqs7mv3z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_hydroelectric_structure == 0 && sva_checker.concrete_deformation_measurement == 1 && $past(sva_checker.seepage_flow_monitoring, 5) == 1 |-> sva_checker.structural_stability_assessment == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.concrete_deformation_measurement && $past(sva_checker.seepage_flow_monitoring, 5) |-> sva_checker.structural_stability_assessment): REFUTED\n[sva_checker.cover_antecedent] cover (d"
  },
  {
    "id": "1520",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_v8mhbc96/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.coral_reef_health_assessment && $past(sva_checker.water_chemistry_analysis, 7) |-> sva_checker.ecosystem_restoration_strategy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_ocean_monitoring == 0 && sva_checker.coral_reef_health_assessment == 1 && $past(sva_checker.water_chemistry_analysis, 7) == 1 |-> sva_checker.ecosystem_restoration_strategy == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.coral_reef_health_assessment && $past(sva_checker.water_chemistry_analysis, 7) |-> sva_checker.ecosystem_restoration_strategy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n4adqfbt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_ocean_monitoring == 0 && sva_checker.coral_reef_health_assessment == 1 && $past(sva_checker.water_chemistry_analysis, 7) == 1 |-> sva_checker.ecosystem_restoration_strategy == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.coral_reef_health_assessment && $past(sva_checker.water_chemistry_analysis, 7) |-> sva_checker.ecosystem_restoration_strategy): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sv"
  },
  {
    "id": "1536",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bhxd9o0r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.emotional_state_recognition && $past(sva_checker.facial_expression_analysis, 12) |-> sva_checker.empathetic_response_generation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.social_interaction_reset == 1 && sva_checker.emotional_state_recognition == 1 && $past(sva_checker.facial_expression_analysis, 12) == 1 |-> sva_checker.empathetic_response_generation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.emotional_state_recognition && $past(sva_checker.facial_expression_analysis, 12) |-> sva_checker.empathetic_response_generation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mxp0fdhj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.social_interaction_reset == 1 && sva_checker.emotional_state_recognition == 1 && $past(sva_checker.facial_expression_analysis, 12) == 1 |-> sva_checker.empathetic_response_generation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.emotional_state_recognition && $past(sva_checker.facial_expression_analysis, 12) |-> sva_checker.empathetic_response_generation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva"
  },
  {
    "id": "1546",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_v3kko692/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.undulatory_motion_control && $past(sva_checker.body_wave_propagation, 5) |-> sva_checker.confined_space_navigation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_serpentine_locomotion == 0 && sva_checker.undulatory_motion_control == 1 && $past(sva_checker.body_wave_propagation, 5) == 1 |-> sva_checker.confined_space_navigation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.undulatory_motion_control && $past(sva_checker.body_wave_propagation, 5) |-> sva_checker.confined_space_navigation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7aeumel1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_serpentine_locomotion == 0 && sva_checker.undulatory_motion_control == 1 && $past(sva_checker.body_wave_propagation, 5) == 1 |-> sva_checker.confined_space_navigation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.undulatory_motion_control && $past(sva_checker.body_wave_propagation, 5) |-> sva_checker.confined_space_navigation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_serpentine_locomotion == 0 && s"
  },
  {
    "id": "1548",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_gn9nlt1r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.selective_harvesting_algorithm && $past(sva_checker.fruit_ripeness_detection, 6) |-> sva_checker.yield_optimization_strategy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crop_harvesting_reset == 1 && sva_checker.selective_harvesting_algorithm == 1 && $past(sva_checker.fruit_ripeness_detection, 6) == 1 |-> sva_checker.yield_optimization_strategy == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.selective_harvesting_algorithm && $past(sva_checker.fruit_ripeness_detection, 6) |-> sva_checker.yield_optimization_strategy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zlm8h2de/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crop_harvesting_reset == 1 && sva_checker.selective_harvesting_algorithm == 1 && $past(sva_checker.fruit_ripeness_detection, 6) == 1 |-> sva_checker.yield_optimization_strategy == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.selective_harvesting_algorithm && $past(sva_checker.fruit_ripeness_detection, 6) |-> sva_checker.yield_optimization_strategy): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_c"
  },
  {
    "id": "1553",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_94nnunpy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adhesion_mechanism_control && $past(sva_checker.surface_texture_adaptation, 3) |-> sva_checker.vertical_mobility_capability): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wall_crawling_reset == 1 && sva_checker.adhesion_mechanism_control == 1 && $past(sva_checker.surface_texture_adaptation, 3) == 1 |-> sva_checker.vertical_mobility_capability == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adhesion_mechanism_control && $past(sva_checker.surface_texture_adaptation, 3) |-> sva_checker.vertical_mobility_capability): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g3zomzzj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wall_crawling_reset == 1 && sva_checker.adhesion_mechanism_control == 1 && $past(sva_checker.surface_texture_adaptation, 3) == 1 |-> sva_checker.vertical_mobility_capability == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adhesion_mechanism_control && $past(sva_checker.surface_texture_adaptation, 3) |-> sva_checker.vertical_mobility_capability): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wa"
  },
  {
    "id": "1567",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_1ak_9w7f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spray_pattern_optimization && $past(sva_checker.paint_viscosity_compensation, 7) |-> sva_checker.uniform_coating_application): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_surface_coating == 0 && sva_checker.spray_pattern_optimization == 1 && $past(sva_checker.paint_viscosity_compensation, 7) == 1 |-> sva_checker.uniform_coating_application == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spray_pattern_optimization && $past(sva_checker.paint_viscosity_compensation, 7) |-> sva_checker.uniform_coating_application): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y4cnz9sr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_surface_coating == 0 && sva_checker.spray_pattern_optimization == 1 && $past(sva_checker.paint_viscosity_compensation, 7) == 1 |-> sva_checker.uniform_coating_application == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spray_pattern_optimization && $past(sva_checker.paint_viscosity_compensation, 7) |-> sva_checker.uniform_coating_application): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_check"
  },
  {
    "id": "1579",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_lh9zwq2n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.structural_reconfiguration_sequence && $past(sva_checker.mechanical_constraint_verification, 9) |-> sva_checker.multi_modal_functionality): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_morphological_change == 0 && sva_checker.structural_reconfiguration_sequence == 1 && $past(sva_checker.mechanical_constraint_verification, 9) == 1 |-> sva_checker.multi_modal_functionality == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.structural_reconfiguration_sequence && $past(sva_checker.mechanical_constraint_verification, 9) |-> sva_checker.multi_modal_functionality): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nq7ydv2e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_morphological_change == 0 && sva_checker.structural_reconfiguration_sequence == 1 && $past(sva_checker.mechanical_constraint_verification, 9) == 1 |-> sva_checker.multi_modal_functionality == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.structural_reconfiguration_sequence && $past(sva_checker.mechanical_constraint_verification, 9) |-> sva_checker.multi_modal_functionality): REFUTED\n[sva_"
  },
  {
    "id": "1586",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nrdczyn_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.seam_tracking_algorithm |-> $past(sva_checker.weld_pool_monitoring, 5) && sva_checker.joint_quality_assurance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_arc_welding_control == 0 && sva_checker.seam_tracking_algorithm == 1 |-> sva_checker.joint_quality_assurance == 1 && $past(sva_checker.weld_pool_monitoring, 5) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.seam_tracking_algorithm |-> $past(sva_checker.weld_pool_monitoring, 5) && sva_checker.joint_quality_assurance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1g2xle97/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_arc_welding_control == 0 && sva_checker.seam_tracking_algorithm == 1 |-> sva_checker.joint_quality_assurance == 1 && $past(sva_checker.weld_pool_monitoring, 5) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.seam_tracking_algorithm |-> $past(sva_checker.weld_pool_monitoring, 5) && sva_checker.joint_quality_assurance): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_arc_welding_control == 0 && sva_checker.seam_tracking_algori"
  },
  {
    "id": "1593",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5m96_23e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.performance_power_area_analysis && $past(sva_checker.architectural_template_evaluation, 8) |-> sva_checker.design_methodology_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_system_architecture == 0 && sva_checker.performance_power_area_analysis == 1 && $past(sva_checker.architectural_template_evaluation, 8) == 1 |-> sva_checker.design_methodology_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.performance_power_area_analysis && $past(sva_checker.architectural_template_evaluation, 8) |-> sva_checker.design_methodology_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tvqxnhqv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_system_architecture == 0 && sva_checker.performance_power_area_analysis == 1 && $past(sva_checker.architectural_template_evaluation, 8) == 1 |-> sva_checker.design_methodology_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.performance_power_area_analysis && $past(sva_checker.architectural_template_evaluation, 8) |-> sva_checker.design_methodology_optimization): REFUTED\n[s"
  },
  {
    "id": "1633",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fz8jd_9w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.operational_amplifier_sizing |-> $past(sva_checker.performance_specification_mapping, 9) && sva_checker.analog_circuit_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_analog_automation == 0 && sva_checker.operational_amplifier_sizing == 1 |-> $past(sva_checker.performance_specification_mapping, 9) == 1 && sva_checker.analog_circuit_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operational_amplifier_sizing |-> $past(sva_checker.performance_specification_mapping, 9) && sva_checker.analog_circuit_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mdxf4t5h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_analog_automation == 0 && sva_checker.operational_amplifier_sizing == 1 |-> $past(sva_checker.performance_specification_mapping, 9) == 1 && sva_checker.analog_circuit_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.operational_amplifier_sizing |-> $past(sva_checker.performance_specification_mapping, 9) && sva_checker.analog_circuit_optimization): REFUTED\n[sva_checker.cover_antecedent] cover (dis"
  },
  {
    "id": "1638",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bcs8wllx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carbon_dioxide_scrubbing && $past(sva_checker.atmospheric_composition_monitoring, 3) |-> sva_checker.crew_safety_assurance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_environmental_control == 0 && sva_checker.carbon_dioxide_scrubbing == 1 && $past(sva_checker.atmospheric_composition_monitoring, 3) == 1 |-> sva_checker.crew_safety_assurance == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.carbon_dioxide_scrubbing && $past(sva_checker.atmospheric_composition_monitoring, 3) |-> sva_checker.crew_safety_assurance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lp0ec29i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_environmental_control == 0 && sva_checker.carbon_dioxide_scrubbing == 1 && $past(sva_checker.atmospheric_composition_monitoring, 3) == 1 |-> sva_checker.crew_safety_assurance == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carbon_dioxide_scrubbing && $past(sva_checker.atmospheric_composition_monitoring, 3) |-> sva_checker.crew_safety_assurance): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_che"
  },
  {
    "id": "1649",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_x_iz1wx7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reaction_wheel_momentum && $past(sva_checker.gyroscope_drift_compensation, 6) |-> sva_checker.three_axis_stabilization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.attitude_control_rst_n == 1 && sva_checker.reaction_wheel_momentum == 1 && $past(sva_checker.gyroscope_drift_compensation, 6) == 1 |-> sva_checker.three_axis_stabilization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reaction_wheel_momentum && $past(sva_checker.gyroscope_drift_compensation, 6) |-> sva_checker.three_axis_stabilization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p_6ymy6g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.attitude_control_rst_n == 1 && sva_checker.reaction_wheel_momentum == 1 && $past(sva_checker.gyroscope_drift_compensation, 6) == 1 |-> sva_checker.three_axis_stabilization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reaction_wheel_momentum && $past(sva_checker.gyroscope_drift_compensation, 6) |-> sva_checker.three_axis_stabilization): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.attitude_control_rst_"
  },
  {
    "id": "1652",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_105ycztu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cesium_hyperfine_transition && $past(sva_checker.magnetic_field_shielding_effectiveness, 3) |-> sva_checker.precision_timekeeping_reference): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frequency_standard_reset == 1 && sva_checker.cesium_hyperfine_transition == 1 && $past(sva_checker.magnetic_field_shielding_effectiveness, 3) == 1 |-> sva_checker.precision_timekeeping_reference == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cesium_hyperfine_transition && $past(sva_checker.magnetic_field_shielding_effectiveness, 3) |-> sva_checker.precision_timekeeping_reference): PROVED\n\n\nBackward: Parsing /tmp/sva_check_26lzc1nf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frequency_standard_reset == 1 && sva_checker.cesium_hyperfine_transition == 1 && $past(sva_checker.magnetic_field_shielding_effectiveness, 3) == 1 |-> sva_checker.precision_timekeeping_reference == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cesium_hyperfine_transition && $past(sva_checker.magnetic_field_shielding_effectiveness, 3) |-> sva_checker.precision_timekeeping_reference): REF"
  },
  {
    "id": "1728",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_rka9gkq_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.electronic_stability_program == 1'b1 |-> $past(sva_checker.yaw_rate_sensor_validation, 3) && sva_checker.traction_control_intervention): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_stability_control == 0 && sva_checker.electronic_stability_program == 1 |-> $past(sva_checker.yaw_rate_sensor_validation, 3) == 1 && sva_checker.traction_control_intervention == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.electronic_stability_program == 1'b1 |-> $past(sva_checker.yaw_rate_sensor_validation, 3) && sva_checker.traction_control_intervention): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ha_0ocuf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_stability_control == 0 && sva_checker.electronic_stability_program == 1 |-> $past(sva_checker.yaw_rate_sensor_validation, 3) == 1 && sva_checker.traction_control_intervention == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.electronic_stability_program == 1'b1 |-> $past(sva_checker.yaw_rate_sensor_validation, 3) && sva_checker.traction_control_intervention): REFUTED\n[sva_checker.cover_antecedent] cover (disa"
  },
  {
    "id": "1730",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_9hde0rme/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fuel_injection_timing && $past(sva_checker.knock_sensor_threshold_adaptation, 7) |-> sva_checker.combustion_efficiency_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_engine_management == 0 && sva_checker.fuel_injection_timing == 1 && $past(sva_checker.knock_sensor_threshold_adaptation, 7) == 1 |-> sva_checker.combustion_efficiency_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fuel_injection_timing && $past(sva_checker.knock_sensor_threshold_adaptation, 7) |-> sva_checker.combustion_efficiency_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cnon3amf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_engine_management == 0 && sva_checker.fuel_injection_timing == 1 && $past(sva_checker.knock_sensor_threshold_adaptation, 7) == 1 |-> sva_checker.combustion_efficiency_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fuel_injection_timing && $past(sva_checker.knock_sensor_threshold_adaptation, 7) |-> sva_checker.combustion_efficiency_optimization): REFUTED\n[sva_checker.cover_antecedent] cover (dis"
  },
  {
    "id": "1740",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nfh3d4b9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.discounted_cash_flow_model && $past(sva_checker.earnings_forecast_revision, 7) |-> sva_checker.fair_value_estimation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_fundamental_analysis == 0 && sva_checker.discounted_cash_flow_model == 1 && $past(sva_checker.earnings_forecast_revision, 7) == 1 |-> sva_checker.fair_value_estimation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.discounted_cash_flow_model && $past(sva_checker.earnings_forecast_revision, 7) |-> sva_checker.fair_value_estimation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z0lealjk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_fundamental_analysis == 0 && sva_checker.discounted_cash_flow_model == 1 && $past(sva_checker.earnings_forecast_revision, 7) == 1 |-> sva_checker.fair_value_estimation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.discounted_cash_flow_model && $past(sva_checker.earnings_forecast_revision, 7) |-> sva_checker.fair_value_estimation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_fundamental_analysis =="
  },
  {
    "id": "1780",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_a7vztyax/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.airbag_deployment_timing && $past(sva_checker.crash_severity_assessment, 12) |-> sva_checker.occupant_protection_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_pre_crash_system == 0 && sva_checker.airbag_deployment_timing == 1 && $past(sva_checker.crash_severity_assessment, 12) == 1 |-> sva_checker.occupant_protection_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.airbag_deployment_timing && $past(sva_checker.crash_severity_assessment, 12) |-> sva_checker.occupant_protection_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0shykco8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_pre_crash_system == 0 && sva_checker.airbag_deployment_timing == 1 && $past(sva_checker.crash_severity_assessment, 12) == 1 |-> sva_checker.occupant_protection_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.airbag_deployment_timing && $past(sva_checker.crash_severity_assessment, 12) |-> sva_checker.occupant_protection_optimization): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sv"
  },
  {
    "id": "1810",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_lqdp6pou/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_split_device_control == 1'b1 |-> $past(sva_checker.battery_state_of_charge_prediction, 6) && sva_checker.fuel_economy_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_energy_management == 0 && sva_checker.power_split_device_control == 1 |-> $past(sva_checker.battery_state_of_charge_prediction, 6) == 1 && sva_checker.fuel_economy_optimization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_split_device_control == 1'b1 |-> $past(sva_checker.battery_state_of_charge_prediction, 6) && sva_checker.fuel_economy_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qmlo8_j7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_energy_management == 0 && sva_checker.power_split_device_control == 1 |-> $past(sva_checker.battery_state_of_charge_prediction, 6) == 1 && sva_checker.fuel_economy_optimization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_split_device_control == 1'b1 |-> $past(sva_checker.battery_state_of_charge_prediction, 6) && sva_checker.fuel_economy_optimization): REFUTED\n[sva_checker.cover_antecedent] c"
  },
  {
    "id": "1802",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_pwofdqus/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.understeer_oversteer_mitigation |-> $past(sva_checker.lateral_acceleration_measurement, 7) && sva_checker.handling_characteristic_enhancement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_yaw_stability == 0 && sva_checker.understeer_oversteer_mitigation == 1 |-> sva_checker.handling_characteristic_enhancement == 1 && $past(sva_checker.lateral_acceleration_measurement, 7) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.understeer_oversteer_mitigation |-> $past(sva_checker.lateral_acceleration_measurement, 7) && sva_checker.handling_characteristic_enhancement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_13k8g8vr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_yaw_stability == 0 && sva_checker.understeer_oversteer_mitigation == 1 |-> sva_checker.handling_characteristic_enhancement == 1 && $past(sva_checker.lateral_acceleration_measurement, 7) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.understeer_oversteer_mitigation |-> $past(sva_checker.lateral_acceleration_measurement, 7) && sva_checker.handling_characteristic_enhancement): REFUTED"
  },
  {
    "id": "1828",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fwbib8ok/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.multi_domain_coordination |-> $past(sva_checker.inter_ecu_communication_validation, 11) && sva_checker.seamless_functionality_integration): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_system_orchestration == 0 && sva_checker.multi_domain_coordination == 1 |-> sva_checker.seamless_functionality_integration == 1 && $past(sva_checker.inter_ecu_communication_validation, 11) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.multi_domain_coordination |-> $past(sva_checker.inter_ecu_communication_validation, 11) && sva_checker.seamless_functionality_integration): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0y95cpb2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_system_orchestration == 0 && sva_checker.multi_domain_coordination == 1 |-> sva_checker.seamless_functionality_integration == 1 && $past(sva_checker.inter_ecu_communication_validation, 11) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.multi_domain_coordination |-> $past(sva_checker.inter_ecu_communication_validation, 11) && sva_checker.seamless_functionality_integration): REFUTED\n[sva_"
  },
  {
    "id": "1848",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_6xt2yybt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_bitrate_streaming == 1'b1 |-> $past(sva_checker.network_bandwidth_estimation, 5) && sva_checker.quality_of_service_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_bitrate_streaming == 1'b1 && sva_checker.rst_streaming_service == 1'b0 |-> $past(sva_checker.network_bandwidth_estimation, 5) == 1'b1 && sva_checker.quality_of_service_optimization == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adaptive_bitrate_streaming == 1'b1 |-> $past(sva_checker.network_bandwidth_estimation, 5) && sva_checker.quality_of_service_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j2esj721/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_bitrate_streaming == 1'b1 && sva_checker.rst_streaming_service == 1'b0 |-> $past(sva_checker.network_bandwidth_estimation, 5) == 1'b1 && sva_checker.quality_of_service_optimization == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adaptive_bitrate_streaming == 1'b1 |-> $past(sva_checker.network_bandwidth_estimation, 5) && sva_checker.quality_of_service_optimization): REFUTED\n[sva_che"
  },
  {
    "id": "1861",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_9mli_7qa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bounding_volume_hierarchy |-> $past(sva_checker.ray_triangle_intersection_test, 8) && sva_checker.photorealistic_lighting_simulation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_acceleration_structure == 0 && sva_checker.bounding_volume_hierarchy == 1 |-> sva_checker.photorealistic_lighting_simulation == 1 && $past(sva_checker.ray_triangle_intersection_test, 8) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bounding_volume_hierarchy |-> $past(sva_checker.ray_triangle_intersection_test, 8) && sva_checker.photorealistic_lighting_simulation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r6nwp_e9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_acceleration_structure == 0 && sva_checker.bounding_volume_hierarchy == 1 |-> sva_checker.photorealistic_lighting_simulation == 1 && $past(sva_checker.ray_triangle_intersection_test, 8) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bounding_volume_hierarchy |-> $past(sva_checker.ray_triangle_intersection_test, 8) && sva_checker.photorealistic_lighting_simulation): REFUTED\n[sva_checker.cover_anteced"
  },
  {
    "id": "1855",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_98bl_7mb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.stereoscopic_rendering_pipeline |-> $past(sva_checker.motion_to_photon_latency_measurement, 3) && sva_checker.presence_illusion_maintenance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_head_mounted_display == 0 && sva_checker.stereoscopic_rendering_pipeline == 1 |-> $past(sva_checker.motion_to_photon_latency_measurement, 3) == 1 && sva_checker.presence_illusion_maintenance == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.stereoscopic_rendering_pipeline |-> $past(sva_checker.motion_to_photon_latency_measurement, 3) && sva_checker.presence_illusion_maintenance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mnwv418z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_head_mounted_display == 0 && sva_checker.stereoscopic_rendering_pipeline == 1 |-> $past(sva_checker.motion_to_photon_latency_measurement, 3) == 1 && sva_checker.presence_illusion_maintenance == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.stereoscopic_rendering_pipeline |-> $past(sva_checker.motion_to_photon_latency_measurement, 3) && sva_checker.presence_illusion_maintenance): REF"
  },
  {
    "id": "1863",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_f7x2y1e1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.connected_autonomous_shared_electric && $past(sva_checker.mobility_service_optimization, 13) |-> sva_checker.sustainable_transportation_ecosystem): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_transportation_evolution == 0 && sva_checker.connected_autonomous_shared_electric == 1 && $past(sva_checker.mobility_service_optimization, 13) == 1 |-> sva_checker.sustainable_transportation_ecosystem == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.connected_autonomous_shared_electric && $past(sva_checker.mobility_service_optimization, 13) |-> sva_checker.sustainable_transportation_ecosystem): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uzp5z_v5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_transportation_evolution == 0 && sva_checker.connected_autonomous_shared_electric == 1 && $past(sva_checker.mobility_service_optimization, 13) == 1 |-> sva_checker.sustainable_transportation_ecosystem == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.connected_autonomous_shared_electric && $past(sva_checker.mobility_service_optimization, 13) |-> sva_checker.sust"
  },
  {
    "id": "1886",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jxya1ab6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution, 10) && sva_checker.immersive_3d_soundscape): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution, 10) && sva_checker.immersive_3d_soundscape): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution, 10) && sva_checker.immersive_3d_soundscape): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lx131e7h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution, 10) && sva_checker.immersive_3d_soundscape): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution, 10) && sva_checker.immersive_3d_soundscape): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.head_tracking_compensation |-> $past(sva_checker.room_impulse_response_convolution,"
  },
  {
    "id": "1868",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_gpx3sk1a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.procedural_quest_generation && $past(sva_checker.story_branch_coherence_check, 5) |-> sva_checker.emergent_narrative_experience): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.narrative_engine_reset == 1 && sva_checker.procedural_quest_generation == 1 && $past(sva_checker.story_branch_coherence_check, 5) == 1 |-> sva_checker.emergent_narrative_experience == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.procedural_quest_generation && $past(sva_checker.story_branch_coherence_check, 5) |-> sva_checker.emergent_narrative_experience): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2ff2lrl6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.narrative_engine_reset == 1 && sva_checker.procedural_quest_generation == 1 && $past(sva_checker.story_branch_coherence_check, 5) == 1 |-> sva_checker.emergent_narrative_experience == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.procedural_quest_generation && $past(sva_checker.story_branch_coherence_check, 5) |-> sva_checker.emergent_narrative_experience): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_che"
  },
  {
    "id": "1879",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_kee4d8di/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.foveated_rendering_optimization && $past(sva_checker.pupil_center_estimation, 8) |-> sva_checker.visual_attention_based_performance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gaze_detection_reset == 1 && sva_checker.foveated_rendering_optimization == 1 && $past(sva_checker.pupil_center_estimation, 8) == 1 |-> sva_checker.visual_attention_based_performance == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.foveated_rendering_optimization && $past(sva_checker.pupil_center_estimation, 8) |-> sva_checker.visual_attention_based_performance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ta83quxx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gaze_detection_reset == 1 && sva_checker.foveated_rendering_optimization == 1 && $past(sva_checker.pupil_center_estimation, 8) == 1 |-> sva_checker.visual_attention_based_performance == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.foveated_rendering_optimization && $past(sva_checker.pupil_center_estimation, 8) |-> sva_checker.visual_attention_based_performance): REFUTED\n[sva_checker.cover_antecedent] cover (disab"
  },
  {
    "id": "1887",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8ym2fgte/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.geometric_acoustics_simulation && $past(sva_checker.surface_material_absorption, 6) |-> sva_checker.realistic_audio_propagation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_audio_ray_casting == 0 && sva_checker.geometric_acoustics_simulation == 1 && $past(sva_checker.surface_material_absorption, 6) == 1 |-> sva_checker.realistic_audio_propagation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.geometric_acoustics_simulation && $past(sva_checker.surface_material_absorption, 6) |-> sva_checker.realistic_audio_propagation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z22095b5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_audio_ray_casting == 0 && sva_checker.geometric_acoustics_simulation == 1 && $past(sva_checker.surface_material_absorption, 6) == 1 |-> sva_checker.realistic_audio_propagation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.geometric_acoustics_simulation && $past(sva_checker.surface_material_absorption, 6) |-> sva_checker.realistic_audio_propagation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_check"
  },
  {
    "id": "1891",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xw25qwk9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.real_time_synchronization && $past(sva_checker.sensor_data_fusion_complete, 5) |-> sva_checker.virtual_model_state_update): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.simulation_engine_rst_n == 1 && sva_checker.real_time_synchronization == 1 && $past(sva_checker.sensor_data_fusion_complete, 5) == 1 |-> sva_checker.virtual_model_state_update == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.real_time_synchronization && $past(sva_checker.sensor_data_fusion_complete, 5) |-> sva_checker.virtual_model_state_update): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6squbsfr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.simulation_engine_rst_n == 1 && sva_checker.real_time_synchronization == 1 && $past(sva_checker.sensor_data_fusion_complete, 5) == 1 |-> sva_checker.virtual_model_state_update == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.real_time_synchronization && $past(sva_checker.sensor_data_fusion_complete, 5) |-> sva_checker.virtual_model_state_update): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.simu"
  },
  {
    "id": "1916",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_2o7auo73/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.layer_deposition_control |-> $past(sva_checker.material_extrusion_temperature, 11) && sva_checker.dimensional_accuracy_maintenance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_3d_printing == 0 && sva_checker.layer_deposition_control == 1 |-> $past(sva_checker.material_extrusion_temperature, 11) == 1 && sva_checker.dimensional_accuracy_maintenance == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.layer_deposition_control |-> $past(sva_checker.material_extrusion_temperature, 11) && sva_checker.dimensional_accuracy_maintenance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rr6mr6nb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_3d_printing == 0 && sva_checker.layer_deposition_control == 1 |-> $past(sva_checker.material_extrusion_temperature, 11) == 1 && sva_checker.dimensional_accuracy_maintenance == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.layer_deposition_control |-> $past(sva_checker.material_extrusion_temperature, 11) && sva_checker.dimensional_accuracy_maintenance): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_ch"
  },
  {
    "id": "1917",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fhy676wx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hazard_detection_algorithm && $past(sva_checker.environmental_risk_assessment, 3) |-> sva_checker.accident_prevention_system): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_personal_protective_equipment == 0 && sva_checker.hazard_detection_algorithm == 1 && $past(sva_checker.environmental_risk_assessment, 3) == 1 |-> sva_checker.accident_prevention_system == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hazard_detection_algorithm && $past(sva_checker.environmental_risk_assessment, 3) |-> sva_checker.accident_prevention_system): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w2cf0xlg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_personal_protective_equipment == 0 && sva_checker.hazard_detection_algorithm == 1 && $past(sva_checker.environmental_risk_assessment, 3) == 1 |-> sva_checker.accident_prevention_system == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hazard_detection_algorithm && $past(sva_checker.environmental_risk_assessment, 3) |-> sva_checker.accident_prevention_system): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!"
  },
  {
    "id": "1941",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_spg07ptx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.material_flow_optimization && $past(sva_checker.lifecycle_assessment_calculation, 3) |-> sva_checker.sustainable_business_model): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_waste_to_value == 0 && sva_checker.material_flow_optimization == 1 && $past(sva_checker.lifecycle_assessment_calculation, 3) == 1 |-> sva_checker.sustainable_business_model == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.material_flow_optimization && $past(sva_checker.lifecycle_assessment_calculation, 3) |-> sva_checker.sustainable_business_model): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p4bdgvu1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_waste_to_value == 0 && sva_checker.material_flow_optimization == 1 && $past(sva_checker.lifecycle_assessment_calculation, 3) == 1 |-> sva_checker.sustainable_business_model == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.material_flow_optimization && $past(sva_checker.lifecycle_assessment_calculation, 3) |-> sva_checker.sustainable_business_model): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst"
  },
  {
    "id": "1962",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_z4etjgqy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quantum_resistant_algorithm && $past(sva_checker.ring_learning_with_errors, 5) |-> sva_checker.cryptographic_security_future_proofing): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lattice_based_reset == 1 && sva_checker.quantum_resistant_algorithm == 1 && $past(sva_checker.ring_learning_with_errors, 5) == 1 |-> sva_checker.cryptographic_security_future_proofing == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.quantum_resistant_algorithm && $past(sva_checker.ring_learning_with_errors, 5) |-> sva_checker.cryptographic_security_future_proofing): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gbspqhjw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lattice_based_reset == 1 && sva_checker.quantum_resistant_algorithm == 1 && $past(sva_checker.ring_learning_with_errors, 5) == 1 |-> sva_checker.cryptographic_security_future_proofing == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quantum_resistant_algorithm && $past(sva_checker.ring_learning_with_errors, 5) |-> sva_checker.cryptographic_security_future_proofing): REFUTED\n[sva_checker.cover_antecedent] cove"
  },
  {
    "id": "1979",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xml_ic4n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ferritin_based_actuator && $past(sva_checker.magnetic_nanoparticle_heating, 8) |-> sva_checker.remote_neural_modulation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_magnetic_field_stimulation == 0 && sva_checker.ferritin_based_actuator == 1 && $past(sva_checker.magnetic_nanoparticle_heating, 8) == 1 |-> sva_checker.remote_neural_modulation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ferritin_based_actuator && $past(sva_checker.magnetic_nanoparticle_heating, 8) |-> sva_checker.remote_neural_modulation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hyx8cubo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_magnetic_field_stimulation == 0 && sva_checker.ferritin_based_actuator == 1 && $past(sva_checker.magnetic_nanoparticle_heating, 8) == 1 |-> sva_checker.remote_neural_modulation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ferritin_based_actuator && $past(sva_checker.magnetic_nanoparticle_heating, 8) |-> sva_checker.remote_neural_modulation): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker."
  },
  {
    "id": "1994",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_7zrek987/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spike_timing_dependent_plasticity && $past(sva_checker.memristive_weight_update, 7) |-> sva_checker.brain_inspired_learning): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_synaptic_plasticity == 0 && sva_checker.spike_timing_dependent_plasticity == 1 && $past(sva_checker.memristive_weight_update, 7) == 1 |-> sva_checker.brain_inspired_learning == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spike_timing_dependent_plasticity && $past(sva_checker.memristive_weight_update, 7) |-> sva_checker.brain_inspired_learning): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eld16hd8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_synaptic_plasticity == 0 && sva_checker.spike_timing_dependent_plasticity == 1 && $past(sva_checker.memristive_weight_update, 7) == 1 |-> sva_checker.brain_inspired_learning == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spike_timing_dependent_plasticity && $past(sva_checker.memristive_weight_update, 7) |-> sva_checker.brain_inspired_learning): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_ch"
  },
  {
    "id": "2000",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_2p2gtc3r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adeno_associated_virus && $past(sva_checker.tissue_specific_promoter, 6) |-> sva_checker.therapeutic_gene_expression): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_viral_vector_delivery == 0 && sva_checker.adeno_associated_virus == 1 && $past(sva_checker.tissue_specific_promoter, 6) == 1 |-> sva_checker.therapeutic_gene_expression == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adeno_associated_virus && $past(sva_checker.tissue_specific_promoter, 6) |-> sva_checker.therapeutic_gene_expression): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iz97_xc8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_viral_vector_delivery == 0 && sva_checker.adeno_associated_virus == 1 && $past(sva_checker.tissue_specific_promoter, 6) == 1 |-> sva_checker.therapeutic_gene_expression == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adeno_associated_virus && $past(sva_checker.tissue_specific_promoter, 6) |-> sva_checker.therapeutic_gene_expression): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_viral_vector_delivery"
  },
  {
    "id": "2016",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ede6ywny/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.byproduct_utilization |-> $past(sva_checker.value_added_product_development, 7) && sva_checker.resource_efficiency_maximization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_circular_economy == 0 && sva_checker.byproduct_utilization == 1 |-> $past(sva_checker.value_added_product_development, 7) == 1 && sva_checker.resource_efficiency_maximization == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.byproduct_utilization |-> $past(sva_checker.value_added_product_development, 7) && sva_checker.resource_efficiency_maximization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_85hygd0z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_circular_economy == 0 && sva_checker.byproduct_utilization == 1 |-> $past(sva_checker.value_added_product_development, 7) == 1 && sva_checker.resource_efficiency_maximization == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.byproduct_utilization |-> $past(sva_checker.value_added_product_development, 7) && sva_checker.resource_efficiency_maximization): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker"
  },
  {
    "id": "2011",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_x58ekige/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.drought_resistant_variety && $past(sva_checker.climate_scenario_modeling, 5) |-> sva_checker.agricultural_resilience_building): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_adaptation_strategy == 0 && sva_checker.drought_resistant_variety == 1 && $past(sva_checker.climate_scenario_modeling, 5) == 1 |-> sva_checker.agricultural_resilience_building == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.drought_resistant_variety && $past(sva_checker.climate_scenario_modeling, 5) |-> sva_checker.agricultural_resilience_building): PROVED\n\n\nBackward: Parsing /tmp/sva_check_08e5nzld/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_adaptation_strategy == 0 && sva_checker.drought_resistant_variety == 1 && $past(sva_checker.climate_scenario_modeling, 5) == 1 |-> sva_checker.agricultural_resilience_building == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.drought_resistant_variety && $past(sva_checker.climate_scenario_modeling, 5) |-> sva_checker.agricultural_resilience_building): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst"
  },
  {
    "id": "2059",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_7ng30r_5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> $past(sva_checker.tag_compare, 1) && !$past(sva_checker.hit_detected, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset_override == 0 && sva_checker.cache_miss == 1 |-> $past(sva_checker.tag_compare) == 1 && $past(sva_checker.hit_detected) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> $past(sva_checker.tag_compare, 1) && !$past(sva_checker.hit_detected, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7_kdit26/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset_override == 0 && sva_checker.cache_miss == 1 |-> $past(sva_checker.tag_compare) == 1 && $past(sva_checker.hit_detected) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> $past(sva_checker.tag_compare, 1) && !$past(sva_checker.hit_detected, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset_override == 0 && sva_checker.cache_miss == 1 |-> $past(sva_checker.tag_compare) == 1 && $past(sva_checker.hit_detected) == 0): PROVED\n"
  },
  {
    "id": "2064",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_o06clk87/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): PROVED\n\n\nBackward: Parsing /tmp/sva_check_34auzx2x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.counter_overflow == 1'b1 |-> $past(sva_checker.counter_value, 1) == 255): PROVED\n"
  },
  {
    "id": "2093",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fb7s7ou1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transmission_error == 1'b1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.io_ready == 1 && sva_checker.transmission_error == 1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.transmission_error == 1'b1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5q2b402p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.io_ready == 1 && sva_checker.transmission_error == 1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transmission_error == 1'b1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.io_ready == 1 && sva_checker.transmission_error == 1 |-> $past(sva_checker.tx_data[7:0], 1) != $past(sva_checker.rx_data[7:0], 2)): PROVED\n"
  },
  {
    "id": "2114",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_792g0rso/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict, 1) || $past(sva_checker.exception_occurred, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.test_reset == 0 && sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict) == 1'b1 || $past(sva_checker.exception_occurred) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict, 1) || $past(sva_checker.exception_occurred, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0qbuzv8o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.test_reset == 0 && sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict) == 1'b1 || $past(sva_checker.exception_occurred) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict, 1) || $past(sva_checker.exception_occurred, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.test_reset == 0 && sva_checker.pipeline_flush == 1'b1 |-> $past(sva_checker.branch_mispredict) "
  },
  {
    "id": "2118",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n0syykja/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_abort == 1'b1 |-> $past(sva_checker.bus_error, 1) || $past(sva_checker.address_fault, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_enable == 1 && sva_checker.transfer_abort == 1 |-> $past(sva_checker.bus_error) == 1 || $past(sva_checker.address_fault) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.transfer_abort == 1'b1 |-> $past(sva_checker.bus_error, 1) || $past(sva_checker.address_fault, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_02idijhp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_enable == 1 && sva_checker.transfer_abort == 1 |-> $past(sva_checker.bus_error) == 1 || $past(sva_checker.address_fault) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transfer_abort == 1'b1 |-> $past(sva_checker.bus_error, 1) || $past(sva_checker.address_fault, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_enable == 1 && sva_checker.transfer_abort == 1 |-> $past(sva_checker.bus_error) == 1 || $past(sva_checker.address_fault) == 1): PROVED\n"
  },
  {
    "id": "2127",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_60sjoc_8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_detect_false |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rf_enable == 1 && sva_checker.carrier_detect_false == 1 |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.carrier_detect_false |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): PROVED\n\n\nBackward: Parsing /tmp/sva_check_of_manre/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rf_enable == 1 && sva_checker.carrier_detect_false == 1 |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_detect_false |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rf_enable == 1 && sva_checker.carrier_detect_false == 1 |-> $past(sva_checker.signal_strength[7:0], 1) < sva_checker.noise_floor): PROVED\n"
  },
  {
    "id": "2142",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_h76a81p0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sector_erase_timeout |-> $past(sva_checker.erase_command, 1) && $past(sva_checker.busy_timeout, 100)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.sector_erase_timeout == 1 |-> $past(sva_checker.erase_command, 1) == 1 && $past(sva_checker.busy_timeout, 100) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sector_erase_timeout |-> $past(sva_checker.erase_command, 1) && $past(sva_checker.busy_timeout, 100)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jtzzifw2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.sector_erase_timeout == 1 |-> $past(sva_checker.erase_command, 1) == 1 && $past(sva_checker.busy_timeout, 100) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sector_erase_timeout |-> $past(sva_checker.erase_command, 1) && $past(sva_checker.busy_timeout, 100)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.sector_erase_timeout == 1 |-> $past(sva_checker.erase_command, 1) == 1 && $past(sva_checker.busy_time"
  },
  {
    "id": "2223",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s_z19a0k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uj7p_bpg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.aquatic_oxygen_content == 1'b1 |-> $past(sva_checker.oxygen_concentration[11:0], 1) < sva_checker.minimum_viable_level): PR"
  },
  {
    "id": "2239",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4570o55b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path, 1) && $past(sva_checker.fault_injection_active, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path) && $past(sva_checker.fault_injection_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path, 1) && $past(sva_checker.fault_injection_active, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0ut8mi8y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path) && $past(sva_checker.fault_injection_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path, 1) && $past(sva_checker.fault_injection_active, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.functional_safety_monitor |-> $past(sva_checker.safety_critical_path) && $past(sva_checker.fault_injection_active)): PROVED\n"
  },
  {
    "id": "2335",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z9wzicdu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.design_for_testability |=> $past(sva_checker.scan_insertion, 1) && $past(sva_checker.bist_controller, 1) && $past(sva_checker.jtag_interface, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.design_for_testability |=> $past(sva_checker.scan_insertion, 1) && $past(sva_checker.bist_controller, 1) && $past(sva_checker.jtag_interface, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.design_for_testability |=> $past(sva_checker.scan_insertion, 1) && $past(sva_checker.bist_controller, 1) && $past(sva_checker.jtag_interface, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cdsvg6vk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.design_for_testability |=> $past(sva_checker.scan_insertion, 1) && $past(sva_checker.bist_controller, 1) && $past(sva_checker.jtag_interface, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.design_for_testability |=> $past(sva_checker.scan_insertion, 1) && $past(sva_checker.bist_controller, 1) && $past(sva_checker.jtag_interface, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_c"
  },
  {
    "id": "2355",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e7nrri0g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.open_source_silicon_root_of_trust |=> $past(sva_checker.secure_boot && sva_checker.hardware_security_module && sva_checker.cryptographic_accelerator, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.open_source_silicon_root_of_trust |=> $past(sva_checker.secure_boot && sva_checker.hardware_security_module && sva_checker.cryptographic_accelerator, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.open_source_silicon_root_of_trust |=> $past(sva_checker.secure_boot && sva_checker.hardware_security_module && sva_checker.cryptographic_accelerator, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_su738uk3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.open_source_silicon_root_of_trust |=> $past(sva_checker.secure_boot && sva_checker.hardware_security_module && sva_checker.cryptographic_accelerator, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.open_source_silicon_root_of_trust |=> $past(sva_checker.secure_boot && sva_checker.hardware_security_module && sva_checker.cryptographic_accelerator, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover"
  },
  {
    "id": "2378",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_4vrs1sat/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.continuous_integration_testing == 1'b1 |-> $past(sva_checker.regression_suite, 1) && $past(sva_checker.automated_testing, 1) && $past(sva_checker.version_control, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.agile_development == 0 && sva_checker.continuous_integration_testing == 1'b1 |-> $past(sva_checker.regression_suite) == 1'b1 && $past(sva_checker.automated_testing) == 1'b1 && $past(sva_checker.version_control) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.continuous_integration_testing == 1'b1 |-> $past(sva_checker.regression_suite, 1) && $past(sva_checker.automated_testing, 1) && $past(sva_checker.version_control, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jbgvp926/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.agile_development == 0 && sva_checker.continuous_integration_testing == 1'b1 |-> $past(sva_checker.regression_suite) == 1'b1 && $past(sva_checker.automated_testing) == 1'b1 && $past(sva_checker.version_control) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.continuous_integration_testing == 1'b1 |-> $past(sva_ch"
  },
  {
    "id": "2379",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xaf3ee5z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.process_technology_scaling == 1'b1 |-> $past(sva_checker.design_rule_compliance, 1) && $past(sva_checker.parasitic_extraction, 1) && $past(sva_checker.yield_optimization, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_node == 0 && sva_checker.process_technology_scaling == 1 |-> $past(sva_checker.design_rule_compliance) == 1 && $past(sva_checker.parasitic_extraction) == 1 && $past(sva_checker.yield_optimization) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.process_technology_scaling == 1'b1 |-> $past(sva_checker.design_rule_compliance, 1) && $past(sva_checker.parasitic_extraction, 1) && $past(sva_checker.yield_optimization, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hav7d6do/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_node == 0 && sva_checker.process_technology_scaling == 1 |-> $past(sva_checker.design_rule_compliance) == 1 && $past(sva_checker.parasitic_extraction) == 1 && $past(sva_checker.yield_optimization) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.process_technology_scaling == 1'b1 |-> $past(sva_checke"
  },
  {
    "id": "2387",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_hwd2uo3x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.direct_memory_access_transfer == 1'b1 |-> $past(sva_checker.dma_src_addr[31:0], 1) && $past(sva_checker.dma_dst_addr[31:0], 1) && $past(sva_checker.transfer_length[15:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_rst_async_n == 1 && sva_checker.direct_memory_access_transfer == 1 |-> $past(sva_checker.dma_src_addr[31:0]) != 0 && $past(sva_checker.dma_dst_addr[31:0]) != 0 && $past(sva_checker.transfer_length[15:0]) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.direct_memory_access_transfer == 1'b1 |-> $past(sva_checker.dma_src_addr[31:0], 1) && $past(sva_checker.dma_dst_addr[31:0], 1) && $past(sva_checker.transfer_length[15:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kgc55oa4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_rst_async_n == 1 && sva_checker.direct_memory_access_transfer == 1 |-> $past(sva_checker.dma_src_addr[31:0]) != 0 && $past(sva_checker.dma_dst_addr[31:0]) != 0 && $past(sva_checker.transfer_length[15:0]) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.direct_memory_access_transfer == 1'b1 |-> $past(sva"
  },
  {
    "id": "2519",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |-> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |=> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |-> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_ovps_mts/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |-> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |=> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |-> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ylq3szrg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |=> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_capacitance, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ferroelectric_field_effect_transistor |-> $past(sva_checker.polarization_state[7:0] & sva_checker.coercive_voltage[11:0] & sva_checker.negative_ca"
  },
  {
    "id": "2522",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3zi1khi1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.microfluidic_logic_processor |-> $past(sva_checker.droplet_formation[7:0], 1) && $past(sva_checker.channel_geometry[11:0], 1) && $past(sva_checker.surface_tension[15:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.microfluidic_logic_processor |-> $past(sva_checker.droplet_formation) != 0 && $past(sva_checker.channel_geometry) != 0 && $past(sva_checker.surface_tension) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.microfluidic_logic_processor |-> $past(sva_checker.droplet_formation[7:0], 1) && $past(sva_checker.channel_geometry[11:0], 1) && $past(sva_checker.surface_tension[15:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_00wolkvi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.microfluidic_logic_processor |-> $past(sva_checker.droplet_formation) != 0 && $past(sva_checker.channel_geometry) != 0 && $past(sva_checker.surface_tension) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.microfluidic_logic_processor |-> $past(sva_checker.droplet_formation[7:0], 1) && $past(sva_checker.channel_geometry[11:0], 1) && $past(sva_checker.surface_"
  },
  {
    "id": "2506",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_20yb88ec/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermoelectric_generator_interface == 1'b1 |-> $past(sva_checker.seebeck_voltage[11:0], 1) != 0 && $past(sva_checker.temperature_differential[7:0], 1) != 0 && $past(sva_checker.internal_resistance[7:0], 1) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermoelectric_ready == 1 && sva_checker.thermoelectric_generator_interface == 1 |-> $past(sva_checker.seebeck_voltage[11:0], 1) != 0 && $past(sva_checker.temperature_differential[7:0], 1) != 0 && $past(sva_checker.internal_resistance[7:0], 1) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermoelectric_generator_interface == 1'b1 |-> $past(sva_checker.seebeck_voltage[11:0], 1) != 0 && $past(sva_checker.temperature_differential[7:0], 1) != 0 && $past(sva_checker.internal_resistance[7:0], 1) != 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4r6ndl9t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermoelectric_ready == 1 && sva_checker.thermoelectric_generator_interface == 1 |-> $past(sva_checker.seebeck_voltage[11:0], 1) != 0 && $past(sva_checker.temperature_differential[7:0], 1) != 0 && $past(sva_checker.internal_resistance[7:0],"
  },
  {
    "id": "2539",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_cxksjcd4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.magnetostrictive_sensor_actuator == 1'b1 |-> $past(sva_checker.magnetic_field_strength[11:0], 1) != 0 && $past(sva_checker.dimensional_change[7:0], 1) != 0 && $past(sva_checker.coupling_factor[15:0], 1) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.magnetostrictive_ready == 1 && sva_checker.magnetostrictive_sensor_actuator == 1 |-> $past(sva_checker.magnetic_field_strength[11:0]) != 0 && $past(sva_checker.dimensional_change[7:0]) != 0 && $past(sva_checker.coupling_factor[15:0]) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.magnetostrictive_sensor_actuator == 1'b1 |-> $past(sva_checker.magnetic_field_strength[11:0], 1) != 0 && $past(sva_checker.dimensional_change[7:0], 1) != 0 && $past(sva_checker.coupling_factor[15:0], 1) != 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lkhl9_pq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.magnetostrictive_ready == 1 && sva_checker.magnetostrictive_sensor_actuator == 1 |-> $past(sva_checker.magnetic_field_strength[11:0]) != 0 && $past(sva_checker.dimensional_change[7:0]) != 0 && $past(sva_checker.coupling_factor[15:0]) != 0): ASSUMED\n[sva_ch"
  },
  {
    "id": "2621",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.x_ray_crystallography == 0 && sva_checker.single_crystal_diffractometer == 1 |-> $past(sva_checker.bragg_reflection_intensity[15:0]) != 0 && $past(sva_checker.unit_cell_parameters[31:0]) != 0 && $past(sva_checker.structure_factor[11:0]) != 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.single_crystal_diffractometer |=> $past(sva_checker.bragg_reflection_intensity[15:0], 1) && $past(sva_checker.unit_cell_parameters[31:0], 1) && $past(sva_checker.structure_factor[11:0], 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_95do41eh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.single_crystal_diffractometer |=> $past(sva_checker.bragg_reflection_intensity[15:0], 1) && $past(sva_checker.unit_cell_parameters[31:0], 1) && $past(sva_checker.structure_factor[11:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.x_ray_crystallography == 0 && sva_checker.single_crystal_diffractometer == 1 |-> $past(sva_checker.bragg_reflection_intensity[15:0]) != 0 && $past(sva_checker.unit_cell_parameters[31:0]) != 0 && $past(sva_checker.structure_factor[11:0]) != 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.single_crystal_diffractometer |=> $past(sva_checker.bragg_reflection_intensity[15:0], 1) && $past(sva_checker.unit_cell_parameters[31:0], 1) && $past(sva_checker.structure_factor[11:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ldvy_u96/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.x_ray_crystallography == 0 && sva_checker.single_crystal_diffractometer == 1 |-> $past(sva_checker.bragg_reflection_intensity[15:0]) != 0 && $past(sva_checker.unit_cell_parameters[31:0]) != 0 && $past(sva_checker.structure_factor[11:0]) != 0): ASSUMED\n"
  },
  {
    "id": "2720",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_zpgsfjjq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.net_radiation_measurement |-> $past(sva_checker.incoming_longwave[15:0], 1) && $past(sva_checker.outgoing_longwave[11:0], 1) && $past(sva_checker.net_shortwave[7:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.radiation_balance_rst_n == 1 && sva_checker.net_radiation_measurement == 1 |-> $past(sva_checker.incoming_longwave[15:0]) != 0 && $past(sva_checker.outgoing_longwave[11:0]) != 0 && $past(sva_checker.net_shortwave[7:0]) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.net_radiation_measurement |-> $past(sva_checker.incoming_longwave[15:0], 1) && $past(sva_checker.outgoing_longwave[11:0], 1) && $past(sva_checker.net_shortwave[7:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cbnq4frv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.radiation_balance_rst_n == 1 && sva_checker.net_radiation_measurement == 1 |-> $past(sva_checker.incoming_longwave[15:0]) != 0 && $past(sva_checker.outgoing_longwave[11:0]) != 0 && $past(sva_checker.net_shortwave[7:0]) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.net_radiation_measurement |-> $past(sva"
  },
  {
    "id": "2761",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nk6y5wr3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.airborne_radiometric_survey |-> $past(sva_checker.gamma_ray_spectrometry[31:0], 1) && $past(sva_checker.potassium_concentration[11:0], 1) && $past(sva_checker.uranium_thorium_ratio[15:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.radiometric_rst_n == 1 && sva_checker.airborne_radiometric_survey == 1 |-> $past(sva_checker.gamma_ray_spectrometry) != 0 && $past(sva_checker.potassium_concentration) != 0 && $past(sva_checker.uranium_thorium_ratio) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.airborne_radiometric_survey |-> $past(sva_checker.gamma_ray_spectrometry[31:0], 1) && $past(sva_checker.potassium_concentration[11:0], 1) && $past(sva_checker.uranium_thorium_ratio[15:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_h9o4kyic/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.radiometric_rst_n == 1 && sva_checker.airborne_radiometric_survey == 1 |-> $past(sva_checker.gamma_ray_spectrometry) != 0 && $past(sva_checker.potassium_concentration) != 0 && $past(sva_checker.uranium_thorium_ratio) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker"
  },
  {
    "id": "3047",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4fi074h5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> !$past(sva_checker.access_granted) && $past(sva_checker.access_attempt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> $past(sva_checker.access_granted) == 1'b0 && $past(sva_checker.access_attempt) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> !$past(sva_checker.access_granted) && $past(sva_checker.access_attempt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tv08w8dd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> $past(sva_checker.access_granted) == 1'b0 && $past(sva_checker.access_attempt) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> !$past(sva_checker.access_granted) && $past(sva_checker.access_attempt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.security_breach == 1'b1 |-> $past(sva_checker.access_granted) == 1'b0 && $past(sva_checker.access_attempt) == 1'b1): PROVED\n"
  },
  {
    "id": "3069",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u8m7fovg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor) > sva_checker.critical_temp || $past(sva_checker.cooling_failed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor) > sva_checker.critical_temp || $past(sva_checker.cooling_failed) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor) > sva_checker.critical_temp || $past(sva_checker.cooling_failed)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wmtcjml0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor) > sva_checker.critical_temp || $past(sva_checker.cooling_failed) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor) > sva_checker.critical_temp || $past(sva_checker.cooling_failed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_che"
  },
  {
    "id": "2985",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_divwhwhk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.robotic_surgical_system == 1'b1 |-> $past(sva_checker.haptic_feedback[15:0], 1) && $past(sva_checker.tremor_filtering[11:0], 1) && $past(sva_checker.motion_scaling[7:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.robotic_surgical_system == 1'b1 && sva_checker.robotic_surgery == 0 |-> $past(sva_checker.haptic_feedback[15:0]) != 0 && $past(sva_checker.tremor_filtering[11:0]) != 0 && $past(sva_checker.motion_scaling[7:0]) != 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.robotic_surgical_system == 1'b1 |-> $past(sva_checker.haptic_feedback[15:0], 1) && $past(sva_checker.tremor_filtering[11:0], 1) && $past(sva_checker.motion_scaling[7:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_reiwiyf5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.robotic_surgical_system == 1'b1 && sva_checker.robotic_surgery == 0 |-> $past(sva_checker.haptic_feedback[15:0]) != 0 && $past(sva_checker.tremor_filtering[11:0]) != 0 && $past(sva_checker.motion_scaling[7:0]) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.robotic_surgical_system == 1'b1 |-> $past(sva_che"
  },
  {
    "id": "3074",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1hlx8o6e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive) && $past(sva_checker.scl_drive) && !$past(sva_checker.bus_free)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive && sva_checker.scl_drive && !sva_checker.bus_free, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive) && $past(sva_checker.scl_drive) && !$past(sva_checker.bus_free)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_44j2822_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive && sva_checker.scl_drive && !sva_checker.bus_free, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive) && $past(sva_checker.scl_drive) && !$past(sva_checker.bus_free)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_collision == 1'b1 |-> $past(sva_checker.sda_drive && sva_checker.scl_drive && !sva_checker.bus_free, 1)): PROVED\n"
  },
  {
    "id": "3078",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5btolbxn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_expired |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_enable == 1 && sva_checker.key_expired == 1 |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_expired |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b1e67ntz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_enable == 1 && sva_checker.key_expired == 1 |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_expired |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crypto_enable == 1 && sva_checker.key_expired == 1 |-> $past(sva_checker.key_age_counter) >= sva_checker.max_key_age): PROVED\n"
  },
  {
    "id": "3096",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n8795wu7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.erase_failure |-> $past(sva_checker.erase_command) && !$past(sva_checker.erase_complete, 32'hs3E8)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.erase_failure == 1 |-> $past(sva_checker.erase_command) == 1 && !$past(sva_checker.erase_complete, 32'hs3E8)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.erase_failure |-> $past(sva_checker.erase_command) && !$past(sva_checker.erase_complete, 32'hs3E8)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b4r1p5on/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.erase_failure == 1 |-> $past(sva_checker.erase_command) == 1 && !$past(sva_checker.erase_complete, 32'hs3E8)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.erase_failure |-> $past(sva_checker.erase_command) && !$past(sva_checker.erase_complete, 32'hs3E8)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_ready == 1 && sva_checker.erase_failure == 1 |-> $past(sva_checker.erase_command) == 1 && !$past(sva_checker.erase_complete, 32'hs3E8)): PROVED\n"
  },
  {
    "id": "3102",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_447wr056/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lock_acquired == 1'b1 |-> $past(sva_checker.lock_request, 3) && !$past(sva_checker.lock_busy)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.lock_acquired == 1 |-> $past(sva_checker.lock_request, 3) == 1 && $past(sva_checker.lock_busy, 1) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lock_acquired == 1'b1 |-> $past(sva_checker.lock_request, 3) && !$past(sva_checker.lock_busy)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c8drj8j9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.lock_acquired == 1 |-> $past(sva_checker.lock_request, 3) == 1 && $past(sva_checker.lock_busy, 1) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lock_acquired == 1'b1 |-> $past(sva_checker.lock_request, 3) && !$past(sva_checker.lock_busy)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reset_n == 1 && sva_checker.lock_acquired == 1 |-> $past(sva_checker.lock_request, 3) == 1 && $past(sva_checker.lock_busy, 1) == 0): PROVED\n"
  },
  {
    "id": "3108",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_o6e3xng3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rynsmmg_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.underrun_condition |-> $past(sva_checker.fifo_level) < sva_checker.min_threshold && $past(sva_checker.playback_active)): PR"
  },
  {
    "id": "3133",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_kr079jke/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_schedule_error |-> $past(sva_checker.key_expansion) && $past(sva_checker.round_key) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_bypass == 0 && sva_checker.key_schedule_error == 1 |-> $past(sva_checker.key_expansion) == 1 && $past(sva_checker.round_key) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_schedule_error |-> $past(sva_checker.key_expansion) && $past(sva_checker.round_key) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uwgis6xv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_bypass == 0 && sva_checker.key_schedule_error == 1 |-> $past(sva_checker.key_expansion) == 1 && $past(sva_checker.round_key) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_schedule_error |-> $past(sva_checker.key_expansion) && $past(sva_checker.round_key) == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crypto_bypass == 0 && sva_checker.key_schedule_error == 1 |-> $past(sva_checker.key_expansion) == 1 && $past(sva_checker.round_key) == 0): PROVED\n"
  },
  {
    "id": "3141",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_96fdakv6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_bubble_detected == 1'b1 |-> $past(sva_checker.instruction_valid) && !$past(sva_checker.data_hazard_resolved) && sva_checker.stall_condition): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scan_test_mode == 0 && sva_checker.pipeline_bubble_detected == 1'b1 |-> $past(sva_checker.instruction_valid) == 1'b1 && $past(sva_checker.data_hazard_resolved) == 1'b0 && sva_checker.stall_condition == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_bubble_detected == 1'b1 |-> $past(sva_checker.instruction_valid) && !$past(sva_checker.data_hazard_resolved) && sva_checker.stall_condition): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u0x4hehj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scan_test_mode == 0 && sva_checker.pipeline_bubble_detected == 1'b1 |-> $past(sva_checker.instruction_valid) == 1'b1 && $past(sva_checker.data_hazard_resolved) == 1'b0 && sva_checker.stall_condition == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_bubble_detected == 1'b1 |-> $past(sva_checker.instruction_valid) && !$past(sva_checker.data_hazard_resol"
  },
  {
    "id": "3145",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7whbzwof/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.race_condition_detected == 1'b1 |-> $past(sva_checker.signal_a_change) && $past(sva_checker.signal_b_change) && !$past(sva_checker.arbitration_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.race_condition_detected == 1'b1 |-> $past(sva_checker.signal_a_change) && $past(sva_checker.signal_b_change) && !$past(sva_checker.arbitration_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.race_condition_detected == 1'b1 |-> $past(sva_checker.signal_a_change) && $past(sva_checker.signal_b_change) && !$past(sva_checker.arbitration_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fbqv1o6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.race_condition_detected == 1'b1 |-> $past(sva_checker.signal_a_change) && $past(sva_checker.signal_b_change) && !$past(sva_checker.arbitration_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.race_condition_detected == 1'b1 |-> $past(sva_checker.signal_a_change) && $past(sva_checker.signal_b_change) && !$past(sva_checker.arbitration_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_"
  },
  {
    "id": "3144",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_auoi7euj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.load_balancer_switch == 1'b1 |-> $past(sva_checker.server_load[7:0]) > sva_checker.threshold_high && $past(sva_checker.alternate_server_ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.load_balancer_switch == 1 |-> $past(sva_checker.server_load[7:0]) > sva_checker.threshold_high && $past(sva_checker.alternate_server_ready) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.load_balancer_switch == 1'b1 |-> $past(sva_checker.server_load[7:0]) > sva_checker.threshold_high && $past(sva_checker.alternate_server_ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z_dwu11n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.load_balancer_switch == 1 |-> $past(sva_checker.server_load[7:0]) > sva_checker.threshold_high && $past(sva_checker.alternate_server_ready) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.load_balancer_switch == 1'b1 |-> $past(sva_checker.server_load[7:0]) > sva_checker.threshold_high && $past(sva_checker.alternate_server_ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent]"
  },
  {
    "id": "3153",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_hekh6uy4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.electromigration_warning |-> $past(sva_checker.current_density) > sva_checker.em_threshold && $past(sva_checker.operating_hours) > sva_checker.reliability_limit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burn_in_test == 0 && sva_checker.electromigration_warning == 1 |-> $past(sva_checker.current_density) > sva_checker.em_threshold && $past(sva_checker.operating_hours) > sva_checker.reliability_limit): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.electromigration_warning |-> $past(sva_checker.current_density) > sva_checker.em_threshold && $past(sva_checker.operating_hours) > sva_checker.reliability_limit): PROVED\n\n\nBackward: Parsing /tmp/sva_check_f3zy2nm3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burn_in_test == 0 && sva_checker.electromigration_warning == 1 |-> $past(sva_checker.current_density) > sva_checker.em_threshold && $past(sva_checker.operating_hours) > sva_checker.reliability_limit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.electromigration_warning |-> $past(sva_checker.current_density) > sva_checker.em_threshold && $past(sva_c"
  },
  {
    "id": "3168",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_43xjykyb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.node_isolation == 1'b1 |-> !$past(sva_checker.neighbor_alive[3:0]) && $past(sva_checker.heartbeat_timeout)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mesh_shutdown == 0 && sva_checker.node_isolation == 1 |-> $past(sva_checker.neighbor_alive[3:0]) == 0 && $past(sva_checker.heartbeat_timeout) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.node_isolation == 1'b1 |-> !$past(sva_checker.neighbor_alive[3:0]) && $past(sva_checker.heartbeat_timeout)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8shlrwzv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mesh_shutdown == 0 && sva_checker.node_isolation == 1 |-> $past(sva_checker.neighbor_alive[3:0]) == 0 && $past(sva_checker.heartbeat_timeout) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.node_isolation == 1'b1 |-> !$past(sva_checker.neighbor_alive[3:0]) && $past(sva_checker.heartbeat_timeout)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mesh_shutdown == 0 && sva_checker.node_isolation == 1 |-> $past(sva_checker.neighbor_alive[3:0]) == 0 && $past(sva_ch"
  },
  {
    "id": "3237",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nnzehhma/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.single_event_upset_detected == 1'b1 |-> $past(sva_checker.cosmic_ray_strike) && $past(sva_checker.flip_flop_state) != $past(sva_checker.expected_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reliability_test == 0 && sva_checker.single_event_upset_detected == 1 |-> $past(sva_checker.cosmic_ray_strike) == 1 && $past(sva_checker.flip_flop_state) != $past(sva_checker.expected_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.single_event_upset_detected == 1'b1 |-> $past(sva_checker.cosmic_ray_strike) && $past(sva_checker.flip_flop_state) != $past(sva_checker.expected_state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m86etsp9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reliability_test == 0 && sva_checker.single_event_upset_detected == 1 |-> $past(sva_checker.cosmic_ray_strike) == 1 && $past(sva_checker.flip_flop_state) != $past(sva_checker.expected_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.single_event_upset_detected == 1'b1 |-> $past(sva_checker.cosmic_ray_strike) && $past(sva_checker.flip_flop_state) != $past(sva_checker.exp"
  },
  {
    "id": "3255",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_csethyyy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.catalytic_converter_efficiency |-> $past(sva_checker.upstream_oxygen) != $past(sva_checker.downstream_oxygen) && $past(sva_checker.converter_temperature_optimal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.emissions_test_mode == 0 && sva_checker.catalytic_converter_efficiency == 1 |-> $past(sva_checker.upstream_oxygen) != $past(sva_checker.downstream_oxygen) && $past(sva_checker.converter_temperature_optimal) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.catalytic_converter_efficiency |-> $past(sva_checker.upstream_oxygen) != $past(sva_checker.downstream_oxygen) && $past(sva_checker.converter_temperature_optimal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tz0fzk10/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.emissions_test_mode == 0 && sva_checker.catalytic_converter_efficiency == 1 |-> $past(sva_checker.upstream_oxygen) != $past(sva_checker.downstream_oxygen) && $past(sva_checker.converter_temperature_optimal) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.catalytic_converter_efficiency |-> $past(sva_checker.upstream_oxygen) != $pas"
  },
  {
    "id": "3276",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fmoq8lvd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fuel_pump_prime_sequence == 1'b1 |-> $past(sva_checker.ignition_key_on) && !$past(sva_checker.fuel_pressure_buildup, 15) && $past(sva_checker.pump_motor_energized)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dealer_mode == 0 && sva_checker.fuel_pump_prime_sequence == 1'b1 |-> $past(sva_checker.ignition_key_on) == 1'b1 && !$past(sva_checker.fuel_pressure_buildup, 15) && $past(sva_checker.pump_motor_energized) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fuel_pump_prime_sequence == 1'b1 |-> $past(sva_checker.ignition_key_on) && !$past(sva_checker.fuel_pressure_buildup, 15) && $past(sva_checker.pump_motor_energized)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_o7rpaupq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dealer_mode == 0 && sva_checker.fuel_pump_prime_sequence == 1'b1 |-> $past(sva_checker.ignition_key_on) == 1'b1 && !$past(sva_checker.fuel_pressure_buildup, 15) && $past(sva_checker.pump_motor_energized) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fuel_pump_prime_sequence == 1'b1 |-> $past(sva_checker.ignition_key_on) &"
  },
  {
    "id": "3295",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_aroxzdha/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.selective_catalytic_reduction |-> $past(sva_checker.nox_concentration) > sva_checker.emission_limit && $past(sva_checker.urea_injection_rate) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adblue_system_ready == 1 && sva_checker.selective_catalytic_reduction == 1 |-> $past(sva_checker.nox_concentration) > sva_checker.emission_limit && $past(sva_checker.urea_injection_rate) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.selective_catalytic_reduction |-> $past(sva_checker.nox_concentration) > sva_checker.emission_limit && $past(sva_checker.urea_injection_rate) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yiwvru8a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adblue_system_ready == 1 && sva_checker.selective_catalytic_reduction == 1 |-> $past(sva_checker.nox_concentration) > sva_checker.emission_limit && $past(sva_checker.urea_injection_rate) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.selective_catalytic_reduction |-> $past(sva_checker.nox_concentration) > sva_checker.emission_limit && $past(sva_checker.urea_injection_rate) == 0)"
  },
  {
    "id": "3318",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8l0d8sqt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.criticality_safety_margin |-> $past(sva_checker.reactivity_insertion_rate) > sva_checker.max_safe_rate && !$past(sva_checker.negative_reactivity_applied)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.research_reactor_mode == 0 && sva_checker.criticality_safety_margin == 1 |-> $past(sva_checker.reactivity_insertion_rate) > sva_checker.max_safe_rate && $past(sva_checker.negative_reactivity_applied) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.criticality_safety_margin |-> $past(sva_checker.reactivity_insertion_rate) > sva_checker.max_safe_rate && !$past(sva_checker.negative_reactivity_applied)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_phowb_k1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.research_reactor_mode == 0 && sva_checker.criticality_safety_margin == 1 |-> $past(sva_checker.reactivity_insertion_rate) > sva_checker.max_safe_rate && $past(sva_checker.negative_reactivity_applied) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.criticality_safety_margin |-> $past(sva_checker.reactivity_insertion_rate) > sva_checker.max_safe_rate && !"
  },
  {
    "id": "3328",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ztbtavs_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.atmospheric_dispersion_modeling |-> $past(sva_checker.radioactive_release_in_progress) && $past(sva_checker.wind_direction_stability) == sva_checker.unfavorable_conditions): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.weather_monitoring_unavailable == 0 && sva_checker.atmospheric_dispersion_modeling == 1 |-> $past(sva_checker.radioactive_release_in_progress) == 1 && $past(sva_checker.wind_direction_stability) == sva_checker.unfavorable_conditions): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.atmospheric_dispersion_modeling |-> $past(sva_checker.radioactive_release_in_progress) && $past(sva_checker.wind_direction_stability) == sva_checker.unfavorable_conditions): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rcgu4h7p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.weather_monitoring_unavailable == 0 && sva_checker.atmospheric_dispersion_modeling == 1 |-> $past(sva_checker.radioactive_release_in_progress) == 1 && $past(sva_checker.wind_direction_stability) == sva_checker.unfavorable_conditions): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.atmospheric_dis"
  },
  {
    "id": "3329",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0xenvit3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.radioactive_waste_containment |-> $past(sva_checker.container_seal_integrity) && $past(sva_checker.radiation_leakage) > sva_checker.acceptable_background): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.waste_system_operational == 1 && sva_checker.radioactive_waste_containment == 1 |-> $past(sva_checker.container_seal_integrity) == 1 && $past(sva_checker.radiation_leakage) > sva_checker.acceptable_background): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.radioactive_waste_containment |-> $past(sva_checker.container_seal_integrity) && $past(sva_checker.radiation_leakage) > sva_checker.acceptable_background): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qeonkeg1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.waste_system_operational == 1 && sva_checker.radioactive_waste_containment == 1 |-> $past(sva_checker.container_seal_integrity) == 1 && $past(sva_checker.radiation_leakage) > sva_checker.acceptable_background): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.radioactive_waste_containment |-> $past(sva_checker.container_seal_integrity) && $past(sva_checker."
  },
  {
    "id": "3340",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_a0ri_w_4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.plant_cooldown_rate |-> $past(sva_checker.cooldown_rate) > sva_checker.max_cooldown_rate && $past(sva_checker.primary_to_secondary_heat_transfer)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.steam_dump_unavailable == 0 && sva_checker.plant_cooldown_rate == 1 |-> $past(sva_checker.cooldown_rate) > sva_checker.max_cooldown_rate && $past(sva_checker.primary_to_secondary_heat_transfer) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.plant_cooldown_rate |-> $past(sva_checker.cooldown_rate) > sva_checker.max_cooldown_rate && $past(sva_checker.primary_to_secondary_heat_transfer)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_82ja38b2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.steam_dump_unavailable == 0 && sva_checker.plant_cooldown_rate == 1 |-> $past(sva_checker.cooldown_rate) > sva_checker.max_cooldown_rate && $past(sva_checker.primary_to_secondary_heat_transfer) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.plant_cooldown_rate |-> $past(sva_checker.cooldown_rate) > sva_checker.max_cooldown_rate && $past(sva_checker.primary_to_secondary_heat"
  },
  {
    "id": "3361",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_y9xu_nl5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.operator_dose_protection |-> $past(sva_checker.control_room_radiation_level) > sva_checker.habitability_limit && !$past(sva_checker.isolation_mode_activated, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.habitability_system_functional == 1 && sva_checker.operator_dose_protection == 1 |-> $past(sva_checker.control_room_radiation_level) > sva_checker.habitability_limit && $past(sva_checker.isolation_mode_activated, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operator_dose_protection |-> $past(sva_checker.control_room_radiation_level) > sva_checker.habitability_limit && !$past(sva_checker.isolation_mode_activated, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_thwsj4e0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.habitability_system_functional == 1 && sva_checker.operator_dose_protection == 1 |-> $past(sva_checker.control_room_radiation_level) > sva_checker.habitability_limit && $past(sva_checker.isolation_mode_activated, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.operator_dose_protection |-> $past(sva_checker.control_room_r"
  },
  {
    "id": "3365",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check__cia6uxn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.solar_panel_orientation == 1'b1 |-> $past(sva_checker.sun_angle_azimuth) != $past(sva_checker.panel_azimuth_angle) && $past(sva_checker.power_generation_suboptimal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_eclipse == 0 && sva_checker.solar_panel_orientation == 1 |-> $past(sva_checker.sun_angle_azimuth) != $past(sva_checker.panel_azimuth_angle) && $past(sva_checker.power_generation_suboptimal) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.solar_panel_orientation == 1'b1 |-> $past(sva_checker.sun_angle_azimuth) != $past(sva_checker.panel_azimuth_angle) && $past(sva_checker.power_generation_suboptimal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_as8sdpx6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_eclipse == 0 && sva_checker.solar_panel_orientation == 1 |-> $past(sva_checker.sun_angle_azimuth) != $past(sva_checker.panel_azimuth_angle) && $past(sva_checker.power_generation_suboptimal) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.solar_panel_orientation == 1'b1 |-> $past(sva_checker.sun_angle_azimuth) != $past(sva"
  },
  {
    "id": "3421",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_qkjyrt_0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.laser_designation_accuracy |-> $past(sva_checker.target_coordinates_updated) && $past(sva_checker.laser_spot_tracker_error) > sva_checker.designation_tolerance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.targeting_system_fault == 0 && sva_checker.laser_designation_accuracy == 1 |-> $past(sva_checker.target_coordinates_updated) == 1 && $past(sva_checker.laser_spot_tracker_error) > sva_checker.designation_tolerance): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.laser_designation_accuracy |-> $past(sva_checker.target_coordinates_updated) && $past(sva_checker.laser_spot_tracker_error) > sva_checker.designation_tolerance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7qy7v27m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.targeting_system_fault == 0 && sva_checker.laser_designation_accuracy == 1 |-> $past(sva_checker.target_coordinates_updated) == 1 && $past(sva_checker.laser_spot_tracker_error) > sva_checker.designation_tolerance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.laser_designation_accuracy |-> $past(sva_checker.target_coordinates_updated) &&"
  },
  {
    "id": "3428",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_axthrtky/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.periscope_depth_control == 1'b1 |-> $past(sva_checker.hull_pressure_differential) > sva_checker.crush_depth_warning && !$past(sva_checker.ballast_tank_blow_initiated, 7)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.surface_mode == 0 && sva_checker.periscope_depth_control == 1 |-> $past(sva_checker.hull_pressure_differential) > sva_checker.crush_depth_warning && $past(sva_checker.ballast_tank_blow_initiated, 7) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.periscope_depth_control == 1'b1 |-> $past(sva_checker.hull_pressure_differential) > sva_checker.crush_depth_warning && !$past(sva_checker.ballast_tank_blow_initiated, 7)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p09g11mo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.surface_mode == 0 && sva_checker.periscope_depth_control == 1 |-> $past(sva_checker.hull_pressure_differential) > sva_checker.crush_depth_warning && $past(sva_checker.ballast_tank_blow_initiated, 7) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.periscope_depth_control == 1'b1 |-> $past(sva_checker.hull_pressure_different"
  },
  {
    "id": "3431",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_pnqbruvi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.low_light_imaging_system == 1'b1 |-> $past(sva_checker.ambient_light_level) < sva_checker.night_vision_threshold && $past(sva_checker.image_intensifier_gain) == sva_checker.minimum_gain): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.daylight_operations == 0 && sva_checker.low_light_imaging_system == 1 |-> $past(sva_checker.ambient_light_level) < sva_checker.night_vision_threshold && $past(sva_checker.image_intensifier_gain) == sva_checker.minimum_gain): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.low_light_imaging_system == 1'b1 |-> $past(sva_checker.ambient_light_level) < sva_checker.night_vision_threshold && $past(sva_checker.image_intensifier_gain) == sva_checker.minimum_gain): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qjgzrwma/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.daylight_operations == 0 && sva_checker.low_light_imaging_system == 1 |-> $past(sva_checker.ambient_light_level) < sva_checker.night_vision_threshold && $past(sva_checker.image_intensifier_gain) == sva_checker.minimum_gain): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.low_lig"
  },
  {
    "id": "3516",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ucg9iqp_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ore_stockpile_management |-> $past(sva_checker.conveyor_belt_load_sensor) > sva_checker.belt_capacity_limit && !$past(sva_checker.material_flow_diversion_activated, 6)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ore_stockpile_management |-> $past(sva_checker.conveyor_belt_load_sensor) > sva_checker.belt_capacity_limit && $past(sva_checker.material_flow_diversion_activated, 6) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ore_stockpile_management |-> $past(sva_checker.conveyor_belt_load_sensor) > sva_checker.belt_capacity_limit && !$past(sva_checker.material_flow_diversion_activated, 6)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g6gsglvb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ore_stockpile_management |-> $past(sva_checker.conveyor_belt_load_sensor) > sva_checker.belt_capacity_limit && $past(sva_checker.material_flow_diversion_activated, 6) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ore_stockpile_management |-> $past(sva_checker.conveyor_belt_load_sensor) > sva_checker.belt_capacity_limit && !$past(sva_checker.material_flow_d"
  },
  {
    "id": "3538",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_i2ifltls/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underground_coal_extraction == 1'b1 |-> $past(sva_checker.cutting_head_vibration_level) > sva_checker.acceptable_vibration_threshold && !$past(sva_checker.cutting_operation_suspended, 5)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underground_coal_extraction == 1'b1 && sva_checker.cutting_head_inspection_overdue == 1'b0 |-> $past(sva_checker.cutting_head_vibration_level) > sva_checker.acceptable_vibration_threshold && $past(sva_checker.cutting_operation_suspended, 5) == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.underground_coal_extraction == 1'b1 |-> $past(sva_checker.cutting_head_vibration_level) > sva_checker.acceptable_vibration_threshold && !$past(sva_checker.cutting_operation_suspended, 5)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cxt0veib/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underground_coal_extraction == 1'b1 && sva_checker.cutting_head_inspection_overdue == 1'b0 |-> $past(sva_checker.cutting_head_vibration_level) > sva_checker.acceptable_vibration_threshold && $past(sva_checker.cutting_operation_suspended, 5) == 1'b0): ASSUMED\n[sva_checker.assert.2] always"
  },
  {
    "id": "3552",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wna3bsdw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cooling_water_intake_system == 1'b1 |-> $past(sva_checker.pump_suction_pressure) < sva_checker.net_positive_suction_head_required && $past(sva_checker.pump_motor_overload_detected)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pump_cavitation_alarm == 0 && sva_checker.cooling_water_intake_system == 1 |-> $past(sva_checker.pump_suction_pressure) < sva_checker.net_positive_suction_head_required && $past(sva_checker.pump_motor_overload_detected) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cooling_water_intake_system == 1'b1 |-> $past(sva_checker.pump_suction_pressure) < sva_checker.net_positive_suction_head_required && $past(sva_checker.pump_motor_overload_detected)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__q_6ivf3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pump_cavitation_alarm == 0 && sva_checker.cooling_water_intake_system == 1 |-> $past(sva_checker.pump_suction_pressure) < sva_checker.net_positive_suction_head_required && $past(sva_checker.pump_motor_overload_detected) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cooling_water"
  },
  {
    "id": "3592",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_hhk3fdkf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.integrated_pest_management |-> $past(sva_checker.insect_trap_count_threshold_exceeded) && $past(sva_checker.biological_control_agent_release) == sva_checker.release_not_authorized): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pest_monitoring_system_active == 1 && sva_checker.integrated_pest_management == 1 |-> $past(sva_checker.insect_trap_count_threshold_exceeded) == 1 && $past(sva_checker.biological_control_agent_release) == sva_checker.release_not_authorized): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.integrated_pest_management |-> $past(sva_checker.insect_trap_count_threshold_exceeded) && $past(sva_checker.biological_control_agent_release) == sva_checker.release_not_authorized): PROVED\n\n\nBackward: Parsing /tmp/sva_check_893p1yek/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pest_monitoring_system_active == 1 && sva_checker.integrated_pest_management == 1 |-> $past(sva_checker.insect_trap_count_threshold_exceeded) == 1 && $past(sva_checker.biological_control_agent_release) == sva_checker.release_not_authorized): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_"
  },
  {
    "id": "3612",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_xqttdgeb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.precision_seeding_depth_control == 1'b1 |-> $past(sva_checker.soil_compaction_measurement) > sva_checker.optimal_seeding_conditions && $past(sva_checker.planting_depth_adjustment) == sva_checker.no_depth_modification): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.field_preparation_complete == 1 && sva_checker.precision_seeding_depth_control == 1 |-> $past(sva_checker.soil_compaction_measurement) > sva_checker.optimal_seeding_conditions && $past(sva_checker.planting_depth_adjustment) == sva_checker.no_depth_modification): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.precision_seeding_depth_control == 1'b1 |-> $past(sva_checker.soil_compaction_measurement) > sva_checker.optimal_seeding_conditions && $past(sva_checker.planting_depth_adjustment) == sva_checker.no_depth_modification): PROVED\n\n\nBackward: Parsing /tmp/sva_check_onukoy1a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.field_preparation_complete == 1 && sva_checker.precision_seeding_depth_control == 1 |-> $past(sva_checker.soil_compaction_measurement) > sva_checker.optimal_seeding_conditions && $past(sva_checker.planting_depth_adju"
  },
  {
    "id": "3603",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_kym1dzgx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.harbor_depth_maintenance == 1'b1 |-> $past(sva_checker.sediment_contamination_level) > sva_checker.environmental_disposal_threshold && $past(sva_checker.contaminated_material_isolation_procedure_initiated, 9) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.environmental_dredging_permit_suspended == 0 && sva_checker.harbor_depth_maintenance == 1'b1 |-> $past(sva_checker.sediment_contamination_level) > sva_checker.environmental_disposal_threshold && $past(sva_checker.contaminated_material_isolation_procedure_initiated, 9) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.harbor_depth_maintenance == 1'b1 |-> $past(sva_checker.sediment_contamination_level) > sva_checker.environmental_disposal_threshold && $past(sva_checker.contaminated_material_isolation_procedure_initiated, 9) == 1'b0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_63y507gr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.environmental_dredging_permit_suspended == 0 && sva_checker.harbor_depth_maintenance == 1'b1 |-> $past(sva_checker.sediment_contamination_level) > sva_checker.environmental_disposal_threshold && $past(sv"
  },
  {
    "id": "3613",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_3v4f4d8v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.port_facility_access_control == 1'b1 |-> $past(sva_checker.unauthorized_vessel_approach_detected) && $past(sva_checker.security_response_protocol_activation) != sva_checker.threat_assessment_completed): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.maritime_security_alert_level_elevated == 0 && sva_checker.port_facility_access_control == 1 |-> $past(sva_checker.unauthorized_vessel_approach_detected) == 1 && $past(sva_checker.security_response_protocol_activation) != sva_checker.threat_assessment_completed): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.port_facility_access_control == 1'b1 |-> $past(sva_checker.unauthorized_vessel_approach_detected) && $past(sva_checker.security_response_protocol_activation) != sva_checker.threat_assessment_completed): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1ud0w95f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.maritime_security_alert_level_elevated == 0 && sva_checker.port_facility_access_control == 1 |-> $past(sva_checker.unauthorized_vessel_approach_detected) == 1 && $past(sva_checker.security_response_protocol_activation) != sva_checker.threat_assess"
  },
  {
    "id": "3646",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6w_lfw9j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mushroom_production_environmental_control == 1'b1 |-> $past(sva_checker.carbon_dioxide_concentration) != sva_checker.mushroom_growth_optimization_level && $past(sva_checker.humidity_control_system_response) == sva_checker.setpoint_deviation_excessive): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mushroom_production_environmental_control == 1'b1 |-> $past(sva_checker.carbon_dioxide_concentration) != sva_checker.mushroom_growth_optimization_level && $past(sva_checker.humidity_control_system_response) == sva_checker.setpoint_deviation_excessive): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mushroom_production_environmental_control == 1'b1 |-> $past(sva_checker.carbon_dioxide_concentration) != sva_checker.mushroom_growth_optimization_level && $past(sva_checker.humidity_control_system_response) == sva_checker.setpoint_deviation_excessive): PROVED\n\n\nBackward: Parsing /tmp/sva_check_41c51exz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mushroom_production_environmental_control == 1'b1 |-> $past(sva_checker.carbon_dioxide_concentration) != sva_checker.mushroom_growth_optimization_level && $pa"
  },
  {
    "id": "3621",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_b18m_z33/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.food_safety_cold_chain_monitoring == 1'b1 |-> $past(sva_checker.refrigerated_transport_temperature_log) && $past(sva_checker.temperature_excursion_duration) > sva_checker.food_safety_tolerance_time): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.farm_to_market_traceability_system_offline == 0 && sva_checker.food_safety_cold_chain_monitoring == 1 |-> $past(sva_checker.refrigerated_transport_temperature_log) == 1 && $past(sva_checker.temperature_excursion_duration) > sva_checker.food_safety_tolerance_time): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.food_safety_cold_chain_monitoring == 1'b1 |-> $past(sva_checker.refrigerated_transport_temperature_log) && $past(sva_checker.temperature_excursion_duration) > sva_checker.food_safety_tolerance_time): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u3wq_m4z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.farm_to_market_traceability_system_offline == 0 && sva_checker.food_safety_cold_chain_monitoring == 1 |-> $past(sva_checker.refrigerated_transport_temperature_log) == 1 && $past(sva_checker.temperature_excursion_duration) > sva_checker.food_safety_tole"
  },
  {
    "id": "3663",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_6pfgix4o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.extreme_weather_event_preparedness |-> $past(sva_checker.weather_pattern_anomaly_detection) && $past(sva_checker.crop_resilience_measure_effectiveness) < sva_checker.climate_risk_mitigation_adequacy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.climate_change_adaptation_strategy_implementation == 1 && sva_checker.extreme_weather_event_preparedness == 1 |-> $past(sva_checker.weather_pattern_anomaly_detection) == 1 && $past(sva_checker.crop_resilience_measure_effectiveness) < sva_checker.climate_risk_mitigation_adequacy): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.extreme_weather_event_preparedness |-> $past(sva_checker.weather_pattern_anomaly_detection) && $past(sva_checker.crop_resilience_measure_effectiveness) < sva_checker.climate_risk_mitigation_adequacy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0xsl7tc5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.climate_change_adaptation_strategy_implementation == 1 && sva_checker.extreme_weather_event_preparedness == 1 |-> $past(sva_checker.weather_pattern_anomaly_detection) == 1 && $past(sva_checker.crop_resilience_measure_effectiveness) < "
  },
  {
    "id": "3683",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_az11_4ba/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.global_supply_chain_optimization == 1'b1 |-> $past(sva_checker.delivery_schedule_reliability_performance) && $past(sva_checker.transportation_cost_efficiency) < sva_checker.profit_margin_sustainability_requirement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.international_shipping_logistics_coordination == 1 && sva_checker.global_supply_chain_optimization == 1 |-> $past(sva_checker.delivery_schedule_reliability_performance) == 1 && $past(sva_checker.transportation_cost_efficiency) < sva_checker.profit_margin_sustainability_requirement): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.global_supply_chain_optimization == 1'b1 |-> $past(sva_checker.delivery_schedule_reliability_performance) && $past(sva_checker.transportation_cost_efficiency) < sva_checker.profit_margin_sustainability_requirement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z_d4gkik/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.international_shipping_logistics_coordination == 1 && sva_checker.global_supply_chain_optimization == 1 |-> $past(sva_checker.delivery_schedule_reliability_performance) == 1 && $past(sva_checker.transp"
  },
  {
    "id": "3771",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_tt3l0qy9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.plumbing_pressure_test_protocol |-> $past(sva_checker.pipe_joint_integrity_inspection_completion) && $past(sva_checker.water_pressure_test_duration_adequate) && $past(sva_checker.leak_detection_sensitivity) == sva_checker.detection_threshold_insufficient): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.water_supply_connection_authorized == 1 && sva_checker.plumbing_pressure_test_protocol == 1 |-> $past(sva_checker.pipe_joint_integrity_inspection_completion) == 1 && $past(sva_checker.water_pressure_test_duration_adequate) == 1 && $past(sva_checker.leak_detection_sensitivity) == sva_checker.detection_threshold_insufficient): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.plumbing_pressure_test_protocol |-> $past(sva_checker.pipe_joint_integrity_inspection_completion) && $past(sva_checker.water_pressure_test_duration_adequate) && $past(sva_checker.leak_detection_sensitivity) == sva_checker.detection_threshold_insufficient): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6h63mqhh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.water_supply_connection_authorized == 1 && sva_checker.plumbing_pressure_tes"
  },
  {
    "id": "3751",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_vp_4j_bc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.climate_resilient_tourism_planning == 1'b1 |-> $past(sva_checker.climate_impact_vulnerability_assessment) && $past(sva_checker.adaptation_measure_implementation_readiness) && $past(sva_checker.climate_resilience_tourism_infrastructure_development) == sva_checker.climate_change_mitigation_tourism_sector_contribution_insufficient): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.climate_resilient_tourism_planning == 1'b1 && sva_checker.climate_change_tourism_adaptation_strategy_development == 1'b0 |-> $past(sva_checker.climate_impact_vulnerability_assessment) == 1'b1 && $past(sva_checker.climate_resilience_tourism_infrastructure_development) == sva_checker.climate_change_mitigation_tourism_sector_contribution_insufficient): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.climate_resilient_tourism_planning == 1'b1 |-> $past(sva_checker.climate_impact_vulnerability_assessment) && $past(sva_checker.adaptation_measure_implementation_readiness) && $past(sva_checker.climate_resilience_tourism_infrastructure_development) == sva_checker.climate_change_mitigation_tourism_sector_contribution_insufficient): PROVED\n\n\nBackward: Parsing /tmp/sva_check_73tlymr9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found wit"
  },
  {
    "id": "3821",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_liq9jn5s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.game_asset_streaming == 1'b1 |-> $past(sva_checker.asset_loading_priority_queue_management) && $past(sva_checker.memory_usage_optimization_strategy) && $past(sva_checker.streaming_performance_efficiency) != sva_checker.seamless_gameplay_experience_maintenance): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bandwidth_optimization_algorithm_disabled == 0 && sva_checker.game_asset_streaming == 1 |-> $past(sva_checker.asset_loading_priority_queue_management) == 1 && $past(sva_checker.memory_usage_optimization_strategy) == 1 && $past(sva_checker.streaming_performance_efficiency) != sva_checker.seamless_gameplay_experience_maintenance): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.game_asset_streaming == 1'b1 |-> $past(sva_checker.asset_loading_priority_queue_management) && $past(sva_checker.memory_usage_optimization_strategy) && $past(sva_checker.streaming_performance_efficiency) != sva_checker.seamless_gameplay_experience_maintenance): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8qg50qtt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bandwidth_optimization_algorithm_disabled == 0 && sva_checker."
  },
  {
    "id": "3863",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_uyf2m5zx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.neutron_scattering_experiment |-> $past(sva_checker.neutron_beam_collimation_accuracy) && $past(sva_checker.sample_positioning_precision) && $past(sva_checker.scattering_pattern_resolution) < sva_checker.experimental_data_quality_requirement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.neutron_flux_monitoring_system_fault == 0 && sva_checker.neutron_scattering_experiment == 1 |-> $past(sva_checker.neutron_beam_collimation_accuracy) == 1 && $past(sva_checker.sample_positioning_precision) == 1 && $past(sva_checker.scattering_pattern_resolution) < sva_checker.experimental_data_quality_requirement): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.neutron_scattering_experiment |-> $past(sva_checker.neutron_beam_collimation_accuracy) && $past(sva_checker.sample_positioning_precision) && $past(sva_checker.scattering_pattern_resolution) < sva_checker.experimental_data_quality_requirement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5vz6gj8f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.neutron_flux_monitoring_system_fault == 0 && sva_checker.neutron_scattering_experiment == 1 |-> $past(sva_checker"
  },
  {
    "id": "3883",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_68i9cszd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.high_energy_particle_collision == 1'b1 |-> $past(sva_checker.beam_energy_ramping_profile) && $past(sva_checker.magnetic_field_synchronization) && $past(sva_checker.collision_luminosity_achievement) < sva_checker.target_interaction_rate): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.beam_injection_system_ready == 1 && sva_checker.high_energy_particle_collision == 1 |-> $past(sva_checker.beam_energy_ramping_profile) == 1 && $past(sva_checker.magnetic_field_synchronization) == 1 && $past(sva_checker.collision_luminosity_achievement) < sva_checker.target_interaction_rate): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.high_energy_particle_collision == 1'b1 |-> $past(sva_checker.beam_energy_ramping_profile) && $past(sva_checker.magnetic_field_synchronization) && $past(sva_checker.collision_luminosity_achievement) < sva_checker.target_interaction_rate): PROVED\n\n\nBackward: Parsing /tmp/sva_check_k1rzbdfe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.beam_injection_system_ready == 1 && sva_checker.high_energy_particle_collision == 1 |-> $past(sva_checker.beam_energy_ramping_profile) == 1 && $past"
  },
  {
    "id": "3892",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e8sevnxz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.high_field_nmr_spectroscopy |-> $past(sva_checker.magnetic_field_uniformity_measurement) && $past(sva_checker.rf_pulse_sequence_calibration_accuracy) && $past(sva_checker.spectral_resolution_enhancement) == sva_checker.molecular_structure_analysis_precision_inadequacy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.high_field_nmr_spectroscopy |-> $past(sva_checker.magnetic_field_uniformity_measurement) && $past(sva_checker.rf_pulse_sequence_calibration_accuracy) && $past(sva_checker.spectral_resolution_enhancement) == sva_checker.molecular_structure_analysis_precision_inadequacy): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.high_field_nmr_spectroscopy |-> $past(sva_checker.magnetic_field_uniformity_measurement) && $past(sva_checker.rf_pulse_sequence_calibration_accuracy) && $past(sva_checker.spectral_resolution_enhancement) == sva_checker.molecular_structure_analysis_precision_inadequacy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_unxz63jr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.high_field_nmr_spectroscopy |-> $past(sva_checker.magnetic_field_uniformity_measurement) && $past(sva_ch"
  },
  {
    "id": "3893",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ambxj7hm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.high_field_magnet_operation == 1'b1 |-> $past(sva_checker.superconducting_wire_current_density, 1) > sva_checker.critical_current_threshold && $past(sva_checker.magnet_quench_detection_response, 2) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quench_protection_system_armed == 0 && sva_checker.high_field_magnet_operation == 1'b1 |-> $past(sva_checker.superconducting_wire_current_density, 1) > sva_checker.critical_current_threshold && $past(sva_checker.magnet_quench_detection_response, 2) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.high_field_magnet_operation == 1'b1 |-> $past(sva_checker.superconducting_wire_current_density, 1) > sva_checker.critical_current_threshold && $past(sva_checker.magnet_quench_detection_response, 2) == 1'b0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j_yx5ppg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quench_protection_system_armed == 0 && sva_checker.high_field_magnet_operation == 1'b1 |-> $past(sva_checker.superconducting_wire_current_density, 1) > sva_checker.critical_current_threshold && $past(sva_checker.magnet_quench_detection_response,"
  },
  {
    "id": "3969",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0kok89mc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.interplanetary_communication == 1'b1 |-> $past(sva_checker.signal_transmission_power_optimization) && $past(sva_checker.data_compression_efficiency_maximization) && $past(sva_checker.communication_link_reliability) < sva_checker.mission_critical_data_transmission_requirement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.deep_space_network_antenna_maintenance == 0 && sva_checker.interplanetary_communication == 1 |-> $past(sva_checker.signal_transmission_power_optimization) == 1 && $past(sva_checker.data_compression_efficiency_maximization) == 1 && $past(sva_checker.communication_link_reliability) < sva_checker.mission_critical_data_transmission_requirement): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.interplanetary_communication == 1'b1 |-> $past(sva_checker.signal_transmission_power_optimization) && $past(sva_checker.data_compression_efficiency_maximization) && $past(sva_checker.communication_link_reliability) < sva_checker.mission_critical_data_transmission_requirement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kam7tl_6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.deep_space_networ"
  },
  {
    "id": "304_3_0007",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_utood8mh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ua1b32l5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.irq_high || sva_checker.irq_low) && !sva_checker.int_mask |-> (##1 sva_checker.int_ack)): PROVED\n"
  },
  {
    "id": "3992",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_irq9xhtb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cardiac_rhythm_management |-> $past(sva_checker.intrinsic_heart_rate_detection_sensitivity) && $past(sva_checker.pacing_threshold_adjustment_accuracy) < sva_checker.cardiac_stimulation_safety_margin): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.heart_rhythm_sensing_reliability_verified == 1 && sva_checker.cardiac_rhythm_management == 1 |-> $past(sva_checker.intrinsic_heart_rate_detection_sensitivity) == 1 && $past(sva_checker.pacing_threshold_adjustment_accuracy) < sva_checker.cardiac_stimulation_safety_margin): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cardiac_rhythm_management |-> $past(sva_checker.intrinsic_heart_rate_detection_sensitivity) && $past(sva_checker.pacing_threshold_adjustment_accuracy) < sva_checker.cardiac_stimulation_safety_margin): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zvipjvmf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.heart_rhythm_sensing_reliability_verified == 1 && sva_checker.cardiac_rhythm_management == 1 |-> $past(sva_checker.intrinsic_heart_rate_detection_sensitivity) == 1 && $past(sva_checker.pacing_threshold_adjustment_accuracy) < sva_checker.cardi"
  },
  {
    "id": "4051",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q4x3t1l5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.continuous_health_monitoring == 1'b1 |-> $past(sva_checker.physiological_parameter_measurement_accuracy) && $past(sva_checker.health_trend_analysis_predictive_capability) < sva_checker.preventive_healthcare_intervention_timing_optimization): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.continuous_health_monitoring == 1'b1 |-> $past(sva_checker.physiological_parameter_measurement_accuracy) && $past(sva_checker.health_trend_analysis_predictive_capability) < sva_checker.preventive_healthcare_intervention_timing_optimization): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.continuous_health_monitoring == 1'b1 |-> $past(sva_checker.physiological_parameter_measurement_accuracy) && $past(sva_checker.health_trend_analysis_predictive_capability) < sva_checker.preventive_healthcare_intervention_timing_optimization): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tuncqz73/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.continuous_health_monitoring == 1'b1 |-> $past(sva_checker.physiological_parameter_measurement_accuracy) && $past(sva_checker.health_trend_analysis_predictive_capability) < sva_checker.preven"
  },
  {
    "id": "310_7_0093",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fdfonu55/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7p_9jtrr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.async_rst_n == 0 |-> $stable(sva_checker.sync_rst_n)): PROVED\n"
  },
  {
    "id": "3995",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wm9csowr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.near_light_speed_travel == 1'b1 |-> $past(sva_checker.relativistic_propulsion_system_performance_validation) && $past(sva_checker.time_synchronization_protocol_effectiveness) && $past(sva_checker.interstellar_travel_time_optimization) != sva_checker.relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.relativistic_effects_calculation_uncertainty_excessive == 0 && sva_checker.near_light_speed_travel == 1 |-> $past(sva_checker.relativistic_propulsion_system_performance_validation) == 1 && $past(sva_checker.time_synchronization_protocol_effectiveness) == 1 && $past(sva_checker.interstellar_travel_time_optimization) != sva_checker.relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.near_light_speed_travel == 1'b1 |-> $past(sva_checker.relativistic_propulsion_system_performance_validation) && $past(sva_checker.time_synchronization_protocol_effectiveness) && $past(sva_checker.interstellar_travel_time_optimization) != sva_checker.relativistic_space_travel_feasibility_demonstration_objective_fulfillment_confirmation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qja5tuaq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path"
  },
  {
    "id": "327_3_0207",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_rljkmzod/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.int_pending && (sva_checker.global_en || sva_checker.local_en) |-> sva_checker.int_effective): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.int_pending == 1 && (sva_checker.global_en == 1 || sva_checker.local_en == 1) |-> sva_checker.int_effective == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.int_pending && (sva_checker.global_en || sva_checker.local_en) |-> sva_checker.int_effective): PROVED\n\n\nBackward: Parsing /tmp/sva_check_99zqw3l1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.int_pending == 1 && (sva_checker.global_en == 1 || sva_checker.local_en == 1) |-> sva_checker.int_effective == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.int_pending && (sva_checker.global_en || sva_checker.local_en) |-> sva_checker.int_effective): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.int_pending == 1 && (sva_checker.global_en == 1 || sva_checker.local_en == 1) |-> sva_checker.int_effective == 1): PROVED\n"
  },
  {
    "id": "335_7_0285",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dsz0k8vd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j237xbpr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> $stable(sva_checker.bus_ack)): PROVED\n"
  },
  {
    "id": "336_2_0299",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_n0l4t2qa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] && !(sva_checker.direct_boot || sva_checker.secure_boot) |=> $fell(sva_checker.boot_sel[0])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1 && sva_checker.direct_boot == 0 && sva_checker.secure_boot == 0 |-> (##1 sva_checker.boot_sel[0] == 0 && $past(sva_checker.boot_sel[0]) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] && !(sva_checker.direct_boot || sva_checker.secure_boot) |=> $fell(sva_checker.boot_sel[0])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gp9m8v5f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1 && sva_checker.direct_boot == 0 && sva_checker.secure_boot == 0 |-> (##1 sva_checker.boot_sel[0] == 0 && $past(sva_checker.boot_sel[0]) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] && !(sva_checker.direct_boot || sva_checker.secure_boot) |=> $fell(sva_checker.boot_sel[0])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1 && sva_checker.direct_boot == 0 && sva_checker.secure_boot == 0 |-> (##"
  },
  {
    "id": "353_10_0421",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vpsn_bkz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !xor(sva_checker.cal_done, sva_checker.cal_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.cal_done == sva_checker.cal_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !xor(sva_checker.cal_done, sva_checker.cal_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ky6wbjm4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.cal_done == sva_checker.cal_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !xor(sva_checker.cal_done, sva_checker.cal_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.cal_done == sva_checker.cal_valid): PROVED\n"
  },
  {
    "id": "349_7_0397",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_crqy8cgl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##1 sva_checker.ack_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A == 1 && sva_checker.trigger_B == 1 && sva_checker.threshold_exceed == 1 |-> (##1 sva_checker.ack_received == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##1 sva_checker.ack_received)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_70yi1p36/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A == 1 && sva_checker.trigger_B == 1 && sva_checker.threshold_exceed == 1 |-> (##1 sva_checker.ack_received == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##1 sva_checker.ack_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trigger_A == 1 && sva_checker.trigger_B == 1 && sva_checker.threshold_exceed == 1 |-> (##1 sva_checker.ack_received == 1)): PROVED\n"
  },
  {
    "id": "361_1_0485",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z8r9v0o_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_th8i_4qk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_valid == 1'b1 |-> xor(sva_checker.crc_result, sva_checker.golden_crc) == 0): PROVED\n"
  },
  {
    "id": "362_9_0509",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zsfi2t4h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parity_err && sva_checker.timeout_err |-> sva_checker.global_err_int): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parity_err == 1 && sva_checker.timeout_err == 1 |-> sva_checker.global_err_int == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parity_err && sva_checker.timeout_err |-> sva_checker.global_err_int): PROVED\n\n\nBackward: Parsing /tmp/sva_check_244na9bx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parity_err == 1 && sva_checker.timeout_err == 1 |-> sva_checker.global_err_int == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parity_err && sva_checker.timeout_err |-> sva_checker.global_err_int): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parity_err == 1 && sva_checker.timeout_err == 1 |-> sva_checker.global_err_int == 1): PROVED\n"
  },
  {
    "id": "368_8_0556",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fagr5c0o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup || sva_checker.rtc_wakeup || sva_checker.comm_wakeup |-> (##[1:3] sva_checker.system_wakeup)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup == 1 || sva_checker.rtc_wakeup == 1 || sva_checker.comm_wakeup == 1 |-> (##[1:3] sva_checker.system_wakeup == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup || sva_checker.rtc_wakeup || sva_checker.comm_wakeup |-> (##[1:3] sva_checker.system_wakeup)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ux2iht5t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup == 1 || sva_checker.rtc_wakeup == 1 || sva_checker.comm_wakeup == 1 |-> (##[1:3] sva_checker.system_wakeup == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup || sva_checker.rtc_wakeup || sva_checker.comm_wakeup |-> (##[1:3] sva_checker.system_wakeup)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_wakeup == 1 || sva_checker.rtc_wakeup == 1 || sva_checker.comm_wakeup == 1 |-> (##[1:3] sva_checker.system_wakeup == 1)): PROVED\n"
  },
  {
    "id": "370_1_0572",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f4rdn5bg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7fjx6dzk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.even_parity) |-> sva_checker.odd_parity != sva_checker.even_parity): PROVED\n"
  },
  {
    "id": "379_4_0673",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_eirm_k8i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.rst_n || !sva_checker.scramble_en || xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.scramble_en == 1 |-> xor(sva_checker.raw_data, sva_checker.scrambler_out) == sva_checker.poly): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.rst_n || !sva_checker.scramble_en || xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qgh2fi6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.scramble_en == 1 |-> xor(sva_checker.raw_data, sva_checker.scrambler_out) == sva_checker.poly): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.rst_n || !sva_checker.scramble_en || xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.scramble_en == 1 |-> xor(sva_checker.raw_data, sva_checker.scrambler_out) == sva_checker.poly): PROVED\n"
  },
  {
    "id": "379_6_0662",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_sgsefkga/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scramble_en == 1'b1 |-> (xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly) and ((##1 sva_checker.scramble_en) |-> xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scramble_en == 1'b1 |-> xor(sva_checker.raw_data, sva_checker.scrambler_out) == sva_checker.poly): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scramble_en == 1'b1 |-> (xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly) and ((##1 sva_checker.scramble_en) |-> xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly)))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ikxq_lb8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scramble_en == 1'b1 |-> xor(sva_checker.raw_data, sva_checker.scrambler_out) == sva_checker.poly): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scramble_en == 1'b1 |-> (xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.poly) and ((##1 sva_checker.scramble_en) |-> xor(sva_checker.raw_data, sva_checker.scrambler_out == sva_checker.pol"
  },
  {
    "id": "380_3_0688",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ri1swzrg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |=> sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |-> (##1 sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |=> sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yxouqjjl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |-> (##1 sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |=> sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.wdt_expire |-> (##1 sva_checker.wdt_timeout || $past(!sva_checker.wdt_expire))): PROVED\n"
  },
  {
    "id": "384_1_0691",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_c_az13u5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> !sva_checker.reg_write): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> sva_checker.reg_write == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> !sva_checker.reg_write): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dr2974jb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> sva_checker.reg_write == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> !sva_checker.reg_write): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cfg_lock) |-> sva_checker.reg_write == 0): PROVED\n"
  },
  {
    "id": "385_7_0712",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_59d_jdg7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8_os6y6l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) xor(sva_checker.bus_request, sva_checker.bus_grant) && !$stable(sva_checker.bus_grant) |-> sva_checker.bus_ack == 1): PROVED\n"
  },
  {
    "id": "385_8_0717",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p_mf57k9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant), 1) |-> sva_checker.bus_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> sva_checker.bus_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant), 1) |-> sva_checker.bus_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fzrthi1m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> sva_checker.bus_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant), 1) |-> sva_checker.bus_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(xor(sva_checker.bus_request, sva_checker.bus_grant)) |-> sva_checker.bus_ack == 1): PROVED\n"
  },
  {
    "id": "393_4_0764",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_b9pvsm5y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> !sva_checker.untrusted_access): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> sva_checker.untrusted_access == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> !sva_checker.untrusted_access): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vqovrkob/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> sva_checker.untrusted_access == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> !sva_checker.untrusted_access): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.secure_region) |-> sva_checker.untrusted_access == 0): PROVED\n"
  },
  {
    "id": "394_1_0762",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_l429g42n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) xor(sva_checker.core_1_result, sva_checker.core_2_result) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.core_1_result == sva_checker.core_2_result): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) xor(sva_checker.core_1_result, sva_checker.core_2_result) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e3sgl86x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.core_1_result == sva_checker.core_2_result): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) xor(sva_checker.core_1_result, sva_checker.core_2_result) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.core_1_result == sva_checker.core_2_result): PROVED\n"
  },
  {
    "id": "394_6_0784",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_o_2w2ehg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zi5dqanb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.core_1_result) |-> !$changed(sva_checker.core_2_result)): PROVED\n"
  },
  {
    "id": "399_6_0841",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |=> (##2 sva_checker.response_signal)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##2 sva_checker.response_signal)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_0jxcvxw8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##2 sva_checker.response_signal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |=> (##2 sva_checker.response_signal)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##2 sva_checker.response_signal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vad7wqqg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |=> (##2 sva_checker.response_signal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |-> (##2 sva_checker.response_signal)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed |=> (##2 sva_checker.response_signal)): PROVED\n"
  },
  {
    "id": "401_3_0848",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9pg66j4q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode && !sva_checker.normal_mode && !sva_checker.test_mode): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode == 1 && sva_checker.normal_mode == 0 && sva_checker.test_mode == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode && !sva_checker.normal_mode && !sva_checker.test_mode): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dchk40pm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode == 1 && sva_checker.normal_mode == 0 && sva_checker.test_mode == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode && !sva_checker.normal_mode && !sva_checker.test_mode): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mode_sel == 2'b10 |-> sva_checker.debug_mode == 1 && sva_checker.normal_mode == 0 && sva_checker.test_mode == 0): PROVED\n"
  },
  {
    "id": "428_8_1047",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_egfpni1p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active && !sva_checker.bus_transfer_done |-> sva_checker.transfer_count[5:0] != 6'b000000): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active == 1 && sva_checker.bus_transfer_done == 0 |-> sva_checker.transfer_count[5:0] != 6'b000000): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active && !sva_checker.bus_transfer_done |-> sva_checker.transfer_count[5:0] != 6'b000000): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ghbnpj2c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active == 1 && sva_checker.bus_transfer_done == 0 |-> sva_checker.transfer_count[5:0] != 6'b000000): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active && !sva_checker.bus_transfer_done |-> sva_checker.transfer_count[5:0] != 6'b000000): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_transfer_active == 1 && sva_checker.bus_transfer_done == 0 |-> sva_checker.transfer_count[5:0] != 6'b000000): PROVED\n"
  },
  {
    "id": "436_5_1106",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z4y1y3lb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.aes_round_en_i |=> sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.aes_round_en_i == 0 |-> (##1 sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.aes_round_en_i |=> sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__og4sv9m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.aes_round_en_i == 0 |-> (##1 sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.aes_round_en_i |=> sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.aes_round_en_i == 0 |-> (##1 sva_checker.aes_round_cnt_o == $past(sva_checker.aes_round_cnt_o))): PROVED\n"
  },
  {
    "id": "479_2_1473",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_egt4yyn2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ebj0w3_x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.pn_sequence) |-> (##[100:32'hs1F4] $rose(sva_checker.decoder_lock))): PROVED\n"
  },
  {
    "id": "483_5_1494",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Internal tool crash. The SVA may contain unsupported constructs.",
    "log": "Parsing /tmp/sva_check_x_7jblcz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: rewrite_sva_sequence.cpp:105 function: admits_empty\nCondition: false\nReason: unexpected SVA sequence: sva_sequence_throughout\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x7fb520]\n[0x7fb9e8]\n[0x835715]\n[0x82989e]\n[0x828d03]\n[0x828d03]\n[0x826d81]\n[0x82be79]\n[0x82c257]\n[0x4b9820]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "502_6_0078",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kma_xdyn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_cmd) |-> (##2 (sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n) ##2 sva_checker.burst_term)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_cmd) |-> (##2 (((sva_checker.cas_n ##[2:8] sva_checker.ras_n) [*4]) ##2 sva_checker.burst_term))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_cmd) |-> (##2 (sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n) ##2 sva_checker.burst_term)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_clusbq6_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_cmd) |-> (##2 (((sva_checker.cas_n ##[2:8] sva_checker.ras_n) [*4]) ##2 sva_checker.burst_term))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_cmd) |-> (##2 (sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_checker.ras_n ##1 sva_checker.cas_n ##[2:8] sva_ch"
  },
  {
    "id": "503_2_0016",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fhr67ois/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mhxxyr3k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.header_valid == 1'b1 |-> (##[1:2] sva_checker.data_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "515_8_0116",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_k1d9mn_0/sva_checker.sv line 28: syntax error, unexpected ';', expecting ')' before ';'",
    "log": "Parsing /tmp/sva_check_k1d9mn_0/sva_checker.sv\nfile /tmp/sva_check_k1d9mn_0/sva_checker.sv line 28: syntax error, unexpected ';', expecting ')' before ';'\n"
  },
  {
    "id": "574_4_0505",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hhfxn3f0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9dtvep92/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_mul) && sva_checker.simd_mul |-> sva_checker.simd_result == sva_checker.src0 * sva_checker.src1): PROVED\n"
  },
  {
    "id": "521_10_0163",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_capahsgv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load [*9]) ##1 sva_checker.pool_en) [*3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load == 1'b1 [*9]) ##1 sva_checker.pool_en == 1'b1) [*3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load [*9]) ##1 sva_checker.pool_en) [*3]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rjy9zjtd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load == 1'b1 [*9]) ##1 sva_checker.pool_en == 1'b1) [*3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load [*9]) ##1 sva_checker.pool_en) [*3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1'b1 |-> (##2 (((sva_checker.weight_load == 1'b1 [*9]) ##1 sva_checker.pool_en == 1'b1) [*3]))): PROVED\n"
  },
  {
    "id": "590_5_0660",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7r7348rq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_amoosjw_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.src0_data) |-> (##[1:2] $rose(sva_checker.simd_cmp))): PROVED\n"
  },
  {
    "id": "597_10_0711",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ty_3mouj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1gpgewkc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_thread_issue) |-> $countones(sva_checker.thread_id ^ sva_checker.thread_id - 1) == 1): PROVED\n"
  },
  {
    "id": "602_6_0738",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2mytjay8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.illegal_opcode)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 sva_checker.illegal_opcode == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.illegal_opcode)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q1itywrn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 sva_checker.illegal_opcode == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.illegal_opcode)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 sva_checker.illegal_opcode == 0)): PROVED\n"
  },
  {
    "id": "603_5_0763",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z2a7oxdf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e7ut_3sa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_priority) |-> !$past(sva_checker.simd_issue)): PROVED\n"
  },
  {
    "id": "615_4_0833",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vbss78d4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): PROVED\n\n\nBackward: Parsing /tmp/sva_check_szca0c03/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_ewidth_set) |-> sva_checker.ewidth_cfg == 64): PROVED\n"
  },
  {
    "id": "615_5_0859",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_07016d3r/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_07016d3r/sva_checker.sv\nfile /tmp/sva_check_07016d3r/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "620_5_0898",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bifx34pw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n7woe1qa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write && sva_checker.segment_idx >= sva_checker.NUM_SEGMENT |=> $fell(sva_checker.simd_segment_write)): PROVED\n"
  },
  {
    "id": "623_2_0930",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_exu4s7j2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.valid_in |=> sva_checker.batchnorm_out == $past(sva_checker.scale * sva_checker.input_data + sva_checker.bias, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.valid_in == 1 |-> (##1 sva_checker.batchnorm_out == $past(sva_checker.scale * sva_checker.input_data + sva_checker.bias))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.valid_in |=> sva_checker.batchnorm_out == $past(sva_checker.scale * sva_checker.input_data + sva_checker.bias, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__qa4fd7m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.valid_in == 1 |-> (##1 sva_checker.batchnorm_out == $past(sva_checker.scale * sva_checker.input_data + sva_checker.bias))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.valid_in |=> sva_checker.batchnorm_out == $past(sva_checker.scale * sva_checker.input_data + sva_checker.bias, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && sva_checker.valid_in == 1 |-> (##1 sva_checker.batchnorm_out == $p"
  },
  {
    "id": "636_5_1021",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_c3i9x400/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "637_4_1023",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a8dro4nn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active && !sva_checker.can_error_flag |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active == 1 && sva_checker.can_error_flag == 0 |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active && !sva_checker.can_error_flag |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ep7f_ijf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active == 1 && sva_checker.can_error_flag == 0 |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active && !sva_checker.can_error_flag |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_frame_active == 1 && sva_checker.can_error_flag == 0 |-> sva_checker.can_len <= sva_checker.CAN_MAX_LEN): PROVED\n"
  },
  {
    "id": "647_5_1123",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cik6esce/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant |-> $past(sva_checker.thread_context_saved, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant == 1 |-> $past(sva_checker.thread_context_saved, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant |-> $past(sva_checker.thread_context_saved, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6azgugyb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant == 1 |-> $past(sva_checker.thread_context_saved, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant |-> $past(sva_checker.thread_context_saved, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thread_switch_grant == 1 |-> $past(sva_checker.thread_context_saved, 1) == 1): PROVED\n"
  },
  {
    "id": "651_4_1171",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xgcw98ko/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> !sva_checker.credit_inc): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> sva_checker.credit_inc == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> !sva_checker.credit_inc): PROVED\n\n\nBackward: Parsing /tmp/sva_check_10zdp7b1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> sva_checker.credit_inc == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> !sva_checker.credit_inc): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.credit_cnt == sva_checker.MAX_CREDIT |-> sva_checker.credit_inc == 0): PROVED\n"
  },
  {
    "id": "648_6_1120",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gx7gl1ax/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mul_in1_unsigned || sva_checker.mul_in2_unsigned |-> sva_checker.mul_result <= sva_checker.MUL_MAX_UNSIGNED && sva_checker.mul_result >= 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && (sva_checker.mul_in1_unsigned == 1 || sva_checker.mul_in2_unsigned == 1) |-> sva_checker.mul_result <= sva_checker.MUL_MAX_UNSIGNED && sva_checker.mul_result >= 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mul_in1_unsigned || sva_checker.mul_in2_unsigned |-> sva_checker.mul_result <= sva_checker.MUL_MAX_UNSIGNED && sva_checker.mul_result >= 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oowqe9kh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_n == 1 && (sva_checker.mul_in1_unsigned == 1 || sva_checker.mul_in2_unsigned == 1) |-> sva_checker.mul_result <= sva_checker.MUL_MAX_UNSIGNED && sva_checker.mul_result >= 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mul_in1_unsigned || sva_checker.mul_in2_unsigned |-> sva_checker.mul_result <= sva_checker.MUL_MAX_UNSIGNED && sva_checker.mul_result >= 0): PROVED up to bound 20\n[sva_checker.cover_antecedent]"
  },
  {
    "id": "653_7_1174",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w3jwzws7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |=> $onehot(sva_checker.vc_sel)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |-> (##1 $onehot(sva_checker.vc_sel))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |=> $onehot(sva_checker.vc_sel)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7ime1ve2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |-> (##1 $onehot(sva_checker.vc_sel))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |=> $onehot(sva_checker.vc_sel)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_end == 1'b1 |-> (##1 $onehot(sva_checker.vc_sel))): PROVED\n"
  },
  {
    "id": "652_5_1181",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9egydkdw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_valid |-> sva_checker.tlp_fmt[1:0] == sva_checker.tlp_type[1:0] && sva_checker.tlp_length[9:0] == sva_checker.tlp_dw_count[9:0]): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_valid == 1 |-> sva_checker.tlp_fmt[1:0] == sva_checker.tlp_type[1:0] && sva_checker.tlp_length[9:0] == sva_checker.tlp_dw_count[9:0]): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_valid |-> sva_checker.tlp_fmt[1:0] == sva_checker.tlp_type[1:0] && sva_checker.tlp_length[9:0] == sva_checker.tlp_dw_count[9:0]): PROVED\n\n\nBackward: Parsing /tmp/sva_check_irqriff8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_valid == 1 |-> sva_checker.tlp_fmt[1:0] == sva_checker.tlp_type[1:0] && sva_checker.tlp_length[9:0] == sva_checker.tlp_dw_count[9:0]): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_valid |-> sva_checker.tlp_fmt[1:0] == sva_checker.tlp_type[1:0] && sva_checker.tlp_length[9:0] == sva_checker.tlp_dw_count[9:0]): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_header_va"
  },
  {
    "id": "657_10_1216",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w0ucpui7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |=> sva_checker.channel_gain <= sva_checker.MAX_GAIN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |-> (##1 sva_checker.channel_gain <= sva_checker.MAX_GAIN)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |=> sva_checker.channel_gain <= sva_checker.MAX_GAIN): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7upts55r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |-> (##1 sva_checker.channel_gain <= sva_checker.MAX_GAIN)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |=> sva_checker.channel_gain <= sva_checker.MAX_GAIN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.channel_gain == sva_checker.MIN_GAIN |-> (##1 sva_checker.channel_gain <= sva_checker.MAX_GAIN)): PROVED\n"
  },
  {
    "id": "663_1_1256",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__83qstbl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_voltage >= sva_checker.V_SET_MIN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.write_voltage >= sva_checker.V_SET_MIN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_voltage >= sva_checker.V_SET_MIN): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ylynxmil/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.write_voltage >= sva_checker.V_SET_MIN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_voltage >= sva_checker.V_SET_MIN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 1 |-> sva_checker.write_voltage >= sva_checker.V_SET_MIN): PROVED\n"
  },
  {
    "id": "658_4_1210",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_h197fyqd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4wc4si2_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ldpc_check_start == 1'b1 |-> (##[1:100] sva_checker.ldpc_check_done == 1'b1 && sva_checker.ldpc_check_status == 1'b1)): PROVED\n"
  },
  {
    "id": "666_10_1314",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vf1tl5cg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2w_z6umd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_mode == sva_checker.LOW_POWER |-> sva_checker.sparse_ratio <= sva_checker.MAX_SPARSE): PROVED\n"
  },
  {
    "id": "673_7_1370",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_72j88ydy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "676_3_1391",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_qkz3hgns/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "677_3_1386",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |-> $stable(sva_checker.batchnorm_param)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |=> $stable(sva_checker.batchnorm_param)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_altdd067/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |=> $stable(sva_checker.batchnorm_param)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |-> $stable(sva_checker.batchnorm_param)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |=> $stable(sva_checker.batchnorm_param)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g91lvc7c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |-> $stable(sva_checker.batchnorm_param)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |=> $stable(sva_checker.batchnorm_param)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.training_mode |-> $stable(sva_checker.batchnorm_param)): PROVED\n"
  },
  {
    "id": "676_6_1381",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5if10mpc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.activation_start ##1 sva_checker.activation_busy) |-> sva_checker.prev_activation_out >= 0 && sva_checker.prev_activation_out <= 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.activation_start == 1 |-> ((##1 sva_checker.activation_busy == 1) |-> sva_checker.prev_activation_out >= 0 && sva_checker.prev_activation_out <= 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.activation_start ##1 sva_checker.activation_busy) |-> sva_checker.prev_activation_out >= 0 && sva_checker.prev_activation_out <= 1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9_siitbk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.activation_start == 1 |-> ((##1 sva_checker.activation_busy == 1) |-> sva_checker.prev_activation_out >= 0 && sva_checker.prev_activation_out <= 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.activation_start ##1 sva_checker.activation_busy) |-> sva_checker.prev_activation_out >= 0 && sva_checker.prev_activation_out <= 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.activation_start == 1 |-> "
  },
  {
    "id": "685_5_1474",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nueca0h3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 !sva_checker.ecc_error_flag)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 sva_checker.ecc_error_flag == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 !sva_checker.ecc_error_flag)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wjdghvxo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 sva_checker.ecc_error_flag == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 !sva_checker.ecc_error_flag)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_error_flag == 1'b1 |-> (##1 sva_checker.ecc_error_flag == 1'b0)): PROVED\n"
  },
  {
    "id": "698_1_1588",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_72rckqwe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8igwlrge/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mul_done == 1'b1 |-> { sva_checker.mul_hi, sva_checker.mul_lo } == sva_checker.mul_op1 * sva_checker.mul_op2): PROVED\n"
  },
  {
    "id": "700_5_1598",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.thread_switch && !$past(sva_checker.thread_switch)) == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.thread_switch && !$past(sva_checker.thread_switch))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_65ta1pg0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.thread_switch && !$past(sva_checker.thread_switch))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.thread_switch && !$past(sva_checker.thread_switch)) == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.thread_switch && !$past(sva_checker.thread_switch))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ky807s86/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.thread_switch && !$past(sva_checker.thread_switch)) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.thread_switch && !$past(sva_checker.thread_switch))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.thread_switch && !$past(sva_checker.thread_switch)) == 1'b1): PROVED\n"
  },
  {
    "id": "724_9_1802",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qynm8tru/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.final_window_pos == sva_checker.feature_width - sva_checker.kernel_size |-> (sva_checker.feature_width - sva_checker.kernel_size) % sva_checker.cfg_stride == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.final_window_pos == sva_checker.feature_width - sva_checker.kernel_size |-> (sva_checker.feature_width - sva_checker.kernel_size) % sva_checker.cfg_stride == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.final_window_pos == sva_checker.feature_width - sva_checker.kernel_size |-> (sva_checker.feature_width - sva_checker.kernel_size) % sva_checker.cfg_stride == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wg52u_no/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.final_window_pos == sva_checker.feature_width - sva_checker.kernel_size |-> (sva_checker.feature_width - sva_checker.kernel_size) % sva_checker.cfg_stride == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.final_window_pos == sva_checker.feature_width - sva_checker.kernel_size |-> (sva_checker.feature_width - sva_checker.kernel_size) % sva_checker.cfg_stride == 0): PROVED up to bound 20\n["
  },
  {
    "id": "738_1_1939",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lbd3vjb9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state |-> !sva_checker.can_tx_frame_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1 |-> sva_checker.can_tx_frame_start == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_state |-> !sva_checker.can_tx_frame_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zjy94ff5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1 |-> sva_checker.can_tx_frame_start == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state |-> !sva_checker.can_tx_frame_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1 |-> sva_checker.can_tx_frame_start == 0): PROVED\n"
  },
  {
    "id": "738_8_1924",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tnk96wvf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> !sva_checker.can_tx_start_bit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> sva_checker.can_tx_start_bit == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> !sva_checker.can_tx_start_bit): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ozag_oqv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> sva_checker.can_tx_start_bit == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> !sva_checker.can_tx_start_bit): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 0 == 1'b1 |-> sva_checker.can_tx_start_bit == 1'b0): PROVED\n"
  },
  {
    "id": "742_4_1935",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ajpdcsw_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t063ppo7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.avb_sync_signal) |-> (##[8:12] $rose(sva_checker.avb_sync_signal))): PROVED\n"
  },
  {
    "id": "744_4_1979",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qijf4fpf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active |-> !(sva_checker.reg_write_enable && sva_checker.reg_write_thread != sva_checker.current_thread_id)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active == 1 |-> sva_checker.reg_write_enable == 0 || sva_checker.reg_write_thread == sva_checker.current_thread_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active |-> !(sva_checker.reg_write_enable && sva_checker.reg_write_thread != sva_checker.current_thread_id)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_46pfis31/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active == 1 |-> sva_checker.reg_write_enable == 0 || sva_checker.reg_write_thread == sva_checker.current_thread_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active |-> !(sva_checker.reg_write_enable && sva_checker.reg_write_thread != sva_checker.current_thread_id)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.atomic_op_active == 1 |-> sva_checker.reg_write_enable == 0 || sva_checker.reg_write_thread == sva_checker.current"
  },
  {
    "id": "744_6_1984",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xfjp581n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request && sva_checker.atomic_op_active |-> sva_checker.reg_access_thread == sva_checker.current_thread_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request == 1 && sva_checker.atomic_op_active == 1 |-> sva_checker.reg_access_thread == sva_checker.current_thread_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request && sva_checker.atomic_op_active |-> sva_checker.reg_access_thread == sva_checker.current_thread_id): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gbm4_8iu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request == 1 && sva_checker.atomic_op_active == 1 |-> sva_checker.reg_access_thread == sva_checker.current_thread_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request && sva_checker.atomic_op_active |-> sva_checker.reg_access_thread == sva_checker.current_thread_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reg_access_request == 1 && sva_checker.atomic_op_active == 1 |-> sva_checker.reg_access_thread == sva_checke"
  },
  {
    "id": "751_2_2034",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_1_w9eh09/sva_checker.sv line 8: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_1_w9eh09/sva_checker.sv\nfile /tmp/sva_check_1_w9eh09/sva_checker.sv line 8: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "754_2_2069",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kpzlph_w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) && !sva_checker.ack_old_channel): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) == 1 && sva_checker.ack_old_channel == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) && !sva_checker.ack_old_channel): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xem034kp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) == 1 && sva_checker.ack_old_channel == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) && !sva_checker.ack_old_channel): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.sel_channel) |-> $past(sva_checker.release_old_channel) == 1 && sva_checker.ack_old_channel == 0): PROVED\n"
  },
  {
    "id": "757_4_2083",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f96l90eg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): PROVED\n\n\nBackward: Parsing /tmp/sva_check_df6yr39v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rb_allocated && $past(sva_checker.rb_allocated) |-> $past(sva_checker.rb_index) != sva_checker.rb_index): PROVED\n"
  },
  {
    "id": "762_5_2138",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gechhhd5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access |=> sva_checker.next_element_access == $past(sva_checker.current_element) + 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access == 1 |-> (##1 sva_checker.next_element_access == $past(sva_checker.current_element) + 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access |=> sva_checker.next_element_access == $past(sva_checker.current_element) + 1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c7l1vs7q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access == 1 |-> (##1 sva_checker.next_element_access == $past(sva_checker.current_element) + 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access |=> sva_checker.next_element_access == $past(sva_checker.current_element) + 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.matrix_element_access == 1 |-> (##1 sva_checker.next_element_access == $past(sva_checker.current_element) + 1)): PROVED\n"
  },
  {
    "id": "763_10_2147",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vtd0wfbj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> !sva_checker.read_enable): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> sva_checker.read_enable == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> !sva_checker.read_enable): PROVED\n\n\nBackward: Parsing /tmp/sva_check_o61vzbcs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> sva_checker.read_enable == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> !sva_checker.read_enable): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_enable == 1'b1 |-> sva_checker.read_enable == 1'b0): PROVED\n"
  },
  {
    "id": "772_2_2217",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_uukory35/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> sva_checker.bn_out >= -3 && sva_checker.bn_out <= 3): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> -3 <= sva_checker.bn_out <= 3): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> sva_checker.bn_out >= -3 && sva_checker.bn_out <= 3): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2r2n3da5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> -3 <= sva_checker.bn_out <= 3): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> sva_checker.bn_out >= -3 && sva_checker.bn_out <= 3): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bn_valid_out == 1'b1 |-> -3 <= sva_checker.bn_out <= 3): PROVED\n"
  },
  {
    "id": "772_3_2223",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v4lfpcyn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): PROVED\n\n\nBackward: Parsing /tmp/sva_check_do5bnmgz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.batch_valid_out == 1'b1 |-> sva_checker.batch_cnt == sva_checker.next_layer_batch_cnt): PROVED\n"
  },
  {
    "id": "773_3_2233",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_igp89lck/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_igp89lck/sva_checker.sv\nfile /tmp/sva_check_igp89lck/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "776_10_2259",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7z3906w5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_109nfvwj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1'b1 |-> sva_checker.wmask_valid == 1'b1): PROVED\n"
  },
  {
    "id": "775_6_2265",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z99b7y2d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req && sva_checker.row_active_status |-> (##[1:4] sva_checker.write_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req == 1 && sva_checker.row_active_status == 1 |-> (##[1:4] sva_checker.write_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req && sva_checker.row_active_status |-> (##[1:4] sva_checker.write_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_je1695x8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req == 1 && sva_checker.row_active_status == 1 |-> (##[1:4] sva_checker.write_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req && sva_checker.row_active_status |-> (##[1:4] sva_checker.write_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bank_write_req == 1 && sva_checker.row_active_status == 1 |-> (##[1:4] sva_checker.write_ack == 1)): PROVED\n"
  },
  {
    "id": "779_6_2298",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4cqdjmge/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z454lucg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.active_channel) |-> (##[1:3] $stable(sva_checker.active_channel))): PROVED\n"
  },
  {
    "id": "776_7_2271",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_ea40a073/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_ea40a073/sva_checker.sv\nfile /tmp/sva_check_ea40a073/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "783_6_2329",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_twac05lv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> !sva_checker.csr_write_enable): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> sva_checker.csr_write_enable == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> !sva_checker.csr_write_enable): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5w93d5rx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> sva_checker.csr_write_enable == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> !sva_checker.csr_write_enable): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.csr_read_enable == 1'b1 |-> sva_checker.csr_write_enable == 1'b0): PROVED\n"
  },
  {
    "id": "781_6_2345",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qajsw2zi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.amo_grant_1 && sva_checker.amo_grant_2 |-> sva_checker.amo_addr_1 != sva_checker.amo_addr_2 && sva_checker.amo_wr_reg_1 != sva_checker.amo_wr_reg_2): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.amo_grant_1 == 1 && sva_checker.amo_grant_2 == 1 |-> sva_checker.amo_addr_1 != sva_checker.amo_addr_2 && sva_checker.amo_wr_reg_1 != sva_checker.amo_wr_reg_2): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.amo_grant_1 && sva_checker.amo_grant_2 |-> sva_checker.amo_addr_1 != sva_checker.amo_addr_2 && sva_checker.amo_wr_reg_1 != sva_checker.amo_wr_reg_2): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i42yarz9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.amo_grant_1 == 1 && sva_checker.amo_grant_2 == 1 |-> sva_checker.amo_addr_1 != sva_checker.amo_addr_2 && sva_checker.amo_wr_reg_1 != sva_checker.amo_wr_reg_2): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.amo_grant_1 && sva_checker.amo_grant_2 |-> sva_checker.amo_addr_1 != sva_checker.amo_addr_2 && sva_checker.amo_wr_reg_1 != sva_checker.amo_wr_reg_2): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (dis"
  },
  {
    "id": "784_9_2357",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f2abdgk5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> !sva_checker.reg_write_enable): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> sva_checker.reg_write_enable == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> !sva_checker.reg_write_enable): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sqlnozn8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> sva_checker.reg_write_enable == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> !sva_checker.reg_write_enable): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.busy_flag == 1'b1 |-> sva_checker.reg_write_enable == 1'b0): PROVED\n"
  },
  {
    "id": "791_6_2471",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_grszmrk1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vdq_7mrg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ch_est_start) |-> (##[1:20] $stable(sva_checker.ch_gain_est))): PROVED\n"
  },
  {
    "id": "798_10_2533",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ufvw6gbh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> !sva_checker.non_zero_mask[sva_checker.bit_idx]): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> sva_checker.non_zero_mask[sva_checker.bit_idx] == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> !sva_checker.non_zero_mask[sva_checker.bit_idx]): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qdyr9a4c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> sva_checker.non_zero_mask[sva_checker.bit_idx] == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> !sva_checker.non_zero_mask[sva_checker.bit_idx]): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.matrix_data[sva_checker.bit_idx] == 0 |-> sva_checker.non_zero_mask[sva_checker.bit_idx] == 0): PROVED\n"
  },
  {
    "id": "811_14_2707",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a4_gp8yh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uqe_s7qi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.channel_est_done == 1'b1 |-> sva_checker.channel_est_error < sva_checker.max_error_threshold): PROVED\n"
  },
  {
    "id": "815_1_2744",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3mrzg5rg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 !sva_checker.mult_en)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 sva_checker.mult_en == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 !sva_checker.mult_en)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dh5h48p5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 sva_checker.mult_en == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 !sva_checker.mult_en)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sparse_val == 0 |-> (##1 sva_checker.mult_en == 0)): PROVED\n"
  },
  {
    "id": "823_4_2823",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7eojkbx2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_spfo59bk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2c_bus_error) |-> (##[1:10] $rose(sva_checker.i2c_start))): PROVED\n"
  },
  {
    "id": "826_5_2884",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oo299sy7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_54q54gzp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.cpol) || $changed(sva_checker.cpha) |-> (##[1:4] $stable(sva_checker.spi_data_counter))): PROVED\n"
  },
  {
    "id": "827_1_2864",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a7zat47s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iv9x6c76/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $onehot0(sva_checker.cs_n) == 1): PROVED\n"
  },
  {
    "id": "828_8_2889",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q8ee7yqu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] $stable(sva_checker.spi_rx_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] sva_checker.spi_rx_data == $past(sva_checker.spi_rx_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] $stable(sva_checker.spi_rx_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a0m1ai1w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] sva_checker.spi_rx_data == $past(sva_checker.spi_rx_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] $stable(sva_checker.spi_rx_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_underflow_flag == 1'b1 |-> (##[1:10] sva_checker.spi_rx_data == $past(sva_checker.spi_rx_data))): PROVED\n"
  },
  {
    "id": "830_1_2918",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9j0qnd9m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.slave_cs_n == 1'b1 && sva_checker.slave_sck == 1'b0 && sva_checker.slave_mosi == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.slave_cs_n == 1'b1 && sva_checker.slave_sck == 1'b0 && sva_checker.slave_mosi == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.slave_cs_n == 1'b1 && sva_checker.slave_sck == 1'b0 && sva_checker.slave_mosi == 1'b0)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jg3ps6f6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.slave_cs_n == 1'b1 && sva_checker.slave_sck == 1'b0 && sva_checker.slave_mosi == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.slave_cs_n == 1'b1 && sva_checker.slave_sck == 1'b0 && sva_checker.slave_mosi == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.master_reset_n) |-> (##[1:5] sva_checker.s"
  },
  {
    "id": "836_10_2997",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cd0v_ddi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ && sva_checker.wr_data_strobe_ |-> (##1 $stable(sva_checker.wr_data_))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ == 1 && sva_checker.wr_data_strobe_ == 1 |-> (##1 sva_checker.wr_data_ == $past(sva_checker.wr_data_))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ && sva_checker.wr_data_strobe_ |-> (##1 $stable(sva_checker.wr_data_))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mpxzw546/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ == 1 && sva_checker.wr_data_strobe_ == 1 |-> (##1 sva_checker.wr_data_ == $past(sva_checker.wr_data_))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ && sva_checker.wr_data_strobe_ |-> (##1 $stable(sva_checker.wr_data_))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_data_valid_ == 1 && sva_checker.wr_data_strobe_ == 1 |-> (##1 sva_checker.wr_data_ == $past(sva_checker.wr_data_))): PROVED\n"
  },
  {
    "id": "838_7_3008",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cvm54uxk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> !sva_checker.ecc_uncorrectable_error): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> sva_checker.ecc_uncorrectable_error == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> !sva_checker.ecc_uncorrectable_error): PROVED\n\n\nBackward: Parsing /tmp/sva_check_whzxl0ec/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> sva_checker.ecc_uncorrectable_error == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> !sva_checker.ecc_uncorrectable_error): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_corrected == 1'b1 |-> sva_checker.ecc_uncorrectable_error == 1'b0): PROVED\n"
  },
  {
    "id": "847_4_3118",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_g2lb9bua/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet |-> (##1 sva_checker.crc_check_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet == 1 |-> (##1 sva_checker.crc_check_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet |-> (##1 sva_checker.crc_check_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u6ty8zd7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet == 1 |-> (##1 sva_checker.crc_check_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet |-> (##1 sva_checker.crc_check_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_end_of_packet == 1 |-> (##1 sva_checker.crc_check_valid == 1)): PROVED\n"
  },
  {
    "id": "849_9_3157",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0aa3_vc_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vl3rb7l8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_valid == 1'b1 |-> sva_checker.packet_size <= sva_checker.max_payload_size): PROVED\n"
  },
  {
    "id": "847_9_3143",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9zko5qtf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted && sva_checker.tlp_sequence_valid |-> sva_checker.tlp_sequence_id == sva_checker.retransmit_sequence_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted == 1 && sva_checker.tlp_sequence_valid == 1 |-> sva_checker.tlp_sequence_id == sva_checker.retransmit_sequence_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted && sva_checker.tlp_sequence_valid |-> sva_checker.tlp_sequence_id == sva_checker.retransmit_sequence_id): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tcteuv37/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted == 1 && sva_checker.tlp_sequence_valid == 1 |-> sva_checker.tlp_sequence_id == sva_checker.retransmit_sequence_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted && sva_checker.tlp_sequence_valid |-> sva_checker.tlp_sequence_id == sva_checker.retransmit_sequence_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tlp_retransmitted == 1 && sva_checker.tlp_sequence_valid == 1 |-> sva_checker.tlp_sequen"
  },
  {
    "id": "850_5_3175",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pk40tzb8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tvbsimdj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.link_training_start) |-> (##[0:32'hs3E8] $fell(sva_checker.link_training_start))): PROVED\n"
  },
  {
    "id": "853_6_3221",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_79ran8az/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_x4zodhfl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.signal_lock) |-> (##[10:100] $rose(sva_checker.signal_lock))): PROVED\n"
  },
  {
    "id": "859_12_3300",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j3mlg9of/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u642uec5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_ok_signal) |-> (##[1:5] sva_checker.core_regs == $past(sva_checker.core_regs, 5))): PROVED\n"
  },
  {
    "id": "863_12_3337",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_y3yp1c2n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_90db4vm9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_ep3_poll_enable == 1'b1 |-> (##[1:100] sva_checker.usb_ep3_data_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "863_7_3355",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0z_refdu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pcqv_rbd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_data_valid == 1'b1 |-> (##1 sva_checker.usb_data_crc == $past(sva_checker.usb_calc_crc))): PROVED\n"
  },
  {
    "id": "865_8_3368",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_51805eey/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_bulk_out_transfer && sva_checker.usb_pid_valid |-> (##[1:4] sva_checker.usb_ack_received || sva_checker.usb_nak_received || sva_checker.usb_stall_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_bulk_out_transfer == 1 && sva_checker.usb_pid_valid == 1 |-> (##[1:4] sva_checker.usb_ack_received == 1 || sva_checker.usb_nak_received == 1 || sva_checker.usb_stall_received == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_bulk_out_transfer && sva_checker.usb_pid_valid |-> (##[1:4] sva_checker.usb_ack_received || sva_checker.usb_nak_received || sva_checker.usb_stall_received)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ubdfczkg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_bulk_out_transfer == 1 && sva_checker.usb_pid_valid == 1 |-> (##[1:4] sva_checker.usb_ack_received == 1 || sva_checker.usb_nak_received == 1 || sva_checker.usb_stall_received == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_bulk_out_transfer && sva_checker.usb_pid_valid |-> (##[1:4] sva_checker.usb_ack_received || sva_checker.usb_nak_received || sva_checker.usb_stall_received)):"
  },
  {
    "id": "878_11_3545",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lfflxo9a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical && !sva_checker.shutdown_override |-> (##[1:5] sva_checker.write_throttling_enabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical == 1 && sva_checker.shutdown_override == 0 |-> (##[1:5] sva_checker.write_throttling_enabled == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical && !sva_checker.shutdown_override |-> (##[1:5] sva_checker.write_throttling_enabled)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_h6_n_zwy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical == 1 && sva_checker.shutdown_override == 0 |-> (##[1:5] sva_checker.write_throttling_enabled == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical && !sva_checker.shutdown_override |-> (##[1:5] sva_checker.write_throttling_enabled)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_sensor_critical == 1 && sva_checker.shutdown_override == 0 |-> (##[1:5] sva_checker.write_throttling_enabled == 1)): PROVED\n"
  },
  {
    "id": "878_2_3526",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4myezmsz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sv2bqcpi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cycle_count >= sva_checker.max_rated_cycles |-> (##2 sva_checker.remap_controller_active == 1)): PROVED\n"
  },
  {
    "id": "881_2_3564",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_x45fc6h5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid == 1 && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d1nmkaae/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid == 1 && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_addr_valid == 1 && sva_checker.flash_addr_bus[31:28] == 4'b0000 |-> (##1 $onehot0(sva_checker.flash_chip_select))): PROVED\n"
  },
  {
    "id": "886_8_3634",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_13gznbud/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p5vkqynf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pd_source_cap_sent) |-> (##[1:15] sva_checker.pd_sink_cap_received)): PROVED\n"
  },
  {
    "id": "887_6_3640",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wkuyk_1j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0im5vyjf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pd_error_count > 3 |-> (##1 sva_checker.pd_safe_shutdown == 1)): PROVED\n"
  },
  {
    "id": "888_4_3670",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4fecsnjg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0c181lt9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.frame_rate_ctrl) |-> (##[1:5] $stable(sva_checker.vsync_period))): PROVED\n"
  },
  {
    "id": "894_14_3727",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q7pwwtmr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wxcoei_y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dsp_output > 32'h7FFFFFFF |-> sva_checker.dsp_output == 32'h7FFFFFFF): PROVED\n"
  },
  {
    "id": "10_17_0465",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5lqvnlaj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> $past(sva_checker.cache_hit, 2) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> !$past(sva_checker.cache_hit, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> $past(sva_checker.cache_hit, 2) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2_xxhwh5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> !$past(sva_checker.cache_hit, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> $past(sva_checker.cache_hit, 2) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.flush, 1) |-> !$past(sva_checker.cache_hit, 2)): PROVED\n"
  },
  {
    "id": "10_21_0473",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ugozosxu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_15y6rvtw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 3) |-> $past(sva_checker.header_valid, 2)): PROVED\n"
  },
  {
    "id": "10_32_0476",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t52tcmgc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_11nddob6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_pulse, 2) |-> $past(sva_checker.sync_req, 3)): PROVED\n"
  },
  {
    "id": "10_37_0474",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2xvfn2c4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ug0q0cri/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.clock_gate_en, 3) |-> $past(sva_checker.clock_active, 4)): PROVED\n"
  },
  {
    "id": "11_10_0519",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j7jrkfwq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty && sva_checker.rd_en |-> (##1 sva_checker.underflow)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty == 1 && sva_checker.rd_en == 1 |-> (##1 sva_checker.underflow == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty && sva_checker.rd_en |-> (##1 sva_checker.underflow)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8w5d5o8g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty == 1 && sva_checker.rd_en == 1 |-> (##1 sva_checker.underflow == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty && sva_checker.rd_en |-> (##1 sva_checker.underflow)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_empty == 1 && sva_checker.rd_en == 1 |-> (##1 sva_checker.underflow == 1)): PROVED\n"
  },
  {
    "id": "11_12_0494",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__3lcxz0h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ack && !sva_checker.err && sva_checker.timeout_counter == 0 |-> sva_checker.complete): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ack == 1 && sva_checker.err == 0 && sva_checker.timeout_counter == 0 |-> sva_checker.complete == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ack && !sva_checker.err && sva_checker.timeout_counter == 0 |-> sva_checker.complete): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8uisw_wd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ack == 1 && sva_checker.err == 0 && sva_checker.timeout_counter == 0 |-> sva_checker.complete == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ack && !sva_checker.err && sva_checker.timeout_counter == 0 |-> sva_checker.complete): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ack == 1 && sva_checker.err == 0 && sva_checker.timeout_counter == 0 |-> sva_checker.complete == 1): PROVED\n"
  },
  {
    "id": "11_19_0537",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_x0goopk7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_high && !sva_checker.fan_on |-> (##[1:3] sva_checker.fan_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_high == 1 && sva_checker.fan_on == 0 |-> (##[1:3] sva_checker.fan_start == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_high && !sva_checker.fan_on |-> (##[1:3] sva_checker.fan_start)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r0pxdjew/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_high == 1 && sva_checker.fan_on == 0 |-> (##[1:3] sva_checker.fan_start == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_high && !sva_checker.fan_on |-> (##[1:3] sva_checker.fan_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_high == 1 && sva_checker.fan_on == 0 |-> (##[1:3] sva_checker.fan_start == 1)): PROVED\n"
  },
  {
    "id": "11_43_0542",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6dly5bhz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty && sva_checker.uart_tx_en && !sva_checker.uart_busy |-> sva_checker.uart_tx_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty == 1 && sva_checker.uart_tx_en == 1 && sva_checker.uart_busy == 0 |-> sva_checker.uart_tx_start == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty && sva_checker.uart_tx_en && !sva_checker.uart_busy |-> sva_checker.uart_tx_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t2s4ixbh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty == 1 && sva_checker.uart_tx_en == 1 && sva_checker.uart_busy == 0 |-> sva_checker.uart_tx_start == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty && sva_checker.uart_tx_en && !sva_checker.uart_busy |-> sva_checker.uart_tx_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.uart_tx_empty == 1 && sva_checker.uart_tx_en == 1 && sva_checker.uart_busy == 0 |-> sva_checker.uart_tx_start == 1): PROVED\n"
  },
  {
    "id": "12_11_0565",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_29__1fgd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow || sva_checker.fifo_underflow |-> (##1 sva_checker.error_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow == 1 || sva_checker.fifo_underflow == 1 |-> (##1 sva_checker.error_interrupt == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow || sva_checker.fifo_underflow |-> (##1 sva_checker.error_interrupt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3be2bd01/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow == 1 || sva_checker.fifo_underflow == 1 |-> (##1 sva_checker.error_interrupt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow || sva_checker.fifo_underflow |-> (##1 sva_checker.error_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_overflow == 1 || sva_checker.fifo_underflow == 1 |-> (##1 sva_checker.error_interrupt == 1)): PROVED\n"
  },
  {
    "id": "12_19_0550",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v1y0npcu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calib_start || sva_checker.manual_override |-> sva_checker.calib_active): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calib_start == 1 || sva_checker.manual_override == 1 |-> sva_checker.calib_active == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calib_start || sva_checker.manual_override |-> sva_checker.calib_active): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kmx3kq71/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calib_start == 1 || sva_checker.manual_override == 1 |-> sva_checker.calib_active == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calib_start || sva_checker.manual_override |-> sva_checker.calib_active): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calib_start == 1 || sva_checker.manual_override == 1 |-> sva_checker.calib_active == 1): PROVED\n"
  },
  {
    "id": "12_26_0578",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_luqbkpk0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert || sva_checker.sensor_b_alert |-> sva_checker.safety_trigger): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert == 1 || sva_checker.sensor_b_alert == 1 |-> sva_checker.safety_trigger == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert || sva_checker.sensor_b_alert |-> sva_checker.safety_trigger): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n17doolb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert == 1 || sva_checker.sensor_b_alert == 1 |-> sva_checker.safety_trigger == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert || sva_checker.sensor_b_alert |-> sva_checker.safety_trigger): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_a_alert == 1 || sva_checker.sensor_b_alert == 1 |-> sva_checker.safety_trigger == 1): PROVED\n"
  },
  {
    "id": "12_29_0589",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hbgzzwhc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_high || sva_checker.voltage_low |-> sva_checker.power_adjust): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_high == 1 || sva_checker.voltage_low == 1 |-> sva_checker.power_adjust == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_high || sva_checker.voltage_low |-> sva_checker.power_adjust): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2vtco7kk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_high == 1 || sva_checker.voltage_low == 1 |-> sva_checker.power_adjust == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_high || sva_checker.voltage_low |-> sva_checker.power_adjust): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_high == 1 || sva_checker.voltage_low == 1 |-> sva_checker.power_adjust == 1): PROVED\n"
  },
  {
    "id": "12_32_0570",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2en5sp6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_err || sva_checker.freq_err |-> sva_checker.pll_adjust): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_err == 1 || sva_checker.freq_err == 1 |-> sva_checker.pll_adjust == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_err || sva_checker.freq_err |-> sva_checker.pll_adjust): PROVED\n\n\nBackward: Parsing /tmp/sva_check_l7gjqj4k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_err == 1 || sva_checker.freq_err == 1 |-> sva_checker.pll_adjust == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_err || sva_checker.freq_err |-> sva_checker.pll_adjust): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_err == 1 || sva_checker.freq_err == 1 |-> sva_checker.pll_adjust == 1): PROVED\n"
  },
  {
    "id": "12_34_0587",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ocz23n22/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_read || sva_checker.mem_write |-> sva_checker.mem_ready): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_read == 1 || sva_checker.mem_write == 1 |-> sva_checker.mem_ready == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mem_read || sva_checker.mem_write |-> sva_checker.mem_ready): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5v35l1x_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_read == 1 || sva_checker.mem_write == 1 |-> sva_checker.mem_ready == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_read || sva_checker.mem_write |-> sva_checker.mem_ready): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mem_read == 1 || sva_checker.mem_write == 1 |-> sva_checker.mem_ready == 1): PROVED\n"
  },
  {
    "id": "12_40_0583",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__4brf0kb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stable || sva_checker.reset_released |-> sva_checker.init_sequence): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stable == 1 || sva_checker.reset_released == 1 |-> sva_checker.init_sequence == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_stable || sva_checker.reset_released |-> sva_checker.init_sequence): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tpouvi10/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stable == 1 || sva_checker.reset_released == 1 |-> sva_checker.init_sequence == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stable || sva_checker.reset_released |-> sva_checker.init_sequence): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_stable == 1 || sva_checker.reset_released == 1 |-> sva_checker.init_sequence == 1): PROVED\n"
  },
  {
    "id": "12_48_0592",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sy_a78p_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok || sva_checker.current_ok |-> sva_checker.power_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok == 1 || sva_checker.current_ok == 1 |-> sva_checker.power_ok == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok || sva_checker.current_ok |-> sva_checker.power_ok): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9joms76j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok == 1 || sva_checker.current_ok == 1 |-> sva_checker.power_ok == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok || sva_checker.current_ok |-> sva_checker.power_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_ok == 1 || sva_checker.current_ok == 1 |-> sva_checker.power_ok == 1): PROVED\n"
  },
  {
    "id": "13_34_0644",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6zp_2png/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): PROVED\n\n\nBackward: Parsing /tmp/sva_check_30npy5kn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.authentication_fail && !sva_checker.retry) |-> sva_checker.authenticated): PROVED\n"
  },
  {
    "id": "13_43_0640",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_llrh0kil/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cs7f4o9t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.pipeline_stall && !sva_checker.flush) |-> sva_checker.pipeline_flow == 1): PROVED\n"
  },
  {
    "id": "1_35_0057",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z8b1o9yi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid && !sva_checker.congestion |-> (##4 sva_checker.infiniband_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid == 1 && sva_checker.congestion == 0 |-> (##4 sva_checker.infiniband_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid && !sva_checker.congestion |-> (##4 sva_checker.infiniband_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gi_b_j0o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid == 1 && sva_checker.congestion == 0 |-> (##4 sva_checker.infiniband_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid && !sva_checker.congestion |-> (##4 sva_checker.infiniband_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.infiniband_packet_valid == 1 && sva_checker.congestion == 0 |-> (##4 sva_checker.infiniband_ack == 1)): PROVED\n"
  },
  {
    "id": "3_34_0119",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jw__j4bx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete && !sva_checker.bist_error): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete == 1'b1 && sva_checker.bist_error == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete && !sva_checker.bist_error): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6ci2ddmm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete == 1'b1 && sva_checker.bist_error == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete && !sva_checker.bist_error): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bist_start == 1'b1 |-> sva_checker.bist_complete == 1'b1 && sva_checker.bist_error == 1'b0): PROVED\n"
  },
  {
    "id": "3_40_0101",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wd2qney_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out && !sva_checker.scan_capture): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out == 1'b1 && sva_checker.scan_capture == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out && !sva_checker.scan_capture): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s6urd8nn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out == 1'b1 && sva_checker.scan_capture == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out && !sva_checker.scan_capture): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scan_shift_en == 1'b1 |-> sva_checker.scan_data_out == 1'b1 && sva_checker.scan_capture == 1'b0): PROVED\n"
  },
  {
    "id": "3_46_0154",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lbglz4af/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate && !sva_checker.bus_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate == 1'b1 && sva_checker.bus_ok == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate && !sva_checker.bus_ok): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ued80ftv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate == 1'b1 && sva_checker.bus_ok == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate && !sva_checker.bus_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 1'b1 |-> sva_checker.transaction_terminate == 1'b1 && sva_checker.bus_ok == 1'b0): PROVED\n"
  },
  {
    "id": "4_13_0193",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nps93cm7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |=> sva_checker.stage2_valid == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |-> (##1 sva_checker.stage2_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |=> sva_checker.stage2_valid == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vwv0_kxf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |-> (##1 sva_checker.stage2_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |=> sva_checker.stage2_valid == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.stage1_valid == 1'b1 |-> (##1 sva_checker.stage2_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "5_13_0215",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5d22icar/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.error_flag && !sva_checker.reset [*3]) |-> sva_checker.system_halt): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.error_flag == 1 && sva_checker.reset == 0 [*3]) |-> sva_checker.system_halt == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.error_flag && !sva_checker.reset [*3]) |-> sva_checker.system_halt): PROVED\n\n\nBackward: Parsing /tmp/sva_check_aen_6fw_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.error_flag == 1 && sva_checker.reset == 0 [*3]) |-> sva_checker.system_halt == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.error_flag && !sva_checker.reset [*3]) |-> sva_checker.system_halt): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.error_flag == 1 && sva_checker.reset == 0 [*3]) |-> sva_checker.system_halt == 1): PROVED\n"
  },
  {
    "id": "10_2_0450",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nv0y3kfd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): PROVED\n\n\nBackward: Parsing /tmp/sva_check_59zmaihm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_ptr, 3) == 31 && $past(sva_checker.wr_ptr, 2) == 32 |-> sva_checker.wr_ptr == 33): PROVED\n"
  },
  {
    "id": "10_40_0496",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j0bngjfi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_82f7l_l1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ref_cnt, 7) == 0 |-> $past(sva_checker.ref_req, 1) == 1): PROVED\n"
  },
  {
    "id": "10_48_0489",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_llq5972b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u_40ztg2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_stage1, 2) == $past(sva_checker.sync_stage2, 1)): PROVED\n"
  },
  {
    "id": "11_5_0509",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kurp_snn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full && sva_checker.write_en |-> $past(sva_checker.error, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1 && sva_checker.write_en == 1 |-> $past(sva_checker.error) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full && sva_checker.write_en |-> $past(sva_checker.error, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rewzjmmj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1 && sva_checker.write_en == 1 |-> $past(sva_checker.error) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full && sva_checker.write_en |-> $past(sva_checker.error, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1 && sva_checker.write_en == 1 |-> $past(sva_checker.error) == 1): PROVED\n"
  },
  {
    "id": "12_3_0569",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w713ku24/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_98jorg2s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.valid || sva_checker.bypass) && sva_checker.ready |-> (##2 sva_checker.done)): PROVED\n"
  },
  {
    "id": "12_37_0607",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wljjkr8j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_lock || sva_checker.freq_lock |-> sva_checker.locked_status): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_lock == 1 || sva_checker.freq_lock == 1 |-> sva_checker.locked_status == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_lock || sva_checker.freq_lock |-> sva_checker.locked_status): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j_ldgrrv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_lock == 1 || sva_checker.freq_lock == 1 |-> sva_checker.locked_status == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_lock || sva_checker.freq_lock |-> sva_checker.locked_status): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_lock == 1 || sva_checker.freq_lock == 1 |-> sva_checker.locked_status == 1): PROVED\n"
  },
  {
    "id": "13_24_0626",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_h_d4ro7l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tx_empty && !sva_checker.rx_full) |-> sva_checker.uart_busy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_empty == 1 || sva_checker.rx_full == 1 |-> sva_checker.uart_busy == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.tx_empty && !sva_checker.rx_full) |-> sva_checker.uart_busy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tl5d7fx2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_empty == 1 || sva_checker.rx_full == 1 |-> sva_checker.uart_busy == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tx_empty && !sva_checker.rx_full) |-> sva_checker.uart_busy): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_empty == 1 || sva_checker.rx_full == 1 |-> sva_checker.uart_busy == 1): PROVED\n"
  },
  {
    "id": "13_25_0634",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xabluufs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_good || sva_checker.low_voltage |-> sva_checker.shutdown): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_good == 1 || sva_checker.low_voltage == 1 |-> sva_checker.shutdown == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwr_good || sva_checker.low_voltage |-> sva_checker.shutdown): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zw87a07d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_good == 1 || sva_checker.low_voltage == 1 |-> sva_checker.shutdown == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_good || sva_checker.low_voltage |-> sva_checker.shutdown): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwr_good == 1 || sva_checker.low_voltage == 1 |-> sva_checker.shutdown == 1): PROVED\n"
  },
  {
    "id": "13_48_0649",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3ystwsfx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z_ctwuxl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.tcam_match && sva_checker.tcam_search) |-> sva_checker.tcam_miss): PROVED\n"
  },
  {
    "id": "15_37_0726",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mi4ae6_l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##100 sva_checker.pll_locked == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_rst == 0 && sva_checker.pll_enable == 1 |-> (##100 sva_checker.pll_locked == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##100 sva_checker.pll_locked == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ioi10on2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_rst == 0 && sva_checker.pll_enable == 1 |-> (##100 sva_checker.pll_locked == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##100 sva_checker.pll_locked == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_rst == 0 && sva_checker.pll_enable == 1 |-> (##100 sva_checker.pll_locked == 1)): PROVED\n"
  },
  {
    "id": "1_16_0001",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9os4xpml/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d8biuxq1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_start == 1'b1 |-> (##6 sva_checker.pipeline_full == 1'b1)): PROVED\n"
  },
  {
    "id": "1_29_0017",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lpsgyofe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8xcqwif9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##1 sva_checker.cmd_accept == 1'b1)): PROVED\n"
  },
  {
    "id": "1_48_0047",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kqii2jo0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pnj6bvkg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wdt_timeout == 1'b1 |-> (##1 sva_checker.watchdog_bark == 1'b1)): PROVED\n"
  },
  {
    "id": "2_46_0120",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1xs1abcu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0d6wryjf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sd_read_cmd == 1'b1 |-> (##[5:10] sva_checker.sd_data_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "3_10_0111",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d40993a9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access && sva_checker.mem_protect_en |-> sva_checker.mem_protect_ok || sva_checker.mem_error): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1 && sva_checker.mem_protect_en == 1 |-> sva_checker.mem_protect_ok == 1 || sva_checker.mem_error == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mem_access && sva_checker.mem_protect_en |-> sva_checker.mem_protect_ok || sva_checker.mem_error): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d2ob4woa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1 && sva_checker.mem_protect_en == 1 |-> sva_checker.mem_protect_ok == 1 || sva_checker.mem_error == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mem_access && sva_checker.mem_protect_en |-> sva_checker.mem_protect_ok || sva_checker.mem_error): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mem_access == 1 && sva_checker.mem_protect_en == 1 |-> sva_checker.mem_protect_ok == 1 || sva_checker.mem_error == 1): PROVED\n"
  },
  {
    "id": "3_14_0093",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tk8ry2f1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req && !sva_checker.power_gate_block |-> sva_checker.power_gate_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req == 1 && sva_checker.power_gate_block == 0 |-> sva_checker.power_gate_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req && !sva_checker.power_gate_block |-> sva_checker.power_gate_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ojvbavjk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req == 1 && sva_checker.power_gate_block == 0 |-> sva_checker.power_gate_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req && !sva_checker.power_gate_block |-> sva_checker.power_gate_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_gate_req == 1 && sva_checker.power_gate_block == 0 |-> sva_checker.power_gate_ack == 1): PROVED\n"
  },
  {
    "id": "3_16_0149",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_b5wxc9ff/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted && !sva_checker.access_denied): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1 && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted == 1 && sva_checker.access_denied == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_valid && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted && !sva_checker.access_denied): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cn7rjbog/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1 && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted == 1 && sva_checker.access_denied == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted && !sva_checker.access_denied): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1 && sva_checker.key_type == sva_checker.admin |-> sva_checker.access_granted == 1 && sva_checker"
  },
  {
    "id": "3_41_0133",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z94m5s33/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise && sva_checker.gpio_int_en |-> sva_checker.gpio_int_status): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise == 1 && sva_checker.gpio_int_en == 1 |-> sva_checker.gpio_int_status == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise && sva_checker.gpio_int_en |-> sva_checker.gpio_int_status): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0dingroi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise == 1 && sva_checker.gpio_int_en == 1 |-> sva_checker.gpio_int_status == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise && sva_checker.gpio_int_en |-> sva_checker.gpio_int_status): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_int_rise == 1 && sva_checker.gpio_int_en == 1 |-> sva_checker.gpio_int_status == 1): PROVED\n"
  },
  {
    "id": "3_43_0126",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_we8gws6j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift && sva_checker.jtag_en |-> sva_checker.jtag_ir_capture): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift == 1 && sva_checker.jtag_en == 1 |-> sva_checker.jtag_ir_capture == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift && sva_checker.jtag_en |-> sva_checker.jtag_ir_capture): PROVED\n\n\nBackward: Parsing /tmp/sva_check_si8vd6k9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift == 1 && sva_checker.jtag_en == 1 |-> sva_checker.jtag_ir_capture == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift && sva_checker.jtag_en |-> sva_checker.jtag_ir_capture): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.jtag_ir_shift == 1 && sva_checker.jtag_en == 1 |-> sva_checker.jtag_ir_capture == 1): PROVED\n"
  },
  {
    "id": "3_44_0139",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_x1ol1znq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready && sva_checker.crypto_start |-> sva_checker.crypto_busy): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready == 1 && sva_checker.crypto_start == 1 |-> sva_checker.crypto_busy == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready && sva_checker.crypto_start |-> sva_checker.crypto_busy): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vv6_69nk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready == 1 && sva_checker.crypto_start == 1 |-> sva_checker.crypto_busy == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready && sva_checker.crypto_start |-> sva_checker.crypto_busy): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crypto_key_ready == 1 && sva_checker.crypto_start == 1 |-> sva_checker.crypto_busy == 1): PROVED\n"
  },
  {
    "id": "3_46_0137",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8jr0dmlr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received == 1 && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nzone_1v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received == 1 && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pcie_tlp_received == 1 && sva_checker.pcie_tlp_type == sva_checker.mem_rd |-> sva_checker.pcie_tlp_processing == 1): PROVED\n"
  },
  {
    "id": "5_25_0236",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_n7wi2s2u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1jtolaf9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.encryption_busy [*12]) |-> sva_checker.encryption_done): PROVED\n"
  },
  {
    "id": "3_7_0112",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j67uj3lq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready && sva_checker.resp_type == 2'b01): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1 && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready == 1 && sva_checker.resp_type == 2'b01): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready && sva_checker.resp_type == 2'b01): PROVED\n\n\nBackward: Parsing /tmp/sva_check_k4elql_b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1 && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready == 1 && sva_checker.resp_type == 2'b01): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready && sva_checker.resp_type == 2'b01): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1 && sva_checker.cmd_type == 3'b101 |-> sva_checker.resp_ready == 1 && sva_checker.resp_type == 2'b01): PROVED\n"
  },
  {
    "id": "5_27_0222",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9iqa7nyj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hp4m058f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*4]) |-> sva_checker.sync_achieved): PROVED\n"
  },
  {
    "id": "5_7_0188",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##1 sva_checker.signal == $past(sva_checker.signal))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##4 $stable(sva_checker.signal))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_gm8cgouy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##4 $stable(sva_checker.signal))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##1 sva_checker.signal == $past(sva_checker.signal))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##4 $stable(sva_checker.signal))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_v0nz_98u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##1 sva_checker.signal == $past(sva_checker.signal))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##4 $stable(sva_checker.signal))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync [*4]) |-> (##1 sva_checker.signal == $past(sva_checker.signal))): PROVED\n"
  },
  {
    "id": "4_34_0196",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |-> (##3 sva_checker.dma_start == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |=> (##3 sva_checker.dma_start == 1'b1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_ggzdsbld/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |=> (##3 sva_checker.dma_start == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |-> (##3 sva_checker.dma_start == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |=> (##3 sva_checker.dma_start == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_po83e1r4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |-> (##3 sva_checker.dma_start == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |=> (##3 sva_checker.dma_start == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_req == 1'b1 |-> (##3 sva_checker.dma_start == 1'b1)): PROVED\n"
  },
  {
    "id": "6_41_0298",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__lvrxjk0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g7ku0b52/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.alarm_active && !sva_checker.alarm_silenced [*4:8]) |-> (##3 sva_checker.alarm_triggered == 1)): PROVED\n"
  },
  {
    "id": "7_37_0334",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qep85ea3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8n0cj59k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.underflow) |-> sva_checker.error_flag == 1): PROVED\n"
  },
  {
    "id": "7_45_0369",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5d9fevmj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0kzvn4td/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.qualifier) |-> sva_checker.data_qualified == 1): PROVED\n"
  },
  {
    "id": "7_4_0275",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fbeujquk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wq2zlehm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.valid) |-> (##2 sva_checker.ready)): PROVED\n"
  },
  {
    "id": "8_3_0337",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gtd9ziz6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> !sva_checker.write_en): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> sva_checker.write_en == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> !sva_checker.write_en): PROVED\n\n\nBackward: Parsing /tmp/sva_check_237mwwf6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> sva_checker.write_en == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> !sva_checker.write_en): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable) |-> sva_checker.write_en == 0): PROVED\n"
  },
  {
    "id": "10_14_0445",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e88f38ix/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r44l8irh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_start, 1) |-> (##[1:3] sva_checker.packet_valid)): PROVED\n"
  },
  {
    "id": "10_1_0439",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ry1c8hvn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) |-> sva_checker.data_stable): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) == 1 |-> sva_checker.data_stable == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) |-> sva_checker.data_stable): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pqerc9mx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) == 1 |-> sva_checker.data_stable == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) |-> sva_checker.data_stable): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.data_valid, 2) == 1 |-> sva_checker.data_stable == 1): PROVED\n"
  },
  {
    "id": "10_50_0527",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d3uqblrk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) |-> sva_checker.arbitration_grant): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) == 1 |-> sva_checker.arbitration_grant == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) |-> sva_checker.arbitration_grant): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b4ifs20y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) == 1 |-> sva_checker.arbitration_grant == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) |-> sva_checker.arbitration_grant): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.yield_req, 5) == 1 |-> sva_checker.arbitration_grant == 1): PROVED\n"
  },
  {
    "id": "11_29_0542",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_znicmne0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_lock && !sva_checker.pll_reset |-> sva_checker.clock_output_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_lock == 1 && sva_checker.pll_reset == 0 |-> sva_checker.clock_output_valid == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_lock && !sva_checker.pll_reset |-> sva_checker.clock_output_valid): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uiwvziuj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_lock == 1 && sva_checker.pll_reset == 0 |-> sva_checker.clock_output_valid == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_lock && !sva_checker.pll_reset |-> sva_checker.clock_output_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_lock == 1 && sva_checker.pll_reset == 0 |-> sva_checker.clock_output_valid == 1): PROVED\n"
  },
  {
    "id": "11_3_0505",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_auzulk4k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.start_transfer && sva_checker.fifo_not_empty |=> sva_checker.transfer_complete): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.start_transfer == 1 && sva_checker.fifo_not_empty == 1 |-> (##1 sva_checker.transfer_complete == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.start_transfer && sva_checker.fifo_not_empty |=> sva_checker.transfer_complete): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zi7y0r65/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.start_transfer == 1 && sva_checker.fifo_not_empty == 1 |-> (##1 sva_checker.transfer_complete == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.start_transfer && sva_checker.fifo_not_empty |=> sva_checker.transfer_complete): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.start_transfer == 1 && sva_checker.fifo_not_empty == 1 |-> (##1 sva_checker.transfer_complete == 1)): PROVED\n"
  },
  {
    "id": "11_8_0512",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3c9oozv4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending && !sva_checker.interrupt_mask |-> sva_checker.interrupt_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending == 1 && sva_checker.interrupt_mask == 0 |-> sva_checker.interrupt_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending && !sva_checker.interrupt_mask |-> sva_checker.interrupt_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i8foxgqj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending == 1 && sva_checker.interrupt_mask == 0 |-> sva_checker.interrupt_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending && !sva_checker.interrupt_mask |-> sva_checker.interrupt_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.interrupt_pending == 1 && sva_checker.interrupt_mask == 0 |-> sva_checker.interrupt_ack == 1): PROVED\n"
  },
  {
    "id": "12_17_0557",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_set_ccmi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full || sva_checker.threshold_reached) && sva_checker.write_enable |-> sva_checker.flow_control): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full == 1 || sva_checker.threshold_reached == 1) && sva_checker.write_enable == 1 |-> sva_checker.flow_control == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full || sva_checker.threshold_reached) && sva_checker.write_enable |-> sva_checker.flow_control): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mu7n_7o4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full == 1 || sva_checker.threshold_reached == 1) && sva_checker.write_enable == 1 |-> sva_checker.flow_control == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full || sva_checker.threshold_reached) && sva_checker.write_enable |-> sva_checker.flow_control): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.buffer_full == 1 || sva_checker.threshold_reached == 1) && sva_checker.write_enable == 1 |-> sva_checker.flow_control == 1): PROVED\n"
  },
  {
    "id": "12_22_0571",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jbx15ll6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) || $past(sva_checker.mem_write, 2) |-> sva_checker.write_pending): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) == 1 || $past(sva_checker.mem_write, 2) == 1 |-> sva_checker.write_pending == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) || $past(sva_checker.mem_write, 2) |-> sva_checker.write_pending): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kk8_pnhf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) == 1 || $past(sva_checker.mem_write, 2) == 1 |-> sva_checker.write_pending == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) || $past(sva_checker.mem_write, 2) |-> sva_checker.write_pending): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.fifo_write, 2) == 1 || $past(sva_checker.mem_write, 2) == 1 |-> sva_checker.write_pending == 1): PROVED\n"
  },
  {
    "id": "12_26_0583",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mcgzgar0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match || sva_checker.signature_detect) && sva_checker.validation_enable |-> sva_checker.match_flag): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match == 1 || sva_checker.signature_detect == 1) && sva_checker.validation_enable == 1 |-> sva_checker.match_flag == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match || sva_checker.signature_detect) && sva_checker.validation_enable |-> sva_checker.match_flag): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7g7jdp1h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match == 1 || sva_checker.signature_detect == 1) && sva_checker.validation_enable == 1 |-> sva_checker.match_flag == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match || sva_checker.signature_detect) && sva_checker.validation_enable |-> sva_checker.match_flag): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.pattern_match == 1 || sva_checker.signature_detect == 1) && sva_checker.validation_enable == 1 |-> sva_checker.match_flag == 1): PROVED\n"
  },
  {
    "id": "12_3_0567",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oq2m0k55/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.enable_a || sva_checker.enable_b) && sva_checker.reset_n |-> sva_checker.data_ready): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.enable_a == 1 || sva_checker.enable_b == 1) && sva_checker.reset_n == 1 |-> sva_checker.data_ready == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.enable_a || sva_checker.enable_b) && sva_checker.reset_n |-> sva_checker.data_ready): PROVED\n\n\nBackward: Parsing /tmp/sva_check__ybog2gn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.enable_a == 1 || sva_checker.enable_b == 1) && sva_checker.reset_n == 1 |-> sva_checker.data_ready == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.enable_a || sva_checker.enable_b) && sva_checker.reset_n |-> sva_checker.data_ready): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.enable_a == 1 || sva_checker.enable_b == 1) && sva_checker.reset_n == 1 |-> sva_checker.data_ready == 1): PROVED\n"
  },
  {
    "id": "12_43_0580",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fzs4ud9j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4fysbste/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.valid_op, 5) || $past(sva_checker.forced_op, 5) |-> sva_checker.result_ready): PROVED\n"
  },
  {
    "id": "12_8_0544",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8qt_nhfc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty || sva_checker.fifo_underflow) && sva_checker.read_enable |-> sva_checker.fifo_error): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 1 || sva_checker.fifo_underflow == 1) && sva_checker.read_enable == 1 |-> sva_checker.fifo_error == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty || sva_checker.fifo_underflow) && sva_checker.read_enable |-> sva_checker.fifo_error): PROVED\n\n\nBackward: Parsing /tmp/sva_check___hs5bsj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 1 || sva_checker.fifo_underflow == 1) && sva_checker.read_enable == 1 |-> sva_checker.fifo_error == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty || sva_checker.fifo_underflow) && sva_checker.read_enable |-> sva_checker.fifo_error): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 1 || sva_checker.fifo_underflow == 1) && sva_checker.read_enable == 1 |-> sva_checker.fifo_error == 1): PROVED\n"
  },
  {
    "id": "13_12_0632",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2zp_v1m7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> !sva_checker.conflict): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> sva_checker.conflict == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> !sva_checker.conflict): PROVED\n\n\nBackward: Parsing /tmp/sva_check_noip18qq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> sva_checker.conflict == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> !sva_checker.conflict): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.wr_en && sva_checker.rd_en) |-> sva_checker.conflict == 0): PROVED\n"
  },
  {
    "id": "13_18_0618",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6kpyj4j4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.partial): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.partial == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.partial): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q8j2qdhx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.partial == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.partial): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.partial == 1): PROVED\n"
  },
  {
    "id": "13_32_0623",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kri66sup/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): PROVED\n\n\nBackward: Parsing /tmp/sva_check_454js0gr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.phase_a && !sva_checker.phase_b) |-> sva_checker.phase_ok): PROVED\n"
  },
  {
    "id": "13_46_0666",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8rlfnh0n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oonm76h3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.clock_div2 && !sva_checker.clock_div4) |-> sva_checker.clock_normal): PROVED\n"
  },
  {
    "id": "13_47_0635",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nnk4s6bv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> !sva_checker.reset_active): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> sva_checker.reset_active == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> !sva_checker.reset_active): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ivv6qgrt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> sva_checker.reset_active == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> !sva_checker.reset_active): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.reset_async && sva_checker.reset_sync) |-> sva_checker.reset_active == 0): PROVED\n"
  },
  {
    "id": "13_6_0645",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_em4h_grr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nli8vsny/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.start && sva_checker.stop) |-> sva_checker.done == 1): PROVED\n"
  },
  {
    "id": "14_1_0662",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_rxlctxzo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mode ? sva_checker.req : 1'b1 |-> sva_checker.mode ? sva_checker.ack : 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mode == 1 |-> (sva_checker.req == 1 |-> sva_checker.ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mode ? sva_checker.req : 1'b1 |-> sva_checker.mode ? sva_checker.ack : 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hn93z8yc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mode == 1 |-> (sva_checker.req == 1 |-> sva_checker.ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mode ? sva_checker.req : 1'b1 |-> sva_checker.mode ? sva_checker.ack : 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mode == 1 |-> (sva_checker.req == 1 |-> sva_checker.ack == 1)): PROVED\n"
  },
  {
    "id": "15_31_0724",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_7gbktnmx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_enable == 1'b1 && sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q097e88_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_enable == 1'b1 && sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_enable == 1'b1 && sva_checker.error_detected == 1'b1 |-> (##1 sva_checker.error_corrected == 1'b1)): PROVED\n"
  },
  {
    "id": "1_44_0009",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q91imad1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yshzmonn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encryption_start == 1'b1 |-> (##7 sva_checker.encryption_done == 1'b1)): PROVED\n"
  },
  {
    "id": "1_7_0054",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e0141yv4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_net7s54a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_valid == 1'b1 |-> (##3 sva_checker.cmd_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "2_5_0077",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2gvh07x5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1dfu_tzp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_start == 1'b1 |-> (##[3:7] sva_checker.packet_end == 1'b1)): PROVED\n"
  },
  {
    "id": "2_8_0029",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k2s9own4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tclw94ai/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.read_req == 1'b1 |-> (##[5:12] sva_checker.read_data_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "3_46_0148",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kjjrfg43/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired && !sva_checker.gps_data_invalid |-> sva_checker.gps_timestamp_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired == 1 && sva_checker.gps_data_invalid == 0 |-> sva_checker.gps_timestamp_valid == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired && !sva_checker.gps_data_invalid |-> sva_checker.gps_timestamp_valid): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qahwga8f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired == 1 && sva_checker.gps_data_invalid == 0 |-> sva_checker.gps_timestamp_valid == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired && !sva_checker.gps_data_invalid |-> sva_checker.gps_timestamp_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_fix_acquired == 1 && sva_checker.gps_data_invalid == 0 |-> sva_checker.gps_timestamp_valid == 1): PROVED\n"
  },
  {
    "id": "3_48_0129",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req == 1 && sva_checker.wifi_disabled == 0 |-> sva_checker.wifi_connection_ack == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req && !sva_checker.wifi_disabled |-> sva_checker.wifi_connect_ack): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_navq7ol1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req && !sva_checker.wifi_disabled |-> sva_checker.wifi_connect_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req == 1 && sva_checker.wifi_disabled == 0 |-> sva_checker.wifi_connection_ack == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req && !sva_checker.wifi_disabled |-> sva_checker.wifi_connect_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_onm6dtg1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req == 1 && sva_checker.wifi_disabled == 0 |-> sva_checker.wifi_connection_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req && !sva_checker.wifi_disabled |-> sva_checker.wifi_connect_ack): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wifi_connect_req == 1 && sva_checker.wifi_disabled == 0 |-> sva_checker.wifi_connection_ack == 1): PROVED\n"
  },
  {
    "id": "6_31_0287",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xbofz4z5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.data_phase && !sva_checker.ack_phase [*2:5]) |-> sva_checker.protocol_violation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.data_phase == 1 && sva_checker.ack_phase == 0 [*2:5]) |-> sva_checker.protocol_violation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.data_phase && !sva_checker.ack_phase [*2:5]) |-> sva_checker.protocol_violation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uekg7gzd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.data_phase == 1 && sva_checker.ack_phase == 0 [*2:5]) |-> sva_checker.protocol_violation == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.data_phase && !sva_checker.ack_phase [*2:5]) |-> sva_checker.protocol_violation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.data_phase == 1 && sva_checker.ack_phase == 0 [*2:5]) |-> sva_checker.protocol_violation == 1): PROVED\n"
  },
  {
    "id": "6_50_0284",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ye0bexek/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): PROVED\n\n\nBackward: Parsing /tmp/sva_check__dtxd3ek/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sensor_active && !sva_checker.sensor_data [*8:20]) |-> sva_checker.sensor_timeout): PROVED\n"
  },
  {
    "id": "10_9_0474",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j2azsv14/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): PROVED\n\n\nBackward: Parsing /tmp/sva_check_izahmvbc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.parity_err, 3) |-> sva_checker.parity_err): PROVED\n"
  },
  {
    "id": "11_26_0544",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lazrnxfq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_hold && sva_checker.fifo_ready |-> sva_checker.dma_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_hold == 0 && sva_checker.fifo_ready == 1 |-> sva_checker.dma_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_hold && sva_checker.fifo_ready |-> sva_checker.dma_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_su8lz4nm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_hold == 0 && sva_checker.fifo_ready == 1 |-> sva_checker.dma_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request && !sva_checker.bus_hold && sva_checker.fifo_ready |-> sva_checker.dma_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 && sva_checker.bus_hold == 0 && sva_checker.fifo_ready == 1 |-> sva_checker.dma_ack == 1): PROVED\n"
  },
  {
    "id": "11_31_0529",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j568c66q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_end && !sva_checker.error_flag && sva_checker.next_buff_ready |-> sva_checker.next_burst_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_end == 1 && sva_checker.error_flag == 0 && sva_checker.next_buff_ready == 1 |-> sva_checker.next_burst_start == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_end && !sva_checker.error_flag && sva_checker.next_buff_ready |-> sva_checker.next_burst_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g6ol6v9k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_end == 1 && sva_checker.error_flag == 0 && sva_checker.next_buff_ready == 1 |-> sva_checker.next_burst_start == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_end && !sva_checker.error_flag && sva_checker.next_buff_ready |-> sva_checker.next_burst_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_end == 1 && sva_checker.error_flag == 0 && sva_checker.next_buff_ready == 1 |-> sva_checker.next_burst_start == 1): PROVED\n"
  },
  {
    "id": "11_32_0549",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jfsyx069/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error && !sva_checker.ignore_phase && sva_checker.lock_window_open |-> sva_checker.phase_adjust): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.ignore_phase == 0 && sva_checker.lock_window_open == 1 |-> sva_checker.phase_adjust == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_error && !sva_checker.ignore_phase && sva_checker.lock_window_open |-> sva_checker.phase_adjust): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dwe_bo41/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.ignore_phase == 0 && sva_checker.lock_window_open == 1 |-> sva_checker.phase_adjust == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error && !sva_checker.ignore_phase && sva_checker.lock_window_open |-> sva_checker.phase_adjust): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.ignore_phase == 0 && sva_checker.lock_window_open == 1 |-> sva_checker.phase_adjust == 1): PROVED\n"
  },
  {
    "id": "11_42_0560",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_94xp0so0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode |-> sva_checker.full_speed_clock): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode == 1 |-> sva_checker.full_speed_clock == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode |-> sva_checker.full_speed_clock): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ox1zx5nl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode == 1 |-> sva_checker.full_speed_clock == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode |-> sva_checker.full_speed_clock): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_divider == 0 && sva_checker.high_speed_mode == 1 |-> sva_checker.full_speed_clock == 1): PROVED\n"
  },
  {
    "id": "12_22_0594",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fpmmra6p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_err || sva_checker.runtime_err |-> sva_checker.system_halt): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_err == 1 || sva_checker.runtime_err == 1 |-> sva_checker.system_halt == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_err || sva_checker.runtime_err |-> sva_checker.system_halt): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q1wbu89q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_err == 1 || sva_checker.runtime_err == 1 |-> sva_checker.system_halt == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_err || sva_checker.runtime_err |-> sva_checker.system_halt): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_err == 1 || sva_checker.runtime_err == 1 |-> sva_checker.system_halt == 1): PROVED\n"
  },
  {
    "id": "12_36_0581",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3gj7zjj6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.low_batt || sva_checker.over_temp |-> sva_checker.shutdown): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.low_batt == 1 || sva_checker.over_temp == 1 |-> sva_checker.shutdown == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.low_batt || sva_checker.over_temp |-> sva_checker.shutdown): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w3glblay/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.low_batt == 1 || sva_checker.over_temp == 1 |-> sva_checker.shutdown == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.low_batt || sva_checker.over_temp |-> sva_checker.shutdown): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.low_batt == 1 || sva_checker.over_temp == 1 |-> sva_checker.shutdown == 1): PROVED\n"
  },
  {
    "id": "12_9_0557",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_29ove8f8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) || $past(sva_checker.ready, 2) |-> sva_checker.curr_state == sva_checker.next_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) == 1 || $past(sva_checker.ready, 2) == 1 |-> sva_checker.curr_state == sva_checker.next_state): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) || $past(sva_checker.ready, 2) |-> sva_checker.curr_state == sva_checker.next_state): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hcn1p4ct/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) == 1 || $past(sva_checker.ready, 2) == 1 |-> sva_checker.curr_state == sva_checker.next_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) || $past(sva_checker.ready, 2) |-> sva_checker.curr_state == sva_checker.next_state): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.valid, 2) == 1 || $past(sva_checker.ready, 2) == 1 |-> sva_checker.curr_state == sva_checker.next_state): PROVED\n"
  },
  {
    "id": "13_2_0603",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dkczcz7g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready): PROVED\n\n\nBackward: Parsing /tmp/sva_check_v5y1njcq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(!sva_checker.enable && sva_checker.reset) |-> sva_checker.ready == 1): PROVED\n"
  },
  {
    "id": "15_18_0709",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nucjc9d7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.force_error == 0 && sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9jxlp055/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.force_error == 0 && sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.force_error == 0 && sva_checker.error_inject == 1'b1 |-> (##2 sva_checker.error_detect == 1'b1)): PROVED\n"
  },
  {
    "id": "15_8_0699",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_sb0fe3g9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr) |-> (##1 $stable(sva_checker.addr))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && $changed(sva_checker.addr) |-> (##1 sva_checker.addr == $past(sva_checker.addr))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr) |-> (##1 $stable(sva_checker.addr))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oui5kjoy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && $changed(sva_checker.addr) |-> (##1 sva_checker.addr == $past(sva_checker.addr))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr) |-> (##1 $stable(sva_checker.addr))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && $changed(sva_checker.addr) |-> (##1 sva_checker.addr == $past(sva_checker.addr))): PROVED\n"
  },
  {
    "id": "1_19_0062",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6mqgsmwo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_align && sva_checker.pll_locked |-> (##7 sva_checker.clock_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_align == 1 && sva_checker.pll_locked == 1 |-> (##7 sva_checker.clock_stable == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_align && sva_checker.pll_locked |-> (##7 sva_checker.clock_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6im53rp2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_align == 1 && sva_checker.pll_locked == 1 |-> (##7 sva_checker.clock_stable == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_align && sva_checker.pll_locked |-> (##7 sva_checker.clock_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_align == 1 && sva_checker.pll_locked == 1 |-> (##7 sva_checker.clock_stable == 1)): PROVED\n"
  },
  {
    "id": "1_35_0073",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_i_n63xf3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match && !sva_checker.mask_match |-> (##1 sva_checker.match_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match == 1 && sva_checker.mask_match == 0 |-> (##1 sva_checker.match_interrupt == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pattern_match && !sva_checker.mask_match |-> (##1 sva_checker.match_interrupt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gxlbcgmw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match == 1 && sva_checker.mask_match == 0 |-> (##1 sva_checker.match_interrupt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match && !sva_checker.mask_match |-> (##1 sva_checker.match_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pattern_match == 1 && sva_checker.mask_match == 0 |-> (##1 sva_checker.match_interrupt == 1)): PROVED\n"
  },
  {
    "id": "1_41_0075",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cj7o4l2o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_received && sva_checker.crc_check |-> (##3 sva_checker.packet_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_received == 1 && sva_checker.crc_check == 1 |-> (##3 sva_checker.packet_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_received && sva_checker.crc_check |-> (##3 sva_checker.packet_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m4od9oyn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_received == 1 && sva_checker.crc_check == 1 |-> (##3 sva_checker.packet_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_received && sva_checker.crc_check |-> (##3 sva_checker.packet_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_received == 1 && sva_checker.crc_check == 1 |-> (##3 sva_checker.packet_valid == 1)): PROVED\n"
  },
  {
    "id": "1_44_0008",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_exiguict/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error && sva_checker.phase_adjust |-> (##5 sva_checker.phase_locked)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.phase_adjust == 1 |-> (##5 sva_checker.phase_locked == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_error && sva_checker.phase_adjust |-> (##5 sva_checker.phase_locked)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w7bmtzpp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.phase_adjust == 1 |-> (##5 sva_checker.phase_locked == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phase_error && sva_checker.phase_adjust |-> (##5 sva_checker.phase_locked)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phase_error == 1 && sva_checker.phase_adjust == 1 |-> (##5 sva_checker.phase_locked == 1)): PROVED\n"
  },
  {
    "id": "2_11_0047",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pjdn8f13/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2yvnf1k7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1'b1 |-> (##[4:9] sva_checker.sync_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "2_13_0010",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s1dcshi7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sr68tkta/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_expired == 1'b1 |-> (##[2:6] sva_checker.timer_reset == 1'b1)): PROVED\n"
  },
  {
    "id": "2_26_0036",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v8dsdome/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch == 1'b1 |-> (##[2:4] sva_checker.clock_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch |-> (##[2:4] sva_checker.clock_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_switch == 1'b1 |-> (##[2:4] sva_checker.clock_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t7bprmj1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch |-> (##[2:4] sva_checker.clock_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch == 1'b1 |-> (##[2:4] sva_checker.clock_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_switch |-> (##[2:4] sva_checker.clock_stable)): PROVED\n"
  },
  {
    "id": "2_48_0087",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ft3zzaam/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j2s9jxf1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.signal_loss == 1'b1 |-> (##[3:6] sva_checker.signal_recovery == 1'b1)): PROVED\n"
  },
  {
    "id": "3_31_0105",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mxozexzk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt && sva_checker.debug_en |-> sva_checker.debug_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 1 && sva_checker.debug_en == 1 |-> sva_checker.debug_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.debug_halt && sva_checker.debug_en |-> sva_checker.debug_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g4xoowh5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 1 && sva_checker.debug_en == 1 |-> sva_checker.debug_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt && sva_checker.debug_en |-> sva_checker.debug_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 1 && sva_checker.debug_en == 1 |-> sva_checker.debug_ack == 1): PROVED\n"
  },
  {
    "id": "5_11_0228",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2sqa4x77/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): PROVED\n\n\nBackward: Parsing /tmp/sva_check_92cg72rk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($fell(sva_checker.interrupt_line) [*3]) |-> sva_checker.interrupt_handled): PROVED\n"
  },
  {
    "id": "5_21_0231",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9ed1i2b9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en && !sva_checker.fifo_full [*2]) |-> (sva_checker.fifo_write_ptr_changed [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en == 1 && sva_checker.fifo_full == 0 [*2]) |-> (sva_checker.fifo_write_ptr_changed == 1 [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en && !sva_checker.fifo_full [*2]) |-> (sva_checker.fifo_write_ptr_changed [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6kmv4prr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en == 1 && sva_checker.fifo_full == 0 [*2]) |-> (sva_checker.fifo_write_ptr_changed == 1 [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en && !sva_checker.fifo_full [*2]) |-> (sva_checker.fifo_write_ptr_changed [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.fifo_write_en == 1 && sva_checker.fifo_full == 0 [*2]) |-> (sva_checker.fifo_write_ptr_changed == 1 [*2])): PROVED\n"
  },
  {
    "id": "5_25_0210",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xbjrw5sm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active && !sva_checker.encryption_error [*2]) |-> (sva_checker.cipher_text_valid [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active == 1 && sva_checker.encryption_error == 0 [*2]) |-> (sva_checker.cipher_text_valid == 1 [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active && !sva_checker.encryption_error [*2]) |-> (sva_checker.cipher_text_valid [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_etuhpxi3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active == 1 && sva_checker.encryption_error == 0 [*2]) |-> (sva_checker.cipher_text_valid == 1 [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active && !sva_checker.encryption_error [*2]) |-> (sva_checker.cipher_text_valid [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.encryption_active == 1 && sva_checker.encryption_error == 0 [*2]) |-> (sva_checker.cipher_text_valid == 1 [*2])): PROVED\n"
  },
  {
    "id": "5_47_0250",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qx87150p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active && !sva_checker.branch_mispredict [*2]) |-> (sva_checker.prediction_valid [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active == 1 && sva_checker.branch_mispredict == 0 [*2]) |-> (sva_checker.prediction_valid == 1 [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active && !sva_checker.branch_mispredict [*2]) |-> (sva_checker.prediction_valid [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check__44oucu1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active == 1 && sva_checker.branch_mispredict == 0 [*2]) |-> (sva_checker.prediction_valid == 1 [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active && !sva_checker.branch_mispredict [*2]) |-> (sva_checker.prediction_valid [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.branch_prediction_active == 1 && sva_checker.branch_mispredict == 0 [*2]) |-> (sva_checker.prediction_valid == 1 [*2])): PROVED\n"
  },
  {
    "id": "6_5_0276",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |=> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |-> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_v9_jbx3k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |-> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |=> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |-> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rmeecprm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |=> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |-> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start && sva_checker.sync_ok |=> ((sva_checker.payload [*8:12]) ##1 sva_checker.frame_end)): PROVED\n"
  },
  {
    "id": "6_7_0247",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j5nxfjg5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (!sva_checker.fifo_empty [*2:4]) |-> sva_checker.rd_en): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 0 [*2:4]) |-> sva_checker.rd_en == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (!sva_checker.fifo_empty [*2:4]) |-> sva_checker.rd_en): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yx5kbybr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 0 [*2:4]) |-> sva_checker.rd_en == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (!sva_checker.fifo_empty [*2:4]) |-> sva_checker.rd_en): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.fifo_empty == 0 [*2:4]) |-> sva_checker.rd_en == 1): PROVED\n"
  },
  {
    "id": "7_5_0311",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_udomnw4_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vxfv52kp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req) |-> sva_checker.grant == 1): PROVED\n"
  },
  {
    "id": "8_19_0375",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ebbto488/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 !sva_checker.dirty_bit)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 sva_checker.dirty_bit == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 !sva_checker.dirty_bit)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q536v4y5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 sva_checker.dirty_bit == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 !sva_checker.dirty_bit)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.update) |-> (##2 sva_checker.dirty_bit == 0)): PROVED\n"
  },
  {
    "id": "10_21_0490",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_uontvbva/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en, 1) |-> sva_checker.burst_cnt == ($past(sva_checker.burst_cnt, 1) + 1) % 8): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en) == 1 |-> sva_checker.burst_cnt % 8 == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en, 1) |-> sva_checker.burst_cnt == ($past(sva_checker.burst_cnt, 1) + 1) % 8): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jz9wu1qs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en) == 1 |-> sva_checker.burst_cnt % 8 == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en, 1) |-> sva_checker.burst_cnt == ($past(sva_checker.burst_cnt, 1) + 1) % 8): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.burst_en) == 1 |-> sva_checker.burst_cnt % 8 == 1): PROVED\n"
  },
  {
    "id": "10_29_0451",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xjnid44g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6o8dzbyl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.ser_valid, 8) |-> sva_checker.par_valid): PROVED\n"
  },
  {
    "id": "10_44_0500",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ymzhan2z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2f62rdf6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.scan_en, 5) |-> sva_checker.scan_out == $past(sva_checker.scan_in, 5)): PROVED\n"
  },
  {
    "id": "10_42_0503",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u1sik_zf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) && !$past(sva_checker.irq_ack, 2) |-> sva_checker.irq_handler_active): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) == 1 && $past(sva_checker.irq_ack, 2) == 0 |-> sva_checker.irq_handler_active == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) && !$past(sva_checker.irq_ack, 2) |-> sva_checker.irq_handler_active): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fi8511mm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) == 1 && $past(sva_checker.irq_ack, 2) == 0 |-> sva_checker.irq_handler_active == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) && !$past(sva_checker.irq_ack, 2) |-> sva_checker.irq_handler_active): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.irq, 3) == 1 && $past(sva_checker.irq_ack, 2) == 0 |-> sva_checker.irq_handler_active == 1): PROVED\n"
  },
  {
    "id": "10_4_0441",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_58vqz2y9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) && $past(sva_checker.err_flag, 1) |-> sva_checker.err_flag): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) == 1 && $past(sva_checker.err_flag, 1) == 1 |-> sva_checker.err_flag == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) && $past(sva_checker.err_flag, 1) |-> sva_checker.err_flag): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9wph7223/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) == 1 && $past(sva_checker.err_flag, 1) == 1 |-> sva_checker.err_flag == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) && $past(sva_checker.err_flag, 1) |-> sva_checker.err_flag): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.err_flag, 2) == 1 && $past(sva_checker.err_flag, 1) == 1 |-> sva_checker.err_flag == 1): PROVED\n"
  },
  {
    "id": "11_15_0504",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0zpcxv3w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse && sva_checker.locked |-> sva_checker.sync_ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 && sva_checker.locked == 1 |-> sva_checker.sync_ack == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse && sva_checker.locked |-> sva_checker.sync_ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mjpzbq1c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 && sva_checker.locked == 1 |-> sva_checker.sync_ack == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse && sva_checker.locked |-> sva_checker.sync_ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 && sva_checker.locked == 1 |-> sva_checker.sync_ack == 1): PROVED\n"
  },
  {
    "id": "11_39_0553",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_firmrtmh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sop && sva_checker.eop && sva_checker.valid |-> sva_checker.single_packet): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sop == 1 && sva_checker.eop == 1 && sva_checker.valid == 1 |-> sva_checker.single_packet == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sop && sva_checker.eop && sva_checker.valid |-> sva_checker.single_packet): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qx9npqqh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sop == 1 && sva_checker.eop == 1 && sva_checker.valid == 1 |-> sva_checker.single_packet == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sop && sva_checker.eop && sva_checker.valid |-> sva_checker.single_packet): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sop == 1 && sva_checker.eop == 1 && sva_checker.valid == 1 |-> sva_checker.single_packet == 1): PROVED\n"
  },
  {
    "id": "11_42_0732",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kjenxreq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en && sva_checker.key_ready |-> sva_checker.cipher_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en == 1 && sva_checker.key_ready == 1 |-> sva_checker.cipher_start == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en && sva_checker.key_ready |-> sva_checker.cipher_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zkh_9n37/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en == 1 && sva_checker.key_ready == 1 |-> sva_checker.cipher_start == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en && sva_checker.key_ready |-> sva_checker.cipher_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_en == 1 && sva_checker.key_ready == 1 |-> sva_checker.cipher_start == 1): PROVED\n"
  },
  {
    "id": "11_4_0511",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_th7nh2h3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.enable && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.enable && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow): PROVED\n\n\nBackward: Parsing /tmp/sva_check_69ct2vad/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.enable && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.enable == 1 && sva_checker.count > sva_checker.threshold |-> sva_checker.overflow == 1): PROVED\n"
  },
  {
    "id": "12_11_0537",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__9j3uoqc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_error || sva_checker.parity_error |-> sva_checker.error_status): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_error == 1 || sva_checker.parity_error == 1 |-> sva_checker.error_status == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_error || sva_checker.parity_error |-> sva_checker.error_status): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ad0kdq02/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_error == 1 || sva_checker.parity_error == 1 |-> sva_checker.error_status == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_error || sva_checker.parity_error |-> sva_checker.error_status): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_error == 1 || sva_checker.parity_error == 1 |-> sva_checker.error_status == 1): PROVED\n"
  },
  {
    "id": "12_21_0546",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t21md1wt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse || sva_checker.async_pulse |-> (##1 sva_checker.pulse_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 || sva_checker.async_pulse == 1 |-> (##1 sva_checker.pulse_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse || sva_checker.async_pulse |-> (##1 sva_checker.pulse_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_inc7t9t9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 || sva_checker.async_pulse == 1 |-> (##1 sva_checker.pulse_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse || sva_checker.async_pulse |-> (##1 sva_checker.pulse_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 || sva_checker.async_pulse == 1 |-> (##1 sva_checker.pulse_ack == 1)): PROVED\n"
  },
  {
    "id": "13_11_0593",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6rk0eig_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.can_write): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.can_write == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.can_write): PROVED\n\n\nBackward: Parsing /tmp/sva_check_k98kd9ft/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.can_write == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.full || sva_checker.empty) |-> sva_checker.can_write): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.full == 0 && sva_checker.empty == 0 |-> sva_checker.can_write == 1): PROVED\n"
  },
  {
    "id": "13_22_0599",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kyky9tlm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hlvtta0b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.fifo_empty && sva_checker.fifo_full) |-> sva_checker.fifo_ok): PROVED\n"
  },
  {
    "id": "13_32_0618",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sijrwh8o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2bnkwos2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.low_power && sva_checker.high_power) |-> sva_checker.mid_power == 1): PROVED\n"
  },
  {
    "id": "13_36_0627",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jeop70py/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c4yao2rc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !(sva_checker.early_term && sva_checker.late_term) |-> sva_checker.on_time == 1): PROVED\n"
  },
  {
    "id": "1_12_0063",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_55djhdfj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timeout_start && !sva_checker.timeout_clear |-> (##8 sva_checker.timeout_event)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timeout_start == 1 && sva_checker.timeout_clear == 0 |-> (##8 sva_checker.timeout_event == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timeout_start && !sva_checker.timeout_clear |-> (##8 sva_checker.timeout_event)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s27u3xf0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timeout_start == 1 && sva_checker.timeout_clear == 0 |-> (##8 sva_checker.timeout_event == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timeout_start && !sva_checker.timeout_clear |-> (##8 sva_checker.timeout_event)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timeout_start == 1 && sva_checker.timeout_clear == 0 |-> (##8 sva_checker.timeout_event == 1)): PROVED\n"
  },
  {
    "id": "1_37_0014",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cmsotoj3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset && sva_checker.tck_stable |-> (##3 sva_checker.jtag_ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset == 1 && sva_checker.tck_stable == 1 |-> (##3 sva_checker.jtag_ready == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset && sva_checker.tck_stable |-> (##3 sva_checker.jtag_ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zcnj553y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset == 1 && sva_checker.tck_stable == 1 |-> (##3 sva_checker.jtag_ready == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset && sva_checker.tck_stable |-> (##3 sva_checker.jtag_ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.jtag_reset == 1 && sva_checker.tck_stable == 1 |-> (##3 sva_checker.jtag_ready == 1)): PROVED\n"
  },
  {
    "id": "1_5_0010",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7_36igtl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.full |-> (##3 sva_checker.overflow_flag)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.full == 1 |-> (##3 sva_checker.overflow_flag == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.full |-> (##3 sva_checker.overflow_flag)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__6aeri85/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.full == 1 |-> (##3 sva_checker.overflow_flag == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.full |-> (##3 sva_checker.overflow_flag)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.full == 1 |-> (##3 sva_checker.overflow_flag == 1)): PROVED\n"
  },
  {
    "id": "2_26_0055",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_45ge_rw5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1ct7tquc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_trigger == 1'b1 |-> (##[3:9] sva_checker.sensor_data_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "3_16_0097",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pq3m5b2o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e2em59i3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.config_done == 1'b1 |-> sva_checker.module_ready == 1'b1): PROVED\n"
  },
  {
    "id": "2_9_0008",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kjnp6oek/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cr_txsnb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1'b1 |-> (##[10:20] sva_checker.dma_complete == 1'b1)): PROVED\n"
  },
  {
    "id": "3_29_0093",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1tyyieg6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.initialized |-> sva_checker.go_signal): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.initialized == 1 |-> sva_checker.go_signal == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.initialized |-> sva_checker.go_signal): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zps9m30d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.initialized == 1 |-> sva_checker.go_signal == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.initialized |-> sva_checker.go_signal): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.initialized == 1 |-> sva_checker.go_signal == 1): PROVED\n"
  },
  {
    "id": "3_49_0745",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gt9y7z_q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): PROVED\n\n\nBackward: Parsing /tmp/sva_check_59pa7i2t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_drop == 1'b1 |-> sva_checker.power_alert == 1'b1): PROVED\n"
  },
  {
    "id": "5_17_0204",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_yov_8pi8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6kd6o0g_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.init_start [*4]) |-> (##4 sva_checker.init_complete)): PROVED\n"
  },
  {
    "id": "5_31_0234",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_28tv5xdc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7mc2eux_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.spi_cs_low [*4]) |-> (##4 sva_checker.spi_cs_high)): PROVED\n"
  },
  {
    "id": "7_47_0367",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9f5z17d4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4rs8cp4x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.monitor) |-> sva_checker.log == 1): PROVED\n"
  },
  {
    "id": "8_18_0360",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ztmidvbp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xgj4ueey/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.calibrate) |-> (##5 sva_checker.calibration_done)): PROVED\n"
  },
  {
    "id": "8_35_0362",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_l4vbn7kb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xtpcrar3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_div) |-> (##2 sva_checker.clock_changed)): PROVED\n"
  },
  {
    "id": "8_5_0345",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nyhjjumk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |=> sva_checker.ack): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |-> (##1 sva_checker.ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |=> sva_checker.ack): PROVED\n\n\nBackward: Parsing /tmp/sva_check__gjz4py1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |-> (##1 sva_checker.ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |=> sva_checker.ack): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.req) |-> (##1 sva_checker.ack == 1)): PROVED\n"
  },
  {
    "id": "10_48_0493",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_23kidnb0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 1'b0 ##0 sva_checker.deadtime_ok)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 0 && sva_checker.deadtime_ok == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 1'b0 ##0 sva_checker.deadtime_ok)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tebg70xk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 0 && sva_checker.deadtime_ok == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 1'b0 ##0 sva_checker.deadtime_ok)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.pwm_a) |-> (##[2:4] $past(sva_checker.pwm_b, 1) == 0 && sva_checker.deadtime_ok == 1)): PROVED\n"
  },
  {
    "id": "11_14_0521",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_c7fj5bse/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_low && !sva_checker.tx_active |-> (##[12:16] sva_checker.break_detected && !sva_checker.framing_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_low == 1 && sva_checker.tx_active == 0 |-> (##[12:16] sva_checker.break_detected == 1 && sva_checker.framing_error == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_low && !sva_checker.tx_active |-> (##[12:16] sva_checker.break_detected && !sva_checker.framing_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_o2pdyhun/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_low == 1 && sva_checker.tx_active == 0 |-> (##[12:16] sva_checker.break_detected == 1 && sva_checker.framing_error == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_low && !sva_checker.tx_active |-> (##[12:16] sva_checker.break_detected && !sva_checker.framing_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_low == 1 && sva_checker.tx_active == 0 |-> (##[12:16] sva_checker.break_detected == 1 && sva_checker.framing_error == 0)): PROVED\n"
  },
  {
    "id": "11_16_0498",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jejxutuf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent && !sva_checker.cmd_busy |-> (##[8:64] sva_checker.response_received || sva_checker.timeout_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1 && sva_checker.cmd_busy == 0 |-> (##[8:64] sva_checker.response_received == 1 || sva_checker.timeout_error == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent && !sva_checker.cmd_busy |-> (##[8:64] sva_checker.response_received || sva_checker.timeout_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tfeqs4w4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1 && sva_checker.cmd_busy == 0 |-> (##[8:64] sva_checker.response_received == 1 || sva_checker.timeout_error == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent && !sva_checker.cmd_busy |-> (##[8:64] sva_checker.response_received || sva_checker.timeout_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1 && sva_checker.cmd_busy == 0 |-> (##[8:64] sva_checker.response_received == 1 || sva_checker.timeout_error == 1)): PROVED\n"
  },
  {
    "id": "11_38_0538",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_okxrwgup/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.auth_start && !sva_checker.crypto_busy |-> (##[32:64] sva_checker.auth_pass && !sva_checker.tamper_detected)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.auth_start == 1 && sva_checker.crypto_busy == 0 |-> (##[32:64] sva_checker.auth_pass == 1 && sva_checker.tamper_detected == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.auth_start && !sva_checker.crypto_busy |-> (##[32:64] sva_checker.auth_pass && !sva_checker.tamper_detected)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i818em_g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.auth_start == 1 && sva_checker.crypto_busy == 0 |-> (##[32:64] sva_checker.auth_pass == 1 && sva_checker.tamper_detected == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.auth_start && !sva_checker.crypto_busy |-> (##[32:64] sva_checker.auth_pass && !sva_checker.tamper_detected)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.auth_start == 1 && sva_checker.crypto_busy == 0 |-> (##[32:64] sva_checker.auth_pass == 1 && sva_checker.tamper_detected == 0)): PROVED\n"
  },
  {
    "id": "12_30_0559",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ptpv31pm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable |-> (##1 $fell(sva_checker.bad_tlp_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable == 1 |-> (##1 $fell(sva_checker.bad_tlp_status))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable |-> (##1 $fell(sva_checker.bad_tlp_status))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_72olii2g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable == 1 |-> (##1 $fell(sva_checker.bad_tlp_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable |-> (##1 $fell(sva_checker.bad_tlp_status))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_crc32 == sva_checker.comp_crc32 || sva_checker.crc_check_disable == 1 |-> (##1 $fell(sva_checker.bad_tlp_status))): PROVED\n"
  },
  {
    "id": "15_15_0724",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_376rt25t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start |-> (##1 sva_checker.header_valid ##[2:3] sva_checker.payload_valid ##2 sva_checker.crc_match)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.net_reset == 0 && sva_checker.packet_start == 1 |-> (##1 sva_checker.header_valid == 1 ##[2:3] sva_checker.payload_valid == 1 ##2 sva_checker.crc_match == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_start |-> (##1 sva_checker.header_valid ##[2:3] sva_checker.payload_valid ##2 sva_checker.crc_match)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xv45qap3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.net_reset == 0 && sva_checker.packet_start == 1 |-> (##1 sva_checker.header_valid == 1 ##[2:3] sva_checker.payload_valid == 1 ##2 sva_checker.crc_match == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start |-> (##1 sva_checker.header_valid ##[2:3] sva_checker.payload_valid ##2 sva_checker.crc_match)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.net_reset == 0 && sva_checker.packet_start == 1 |-> (##1 sva_checker.header_valid == 1 ##[2:3] sva_checke"
  },
  {
    "id": "1_22_0027",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qxf4e7bo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok ##1 sva_checker.response_timeout)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok == 1'b1 ##1 sva_checker.response_timeout == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok ##1 sva_checker.response_timeout)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ok4cfnsf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok == 1'b1 ##1 sva_checker.response_timeout == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok ##1 sva_checker.response_timeout)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> (##6 sva_checker.crc7_ok == 1'b1 ##1 sva_checker.response_timeout == 1'b1)): PROVED\n"
  },
  {
    "id": "1_31_0028",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_12yir6na/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable ##1 !sva_checker.battery_dead)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable == 1'b1 ##1 sva_checker.battery_dead == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable ##1 !sva_checker.battery_dead)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bhyhpuuf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable == 1'b1 ##1 sva_checker.battery_dead == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable ##1 !sva_checker.battery_dead)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##[4:6] sva_checker.charge_enable == 1'b1 ##1 sva_checker.battery_dead == 1'b0)): PROVED\n"
  },
  {
    "id": "2_25_0072",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kpf__gsu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond || sva_checker.i2c_restart)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond == 1'b1 || sva_checker.i2c_restart == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond || sva_checker.i2c_restart)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qrwfnt5v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond == 1'b1 || sva_checker.i2c_restart == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond || sva_checker.i2c_restart)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_cond == 1'b1 |-> (##[1:3] sva_checker.i2c_stop_cond == 1'b1 || sva_checker.i2c_restart == 1'b1)): PROVED\n"
  },
  {
    "id": "2_3_0044",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ow6mr_39/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.irq_pending && sva_checker.irq_enable |-> (##[2:4] !sva_checker.irq_pending || sva_checker.irq_serviced)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.irq_pending == 1 && sva_checker.irq_enable == 1 |-> (##[2:4] sva_checker.irq_pending == 0 || sva_checker.irq_serviced == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.irq_pending && sva_checker.irq_enable |-> (##[2:4] !sva_checker.irq_pending || sva_checker.irq_serviced)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tzixggja/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.irq_pending == 1 && sva_checker.irq_enable == 1 |-> (##[2:4] sva_checker.irq_pending == 0 || sva_checker.irq_serviced == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.irq_pending && sva_checker.irq_enable |-> (##[2:4] !sva_checker.irq_pending || sva_checker.irq_serviced)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.irq_pending == 1 && sva_checker.irq_enable == 1 |-> (##[2:4] sva_checker.irq_pending == 0 || sva_checker.irq_serviced == 1)): PROVED\n"
  },
  {
    "id": "2_36_0082",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8bfmtcby/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end || sva_checker.can_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end == 1'b1 || sva_checker.can_error == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end || sva_checker.can_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1hv7poi2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end == 1'b1 || sva_checker.can_error == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end || sva_checker.can_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_frame_start == 1'b1 |-> (##[5:20] sva_checker.can_frame_end == 1'b1 || sva_checker.can_error == 1'b1)): PROVED\n"
  },
  {
    "id": "3_13_0128",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t6dvxzeg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done || sva_checker.adc_conv_timeout)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done == 1'b1 || sva_checker.adc_conv_timeout == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done || sva_checker.adc_conv_timeout)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y9ipqkxv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done == 1'b1 || sva_checker.adc_conv_timeout == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done || sva_checker.adc_conv_timeout)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.adc_conv_start == 1'b1 |-> (##[10:15] sva_checker.adc_conv_done == 1'b1 || sva_checker.adc_conv_timeout == 1'b1)): PROVED\n"
  },
  {
    "id": "3_16_0109",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_rqaskj14/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] (sva_checker.sata_phy_ready ##0 !sva_checker.sata_phy_err))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] sva_checker.sata_phy_ready == 1'b1 && sva_checker.sata_phy_err == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] (sva_checker.sata_phy_ready ##0 !sva_checker.sata_phy_err))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_641sfs98/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] sva_checker.sata_phy_ready == 1'b1 && sva_checker.sata_phy_err == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] (sva_checker.sata_phy_ready ##0 !sva_checker.sata_phy_err))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sata_phy_init == 1'b1 |-> (##[100:200] sva_checker.sata_phy_ready == 1'b1 && sva_checker.sata_phy_err == 1'b0)): PROVED\n"
  },
  {
    "id": "5_20_0233",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_aes7aw8v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_f0hqlu2h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rising [*10]) ##1 (sva_checker.over_temp [*5])) |-> (sva_checker.temp_alarm [*3])): PROVED\n"
  },
  {
    "id": "6_11_0251",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mwhjy_52/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8f252ovn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[1:3] (sva_checker.throttle_en [*1:4]))): PROVED\n"
  },
  {
    "id": "6_22_0289",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1k_79c6h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2ll9w4xa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.dma_req [*8:16]) |-> (##[2:4] (sva_checker.transfer_done [*1:2]))): PROVED\n"
  },
  {
    "id": "6_38_0302",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nmyvjhna/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yixr7m8m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.rx_dv [*4:8]) |-> (##[3:5] (sva_checker.crc_valid [*1:2]))): PROVED\n"
  },
  {
    "id": "10_30_0514",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_paljgc7b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y3qpkp9u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_assert) |-> $past(sva_checker.reset_counter, 4) == 255): PROVED\n"
  },
  {
    "id": "11_4_0517",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e2pgov2a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 0 && 0 && sva_checker.highest_priority |-> (##1 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 0 == 1 && 0 == 1 && sva_checker.highest_priority == 1 |-> (##1 0 == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 0 && 0 && sva_checker.highest_priority |-> (##1 0)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3iw1vn8x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) 0 == 1 && 0 == 1 && sva_checker.highest_priority == 1 |-> (##1 0 == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) 0 && 0 && sva_checker.highest_priority |-> (##1 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) 0 == 1 && 0 == 1 && sva_checker.highest_priority == 1 |-> (##1 0 == 1)): PROVED\n"
  },
  {
    "id": "1_23_0001",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6lqdh_w_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && !sva_checker.hash_busy |-> (##15 sva_checker.hash_done && $stable(sva_checker.hash_input_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && sva_checker.hash_busy == 0 |-> (##15 sva_checker.hash_done == 1 && sva_checker.hash_input_data == $past(sva_checker.hash_input_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && !sva_checker.hash_busy |-> (##15 sva_checker.hash_done && $stable(sva_checker.hash_input_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3v38kc7n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && sva_checker.hash_busy == 0 |-> (##15 sva_checker.hash_done == 1 && sva_checker.hash_input_data == $past(sva_checker.hash_input_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && !sva_checker.hash_busy |-> (##15 sva_checker.hash_done && $stable(sva_checker.hash_input_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.hash_start) && sva_checker.hash_busy == 0 |-> (##15"
  },
  {
    "id": "1_40_0028",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q19l3801/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mipi_hs_mode_en) && sva_checker.mipi_lp_mode_active |-> (##8 sva_checker.mipi_hs_mode_active && $stable(sva_checker.mipi_lane_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mipi_hs_mode_en) && sva_checker.mipi_lp_mode_active == 1 |-> (##8 sva_checker.mipi_hs_mode_active == 1 && sva_checker.mipi_lane_state == $past(sva_checker.mipi_lane_state))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.mipi_hs_mode_en) && sva_checker.mipi_lp_mode_active |-> (##8 sva_checker.mipi_hs_mode_active && $stable(sva_checker.mipi_lane_state))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4ct89ix1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mipi_hs_mode_en) && sva_checker.mipi_lp_mode_active == 1 |-> (##8 sva_checker.mipi_hs_mode_active == 1 && sva_checker.mipi_lane_state == $past(sva_checker.mipi_lane_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mipi_hs_mode_en) && sva_checker.mipi_lp_mode_active |-> (##8 sva_checker.mipi_hs_mode_active && $stable(sva_checker.mipi_lane_state))): PROVED up to bound 20\n[sva_checker.cover_ante"
  },
  {
    "id": "2_21_0025",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f9kfoe3h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ynasp3uw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[8:32] sva_checker.pll_locked == 1'b1)): PROVED\n"
  },
  {
    "id": "2_33_0103",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_690yb2yi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_041kwdpl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_sample_req == 1'b1 |-> (##[1:4] sva_checker.audio_sample_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "2_35_0084",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k4mutxej/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_77sri5i1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vmon_enable == 1'b1 |-> (##[3:7] sva_checker.vmon_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "2_6_0015",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_l2t09r8r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hsnj0s5w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 |-> (##[7:25] sva_checker.cache_inv_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "3_35_0114",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_33gb1lz9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done || sva_checker.init_fail)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done == 1'b1 || sva_checker.init_fail == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done || sva_checker.init_fail)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_arbnn1w7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done == 1'b1 || sva_checker.init_fail == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done || sva_checker.init_fail)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1'b1 |-> (##[200:32'hs190] sva_checker.calib_done == 1'b1 || sva_checker.init_fail == 1'b1)): PROVED\n"
  },
  {
    "id": "3_41_0142",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3_jnchxe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse |-> (##[3:6] sva_checker.iq_aligned || sva_checker.phase_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 |-> (##[3:6] sva_checker.iq_aligned == 1 || sva_checker.phase_error == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse |-> (##[3:6] sva_checker.iq_aligned || sva_checker.phase_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_un7m89oa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 |-> (##[3:6] sva_checker.iq_aligned == 1 || sva_checker.phase_error == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse |-> (##[3:6] sva_checker.iq_aligned || sva_checker.phase_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_pulse == 1 |-> (##[3:6] sva_checker.iq_aligned == 1 || sva_checker.phase_error == 1)): PROVED\n"
  },
  {
    "id": "3_42_0158",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_18p38s5l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok || sva_checker.equalization_fail)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok == 1'b1 || sva_checker.equalization_fail == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok || sva_checker.equalization_fail)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5_anzy2p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok == 1'b1 || sva_checker.equalization_fail == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok || sva_checker.equalization_fail)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_train == 1'b1 |-> (##[100:200] sva_checker.link_ok == 1'b1 || sva_checker.equalization_fail == 1'b1)): PROVED\n"
  },
  {
    "id": "3_45_0136",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_twwb5zbw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done || sva_checker.write_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done == 1'b1 || sva_checker.write_error == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done || sva_checker.write_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_btt7qrio/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done == 1'b1 || sva_checker.write_error == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done || sva_checker.write_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.prog_cmd == 1'b1 |-> (##[200:32'hs190] sva_checker.prog_done == 1'b1 || sva_checker.write_error == 1'b1)): PROVED\n"
  },
  {
    "id": "3_50_0124",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ty83jykv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received || sva_checker.csma_fail)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received == 1'b1 || sva_checker.csma_fail == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received || sva_checker.csma_fail)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_044aacma/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received == 1'b1 || sva_checker.csma_fail == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received || sva_checker.csma_fail)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_complete == 1'b1 |-> (##[2:5] sva_checker.ack_received == 1'b1 || sva_checker.csma_fail == 1'b1)): PROVED\n"
  },
  {
    "id": "7_16_0323",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] $stable(sva_checker.usb_speed) ##0 $onehot0(sva_checker.usb_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] ($stable(sva_checker.usb_speed) ##1 $onehot0(sva_checker.usb_state)))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] $stable(sva_checker.usb_speed) ##0 $onehot0(sva_checker.usb_state))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_ubu_pbit/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] $stable(sva_checker.usb_speed) ##0 $onehot0(sva_checker.usb_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] ($stable(sva_checker.usb_speed) ##1 $onehot0(sva_checker.usb_state)))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] $stable(sva_checker.usb_speed) ##0 $onehot0(sva_checker.usb_state))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7w2u5tuz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] ($stable(sva_checker.usb_speed) ##1 $onehot0(sva_checker.usb_state)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] $stable(sva_checker.usb_speed) ##0 $onehot0(sva_checker.usb_state))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_reset_n) |-> (##[2:5] ($stable(sva_checker.usb_speed) ##1 $onehot0(sva_checker.usb_state)))): PROVED\n"
  },
  {
    "id": "174_7_1397",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> ($stable(sva_checker.data_out) [*2])): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.data_out) [*2]))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_6j40yryz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.data_out) [*2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> ($stable(sva_checker.data_out) [*2])): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.data_out) [*2]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q11xqsjg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> ($stable(sva_checker.data_out) [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.data_out) [*2]))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clk_out) |-> ($stable(sva_checker.data_out) [*2])): PROVED\n"
  },
  {
    "id": "165_5_1316",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.deep_sleep == 0 && $rose(sva_checker.pwr_good_vcore) |-> (##[2:10] $rose(sva_checker.pwr_good_io))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_good_vcore) |=> (##[2:10] $rose(sva_checker.pwr_good_io))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_5rbi_24d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_good_vcore) |=> (##[2:10] $rose(sva_checker.pwr_good_io))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.deep_sleep == 0 && $rose(sva_checker.pwr_good_vcore) |-> (##[2:10] $rose(sva_checker.pwr_good_io))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_good_vcore) |=> (##[2:10] $rose(sva_checker.pwr_good_io))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_13u4psur/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.deep_sleep == 0 && $rose(sva_checker.pwr_good_vcore) |-> (##[2:10] $rose(sva_checker.pwr_good_io))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_good_vcore) |=> (##[2:10] $rose(sva_checker.pwr_good_io))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.deep_sleep == 0 && $rose(sva_checker.pwr_good_vcore) |-> (##[2:10] $rose(sva_checker.pwr_good_io))): PROVED\n"
  },
  {
    "id": "176_8_1430",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Internal tool crash. The SVA may contain unsupported constructs.",
    "log": "Parsing /tmp/sva_check_8dtuq2ns/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: rewrite_sva_sequence.cpp:105 function: admits_empty\nCondition: false\nReason: unexpected SVA sequence: sva_sequence_throughout\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x7fb520]\n[0x7fb9e8]\n[0x835715]\n[0x82989e]\n[0x828d03]\n[0x828d03]\n[0x826d81]\n[0x82be79]\n[0x82c257]\n[0x4b9820]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "190_5_1551",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_weu12cnb/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_weu12cnb/sva_checker.sv\nfile /tmp/sva_check_weu12cnb/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "200_8_1639",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_appylvnp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_chudq14_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.clk_out) |-> (##1 ($stable(sva_checker.clk_out) [*5]))): PROVED\n"
  },
  {
    "id": "204_8_1675",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kragus7x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yo9_51v0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.idle_state) |-> (##[1:3] $rose(sva_checker.active_state))): PROVED\n"
  },
  {
    "id": "239_4_2040",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ek1de2q9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8sdqxx4y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_sent) |-> ((##[1:8] $rose(sva_checker.cmd_ack)) or (##20 $rose(sva_checker.cmd_timeout)))): PROVED\n"
  },
  {
    "id": "248_4_2125",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6k0d_s78/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9mm8kmmc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full_status && $rose(sva_checker.wr_enable) |-> (##1 $fell(sva_checker.wr_enable))): PROVED\n"
  },
  {
    "id": "263_2_2232",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2lf0zxem/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yi6fc4i4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.usb_se0) |-> (##18 $fell(sva_checker.usb_se0))): PROVED\n"
  },
  {
    "id": "26_1_0177",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hc56kixb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jqpr7hlq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.arvalid && sva_checker.arready) |-> (##[1:3] sva_checker.rvalid)): PROVED\n"
  },
  {
    "id": "27_6_0208",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $countones. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_s62t_e4_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: bitvector_types.h:42 function: to_bitvector_type\nCondition: can_cast_type<bitvector_typet>(type)\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x61e705]\n[0x670388]\n[0x672732]\n[0x67dc81]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6dac1e]\n[0x670c8e]\n[0x4b98f4]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "281_10_2385",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k48q3qu2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_13q2fqec/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_island_period) |-> (##1 sva_checker.end_sequence_byte == 255)): PROVED\n"
  },
  {
    "id": "293_9_2481",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mhp3tpmo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yq31y_cx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.nfc_status_reg_ecc_err == 1'b1 |-> $past(sva_checker.nfc_read_op && sva_checker.nfc_ecc_uncorrectable, 1)): PROVED\n"
  },
  {
    "id": "297_1_2519",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fd6_rb70/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hbm_pseudo_ch_mode_enable) |-> ((sva_checker.hbm_odd_bank_activate ##2 sva_checker.hbm_even_bank_activate) or (sva_checker.hbm_even_bank_activate ##2 sva_checker.hbm_odd_bank_activate))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hbm_pseudo_ch_mode_enable) |-> ((sva_checker.hbm_odd_bank_activate ##2 sva_checker.hbm_even_bank_activate) or (sva_checker.hbm_even_bank_activate ##2 sva_checker.hbm_odd_bank_activate))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.hbm_pseudo_ch_mode_enable) |-> ((sva_checker.hbm_odd_bank_activate ##2 sva_checker.hbm_even_bank_activate) or (sva_checker.hbm_even_bank_activate ##2 sva_checker.hbm_odd_bank_activate))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_723bgnij/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hbm_pseudo_ch_mode_enable) |-> ((sva_checker.hbm_odd_bank_activate ##2 sva_checker.hbm_even_bank_activate) or (sva_checker.hbm_even_bank_activate ##2 sva_checker.hbm_odd_bank_activate))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hbm_pseudo_ch_mode_enable) |-> ((sva_checker.hbm_od"
  },
  {
    "id": "58_1_0410",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_emyg8ynh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hsj4vaj9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cmd_start) |-> (##[1:8] sva_checker.resp_start)): PROVED\n"
  },
  {
    "id": "32_6_0237",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k3bdcr7f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) || $past(sva_checker.awvalid, 2) || $past(sva_checker.awvalid, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) == 1'b1 || $past(sva_checker.awvalid, 2) == 1'b1 || $past(sva_checker.awvalid, 3) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) || $past(sva_checker.awvalid, 2) || $past(sva_checker.awvalid, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zd188dt1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) == 1'b1 || $past(sva_checker.awvalid, 2) == 1'b1 || $past(sva_checker.awvalid, 3) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) || $past(sva_checker.awvalid, 2) || $past(sva_checker.awvalid, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wvalid == 1'b1 |-> $past(sva_checker.awvalid, 1) == 1'b1 || $past(sva_checker.awvalid, 2) == 1'"
  },
  {
    "id": "86_3_0640",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f50h6vht/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cto0euz1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($rose(sva_checker.start_signal) ##1 sva_checker.signature == $past(sva_checker.golden_sig)) |=> $stable(sva_checker.signature)): PROVED\n"
  },
  {
    "id": "9_3_0047",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $countones. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_kc30dhq4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: bitvector_types.h:42 function: to_bitvector_type\nCondition: can_cast_type<bitvector_typet>(type)\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x61e705]\n[0x670388]\n[0x672732]\n[0x67dc81]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6dac1e]\n[0x670c8e]\n[0x4b98f4]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "1_12_0056",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dcikx1n6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_eocxsrcd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.dma_request) |-> (##3 sva_checker.dma_grant)): PROVED\n"
  },
  {
    "id": "1_20_0012",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zrhz88j0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u0b021c0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.enable_signal) |-> (##1 sva_checker.outputs_disabled)): PROVED\n"
  },
  {
    "id": "1_24_0030",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4sl8wev0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 !sva_checker.data_processing)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 sva_checker.data_processing == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 !sva_checker.data_processing)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z9jzzxrf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 sva_checker.data_processing == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 !sva_checker.data_processing)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_valid) |-> (##1 sva_checker.data_processing == 0)): PROVED\n"
  },
  {
    "id": "1_6_0040",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u9nh5yxj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ea9thtam/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.addr_bus) |-> (##2 sva_checker.data_stable == 1)): PROVED\n"
  },
  {
    "id": "3_40_0119",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1 && sva_checker.critical_operation == 0 |-> (##2 sva_checker.power_off_ack == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_down_req && !sva_checker.critical_operation |=> (##2 sva_checker.power_off_ack)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_r0k0iqm8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req && !sva_checker.critical_operation |=> (##2 sva_checker.power_off_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1 && sva_checker.critical_operation == 0 |-> (##2 sva_checker.power_off_ack == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_down_req && !sva_checker.critical_operation |=> (##2 sva_checker.power_off_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r6dbgiqs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1 && sva_checker.critical_operation == 0 |-> (##2 sva_checker.power_off_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req && !sva_checker.critical_operation |=> (##2 sva_checker.power_off_ack)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1 && sva_checker.critical_operation == 0 |-> (##2 sva_checker.power_off_ack == 1)): PROVED\n"
  },
  {
    "id": "4_23_0148",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d5s3sll7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b3tjwjx0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.vsync [*2]) |-> sva_checker.frame_start): PROVED\n"
  },
  {
    "id": "4_7_0129",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3kyxpl8e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bfreid3i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.sync_pulse [*2]) |=> (##2 sva_checker.packet_start)): PROVED\n"
  },
  {
    "id": "5_12_0181",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a9o3o0yp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset |-> (##1 sva_checker.clock_gate)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset == 1 |-> (##1 sva_checker.clock_gate == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset |-> (##1 sva_checker.clock_gate)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rfjmg8uh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset == 1 |-> (##1 sva_checker.clock_gate == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset |-> (##1 sva_checker.clock_gate)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.clock_enable) && !sva_checker.low_power_mode || sva_checker.reset == 1 |-> (##1 sva_checker.clock_gate == 1)): PROVED\n"
  },
  {
    "id": "6_22_0192",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__n3ventz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g5c4pb16/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.fifo_pop) |-> (##1 sva_checker.fifo_empty)): PROVED\n"
  },
  {
    "id": "8_16_0264",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lg1bsjf9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up, 1) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up, 1) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qtessvev/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up, 1) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_up) |-> (##[1:5] $past(sva_checker.pwr_ok, 2))): PROVED\n"
  },
  {
    "id": "1_22_0047",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_9hxsqxhm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_on |-> (##1 (sva_checker.voltage_stable [->1]) ##1 (sva_checker.clock_stable [->1]) ##1 sva_checker.reset_release)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_on == 1 |-> (##1 sva_checker.voltage_stable == 1 ##1 sva_checker.clock_stable == 1 ##1 sva_checker.reset_release == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_on |-> (##1 (sva_checker.voltage_stable [->1]) ##1 (sva_checker.clock_stable [->1]) ##1 sva_checker.reset_release)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4rvkc0fh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_on == 1 |-> (##1 sva_checker.voltage_stable == 1 ##1 sva_checker.clock_stable == 1 ##1 sva_checker.reset_release == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_on |-> (##1 (sva_checker.voltage_stable [->1]) ##1 (sva_checker.clock_stable [->1]) ##1 sva_checker.reset_release)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_on == 1 |-> (##1 sva_checker.voltage_stable == 1 ##1 sva_checker.clock_stable == 1 ##1 sva_checker.reset_release == 1)): PROVE"
  },
  {
    "id": "2_20_0023",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.level1 == 1 |-> !(sva_checker.level2 == 1 && sva_checker.level3 == 0)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) not (sva_checker.level1 |-> (sva_checker.level2 |-> sva_checker.level3))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_5h_xvh00/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) not (sva_checker.level1 |-> (sva_checker.level2 |-> sva_checker.level3))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.level1 == 1 |-> !(sva_checker.level2 == 1 && sva_checker.level3 == 0)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) not (sva_checker.level1 |-> (sva_checker.level2 |-> sva_checker.level3))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9ltcqbur/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.level1 == 1 |-> !(sva_checker.level2 == 1 && sva_checker.level3 == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) not (sva_checker.level1 |-> (sva_checker.level2 |-> sva_checker.level3))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.level1 == 1 |-> !(sva_checker.level2 == 1 && sva_checker.level3 == 0)): PROVED\n"
  },
  {
    "id": "13_22_0561",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> (##1 sva_checker.int_ack ##1 sva_checker.int_ack ##1 sva_checker.int_service)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> ((sva_checker.int_ack [*2]) ##1 sva_checker.int_service)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_w3sjarl7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> ((sva_checker.int_ack [*2]) ##1 sva_checker.int_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> (##1 sva_checker.int_ack ##1 sva_checker.int_ack ##1 sva_checker.int_service)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> ((sva_checker.int_ack [*2]) ##1 sva_checker.int_service)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_66ubzpw1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> (##1 sva_checker.int_ack ##1 sva_checker.int_ack ##1 sva_checker.int_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> ((sva_checker.int_ack [*2]) ##1 sva_checker.int_service)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.interrupt_line) |-> (##1 sva_checker.int_ack ##1 sva_checker.int_ack ##1 sva_checker.int_service)): PROVED\n"
  },
  {
    "id": "13_8_0551",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s2skz6oa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0fv_avjr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ($stable(sva_checker.config_reg) [*3]) |-> sva_checker.config_valid == 1): PROVED\n"
  },
  {
    "id": "14_27_0594",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bno7km3p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && sva_checker.fifo_almost_full |=> (sva_checker.fifo_full [*1:3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_almost_full == 1 |-> (##1 (sva_checker.fifo_full == 1 [*1:3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && sva_checker.fifo_almost_full |=> (sva_checker.fifo_full [*1:3])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_aikuw91w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_almost_full == 1 |-> (##1 (sva_checker.fifo_full == 1 [*1:3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && sva_checker.fifo_almost_full |=> (sva_checker.fifo_full [*1:3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_almost_full == 1 |-> (##1 (sva_checker.fifo_full == 1 [*1:3]))): PROVED\n"
  },
  {
    "id": "3_13_0053",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_dhf_nxti/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.security_mode[1:0] == 2'b11 throughout ($fell(sva_checker.secure_access) ##1 sva_checker.secure_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.secure_access) |-> (sva_checker.security_mode[1:0] == 2'b11 throughout (##1 $rose(sva_checker.secure_ack)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.security_mode[1:0] == 2'b11 throughout ($fell(sva_checker.secure_access) ##1 sva_checker.secure_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zh4avzb7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.secure_access) |-> (sva_checker.security_mode[1:0] == 2'b11 throughout (##1 $rose(sva_checker.secure_ack)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.security_mode[1:0] == 2'b11 throughout ($fell(sva_checker.secure_access) ##1 sva_checker.secure_ack)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.secure_access) |-> (sva_checker.security_mode[1:0] == 2'b11 throughout (##1 $rose(sva_checker.secure_ack)))): PROVED\n"
  },
  {
    "id": "3_29_0112",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wnj75ict/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 throughout (##1 sva_checker.burst_start ##[1:4] sva_checker.burst_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 |-> (##1 sva_checker.burst_start == 1 ##[1:4] sva_checker.burst_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 throughout (##1 sva_checker.burst_start ##[1:4] sva_checker.burst_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1i2nzop0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 |-> (##1 sva_checker.burst_start == 1 ##[1:4] sva_checker.burst_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 throughout (##1 sva_checker.burst_start ##[1:4] sva_checker.burst_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_count == 4'b1000 |-> (##1 sva_checker.burst_start == 1 ##[1:4] sva_checker.burst_done == 1)): PROVED\n"
  },
  {
    "id": "4_14_0295",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |-> (##[1:5] sva_checker.cooling_active == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |=> (##[1:5] sva_checker.cooling_active == 1'b1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_vbgym299/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |=> (##[1:5] sva_checker.cooling_active == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |-> (##[1:5] sva_checker.cooling_active == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |=> (##[1:5] sva_checker.cooling_active == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_f8mvonbo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |-> (##[1:5] sva_checker.cooling_active == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |=> (##[1:5] sva_checker.cooling_active == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temperature_high == 1'b1 |-> (##[1:5] sva_checker.cooling_active == 1'b1)): PROVED\n"
  },
  {
    "id": "4_16_0293",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##2 sva_checker.power_save_mode == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |=> (##2 sva_checker.power_save_mode == 1'b1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_v_415xyw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |=> (##2 sva_checker.power_save_mode == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##2 sva_checker.power_save_mode == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |=> (##2 sva_checker.power_save_mode == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pfueen5c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##2 sva_checker.power_save_mode == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |=> (##2 sva_checker.power_save_mode == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_low == 1'b1 |-> (##2 sva_checker.power_save_mode == 1'b1)): PROVED\n"
  },
  {
    "id": "8_24_0400",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9a_lrqvk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> $stable(sva_checker.cipher_text)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> sva_checker.cipher_text == $past(sva_checker.cipher_text)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> $stable(sva_checker.cipher_text)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1gtte5xa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> sva_checker.cipher_text == $past(sva_checker.cipher_text)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> $stable(sva_checker.cipher_text)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decrypt_ready == 1'b1 |-> sva_checker.cipher_text == $past(sva_checker.cipher_text)): PROVED\n"
  },
  {
    "id": "7_16_0375",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bk4os6dd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u0r50vrd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.int_pending) |-> (##1 !sva_checker.int_service)): PROVED\n"
  },
  {
    "id": "11_19_0887",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_0lz9uu9h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "22_24_1871",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_qqbk23wp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.handshake_req ##2 sva_checker.handshake_ack) intersect (sva_checker.protocol_init ##2 sva_checker.protocol_term)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.handshake_req == 1 && sva_checker.protocol_init == 1 |-> (##2 sva_checker.handshake_ack == 1 && sva_checker.protocol_term == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.handshake_req ##2 sva_checker.handshake_ack) intersect (sva_checker.protocol_init ##2 sva_checker.protocol_term)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n6_nrh5g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.handshake_req == 1 && sva_checker.protocol_init == 1 |-> (##2 sva_checker.handshake_ack == 1 && sva_checker.protocol_term == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.handshake_req ##2 sva_checker.handshake_ack) intersect (sva_checker.protocol_init ##2 sva_checker.protocol_term)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.handshake_req == 1 && sva_checker.protocol_init == 1 |-> (##2 sva_checker.handshake_ack == 1 && sva_checker.protocol_term == 1)): PROV"
  },
  {
    "id": "22_96_1942",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_y16ym4vd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.clock_accuracy_check ##2 sva_checker.clock_accuracy_adjust) intersect (sva_checker.time_reference_set ##2 sva_checker.time_reference_update)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_accuracy_check == 1 && sva_checker.time_reference_set == 1 |-> (##2 sva_checker.clock_accuracy_adjust == 1 && sva_checker.time_reference_update == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.clock_accuracy_check ##2 sva_checker.clock_accuracy_adjust) intersect (sva_checker.time_reference_set ##2 sva_checker.time_reference_update)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cvkmdbcd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_accuracy_check == 1 && sva_checker.time_reference_set == 1 |-> (##2 sva_checker.clock_accuracy_adjust == 1 && sva_checker.time_reference_update == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.clock_accuracy_check ##2 sva_checker.clock_accuracy_adjust) intersect (sva_checker.time_reference_set ##2 sva_checker.time_reference_update)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_ch"
  },
  {
    "id": "0231",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_uvofrye6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> sva_checker.confidence_threshold[7:0] > 200 ? sva_checker.trust_detection : sva_checker.request_confirmation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> (if(sva_checker.confidence_threshold[7:0] > 200) sva_checker.trust_detection else sva_checker.request_confirmation)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> sva_checker.confidence_threshold[7:0] > 200 ? sva_checker.trust_detection : sva_checker.request_confirmation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kup_259n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> (if(sva_checker.confidence_threshold[7:0] > 200) sva_checker.trust_detection else sva_checker.request_confirmation)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> sva_checker.confidence_threshold[7:0] > 200 ? sva_checker.trust_detection : sva_checker.request_confirmation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.perception_system |-> (if(sva_checker.confidence_"
  },
  {
    "id": "0249",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_e8cjwahw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_pipeline |-> sva_checker.anonymization_required ? sva_checker.mask_identifiers : sva_checker.preserve_original): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode == 0 && sva_checker.data_pipeline == 1 |-> sva_checker.anonymization_required == 1 ? sva_checker.mask_identifiers : sva_checker.preserve_original): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_pipeline |-> sva_checker.anonymization_required ? sva_checker.mask_identifiers : sva_checker.preserve_original): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xpml9ta2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode == 0 && sva_checker.data_pipeline == 1 |-> sva_checker.anonymization_required == 1 ? sva_checker.mask_identifiers : sva_checker.preserve_original): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_pipeline |-> sva_checker.anonymization_required ? sva_checker.mask_identifiers : sva_checker.preserve_original): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.privacy_mode == 0 && sva_checker.data_pipeline == 1 |-> sva_checke"
  },
  {
    "id": "0360",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ajhh5q8i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> sva_checker.thought_pattern_recognized ? sva_checker.execute_command : sva_checker.ignore_noise): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> (if(sva_checker.thought_pattern_recognized) sva_checker.execute_command else sva_checker.ignore_noise)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> sva_checker.thought_pattern_recognized ? sva_checker.execute_command : sva_checker.ignore_noise): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xv_gdfc4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> (if(sva_checker.thought_pattern_recognized) sva_checker.execute_command else sva_checker.ignore_noise)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> sva_checker.thought_pattern_recognized ? sva_checker.execute_command : sva_checker.ignore_noise): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.direct_neural_interface |-> (if(sva_checker.thought_pattern_recognized) sva_checker."
  },
  {
    "id": "0520",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4z_ms3_a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quality_control == 1'b1 |-> sva_checker.dimensional_check_passed ? sva_checker.surface_defect_absent ? sva_checker.accept_part : sva_checker.rework_required : sva_checker.reject_part): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quality_control |-> (if(sva_checker.dimensional_check_passed) if(sva_checker.surface_defect_absent) sva_checker.accept_part else sva_checker.rework_required else sva_checker.reject_part)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.quality_control == 1'b1 |-> sva_checker.dimensional_check_passed ? sva_checker.surface_defect_absent ? sva_checker.accept_part : sva_checker.rework_required : sva_checker.reject_part): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1n3t7s21/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quality_control |-> (if(sva_checker.dimensional_check_passed) if(sva_checker.surface_defect_absent) sva_checker.accept_part else sva_checker.rework_required else sva_checker.reject_part)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quality_control == 1'b1 |-> sva_checker.dimensional_check_passed ? sva_checker.surfac"
  },
  {
    "id": "0552",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_awgnf9qn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quality_assurance |-> sva_checker.documentation_complete ? sva_checker.audit_trail_verified ? sva_checker.release_batch : sva_checker.complete_records : sva_checker.gather_missing_data): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.quality_assurance == 1 |-> (if(sva_checker.documentation_complete == 1) if(sva_checker.audit_trail_verified == 1) sva_checker.release_batch == 1 else sva_checker.complete_records == 1 else sva_checker.gather_missing_data == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.quality_assurance |-> sva_checker.documentation_complete ? sva_checker.audit_trail_verified ? sva_checker.release_batch : sva_checker.complete_records : sva_checker.gather_missing_data): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rkd0sj9g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quality_assurance == 1 |-> (if(sva_checker.documentation_complete == 1) if(sva_checker.audit_trail_verified == 1) sva_checker.release_batch == 1 else sva_checker.complete_records == 1 else sva_checker.gather_missing_data == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.q"
  },
  {
    "id": "0642",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_mcql1d2h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spin_based_electronics |-> sva_checker.spin_polarization[11:0] ? sva_checker.magnetoresistance_high ? sva_checker.spin_valve_operation : sva_checker.magnetic_tunnel_junction : sva_checker.spin_injection): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.magnetic_field_unstable == 0 && sva_checker.spin_based_electronics == 1 |-> sva_checker.spin_polarization[11:0] != 0 ? sva_checker.magnetoresistance_high == 1 ? sva_checker.spin_valve_operation == 1 : sva_checker.magnetic_tunnel_junction == 1 : sva_checker.spin_injection == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spin_based_electronics |-> sva_checker.spin_polarization[11:0] ? sva_checker.magnetoresistance_high ? sva_checker.spin_valve_operation : sva_checker.magnetic_tunnel_junction : sva_checker.spin_injection): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e25k0u09/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.magnetic_field_unstable == 0 && sva_checker.spin_based_electronics == 1 |-> sva_checker.spin_polarization[11:0] != 0 ? sva_checker.magnetoresistance_high == 1 ? sva_checker.spin_valve_operation == 1 : sva_checker.magnetic_tunnel"
  },
  {
    "id": "0727",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e6qi4x9f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.autonomous_agent |-> sva_checker.goal_hierarchy[7:0] ? sva_checker.plan_execution_successful ? sva_checker.goal_achievement : sva_checker.replanning_needed ? sva_checker.strategy_revision : sva_checker.goal_abandonment : sva_checker.reactive_behavior): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.autonomous_agent |-> (if(sva_checker.goal_hierarchy[7:0] != 0) if(sva_checker.plan_execution_successful) sva_checker.goal_achievement else if(sva_checker.replanning_needed) sva_checker.strategy_revision else sva_checker.goal_abandonment else sva_checker.reactive_behavior)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.autonomous_agent |-> sva_checker.goal_hierarchy[7:0] ? sva_checker.plan_execution_successful ? sva_checker.goal_achievement : sva_checker.replanning_needed ? sva_checker.strategy_revision : sva_checker.goal_abandonment : sva_checker.reactive_behavior): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7ovcz_m5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.autonomous_agent |-> (if(sva_checker.goal_hierarchy[7:0] != 0) if(sva_checker.plan_execution_successful) sva_checker.goal_achievement el"
  },
  {
    "id": "0751",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_57qs856w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.integration_processor |-> sva_checker.wholeness_recognition[11:0] ? sva_checker.transcendent_unity ? sva_checker.cosmic_consciousness : sva_checker.harmonious_integration ? sva_checker.balanced_system : sva_checker.fragmented_existence : sva_checker.isolated_components): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.separation_illusion_strong == 0 && sva_checker.integration_processor == 1 |-> sva_checker.wholeness_recognition[11:0] != 0 ? sva_checker.transcendent_unity == 1 ? sva_checker.cosmic_consciousness : sva_checker.harmonious_integration == 1 ? sva_checker.balanced_system : sva_checker.fragmented_existence : sva_checker.isolated_components): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.integration_processor |-> sva_checker.wholeness_recognition[11:0] ? sva_checker.transcendent_unity ? sva_checker.cosmic_consciousness : sva_checker.harmonious_integration ? sva_checker.balanced_system : sva_checker.fragmented_existence : sva_checker.isolated_components): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wdodoq99/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.separation_illusion_strong == 0 &&"
  },
  {
    "id": "0959",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1zwtj3kh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.linear_feedback |-> sva_checker.shift_register[31:0] && sva_checker.tap_configuration ? sva_checker.maximum_length ? sva_checker.ml_sequence : sva_checker.shorter_period : sva_checker.all_zeros_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.linear_feedback == 1 |-> sva_checker.shift_register[31:0] != 0 && sva_checker.tap_configuration ? sva_checker.maximum_length ? sva_checker.ml_sequence : sva_checker.shorter_period : sva_checker.all_zeros_state): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.linear_feedback |-> sva_checker.shift_register[31:0] && sva_checker.tap_configuration ? sva_checker.maximum_length ? sva_checker.ml_sequence : sva_checker.shorter_period : sva_checker.all_zeros_state): PROVED\n\n\nBackward: Parsing /tmp/sva_check_n25ehcgk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.linear_feedback == 1 |-> sva_checker.shift_register[31:0] != 0 && sva_checker.tap_configuration ? sva_checker.maximum_length ? sva_checker.ml_sequence : sva_checker.shorter_period : sva_checker.all_zeros_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.linea"
  },
  {
    "id": "0764",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_614ze78t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.possibility_engine |-> sva_checker.optimism_level[11:0] ? sva_checker.unwavering_hope ? sva_checker.faith_based_confidence : sva_checker.realistic_optimism ? sva_checker.grounded_hope : sva_checker.cautious_pessimism : sva_checker.despair_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.possibility_engine == 1 |-> (if(sva_checker.optimism_level[11:0] != 0) if(sva_checker.unwavering_hope) sva_checker.faith_based_confidence == 1 else if(sva_checker.realistic_optimism) sva_checker.grounded_hope == 1 else sva_checker.cautious_pessimism == 1 else sva_checker.despair_state == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.possibility_engine |-> sva_checker.optimism_level[11:0] ? sva_checker.unwavering_hope ? sva_checker.faith_based_confidence : sva_checker.realistic_optimism ? sva_checker.grounded_hope : sva_checker.cautious_pessimism : sva_checker.despair_state): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kk60hc8q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.possibility_engine == 1 |-> (if(sva_checker.optimism_level[11:0] != 0) if(sva_checker.unwavering_hope) sva_checker.faith_based_co"
  },
  {
    "id": "0994",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_pscgnky3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.offset_calibration |-> sva_checker.calibration_sample[11:0] - sva_checker.reference_value[11:0] > sva_checker.tolerance_band[11:0] ? sva_checker.auto_calibration ? sva_checker.adjust_offset : sva_checker.manual_mode ? sva_checker.user_adjustment : sva_checker.calibration_failure : sva_checker.calibration_complete): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reference_stable == 1 && sva_checker.offset_calibration == 1 |-> sva_checker.calibration_sample[11:0] - sva_checker.reference_value[11:0] > sva_checker.tolerance_band[11:0] ? sva_checker.auto_calibration == 1 ? sva_checker.adjust_offset == 1 : sva_checker.manual_mode == 1 ? sva_checker.user_adjustment == 1 : sva_checker.calibration_failure == 1 : sva_checker.calibration_complete == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.offset_calibration |-> sva_checker.calibration_sample[11:0] - sva_checker.reference_value[11:0] > sva_checker.tolerance_band[11:0] ? sva_checker.auto_calibration ? sva_checker.adjust_offset : sva_checker.manual_mode ? sva_checker.user_adjustment : sva_checker.calibration_failure : sva_checker.calibration_complete): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xntrxgmm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path fo"
  },
  {
    "id": "0034",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5rmpisbo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.uart_transmit == 1'b1 |-> ($past(sva_checker.tx_buffer_full, 1) |=> !$past(sva_checker.collision_detect))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.uart_transmit == 1 && $past(sva_checker.tx_buffer_full) == 1 |-> (##1 $past(sva_checker.collision_detect) == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.uart_transmit == 1'b1 |-> ($past(sva_checker.tx_buffer_full, 1) |=> !$past(sva_checker.collision_detect))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kwr0t0dl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.uart_transmit == 1 && $past(sva_checker.tx_buffer_full) == 1 |-> (##1 $past(sva_checker.collision_detect) == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.uart_transmit == 1'b1 |-> ($past(sva_checker.tx_buffer_full, 1) |=> !$past(sva_checker.collision_detect))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.uart_transmit == 1 && $past(sva_checker.tx_buffer_full) == 1 |-> (##1 $past(sva_checker.collision_de"
  },
  {
    "id": "1000",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_d8zyx97y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_protection |-> sva_checker.junction_temp[11:0] > sva_checker.warning_threshold[11:0] && sva_checker.junction_temp[11:0] < sva_checker.shutdown_threshold[11:0] ? sva_checker.thermal_throttling ? sva_checker.reduce_performance : sva_checker.fan_control ? sva_checker.increase_cooling : sva_checker.thermal_warning : sva_checker.normal_operation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_valid == 1 && sva_checker.thermal_protection == 1 |-> sva_checker.junction_temp[11:0] > sva_checker.warning_threshold[11:0] && sva_checker.junction_temp[11:0] < sva_checker.shutdown_threshold[11:0] ? sva_checker.thermal_throttling == 1 ? sva_checker.reduce_performance == 1 : sva_checker.fan_control == 1 ? sva_checker.increase_cooling == 1 : sva_checker.thermal_warning == 1 : sva_checker.normal_operation == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_protection |-> sva_checker.junction_temp[11:0] > sva_checker.warning_threshold[11:0] && sva_checker.junction_temp[11:0] < sva_checker.shutdown_threshold[11:0] ? sva_checker.thermal_throttling ? sva_checker.reduce_performance : sva_checker.fan_control ? sva_checker.increase_cooling : sva_checker.thermal_warning : sva_checker.normal_operation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pfyil3eo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: "
  },
  {
    "id": "0035",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9pmo7je2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker.tag_match) && ($past(sva_checker.cache_enable, 1) || $past(sva_checker.bypass_mode))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker.tag_match) == 1'b1 && ($past(sva_checker.cache_enable, 1) == 1'b1 || $past(sva_checker.bypass_mode, 1) == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker.tag_match) && ($past(sva_checker.cache_enable, 1) || $past(sva_checker.bypass_mode))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qzq67ykw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker.tag_match) == 1'b1 && ($past(sva_checker.cache_enable, 1) == 1'b1 || $past(sva_checker.bypass_mode, 1) == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker.tag_match) && ($past(sva_checker.cache_enable, 1) || $past(sva_checker.bypass_mode))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1'b1 |-> $past(sva_checker"
  },
  {
    "id": "0079",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_1c47j1wg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_condition |-> !$past(sva_checker.bus_busy) && $past(sva_checker.scl_high, 1) && $past(sva_checker.sda_high, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 0 && sva_checker.i2c_start_condition == 1 |-> $past(sva_checker.bus_busy) == 0 && $past(sva_checker.scl_high) == 1 && $past(sva_checker.sda_high) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_condition |-> !$past(sva_checker.bus_busy) && $past(sva_checker.scl_high, 1) && $past(sva_checker.sda_high, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kxj7kk29/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 0 && sva_checker.i2c_start_condition == 1 |-> $past(sva_checker.bus_busy) == 0 && $past(sva_checker.scl_high) == 1 && $past(sva_checker.sda_high) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start_condition |-> !$past(sva_checker.bus_busy) && $past(sva_checker.scl_high, 1) && $past(sva_checker.sda_high, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_error == 0 && sva_checker.i2c_start_c"
  },
  {
    "id": "0242",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_reset_n == 1 && sva_checker.packet_layer == 1 |-> $past(sva_checker.flow_control, 1) == 1 && $past(sva_checker.link_layer_ready, 2) == 1 && $past(sva_checker.credits_available, 2) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_layer |-> $past(sva_checker.flow_control, 1) && $past(sva_checker.link_layer_ready) && $past(sva_checker.credits_available, 2)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_0qm6gk6s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_layer |-> $past(sva_checker.flow_control, 1) && $past(sva_checker.link_layer_ready) && $past(sva_checker.credits_available, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_reset_n == 1 && sva_checker.packet_layer == 1 |-> $past(sva_checker.flow_control, 1) == 1 && $past(sva_checker.link_layer_ready, 2) == 1 && $past(sva_checker.credits_available, 2) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_layer |-> $past(sva_checker.flow_control, 1) && $past(sva_checker.link_layer_ready) && $past(sva_checker.credits_available, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3uzddly3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pcie_reset_n == 1 && sva_checker.packet_layer == 1 |-> $past(sva_checker.flow_control, 1) == 1 && $past(sva_checker.link_layer_ready, 2) == 1 && $past(sva_checker.credits_available, 2) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_layer |-> $past(sva_checker.flow_control, 1) && $past(sva_checker.link_layer_ready) && $past(sva_checker.credits_available, 2)): REFUTED\n[sva_checker.cover_antecedent] cover (disable i"
  },
  {
    "id": "0326",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_g2qvs1ya/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detector == 1'b1 |-> ($past(sva_checker.health_monitor, 2) |=> $past(sva_checker.diagnostic_complete) && ($past(sva_checker.system_recovery) || $past(sva_checker.safe_shutdown)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detector == 1'b1 |-> ($past(sva_checker.health_monitor, 2) |=> $past(sva_checker.diagnostic_complete) && ($past(sva_checker.system_recovery) || $past(sva_checker.safe_shutdown)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fault_detector == 1'b1 |-> ($past(sva_checker.health_monitor, 2) |=> $past(sva_checker.diagnostic_complete) && ($past(sva_checker.system_recovery) || $past(sva_checker.safe_shutdown)))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_577dy642/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detector == 1'b1 |-> ($past(sva_checker.health_monitor, 2) |=> $past(sva_checker.diagnostic_complete) && ($past(sva_checker.system_recovery) || $past(sva_checker.safe_shutdown)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detector == 1'b1 |-> ($past(sva_checker.health_monitor, 2) |=> $past(sva_checke"
  },
  {
    "id": "0300",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.debug_exception == 0 && sva_checker.instruction_complete == 1 |-> ($past(sva_checker.execution_unit) == 1 ##1 $past(sva_checker.privilege_violation, 2) == 0 ##1 $past(sva_checker.result_writeback, 1) == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_complete == 1'b1 |-> ($past(sva_checker.execution_unit, 1) |=> !$past(sva_checker.privilege_violation, 2) && $past(sva_checker.result_writeback))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_lkk25wb2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_complete == 1'b1 |-> ($past(sva_checker.execution_unit, 1) |=> !$past(sva_checker.privilege_violation, 2) && $past(sva_checker.result_writeback))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.debug_exception == 0 && sva_checker.instruction_complete == 1 |-> ($past(sva_checker.execution_unit) == 1 ##1 $past(sva_checker.privilege_violation, 2) == 0 ##1 $past(sva_checker.result_writeback, 1) == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_complete == 1'b1 |-> ($past(sva_checker.execution_unit, 1) |=> !$past(sva_checker.privilege_violation, 2) && $past(sva_checker.result_writeback))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xbmishnj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.debug_exception == 0 && sva_checker.instruction_complete == 1 |-> ($past(sva_checker.execution_unit) == 1 ##1 $past(sva_checker.privilege_violation, 2) == 0 ##1 $past(sva_checker.result_writeback, 1) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_complete == 1'b1 |-> ($past(sva_checker.execution_unit, 1) |=> !$past(sva_checker.privilege_violati"
  },
  {
    "id": "0403",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__bow03nw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.subband_processing == 1'b1 |-> ($past(sva_checker.carrier_allocation, 2) |=> $past(sva_checker.power_distribution) && $past(sva_checker.spectral_efficiency))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.subband_processing == 1'b1 |-> ($past(sva_checker.carrier_allocation, 2) |=> $past(sva_checker.power_distribution) && $past(sva_checker.spectral_efficiency))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.subband_processing == 1'b1 |-> ($past(sva_checker.carrier_allocation, 2) |=> $past(sva_checker.power_distribution) && $past(sva_checker.spectral_efficiency))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d58i681i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.subband_processing == 1'b1 |-> ($past(sva_checker.carrier_allocation, 2) |=> $past(sva_checker.power_distribution) && $past(sva_checker.spectral_efficiency))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.subband_processing == 1'b1 |-> ($past(sva_checker.carrier_allocation, 2) |=> $past(sva_checker.power_distribution) && $past(sva_checker.spectral_efficiency))): PROVED up to bound 20\n[sva_checke"
  },
  {
    "id": "0369",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.saturation_flag == 0 && sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) == 1'b1 && $past(sva_checker.adaptation_coefficient, 3) == 1'b1 && $past(sva_checker.convergence_monitor, 3) == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) && $past(sva_checker.adaptation_coefficient, 3) && $past(sva_checker.convergence_monitor, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_vrfwhr9t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) && $past(sva_checker.adaptation_coefficient, 3) && $past(sva_checker.convergence_monitor, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.saturation_flag == 0 && sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) == 1'b1 && $past(sva_checker.adaptation_coefficient, 3) == 1'b1 && $past(sva_checker.convergence_monitor, 3) == 1'b1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) && $past(sva_checker.adaptation_coefficient, 3) && $past(sva_checker.convergence_monitor, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kg4y_bma/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.saturation_flag == 0 && sva_checker.digital_predistortion == 1'b1 |-> $past(sva_checker.nonlinearity_model, 1) == 1'b1 && $past(sva_checker.adaptation_coefficient, 3) == 1'b1 && $past(sva_checker.convergence_monitor, 3) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.digital_predistortion == 1'b1 |-> $past(sva_che"
  },
  {
    "id": "0414",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fm9mns71/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.particle_manipulation == 1'b1 |-> ($past(sva_checker.laser_trapping, 1) |=> $past(sva_checker.force_measurement, 2) && $past(sva_checker.position_control))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.optical_tweezers_on == 1 && sva_checker.particle_manipulation == 1 |-> ($past(sva_checker.laser_trapping) == 1 |-> (##1 $past(sva_checker.force_measurement, 2) == 1 && $past(sva_checker.position_control, 1) == 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.particle_manipulation == 1'b1 |-> ($past(sva_checker.laser_trapping, 1) |=> $past(sva_checker.force_measurement, 2) && $past(sva_checker.position_control))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2zu8e3u0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.optical_tweezers_on == 1 && sva_checker.particle_manipulation == 1 |-> ($past(sva_checker.laser_trapping) == 1 |-> (##1 $past(sva_checker.force_measurement, 2) == 1 && $past(sva_checker.position_control, 1) == 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.particle_manipulation == 1'b1 |-> ($past(sva_checker.laser_trapping, 1) |=> $past(sva"
  },
  {
    "id": "0546",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k6s2v1n7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_preserving_analytics |-> ($past(sva_checker.encrypted_data_processing, 1) |=> $past(sva_checker.computation_verification, 2) && !$past(sva_checker.plaintext_leakage))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_preserving_analytics |-> ($past(sva_checker.encrypted_data_processing, 1) |=> $past(sva_checker.computation_verification, 2) && !$past(sva_checker.plaintext_leakage))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.privacy_preserving_analytics |-> ($past(sva_checker.encrypted_data_processing, 1) |=> $past(sva_checker.computation_verification, 2) && !$past(sva_checker.plaintext_leakage))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_odpkyamv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_preserving_analytics |-> ($past(sva_checker.encrypted_data_processing, 1) |=> $past(sva_checker.computation_verification, 2) && !$past(sva_checker.plaintext_leakage))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.privacy_preserving_analytics |-> ($past(sva_checker.encrypted_data_processing, 1) |=> $past(sva_checker.computation_verificat"
  },
  {
    "id": "0845",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3ww2mda8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.computational_auditory_scene_analysis |-> ($past(sva_checker.source_separation_algorithm, 2) && $past(sva_checker.auditory_object_formation) |=> !$past(sva_checker.cocktail_party_problem))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.computational_auditory_scene_analysis |-> ($past(sva_checker.source_separation_algorithm, 2) && $past(sva_checker.auditory_object_formation) |=> !$past(sva_checker.cocktail_party_problem))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.computational_auditory_scene_analysis |-> ($past(sva_checker.source_separation_algorithm, 2) && $past(sva_checker.auditory_object_formation) |=> !$past(sva_checker.cocktail_party_problem))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_04x559bf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.computational_auditory_scene_analysis |-> ($past(sva_checker.source_separation_algorithm, 2) && $past(sva_checker.auditory_object_formation) |=> !$past(sva_checker.cocktail_party_problem))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.computational_auditory_scene_analysis |-> ($past(sva_checker.source_s"
  },
  {
    "id": "0933",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j6z4adj7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decorative_stitching |-> $past(sva_checker.stitch_density_optimization, 1) && $past(sva_checker.design_registration_accuracy, 2) && $past(sva_checker.thread_break_minimization, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decorative_stitching |-> $past(sva_checker.stitch_density_optimization, 1) && $past(sva_checker.design_registration_accuracy, 2) && $past(sva_checker.thread_break_minimization, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decorative_stitching |-> $past(sva_checker.stitch_density_optimization, 1) && $past(sva_checker.design_registration_accuracy, 2) && $past(sva_checker.thread_break_minimization, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7w2qp6wb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decorative_stitching |-> $past(sva_checker.stitch_density_optimization, 1) && $past(sva_checker.design_registration_accuracy, 2) && $past(sva_checker.thread_break_minimization, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decorative_stitching |-> $past(sva_checker.stitch_density_optimization, 1) && $past(sva_checker.design_re"
  },
  {
    "id": "1000",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_etw0zaj3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_read && $past(sva_checker.fifo_not_empty, 1) |-> (sva_checker.read_data_valid ##1 sva_checker.read_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_read == 1 && $past(sva_checker.fifo_not_empty) == 1 |-> (sva_checker.read_data_valid == 1 ##1 sva_checker.read_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_read && $past(sva_checker.fifo_not_empty, 1) |-> (sva_checker.read_data_valid ##1 sva_checker.read_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9b2g4a9i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_read == 1 && $past(sva_checker.fifo_not_empty) == 1 |-> (sva_checker.read_data_valid == 1 ##1 sva_checker.read_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_read && $past(sva_checker.fifo_not_empty, 1) |-> (sva_checker.read_data_valid ##1 sva_checker.read_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_read == 1 && $past(sva_checker.fifo_not_empty) == 1 |-> (sva_checker.read_data_valid == 1 ##1 sva_checker.read_ack == 1)): PROVED\n"
  },
  {
    "id": "1051",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_avhd6je4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch && $past(sva_checker.pc_valid) |-> $past(sva_checker.instruction_cache_hit) || sva_checker.memory_access): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch == 1 && $past(sva_checker.pc_valid) == 1 |-> $past(sva_checker.instruction_cache_hit) == 1 || sva_checker.memory_access == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch && $past(sva_checker.pc_valid) |-> $past(sva_checker.instruction_cache_hit) || sva_checker.memory_access): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nrlcrh5e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch == 1 && $past(sva_checker.pc_valid) == 1 |-> $past(sva_checker.instruction_cache_hit) == 1 || sva_checker.memory_access == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch && $past(sva_checker.pc_valid) |-> $past(sva_checker.instruction_cache_hit) || sva_checker.memory_access): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_fetch == 1 && $past(sva_checker.pc_valid) == 1 |-> "
  },
  {
    "id": "1014",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_p0iwe0re/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.industrial_heritage_study == 1'b1 |-> $past(sva_checker.machinery_operation_reconstruction, 1) && $past(sva_checker.production_process_documentation, 2) && $past(sva_checker.social_impact_assessment, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.technological_context_overlooked == 0 && sva_checker.industrial_heritage_study == 1 |-> $past(sva_checker.machinery_operation_reconstruction, 1) == 1 && $past(sva_checker.production_process_documentation, 2) == 1 && $past(sva_checker.social_impact_assessment, 3) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.industrial_heritage_study == 1'b1 |-> $past(sva_checker.machinery_operation_reconstruction, 1) && $past(sva_checker.production_process_documentation, 2) && $past(sva_checker.social_impact_assessment, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uo_xe35f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.technological_context_overlooked == 0 && sva_checker.industrial_heritage_study == 1 |-> $past(sva_checker.machinery_operation_reconstruction, 1) == 1 && $past(sva_checker.production_process_documentation, 2) == 1 && $past(sva_checker.soc"
  },
  {
    "id": "1207",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_lcvbxxdm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frequency_hopping_sequence && $past(sva_checker.master_clock_synchronization) |-> sva_checker.channel_selection_update): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_radio == 0 && sva_checker.frequency_hopping_sequence == 1 && $past(sva_checker.master_clock_synchronization) == 1 |-> sva_checker.channel_selection_update == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frequency_hopping_sequence && $past(sva_checker.master_clock_synchronization) |-> sva_checker.channel_selection_update): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tj8oayay/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_radio == 0 && sva_checker.frequency_hopping_sequence == 1 && $past(sva_checker.master_clock_synchronization) == 1 |-> sva_checker.channel_selection_update == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frequency_hopping_sequence && $past(sva_checker.master_clock_synchronization) |-> sva_checker.channel_selection_update): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rst_radio == 0 && sva_checker.frequency_hopping"
  },
  {
    "id": "1286",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7gha7rp8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_phase_ambiguity_resolution == 1'b1 |-> $past(sva_checker.integer_least_squares_solution, 17) && sva_checker.precise_positioning_output): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_phase_ambiguity_resolution == 1'b1 |-> $past(sva_checker.integer_least_squares_solution, 17) && sva_checker.precise_positioning_output): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.carrier_phase_ambiguity_resolution == 1'b1 |-> $past(sva_checker.integer_least_squares_solution, 17) && sva_checker.precise_positioning_output): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gm2nhjed/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_phase_ambiguity_resolution == 1'b1 |-> $past(sva_checker.integer_least_squares_solution, 17) && sva_checker.precise_positioning_output): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_phase_ambiguity_resolution == 1'b1 |-> $past(sva_checker.integer_least_squares_solution, 17) && sva_checker.precise_positioning_output): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.car"
  },
  {
    "id": "1310",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mvradc72/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_checker.instruction_completion_checkpoint, 6) && sva_checker.architectural_state_preservation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_checker.instruction_completion_checkpoint, 6) && sva_checker.architectural_state_preservation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_checker.instruction_completion_checkpoint, 6) && sva_checker.architectural_state_preservation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m0_7n4l9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_checker.instruction_completion_checkpoint, 6) && sva_checker.architectural_state_preservation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_checker.instruction_completion_checkpoint, 6) && sva_checker.architectural_state_preservation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.precise_interrupt_delivery |-> $past(sva_ch"
  },
  {
    "id": "1446",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vwqo4i7o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ik84xvyc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.excitation_system_control |-> $past(sva_checker.field_current_adjustment, 8) && sva_checker.terminal_voltage_regulatio"
  },
  {
    "id": "1467",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wyqm3gr9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.barometric_pressure_trend |-> $past(sva_checker.temperature_humidity_correlation, 7) && sva_checker.storm_prediction_algorithm): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_meteorological == 0 && sva_checker.barometric_pressure_trend == 1 |-> sva_checker.storm_prediction_algorithm == 1 && $past(sva_checker.temperature_humidity_correlation, 7) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.barometric_pressure_trend |-> $past(sva_checker.temperature_humidity_correlation, 7) && sva_checker.storm_prediction_algorithm): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ez4d6nir/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_meteorological == 0 && sva_checker.barometric_pressure_trend == 1 |-> sva_checker.storm_prediction_algorithm == 1 && $past(sva_checker.temperature_humidity_correlation, 7) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.barometric_pressure_trend |-> $past(sva_checker.temperature_humidity_correlation, 7) && sva_checker.storm_prediction_algorithm): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) s"
  },
  {
    "id": "1734",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jnmx6ssz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investment_screening): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investment_screening): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investment_screening): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fyfyjuq7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investment_screening): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investment_screening): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.profit_sharing_mechanism |-> $past(sva_checker.asset_backing_verification, 8) && sva_checker.ethical_investm"
  },
  {
    "id": "1954",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_y1iatpg5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $past(sva_checker.hybridization_thermodynamics, 12) && sva_checker.biological_information_processing): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $past(sva_checker.hybridization_thermodynamics, 12) && sva_checker.biological_information_processing): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $past(sva_checker.hybridization_thermodynamics, 12) && sva_checker.biological_information_processing): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tu6wyef3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $past(sva_checker.hybridization_thermodynamics, 12) && sva_checker.biological_information_processing): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $past(sva_checker.hybridization_thermodynamics, 12) && sva_checker.biological_information_processing): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.nucleotide_sequence_processing |-> $pa"
  },
  {
    "id": "2035",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nh3d299n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request, 1) && $past(sva_checker.priority_high, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request) == 1'b1 && $past(sva_checker.priority_high) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request, 1) && $past(sva_checker.priority_high, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oy0yzlk6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request) == 1'b1 && $past(sva_checker.priority_high) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request, 1) && $past(sva_checker.priority_high, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.soft_reset == 0 && sva_checker.bus_grant == 1'b1 |-> $past(sva_checker.bus_request) == 1'b1 && $past(sva_checker.priority_high) == 1'b1): PROVED\n"
  },
  {
    "id": "2018",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_zvgf2l0m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_compensating_valve |-> $past(sva_checker.flow_rate_uniformity_check, 7) && sva_checker.water_distribution_efficiency): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rst_drip_emitter_control == 0 && sva_checker.pressure_compensating_valve == 1 |-> $past(sva_checker.flow_rate_uniformity_check, 7) == 1 && sva_checker.water_distribution_efficiency == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pressure_compensating_valve |-> $past(sva_checker.flow_rate_uniformity_check, 7) && sva_checker.water_distribution_efficiency): PROVED\n\n\nBackward: Parsing /tmp/sva_check_engi49vt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rst_drip_emitter_control == 0 && sva_checker.pressure_compensating_valve == 1 |-> $past(sva_checker.flow_rate_uniformity_check, 7) == 1 && sva_checker.water_distribution_efficiency == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pressure_compensating_valve |-> $past(sva_checker.flow_rate_uniformity_check, 7) && sva_checker.water_distribution_efficiency): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.r"
  },
  {
    "id": "2055",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_uk6uof65/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_stall == 1'b1 |-> $past(sva_checker.resource_busy || sva_checker.dependency_hazard, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && sva_checker.pipeline_stall == 1 |-> $past(sva_checker.resource_busy) == 1 || $past(sva_checker.dependency_hazard) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pipeline_stall == 1'b1 |-> $past(sva_checker.resource_busy || sva_checker.dependency_hazard, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yjc8qmkv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && sva_checker.pipeline_stall == 1 |-> $past(sva_checker.resource_busy) == 1 || $past(sva_checker.dependency_hazard) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pipeline_stall == 1'b1 |-> $past(sva_checker.resource_busy || sva_checker.dependency_hazard, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bypass_mode == 0 && sva_checker.pipeline_stall == 1 |-> $past(sva_checker.resource_busy) == 1 || $past(sva_checker.dependency_hazard) == 1): PROVED\n"
  },
  {
    "id": "2061",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |=> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_p7uwh613/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |=> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |=> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_h8ljb6u1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |=> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.thermal_shutdown == 1'b1 |-> $past(sva_checker.temperature_sensor[9:0] >= sva_checker.critical_temp, 1)): PROVED\n"
  },
  {
    "id": "2087",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset == 1 |-> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset |=> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_qi7b1xq6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset |=> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset == 1 |-> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset |=> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5w1r6_s8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset == 1 |-> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset |=> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.watchdog_reset == 1 |-> $past(sva_checker.timeout_counter[15:0] == sva_checker.timeout_limit, 1)): PROVED\n"
  },
  {
    "id": "2104",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_o_9m11zs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0], 2) == 16'hFFFF): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0] == 16'hFFFF, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0], 2) == 16'hFFFF): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uu6g8l9p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0] == 16'hFFFF, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0], 2) == 16'hFFFF): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.routing_deadlock == 1'b1 |-> $past(sva_checker.all_buffers_full[15:0] == 16'hFFFF, 2)): PROVED\n"
  },
  {
    "id": "2300",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6z48maod/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_encryption_standard |-> $past(sva_checker.key_expansion[127:0], 1) && $past(sva_checker.substitute_bytes, 1) && $past(sva_checker.shift_rows, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_encryption_standard |-> $past(sva_checker.key_expansion[127:0]) != 0 && $past(sva_checker.substitute_bytes) && $past(sva_checker.shift_rows)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.advanced_encryption_standard |-> $past(sva_checker.key_expansion[127:0], 1) && $past(sva_checker.substitute_bytes, 1) && $past(sva_checker.shift_rows, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r3ri1p_0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_encryption_standard |-> $past(sva_checker.key_expansion[127:0]) != 0 && $past(sva_checker.substitute_bytes) && $past(sva_checker.shift_rows)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.advanced_encryption_standard |-> $past(sva_checker.key_expansion[127:0], 1) && $past(sva_checker.substitute_bytes, 1) && $past(sva_checker.shift_rows, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (d"
  },
  {
    "id": "2318",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_85n02b1y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flexible_intermediate_representation |-> $past(sva_checker.circuit_ir, 1) && $past(sva_checker.transformation_pass, 1) && $past(sva_checker.backend_emission, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flexible_intermediate_representation |-> $past(sva_checker.circuit_ir) && $past(sva_checker.transformation_pass) && $past(sva_checker.backend_emission)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flexible_intermediate_representation |-> $past(sva_checker.circuit_ir, 1) && $past(sva_checker.transformation_pass, 1) && $past(sva_checker.backend_emission, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fbgld1ke/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flexible_intermediate_representation |-> $past(sva_checker.circuit_ir) && $past(sva_checker.transformation_pass) && $past(sva_checker.backend_emission)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flexible_intermediate_representation |-> $past(sva_checker.circuit_ir, 1) && $past(sva_checker.transformation_pass, 1) && $past(sva_checker.backend_emission, 1)): PROVED up to bound 20\n[sva_checker.c"
  },
  {
    "id": "2327",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |-> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |=> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_eaj6j4is/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |=> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |-> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |=> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d6tdo71w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |-> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.systolic_array_generator |=> $past(sva_checker.gemm_operation && sva_checker.accumulator_memory && sva_checker.dataflow_orchestration, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sys"
  },
  {
    "id": "2367",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |=> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |-> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_csbb6zwy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |-> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |=> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |-> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7b5gcxtu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |=> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |-> $past(sva_checker.erase_operation && sva_checker.program_operation && sva_checker.read_operation, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_memory_controller |=> $past(sva_checker.er"
  },
  {
    "id": "2555",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mgufg8h5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.avian_magnetic_compass_mechanism |-> $past(sva_checker.cryptochrome_protein[15:0] & sva_checker.radical_pair_mechanism & sva_checker.geomagnetic_field_sensitivity[11:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.avian_magnetic_compass_mechanism |-> $past(sva_checker.cryptochrome_protein[15:0] & sva_checker.radical_pair_mechanism & sva_checker.geomagnetic_field_sensitivity[11:0], 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.avian_magnetic_compass_mechanism |-> $past(sva_checker.cryptochrome_protein[15:0] & sva_checker.radical_pair_mechanism & sva_checker.geomagnetic_field_sensitivity[11:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a_t21x8y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.avian_magnetic_compass_mechanism |-> $past(sva_checker.cryptochrome_protein[15:0] & sva_checker.radical_pair_mechanism & sva_checker.geomagnetic_field_sensitivity[11:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.avian_magnetic_compass_mechanism |-> $past(sva_checker.cryptochrome_protein[15:0] & sva_checker.radical_pair_mechanism & sva_checker."
  },
  {
    "id": "2576",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xqlxbxb9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trapped_ion_quantum_gate == 1'b1 |-> $past(sva_checker.laser_pulse_sequence[31:0] & sva_checker.vibrational_mode_coupling & sva_checker.phonon_mediated_interaction, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trapped_ion_quantum_gate == 1'b1 |-> $past(sva_checker.laser_pulse_sequence[31:0] & sva_checker.vibrational_mode_coupling & sva_checker.phonon_mediated_interaction, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trapped_ion_quantum_gate == 1'b1 |-> $past(sva_checker.laser_pulse_sequence[31:0] & sva_checker.vibrational_mode_coupling & sva_checker.phonon_mediated_interaction, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zdub1__j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trapped_ion_quantum_gate == 1'b1 |-> $past(sva_checker.laser_pulse_sequence[31:0] & sva_checker.vibrational_mode_coupling & sva_checker.phonon_mediated_interaction, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trapped_ion_quantum_gate == 1'b1 |-> $past(sva_checker.laser_pulse_sequence[31:0] & sva_checker.vibrational_mode_coupling & sva_checker.phonon_mediated_i"
  },
  {
    "id": "2637",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |-> $past(sva_checker.stellar_brightness[15:0]) != 0 && $past(sva_checker.transit_depth[11:0]) != 0 && $past(sva_checker.orbital_period[31:0]) != 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |=> $past(sva_checker.stellar_brightness[15:0], 1) && $past(sva_checker.transit_depth[11:0], 1) && $past(sva_checker.orbital_period[31:0], 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_l2onth04/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |=> $past(sva_checker.stellar_brightness[15:0], 1) && $past(sva_checker.transit_depth[11:0], 1) && $past(sva_checker.orbital_period[31:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |-> $past(sva_checker.stellar_brightness[15:0]) != 0 && $past(sva_checker.transit_depth[11:0]) != 0 && $past(sva_checker.orbital_period[31:0]) != 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |=> $past(sva_checker.stellar_brightness[15:0], 1) && $past(sva_checker.transit_depth[11:0], 1) && $past(sva_checker.orbital_period[31:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fxqlnkr5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |-> $past(sva_checker.stellar_brightness[15:0]) != 0 && $past(sva_checker.transit_depth[11:0]) != 0 && $past(sva_checker.orbital_period[31:0]) != 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.transit_photometry_detector |=> $past(sva_checker.stellar_brightness[15:0], 1) && $past(sva_ch"
  },
  {
    "id": "2664",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |=> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |-> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_owd4w4b2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |-> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |=> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |-> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_99_lmcj9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |=> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_heating_mechanism[11:0] & sva_checker.magnetic_field_structure, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parker_solar_probe_investigation |-> $past(sva_checker.solar_wind_velocity[15:0] & sva_checker.coronal_hea"
  },
  {
    "id": "2707",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |=> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |-> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_mbveoss7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |-> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |=> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |-> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_st1owxtl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |=> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker.vertical_visibility, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cloud_base_height_measurement |-> $past(sva_checker.laser_pulse_backscatter[15:0] & sva_checker.cloud_layer_detection[11:0] & sva_checker."
  },
  {
    "id": "3129",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8g7osy2a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_checker.single_bit_errors) > sva_checker.max_correctable && $past(sva_checker.ecc_enabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_checker.single_bit_errors) > sva_checker.max_correctable && $past(sva_checker.ecc_enabled)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_checker.single_bit_errors) > sva_checker.max_correctable && $past(sva_checker.ecc_enabled)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6ovkr088/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_checker.single_bit_errors) > sva_checker.max_correctable && $past(sva_checker.ecc_enabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_checker.single_bit_errors) > sva_checker.max_correctable && $past(sva_checker.ecc_enabled)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_limit == 1'b1 |-> $past(sva_check"
  },
  {
    "id": "2952",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |-> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |=> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_3l_85hfo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |=> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |-> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |=> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9sb6z6d0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |-> $past(sva_checker.imaging_contrast_agent[15:0], 1) && $past(sva_checker.therapeutic_payload[11:0], 1) && $past(sva_checker.targeted_delivery[31:0], 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.theranostic_nanoparticle_system |=> $p"
  },
  {
    "id": "3220",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_17qo5jt3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.metastability_detection |-> $past(sva_checker.async_input_changed) && $past(sva_checker.setup_time_margin) < sva_checker.min_setup_margin): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scan_chain_active == 0 && sva_checker.metastability_detection == 1 |-> $past(sva_checker.async_input_changed) == 1 && $past(sva_checker.setup_time_margin) < sva_checker.min_setup_margin): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.metastability_detection |-> $past(sva_checker.async_input_changed) && $past(sva_checker.setup_time_margin) < sva_checker.min_setup_margin): PROVED\n\n\nBackward: Parsing /tmp/sva_check_19swcgdt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scan_chain_active == 0 && sva_checker.metastability_detection == 1 |-> $past(sva_checker.async_input_changed) == 1 && $past(sva_checker.setup_time_margin) < sva_checker.min_setup_margin): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.metastability_detection |-> $past(sva_checker.async_input_changed) && $past(sva_checker.setup_time_margin) < sva_checker.min_setup_margin): REFUTED\n[sva_checker.cover_antecedent"
  },
  {
    "id": "3216",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8wv_3qx6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.congestion_control_fail == 1'b1 |-> $past(sva_checker.packet_queue_depth) > sva_checker.congestion_threshold && !$past(sva_checker.flow_control_applied)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.congestion_control_fail == 1'b1 && sva_checker.routing_reset == 0 |-> $past(sva_checker.packet_queue_depth) > sva_checker.congestion_threshold && $past(sva_checker.flow_control_applied) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.congestion_control_fail == 1'b1 |-> $past(sva_checker.packet_queue_depth) > sva_checker.congestion_threshold && !$past(sva_checker.flow_control_applied)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1j269a67/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.congestion_control_fail == 1'b1 && sva_checker.routing_reset == 0 |-> $past(sva_checker.packet_queue_depth) > sva_checker.congestion_threshold && $past(sva_checker.flow_control_applied) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.congestion_control_fail == 1'b1 |-> $past(sva_checker.packet_queue_depth) > sva_checker.congestion_threshold && !$past(sva_checker.flow_c"
  },
  {
    "id": "3249",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sw0tb43x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == sva_checker.clock_polarity && $past(sva_checker.transmission_idle)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == sva_checker.clock_polarity && $past(sva_checker.transmission_idle) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == sva_checker.clock_polarity && $past(sva_checker.transmission_idle)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pcm0ceu5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == sva_checker.clock_polarity && $past(sva_checker.transmission_idle) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == sva_checker.clock_polarity && $past(sva_checker.transmission_idle)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spi_clock_polarity_check |-> $past(sva_checker.sclk_idle) == s"
  },
  {
    "id": "3349",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ayvp11at/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.natural_circulation_establishment |-> $past(sva_checker.forced_circulation_lost) && !$past(sva_checker.natural_circulation_verified, 15)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rcp_power_available == 1 && sva_checker.natural_circulation_establishment == 1 |-> $past(sva_checker.forced_circulation_lost) == 1 && !$past(sva_checker.natural_circulation_verified, 15)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.natural_circulation_establishment |-> $past(sva_checker.forced_circulation_lost) && !$past(sva_checker.natural_circulation_verified, 15)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_coh_3hpv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rcp_power_available == 1 && sva_checker.natural_circulation_establishment == 1 |-> $past(sva_checker.forced_circulation_lost) == 1 && !$past(sva_checker.natural_circulation_verified, 15)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.natural_circulation_establishment |-> $past(sva_checker.forced_circulation_lost) && !$past(sva_checker.natural_circulation_verified, 15)): REFUTED\n[sva_checker.cover_antecedent]"
  },
  {
    "id": "3377",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3klz3aip/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spacecraft_range_measurement |-> $past(sva_checker.range_tone_transmitted) && $past(sva_checker.round_trip_time) > sva_checker.maximum_expected_delay): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spacecraft_range_measurement |-> $past(sva_checker.range_tone_transmitted) && $past(sva_checker.round_trip_time) > sva_checker.maximum_expected_delay): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spacecraft_range_measurement |-> $past(sva_checker.range_tone_transmitted) && $past(sva_checker.round_trip_time) > sva_checker.maximum_expected_delay): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a2bp4k8l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spacecraft_range_measurement |-> $past(sva_checker.range_tone_transmitted) && $past(sva_checker.round_trip_time) > sva_checker.maximum_expected_delay): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spacecraft_range_measurement |-> $past(sva_checker.range_tone_transmitted) && $past(sva_checker.round_trip_time) > sva_checker.maximum_expected_delay): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff ("
  },
  {
    "id": "3354",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.human_factors_analysis == 0 && sva_checker.operator_action_reliability == 1 |-> $past(sva_checker.stress_level_high) == 1 && $past(sva_checker.procedure_compliance) != $past(sva_checker.expected_performance) && $past(sva_checker.safety_significant_task) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operator_action_reliability == 1'b1 |-> $past(sva_checker.stress_level_high) && $past(sva_checker.procedure_compliance) != sva_checker.expected_performance && $past(sva_checker.safety_significant_task)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_qun6ufsf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.operator_action_reliability == 1'b1 |-> $past(sva_checker.stress_level_high) && $past(sva_checker.procedure_compliance) != sva_checker.expected_performance && $past(sva_checker.safety_significant_task)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.human_factors_analysis == 0 && sva_checker.operator_action_reliability == 1 |-> $past(sva_checker.stress_level_high) == 1 && $past(sva_checker.procedure_compliance) != $past(sva_checker.expected_performance) && $past(sva_checker.safety_significant_task) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operator_action_reliability == 1'b1 |-> $past(sva_checker.stress_level_high) && $past(sva_checker.procedure_compliance) != sva_checker.expected_performance && $past(sva_checker.safety_significant_task)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w40cdixg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.human_factors_analysis == 0 && sva_checker.operator_action_reliability == 1 |-> $past(sva_checker.stress_level_high) == 1 && $past(sva_checker.procedure_compliance) != $past(sva_checker.expected_performance) && $past(sva_checker.safety_significant_task) == 1): A"
  },
  {
    "id": "3378",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_n7xn61d2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.angular_rate_measurement_drift == 1'b1 |-> $past(sva_checker.gyro_bias_estimate) - $past(sva_checker.gyro_bias_estimate, 100) > sva_checker.bias_drift_limit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gyroscope_calibration_mode == 0 && sva_checker.angular_rate_measurement_drift == 1'b1 |-> $past(sva_checker.gyro_bias_estimate) - $past(sva_checker.gyro_bias_estimate, 100) > sva_checker.bias_drift_limit): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.angular_rate_measurement_drift == 1'b1 |-> $past(sva_checker.gyro_bias_estimate) - $past(sva_checker.gyro_bias_estimate, 100) > sva_checker.bias_drift_limit): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mq78ns86/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gyroscope_calibration_mode == 0 && sva_checker.angular_rate_measurement_drift == 1'b1 |-> $past(sva_checker.gyro_bias_estimate) - $past(sva_checker.gyro_bias_estimate, 100) > sva_checker.bias_drift_limit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.angular_rate_measurement_drift == 1'b1 |-> $past(sva_checker.gyro_bias_estimate) - $past(sva_checker.gy"
  },
  {
    "id": "3390",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_izu80mrs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scientific_instrument_calibration == 1'b1 |-> $past(sva_checker.calibration_source_exposure_time) && $past(sva_checker.instrument_response) < sva_checker.expected_signal_level): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.payload_standby == 0 && sva_checker.scientific_instrument_calibration == 1 |-> $past(sva_checker.calibration_source_exposure_time) == 1 && $past(sva_checker.instrument_response) < sva_checker.expected_signal_level): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scientific_instrument_calibration == 1'b1 |-> $past(sva_checker.calibration_source_exposure_time) && $past(sva_checker.instrument_response) < sva_checker.expected_signal_level): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vyactkr4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.payload_standby == 0 && sva_checker.scientific_instrument_calibration == 1 |-> $past(sva_checker.calibration_source_exposure_time) == 1 && $past(sva_checker.instrument_response) < sva_checker.expected_signal_level): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scientific_instrument_calibration == 1'b1 |->"
  },
  {
    "id": "3402",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_jwlmrrr8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.marsquake_detection_sensitivity |-> $past(sva_checker.ground_motion_amplitude) > sva_checker.detection_threshold && !$past(sva_checker.event_classification_completed, 18)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.planetary_seismology_experiment == 1 && sva_checker.marsquake_detection_sensitivity == 1 |-> $past(sva_checker.ground_motion_amplitude) > sva_checker.detection_threshold && $past(sva_checker.event_classification_completed, 18) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.marsquake_detection_sensitivity |-> $past(sva_checker.ground_motion_amplitude) > sva_checker.detection_threshold && !$past(sva_checker.event_classification_completed, 18)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zmqiquks/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.planetary_seismology_experiment == 1 && sva_checker.marsquake_detection_sensitivity == 1 |-> $past(sva_checker.ground_motion_amplitude) > sva_checker.detection_threshold && $past(sva_checker.event_classification_completed, 18) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.marsquake_detection"
  },
  {
    "id": "3425",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_scccxkcp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.enemy_communication_disruption == 1'b1 |-> $past(sva_checker.enemy_frequency_identified) && $past(sva_checker.jamming_signal_strength) < sva_checker.communication_denial_threshold): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.offensive_electronic_warfare == 1 && sva_checker.enemy_communication_disruption == 1 |-> $past(sva_checker.enemy_frequency_identified) == 1 && $past(sva_checker.jamming_signal_strength) < sva_checker.communication_denial_threshold): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.enemy_communication_disruption == 1'b1 |-> $past(sva_checker.enemy_frequency_identified) && $past(sva_checker.jamming_signal_strength) < sva_checker.communication_denial_threshold): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i4_v_kxf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.offensive_electronic_warfare == 1 && sva_checker.enemy_communication_disruption == 1 |-> $past(sva_checker.enemy_frequency_identified) == 1 && $past(sva_checker.jamming_signal_strength) < sva_checker.communication_denial_threshold): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ene"
  },
  {
    "id": "3494",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w1new3xf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.solid_phase_peptide_synthesis |-> $past(sva_checker.deprotection_cycle_efficiency) < sva_checker.complete_deprotection_threshold && $past(sva_checker.synthesis_fidelity_monitoring_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.solid_phase_peptide_synthesis |-> $past(sva_checker.deprotection_cycle_efficiency) < sva_checker.complete_deprotection_threshold && $past(sva_checker.synthesis_fidelity_monitoring_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.solid_phase_peptide_synthesis |-> $past(sva_checker.deprotection_cycle_efficiency) < sva_checker.complete_deprotection_threshold && $past(sva_checker.synthesis_fidelity_monitoring_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yjb6wei0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.solid_phase_peptide_synthesis |-> $past(sva_checker.deprotection_cycle_efficiency) < sva_checker.complete_deprotection_threshold && $past(sva_checker.synthesis_fidelity_monitoring_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.solid_phase_peptide_synthesis |-> $past(sva_checker.deprotection_cycle_ef"
  },
  {
    "id": "3506",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_9b2xsbe1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.quartz_crystal_microbalance_measurement |-> $past(sva_checker.frequency_shift_detection_sensitivity) && $past(sva_checker.mass_loading_calculation) && $past(sva_checker.measurement_precision) < sva_checker.required_detection_limit): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vibration_isolation_compromised == 0 && sva_checker.quartz_crystal_microbalance_measurement == 1 |-> $past(sva_checker.frequency_shift_detection_sensitivity) == 1 && $past(sva_checker.mass_loading_calculation) == 1 && $past(sva_checker.measurement_precision) < sva_checker.required_detection_limit): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.quartz_crystal_microbalance_measurement |-> $past(sva_checker.frequency_shift_detection_sensitivity) && $past(sva_checker.mass_loading_calculation) && $past(sva_checker.measurement_precision) < sva_checker.required_detection_limit): PROVED\n\n\nBackward: Parsing /tmp/sva_check_o__cwnwx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vibration_isolation_compromised == 0 && sva_checker.quartz_crystal_microbalance_measurement == 1 |-> $past(sva_checker.frequency_shift_detection_sensit"
  },
  {
    "id": "3528",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8vct_sez/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.open_pit_wall_stability |-> $past(sva_checker.slope_displacement_measurement) > sva_checker.stability_threshold && !$past(sva_checker.mining_operations_suspended_in_area, 12)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.geotechnical_monitoring_suspended == 0 && sva_checker.open_pit_wall_stability == 1 |-> $past(sva_checker.slope_displacement_measurement) > sva_checker.stability_threshold && $past(sva_checker.mining_operations_suspended_in_area, 12) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.open_pit_wall_stability |-> $past(sva_checker.slope_displacement_measurement) > sva_checker.stability_threshold && !$past(sva_checker.mining_operations_suspended_in_area, 12)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cz6c_s0g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.geotechnical_monitoring_suspended == 0 && sva_checker.open_pit_wall_stability == 1 |-> $past(sva_checker.slope_displacement_measurement) > sva_checker.stability_threshold && $past(sva_checker.mining_operations_suspended_in_area, 12) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker"
  },
  {
    "id": "3568",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_fq88i4xb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.marine_casualty_response |-> $past(sva_checker.vessel_stability_assessment) == sva_checker.critical_stability_condition && !$past(sva_checker.emergency_response_team_deployment_confirmed, 15)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.salvage_operation_in_progress == 0 && sva_checker.marine_casualty_response == 1 |-> $past(sva_checker.vessel_stability_assessment) == sva_checker.critical_stability_condition && $past(sva_checker.emergency_response_team_deployment_confirmed, 15) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.marine_casualty_response |-> $past(sva_checker.vessel_stability_assessment) == sva_checker.critical_stability_condition && !$past(sva_checker.emergency_response_team_deployment_confirmed, 15)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uix_taa2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.salvage_operation_in_progress == 0 && sva_checker.marine_casualty_response == 1 |-> $past(sva_checker.vessel_stability_assessment) == sva_checker.critical_stability_condition && $past(sva_checker.emergency_response_team_deployment_confirmed, 15) == 0): ASSUMED\n[sva_checker.as"
  },
  {
    "id": "3609",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_iuuhtvtf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cultural_heritage_preservation == 1'b1 |-> $past(sva_checker.archaeological_artifact_disturbance_sensor_triggered) && $past(sva_checker.site_access_restriction_enforcement) != sva_checker.unauthorized_access_prevented): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_archaeology_site_protection == 0 && sva_checker.cultural_heritage_preservation == 1 |-> $past(sva_checker.archaeological_artifact_disturbance_sensor_triggered) == 1 && $past(sva_checker.site_access_restriction_enforcement) != sva_checker.unauthorized_access_prevented): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cultural_heritage_preservation == 1'b1 |-> $past(sva_checker.archaeological_artifact_disturbance_sensor_triggered) && $past(sva_checker.site_access_restriction_enforcement) != sva_checker.unauthorized_access_prevented): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w397y53j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.underwater_archaeology_site_protection == 0 && sva_checker.cultural_heritage_preservation == 1 |-> $past(sva_checker.archaeological_artifact_disturbance_sensor_triggered) == 1 && $past(sva_checker"
  },
  {
    "id": "3619",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_6phz8506/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.integrated_crop_management |-> $past(sva_checker.pest_disease_pressure_forecast) && $past(sva_checker.preventive_treatment_application_timing) > sva_checker.optimal_intervention_window): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.integrated_crop_management == 1 && sva_checker.agricultural_extension_service_recommendation_update == 0 |-> $past(sva_checker.pest_disease_pressure_forecast) == 1 && $past(sva_checker.preventive_treatment_application_timing) > sva_checker.optimal_intervention_window): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.integrated_crop_management |-> $past(sva_checker.pest_disease_pressure_forecast) && $past(sva_checker.preventive_treatment_application_timing) > sva_checker.optimal_intervention_window): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a8f51ewv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.integrated_crop_management == 1 && sva_checker.agricultural_extension_service_recommendation_update == 0 |-> $past(sva_checker.pest_disease_pressure_forecast) == 1 && $past(sva_checker.preventive_treatment_application_timing) > sva_checker.optimal_intervention_window): ASS"
  },
  {
    "id": "3639",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_m4o9jl6i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crop_yield_monitoring == 1'b1 |-> $past(sva_checker.grain_flow_sensor_reading) < sva_checker.expected_yield_per_hectare && $past(sva_checker.harvest_speed_optimization_disabled)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crop_yield_monitoring |-> $past(sva_checker.grain_flow_sensor_reading) < sva_checker.expected_yield_per_hectare && $past(sva_checker.harvest_speed_optimization_disabled) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crop_yield_monitoring == 1'b1 |-> $past(sva_checker.grain_flow_sensor_reading) < sva_checker.expected_yield_per_hectare && $past(sva_checker.harvest_speed_optimization_disabled)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7p1b20kl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crop_yield_monitoring |-> $past(sva_checker.grain_flow_sensor_reading) < sva_checker.expected_yield_per_hectare && $past(sva_checker.harvest_speed_optimization_disabled) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crop_yield_monitoring == 1'b1 |-> $past(sva_checker.grain_flow_sensor_reading) < sva_checker.expected_yield_per_h"
  },
  {
    "id": "3640",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_sdl2hja3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.soil_health_improvement == 1'b1 |-> $past(sva_checker.nitrogen_fixing_crop_establishment) && $past(sva_checker.soil_biology_activity_measurement) && $past(sva_checker.organic_matter_accumulation_rate) < sva_checker.soil_health_improvement_target): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sustainable_agriculture_practice_compliance == 1 && sva_checker.soil_health_improvement == 1 |-> $past(sva_checker.nitrogen_fixing_crop_establishment) == 1 && $past(sva_checker.soil_biology_activity_measurement) == 1 && $past(sva_checker.organic_matter_accumulation_rate) < sva_checker.soil_health_improvement_target): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.soil_health_improvement == 1'b1 |-> $past(sva_checker.nitrogen_fixing_crop_establishment) && $past(sva_checker.soil_biology_activity_measurement) && $past(sva_checker.organic_matter_accumulation_rate) < sva_checker.soil_health_improvement_target): PROVED\n\n\nBackward: Parsing /tmp/sva_check_se_71vsh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sustainable_agriculture_practice_compliance == 1 && sva_checker.soil_health_improvement == 1 |-> $past"
  },
  {
    "id": "3672",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_tjeq5z8u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.production_line_power_consumption == 1'b1 |-> $past(sva_checker.machine_utilization_rate) < sva_checker.optimal_efficiency_threshold && $past(sva_checker.energy_cost_per_unit_production) == sva_checker.cost_target_exceeded): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.textile_mill_energy_efficiency_optimization == 0 && sva_checker.production_line_power_consumption == 1 |-> $past(sva_checker.machine_utilization_rate) < sva_checker.optimal_efficiency_threshold && $past(sva_checker.energy_cost_per_unit_production) == sva_checker.cost_target_exceeded): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.production_line_power_consumption == 1'b1 |-> $past(sva_checker.machine_utilization_rate) < sva_checker.optimal_efficiency_threshold && $past(sva_checker.energy_cost_per_unit_production) == sva_checker.cost_target_exceeded): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2det56dk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.textile_mill_energy_efficiency_optimization == 0 && sva_checker.production_line_power_consumption == 1 |-> $past(sva_checker.machine_utilization_rate) < sva_checker.optimal_efficien"
  },
  {
    "id": "3811",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d5e592xk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.competitive_event_technical_reliability |-> $past(sva_checker.server_performance_stability_verification) && $past(sva_checker.broadcast_quality_assurance_validation) < sva_checker.professional_esports_standard_requirement): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.competitive_event_technical_reliability |-> $past(sva_checker.server_performance_stability_verification) && $past(sva_checker.broadcast_quality_assurance_validation) < sva_checker.professional_esports_standard_requirement): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.competitive_event_technical_reliability |-> $past(sva_checker.server_performance_stability_verification) && $past(sva_checker.broadcast_quality_assurance_validation) < sva_checker.professional_esports_standard_requirement): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5niawvk3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.competitive_event_technical_reliability |-> $past(sva_checker.server_performance_stability_verification) && $past(sva_checker.broadcast_quality_assurance_validation) < sva_checker.professional_esports_standard_requirement): ASSUMED\n[sva_checker."
  },
  {
    "id": "3885",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p70u0x5n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dark_matter_detection_experiment |-> $past(sva_checker.detector_shielding_effectiveness_verification) && $past(sva_checker.background_event_discrimination_capability) && $past(sva_checker.dark_matter_signal_sensitivity) != sva_checker.detection_threshold_achievement_confirmation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dark_matter_detection_experiment |-> $past(sva_checker.detector_shielding_effectiveness_verification) && $past(sva_checker.background_event_discrimination_capability) && $past(sva_checker.dark_matter_signal_sensitivity) != sva_checker.detection_threshold_achievement_confirmation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dark_matter_detection_experiment |-> $past(sva_checker.detector_shielding_effectiveness_verification) && $past(sva_checker.background_event_discrimination_capability) && $past(sva_checker.dark_matter_signal_sensitivity) != sva_checker.detection_threshold_achievement_confirmation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uq206giw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dark_matter_detection_experiment |-> $past(sva_checker.detector_shieldi"
  },
  {
    "id": "3758",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zs888385/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.destination_competitiveness_enhancement == 1'b1 |-> $past(sva_checker.innovation_capacity_building_initiative_outcome) && $past(sva_checker.tourism_entrepreneur_support_program_effectiveness) && $past(sva_checker.destination_innovation_leadership_achievement) == sva_checker.tourism_sector_transformation_competitive_advantage_realization_shortfall): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.destination_competitiveness_enhancement == 1'b1 |-> $past(sva_checker.innovation_capacity_building_initiative_outcome) == 1'b1 && $past(sva_checker.tourism_entrepreneur_support_program_effectiveness) == 1'b1 && $past(sva_checker.destination_innovation_leadership_achievement) == sva_checker.tourism_sector_transformation_competitive_advantage_realization_shortfall): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.destination_competitiveness_enhancement == 1'b1 |-> $past(sva_checker.innovation_capacity_building_initiative_outcome) && $past(sva_checker.tourism_entrepreneur_support_program_effectiveness) && $past(sva_checker.destination_innovation_leadership_achievement) == sva_checker.tourism_sector_transformation_competitive_advantage_realization_shortfall): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qtbizy5u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsisten"
  },
  {
    "id": "3916",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0m4dsf6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.artificial_atom_spectroscopy == 1'b1 |-> $past(sva_checker.quantum_confinement_energy_level_calculation_accuracy) && $past(sva_checker.optical_transition_linewidth_measurement_precision) && $past(sva_checker.single_photon_emission_purity_verification) < sva_checker.quantum_dot_device_performance_specification): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.artificial_atom_spectroscopy == 1'b1 |-> $past(sva_checker.quantum_confinement_energy_level_calculation_accuracy) && $past(sva_checker.optical_transition_linewidth_measurement_precision) && $past(sva_checker.single_photon_emission_purity_verification) < sva_checker.quantum_dot_device_performance_specification): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.artificial_atom_spectroscopy == 1'b1 |-> $past(sva_checker.quantum_confinement_energy_level_calculation_accuracy) && $past(sva_checker.optical_transition_linewidth_measurement_precision) && $past(sva_checker.single_photon_emission_purity_verification) < sva_checker.quantum_dot_device_performance_specification): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i27xen07/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_check"
  },
  {
    "id": "3924",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_70njkruv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.regtech_compliance_automation == 1'b1 |-> $past(sva_checker.regulatory_change_management_effectiveness) && $past(sva_checker.compliance_cost_reduction_quantification) < sva_checker.regulatory_technology_efficiency_improvement_target): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.regulatory_technology_implementation_assessment_complete == 1 && sva_checker.regtech_compliance_automation == 1 |-> $past(sva_checker.regulatory_change_management_effectiveness) == 1 && $past(sva_checker.compliance_cost_reduction_quantification) < sva_checker.regulatory_technology_efficiency_improvement_target): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.regtech_compliance_automation == 1'b1 |-> $past(sva_checker.regulatory_change_management_effectiveness) && $past(sva_checker.compliance_cost_reduction_quantification) < sva_checker.regulatory_technology_efficiency_improvement_target): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uublo4g8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.regulatory_technology_implementation_assessment_complete == 1 && sva_checker.regtech_compliance_automation == 1 |-> $past(sva_checker"
  },
  {
    "id": "3934",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cri6ipdm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.strong_coupling_regime_investigation |-> $past(sva_checker.atom_cavity_coupling_strength_measurement) && $past(sva_checker.vacuum_rabi_splitting_observation_clarity) < sva_checker.quantum_optics_phenomena_demonstration_threshold): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.strong_coupling_regime_investigation |-> $past(sva_checker.atom_cavity_coupling_strength_measurement) && $past(sva_checker.vacuum_rabi_splitting_observation_clarity) < sva_checker.quantum_optics_phenomena_demonstration_threshold): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.strong_coupling_regime_investigation |-> $past(sva_checker.atom_cavity_coupling_strength_measurement) && $past(sva_checker.vacuum_rabi_splitting_observation_clarity) < sva_checker.quantum_optics_phenomena_demonstration_threshold): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wdljw4xl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.strong_coupling_regime_investigation |-> $past(sva_checker.atom_cavity_coupling_strength_measurement) && $past(sva_checker.vacuum_rabi_splitting_observation_clarity) < sva_checker.quantum_optics_phenomena_demonstration_thres"
  },
  {
    "id": "3959",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_039v8ujo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.extraterrestrial_sample_acquisition == 1'b1 |-> $past(sva_checker.contamination_prevention_procedure_implementation) && $past(sva_checker.sample_integrity_preservation_effectiveness) < sva_checker.scientific_analysis_validity_standard): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.planetary_protection_protocol_compliance_verified == 1 && sva_checker.extraterrestrial_sample_acquisition == 1 |-> $past(sva_checker.contamination_prevention_procedure_implementation) == 1 && $past(sva_checker.sample_integrity_preservation_effectiveness) < sva_checker.scientific_analysis_validity_standard): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.extraterrestrial_sample_acquisition == 1'b1 |-> $past(sva_checker.contamination_prevention_procedure_implementation) && $past(sva_checker.sample_integrity_preservation_effectiveness) < sva_checker.scientific_analysis_validity_standard): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0p5l0ua0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.planetary_protection_protocol_compliance_verified == 1 && sva_checker.extraterrestrial_sample_acquisition == 1 |-> $past(sva_checker.c"
  },
  {
    "id": "4014",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7y8a2u3f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.physical_therapy_progress_monitoring |-> $past(sva_checker.range_of_motion_improvement_measurement) && $past(sva_checker.muscle_strength_recovery_assessment) && $past(sva_checker.functional_independence_achievement_rate) < sva_checker.rehabilitation_outcome_target_expectation): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.physical_therapy_progress_monitoring |-> $past(sva_checker.range_of_motion_improvement_measurement) && $past(sva_checker.muscle_strength_recovery_assessment) && $past(sva_checker.functional_independence_achievement_rate) < sva_checker.rehabilitation_outcome_target_expectation): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.physical_therapy_progress_monitoring |-> $past(sva_checker.range_of_motion_improvement_measurement) && $past(sva_checker.muscle_strength_recovery_assessment) && $past(sva_checker.functional_independence_achievement_rate) < sva_checker.rehabilitation_outcome_target_expectation): PROVED\n\n\nBackward: Parsing /tmp/sva_check_529h_w4z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.physical_therapy_progress_monitoring |-> $past(sva_checker.range_of_motion_impro"
  },
  {
    "id": "312_6_0103",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5g_3pqxj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> !(sva_checker.parity_err || sva_checker.timeout_err || sva_checker.protocol_err)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> sva_checker.parity_err == 0 && sva_checker.timeout_err == 0 && sva_checker.protocol_err == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> !(sva_checker.parity_err || sva_checker.timeout_err || sva_checker.protocol_err)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zzvbixu9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> sva_checker.parity_err == 0 && sva_checker.timeout_err == 0 && sva_checker.protocol_err == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> !(sva_checker.parity_err || sva_checker.timeout_err || sva_checker.protocol_err)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.global_err_int) |-> sva_checker.parity_err == 0 && sva_checker.timeout_err == 0 && sva_checker.protocol_err == 0): PROVED\n"
  },
  {
    "id": "315_1_0143",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_uj18ydbv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok || sva_checker.bypass_mode): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok == 1 || sva_checker.bypass_mode == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok || sva_checker.bypass_mode): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zh_2xlgn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok == 1 || sva_checker.bypass_mode == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok || sva_checker.bypass_mode): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pwr_en) |-> sva_checker.vdd_ok == 1 || sva_checker.bypass_mode == 1): PROVED\n"
  },
  {
    "id": "316_2_0119",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |-> sva_checker.adc_start == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |=> !sva_checker.adc_start): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_p84i1kwy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |=> !sva_checker.adc_start): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |-> sva_checker.adc_start == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |=> !sva_checker.adc_start): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oup7_5pw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |-> sva_checker.adc_start == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |=> !sva_checker.adc_start): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_ready) |-> sva_checker.adc_start == 0): PROVED\n"
  },
  {
    "id": "4030",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ak5slxrg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.green_healthcare_system_transformation |-> $past(sva_checker.healthcare_carbon_footprint_reduction_strategy_implementation) && $past(sva_checker.sustainable_healthcare_practice_adoption_effectiveness) < sva_checker.environmental_stewardship_healthcare_sector_leadership_target): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.environmental_health_impact_assessment_methodology_validated == 1 && sva_checker.green_healthcare_system_transformation == 1 |-> $past(sva_checker.healthcare_carbon_footprint_reduction_strategy_implementation) == 1 && $past(sva_checker.sustainable_healthcare_practice_adoption_effectiveness) < sva_checker.environmental_stewardship_healthcare_sector_leadership_target): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.green_healthcare_system_transformation |-> $past(sva_checker.healthcare_carbon_footprint_reduction_strategy_implementation) && $past(sva_checker.sustainable_healthcare_practice_adoption_effectiveness) < sva_checker.environmental_stewardship_healthcare_sector_leadership_target): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xt6ul81a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) s"
  },
  {
    "id": "317_2_0130",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |-> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |=> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_i4of9vin/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |=> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |-> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |=> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hamr00gw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |-> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |=> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.key_valid == 1'b1 |-> xor(sva_checker.key_reg, !sva_checker.key_check) == 0): PROVED\n"
  },
  {
    "id": "318_3_0153",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3ttnwdml/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && !sva_checker.gpio_wakeup && !sva_checker.comm_wakeup |-> (##2 sva_checker.sys_wakeup)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && sva_checker.gpio_wakeup == 0 && sva_checker.comm_wakeup == 0 |-> (##2 sva_checker.sys_wakeup == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && !sva_checker.gpio_wakeup && !sva_checker.comm_wakeup |-> (##2 sva_checker.sys_wakeup)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s7rnnycj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && sva_checker.gpio_wakeup == 0 && sva_checker.comm_wakeup == 0 |-> (##2 sva_checker.sys_wakeup == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && !sva_checker.gpio_wakeup && !sva_checker.comm_wakeup |-> (##2 sva_checker.sys_wakeup)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.rtc_wakeup) && sva_checker.gpio_wakeup == 0 && sva_checker.comm_wakeup == 0 |-> (##2 sva_checker.sys_wakeup == 1)): PROVED\n"
  },
  {
    "id": "336_4_0291",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jkq71l6q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot || sva_checker.secure_boot throughout (sva_checker.boot_sel[0] [*1:$]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot == 1'b1 or (sva_checker.secure_boot == 1'b1 throughout sva_checker.boot_sel[0] == 1'b1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot || sva_checker.secure_boot throughout (sva_checker.boot_sel[0] [*1:$]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check__tqzbsje/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot == 1'b1 or (sva_checker.secure_boot == 1'b1 throughout sva_checker.boot_sel[0] == 1'b1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot || sva_checker.secure_boot throughout (sva_checker.boot_sel[0] [*1:$]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.boot_sel[0] == 1'b1 |-> (sva_checker.direct_boot == 1'b1 or (sva_checker.secure_boot == 1'b1"
  },
  {
    "id": "337_6_0281",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_td2l_iuc/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_td2l_iuc/sva_checker.sv\nfile /tmp/sva_check_td2l_iuc/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "346_8_0371",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jl3gm6pt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.active_mode && !$past(sva_checker.clock_en) |-> !sva_checker.clock_en): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.active_mode == 0 && $past(sva_checker.clock_en) == 0 |-> sva_checker.clock_en == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.active_mode && !$past(sva_checker.clock_en) |-> !sva_checker.clock_en): PROVED\n\n\nBackward: Parsing /tmp/sva_check_o_bn3nrm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.active_mode == 0 && $past(sva_checker.clock_en) == 0 |-> sva_checker.clock_en == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.active_mode && !$past(sva_checker.clock_en) |-> !sva_checker.clock_en): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.active_mode == 0 && $past(sva_checker.clock_en) == 0 |-> sva_checker.clock_en == 0): PROVED\n"
  },
  {
    "id": "349_5_0404",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kjpsv5gi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 !sva_checker.interrupt_pending)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 sva_checker.interrupt_pending == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 !sva_checker.interrupt_pending)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7fzoorsi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 sva_checker.interrupt_pending == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 !sva_checker.interrupt_pending)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.trigger_A && sva_checker.trigger_B && sva_checker.threshold_exceed) |-> (##1 sva_checker.interrupt_pending == 0)): PROVED\n"
  },
  {
    "id": "381_4_0656",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ls_4tsgy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase1) && $stable(sva_checker.auth_pass_phase2) && $stable(sva_checker.auth_pass_phase3) |-> sva_checker.auth_granted): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase1) && $stable(sva_checker.auth_pass_phase2) && $stable(sva_checker.auth_pass_phase3) |-> sva_checker.auth_granted == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase1) && $stable(sva_checker.auth_pass_phase2) && $stable(sva_checker.auth_pass_phase3) |-> sva_checker.auth_granted): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uqte7r9p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase1) && $stable(sva_checker.auth_pass_phase2) && $stable(sva_checker.auth_pass_phase3) |-> sva_checker.auth_granted == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase1) && $stable(sva_checker.auth_pass_phase2) && $stable(sva_checker.auth_pass_phase3) |-> sva_checker.auth_granted): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $stable(sva_checker.auth_pass_phase"
  },
  {
    "id": "386_1_0715",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_24zs88za/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot || sva_checker.secure_boot): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot == 1 || sva_checker.secure_boot == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot || sva_checker.secure_boot): PROVED\n\n\nBackward: Parsing /tmp/sva_check_i_4pkwdj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot == 1 || sva_checker.secure_boot == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot || sva_checker.secure_boot): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_sel[0]) |-> sva_checker.direct_boot == 1 || sva_checker.secure_boot == 1): PROVED\n"
  },
  {
    "id": "389_2_0737",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ext_reset == 1 || sva_checker.wdt_reset == 1 || sva_checker.power_good == 0 |-> $past(sva_checker.reset_active) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ext_reset || sva_checker.wdt_reset || !sva_checker.power_good |=> $past(sva_checker.reset_active, 1)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_dyuaqgkc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ext_reset || sva_checker.wdt_reset || !sva_checker.power_good |=> $past(sva_checker.reset_active, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ext_reset == 1 || sva_checker.wdt_reset == 1 || sva_checker.power_good == 0 |-> $past(sva_checker.reset_active) == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ext_reset || sva_checker.wdt_reset || !sva_checker.power_good |=> $past(sva_checker.reset_active, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xg5glvnm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ext_reset == 1 || sva_checker.wdt_reset == 1 || sva_checker.power_good == 0 |-> $past(sva_checker.reset_active) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ext_reset || sva_checker.wdt_reset || !sva_checker.power_good |=> $past(sva_checker.reset_active, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ext_reset == 1 || sva_checker.wdt_reset == 1 || sva_checker.power_good == 0 |-> $past(sva_checker.reset_active) == 1): PROVED\n"
  },
  {
    "id": "389_5_0727",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6rukuoh9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(!sva_checker.ext_reset && !sva_checker.wdt_reset && sva_checker.power_good, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(sva_checker.ext_reset) == 0 && $past(sva_checker.wdt_reset) == 0 && $past(sva_checker.power_good) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(!sva_checker.ext_reset && !sva_checker.wdt_reset && sva_checker.power_good, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5rmz3d3m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(sva_checker.ext_reset) == 0 && $past(sva_checker.wdt_reset) == 0 && $past(sva_checker.power_good) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(!sva_checker.ext_reset && !sva_checker.wdt_reset && sva_checker.power_good, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_active) |-> $past(sva_checker.ext_reset) == 0 && $past(sva_checker.wdt_reset) == 0 && $past(sva_checker.power_goo"
  },
  {
    "id": "394_9_0788",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_uc86hl8n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> $fell(sva_checker.core_sync)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> sva_checker.core_sync == 1'b0 && $past(sva_checker.core_sync) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> $fell(sva_checker.core_sync)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qv93ig3p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> sva_checker.core_sync == 1'b0 && $past(sva_checker.core_sync) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> $fell(sva_checker.core_sync)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.core_1_result != sva_checker.core_2_result |-> sva_checker.core_sync == 1'b0 && $past(sva_checker.core_sync) == 1'b1): PROVED\n"
  },
  {
    "id": "449_6_1257",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pp2kim3k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jlek3gpb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.gpu_freq_change) |-> (##[1:5] $fell(sva_checker.gpu_freq_busy))): PROVED\n"
  },
  {
    "id": "451_2_1255",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |-> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |=> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_cebq6bjl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |=> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |-> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |=> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dtnzp38f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |-> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |=> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.boot_enable) |-> ($stable(sva_checker.bootloader_hash) throughout sva_checker.boot_done)): PROVED\n"
  },
  {
    "id": "454_2_1283",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Internal tool crash. The SVA may contain unsupported constructs.",
    "log": "Parsing /tmp/sva_check_wuwix5pi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: rewrite_sva_sequence.cpp:105 function: admits_empty\nCondition: false\nReason: unexpected SVA sequence: sva_sequence_throughout\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x7fb520]\n[0x7fb9e8]\n[0x835715]\n[0x82989e]\n[0x828d03]\n[0x828d03]\n[0x826d81]\n[0x82be79]\n[0x82c257]\n[0x4b9820]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "457_8_1280",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_zalcgfwm/sva_checker.sv line 8: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_zalcgfwm/sva_checker.sv\nfile /tmp/sva_check_zalcgfwm/sva_checker.sv line 8: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "459_4_1329",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_o1vxy_az/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [->3]) ##1 sva_checker.phy_init) |-> (##[10:20] $stable(sva_checker.dll_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [*3]) ##1 sva_checker.phy_init) |-> (##10 (sva_checker.dll_lock == $past(sva_checker.dll_lock) [*10:20]))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [->3]) ##1 sva_checker.phy_init) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3ffngnpf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [*3]) ##1 sva_checker.phy_init) |-> (##10 (sva_checker.dll_lock == $past(sva_checker.dll_lock) [*10:20]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [->3]) ##1 sva_checker.phy_init) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.zq_cal [*3]) ##1 sva_checker.phy_init) |-> (##10 (sva_checker.dll_lock == $past(sva_checker.dll_lock) [*10:20]))): PROVED\n"
  },
  {
    "id": "459_7_1322",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lb1zecit/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pat54u4u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.zq_cal [->3]) |-> (##[10:20] $stable(sva_checker.dll_lock))): PROVED\n"
  },
  {
    "id": "468_7_1360",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [*6]))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [->6]))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_y9he3bit/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [->6]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [*6]))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [->6]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g79v2tc6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [*6]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [->6]))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.prim_assembler_start) |-> (##1 (sva_checker.vertex_valid [*6]))): PROVED\n"
  },
  {
    "id": "462_1_1332",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Internal tool crash. The SVA may contain unsupported constructs.",
    "log": "Parsing /tmp/sva_check_iih2jazb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: rewrite_sva_sequence.cpp:105 function: admits_empty\nCondition: false\nReason: unexpected SVA sequence: sva_sequence_throughout\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x7fb520]\n[0x7fb9e8]\n[0x835715]\n[0x82989e]\n[0x828d03]\n[0x828d03]\n[0x826d81]\n[0x82be79]\n[0x82c257]\n[0x4b9820]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "473_6_1417",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_p9j_d9r1/sva_checker.sv line 8: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_p9j_d9r1/sva_checker.sv\nfile /tmp/sva_check_p9j_d9r1/sva_checker.sv line 8: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "484_3_1477",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xvkja2he/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_17a5w1m6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.auto_refresh) |-> (##[1:8] $stable(sva_checker.refresh_addr))): PROVED\n"
  },
  {
    "id": "498_3_1590",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lfcfw2wq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 $stable(sva_checker.link_width))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 sva_checker.link_width == $past(sva_checker.link_width))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 $stable(sva_checker.link_width))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_959phbsx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 sva_checker.link_width == $past(sva_checker.link_width))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 $stable(sva_checker.link_width))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.ucie_linkup) |-> (##1 sva_checker.link_width == $past(sva_checker.link_width))): PROVED\n"
  },
  {
    "id": "498_5_1581",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u43h_2qz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_53amy0oh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.phy_ready) |-> (##1 $fell(sva_checker.protocol_handshake))): PROVED\n"
  },
  {
    "id": "503_9_0044",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oczi667n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.crc_valid ##1 sva_checker.header_valid) |-> $fell(sva_checker.tlp_start) || $past($fell(sva_checker.tlp_start))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.crc_valid ##1 sva_checker.header_valid) |-> ($fell(sva_checker.tlp_start) or $past($fell(sva_checker.tlp_start), 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.crc_valid ##1 sva_checker.header_valid) |-> $fell(sva_checker.tlp_start) || $past($fell(sva_checker.tlp_start))): PROVED\nwarning: ignoring function_call\n  * type: bool\n  * #source_location: \n    * file: /tmp/sva_check_oczi667n/sva_checker.sv\n    * line: 20\n    * working_directory: /tmp/sva_check_oczi667n\n  0: symbol\n      * type: \n      * #source_location: \n        * file: /tmp/sva_check_oczi667n/sva_checker.sv\n        * line: 20\n        * working_directory: /tmp/sva_check_oczi667n\n      * identifier: $fell@0\n      * base_name: $fell\n  1: \n    * type: \n    * #source_location: \n      * file: /tmp/sva_check_oczi667n/sva_checker.sv\n      * line: 20\n      * working_directory: /tmp/sva_check_oczi667n\n    0: symbol\n        * type: bool\n            * #source_location: \n              * file: /tmp/sva_check_oczi667n/sva_checker.sv\n              * line: 7\n              * working_directory: /tmp/sva_check_oczi667n\n        * #source_location: \n          * file: /tmp/sva_check_oczi667n/sva_checker.sv\n          * line: 20\n          * working_directory: /tmp/sva_check_oczi667n\n        * identifier: Verilog::sva_checker.tlp_start@0"
  },
  {
    "id": "507_1_0014",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_s5trmw1e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 (((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 ((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 (((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uhsksc8j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 ((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 (((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> (##2 ((sva_checker.desc_fetch ##[1:3] sva_checker.data_xfer) [*4]) ##1 sva_checker.irq_gen)): PROVED\n"
  },
  {
    "id": "515_5_0112",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_199xs0bh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_33yg1f7k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.result_valid) |-> $past(sva_checker.fir_enable, 118)): PROVED\n"
  },
  {
    "id": "573_1_0536",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_no87qvz4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1pz4d66w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_add) |-> sva_checker.simd_sum <= sva_checker.VMAX && sva_checker.simd_sum >= sva_checker.VMIN): PROVED\n"
  },
  {
    "id": "581_2_0573",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_glv1ufjk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1l_mr91_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_store) |-> sva_checker.mem_addr % sva_checker.VLEN == 0): PROVED\n"
  },
  {
    "id": "581_4_0584",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_4_z208xf/sva_checker.sv line 21: syntax error, unexpected or, expecting ')' before 'or'",
    "log": "Parsing /tmp/sva_check_4_z208xf/sva_checker.sv\nfile /tmp/sva_check_4_z208xf/sva_checker.sv line 21: syntax error, unexpected or, expecting ')' before 'or'\n"
  },
  {
    "id": "592_3_0661",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_n0iitu4t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |=> !sva_checker.simd_hazard): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.simd_hazard)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |=> !sva_checker.simd_hazard): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5bxjwqkm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.simd_hazard)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |=> !sva_checker.simd_hazard): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##1 !sva_checker.simd_hazard)): PROVED\n"
  },
  {
    "id": "592_6_0679",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_ruqfsy7a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##[0:2] !sva_checker.simd_hazard)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (!sva_checker.simd_hazard throughout (1 ##1 1))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##[0:2] !sva_checker.simd_hazard)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_61is6d9y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (!sva_checker.simd_hazard throughout (1 ##1 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (##[0:2] !sva_checker.simd_hazard)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue) |-> (!sva_checker.simd_hazard throughout (1 ##1 1))): PROVED\n"
  },
  {
    "id": "594_8_0693",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |=> (##[1:3] $onehot(sva_checker.simd_decoded_o))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |-> (##[1:3] $onehot(sva_checker.simd_decoded_o))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_f5nsc85_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |-> (##[1:3] $onehot(sva_checker.simd_decoded_o))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |=> (##[1:3] $onehot(sva_checker.simd_decoded_o))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |-> (##[1:3] $onehot(sva_checker.simd_decoded_o))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_01aadd8b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |=> (##[1:3] $onehot(sva_checker.simd_decoded_o))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |-> (##[1:3] $onehot(sva_checker.simd_decoded_o))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_issue_i) |=> (##[1:3] $onehot(sva_checker.simd_decoded_o))): PROVED\n"
  },
  {
    "id": "596_3_0684",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_5vezg392/sva_checker.sv line 44: syntax error, unexpected ';', expecting ')' before ';'",
    "log": "Parsing /tmp/sva_check_5vezg392/sva_checker.sv\nfile /tmp/sva_check_5vezg392/sva_checker.sv line 44: syntax error, unexpected ';', expecting ')' before ';'\n"
  },
  {
    "id": "602_8_0784",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_211wtn9v/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_211wtn9v/sva_checker.sv\nfile /tmp/sva_check_211wtn9v/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "618_5_0871",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fjr3exqa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_segment_op) |-> sva_checker.segment_base_i < sva_checker.VLEN_i && sva_checker.segment_len_i <= sva_checker.VLEN_i - sva_checker.segment_base_i): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_segment_op) |-> sva_checker.segment_base_i < sva_checker.VLEN_i && sva_checker.segment_len_i <= sva_checker.VLEN_i - sva_checker.segment_base_i): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_segment_op) |-> sva_checker.segment_base_i < sva_checker.VLEN_i && sva_checker.segment_len_i <= sva_checker.VLEN_i - sva_checker.segment_base_i): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xh92ihey/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_segment_op) |-> sva_checker.segment_base_i < sva_checker.VLEN_i && sva_checker.segment_len_i <= sva_checker.VLEN_i - sva_checker.segment_base_i): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.simd_segment_op) |-> sva_checker.segment_base_i < sva_checker.VLEN_i && sva_checker.segment_len_i <= sva_checker.VLEN_i - sva_checker.segment_base_i): PROVED up to bound 20\n[sva_checker.cover_anteced"
  },
  {
    "id": "620_3_0875",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oaqc616x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_segment_write) && sva_checker.simd_segment_write |-> sva_checker.segment_idx < sva_checker.NUM_SEGMENT): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write == 1 && $past(sva_checker.simd_segment_write) == 0 |-> sva_checker.segment_idx < sva_checker.NUM_SEGMENT): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_segment_write) && sva_checker.simd_segment_write |-> sva_checker.segment_idx < sva_checker.NUM_SEGMENT): PROVED\n\n\nBackward: Parsing /tmp/sva_check_61a0gcz5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write == 1 && $past(sva_checker.simd_segment_write) == 0 |-> sva_checker.segment_idx < sva_checker.NUM_SEGMENT): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $changed(sva_checker.simd_segment_write) && sva_checker.simd_segment_write |-> sva_checker.segment_idx < sva_checker.NUM_SEGMENT): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.simd_segment_write == 1 && $past(sva_checker.simd_segment_write) == 0 |-> sva_checker.segment_idx < sva_checker.NUM_SEG"
  },
  {
    "id": "622_5_0887",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_opncxgq0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): PROVED\n\n\nBackward: Parsing /tmp/sva_check_x26nok0x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_valid && sva_checker.abs_data < sva_checker.norm_max [*8]): PROVED\n"
  },
  {
    "id": "636_4_1013",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_4qne3rah/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "641_6_1067",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_r9uvulhf/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_r9uvulhf/sva_checker.sv\nfile /tmp/sva_check_r9uvulhf/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "647_9_1122",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_cz6e13l1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_07axd8y9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thread_context_saved) |-> (##1 !$fell(sva_checker.thread_context_saved))): PROVED\n"
  },
  {
    "id": "649_7_1139",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_30x5coz7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1'b1 |-> $onehot(sva_checker.decoded_inst_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1 |-> $onehot(sva_checker.decoded_inst_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1'b1 |-> $onehot(sva_checker.decoded_inst_)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5kuhvbqt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1 |-> $onehot(sva_checker.decoded_inst_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1'b1 |-> $onehot(sva_checker.decoded_inst_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fetch_complete_ == 1 |-> $onehot(sva_checker.decoded_inst_)): PROVED\n"
  },
  {
    "id": "652_4_1170",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_8w_zyxbo/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_8w_zyxbo/sva_checker.sv\nfile /tmp/sva_check_8w_zyxbo/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "657_4_1204",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_8tph9d0q/sva_checker.sv line 8: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_8tph9d0q/sva_checker.sv\nfile /tmp/sva_check_8tph9d0q/sva_checker.sv line 8: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "658_10_1198",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bh4n9zst/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): PROVED\n\n\nBackward: Parsing /tmp/sva_check_39n8f5gl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) first_match(##[1:20] sva_checker.ldpc_check_finished) |-> sva_checker.ldpc_check_correct): PROVED\n"
  },
  {
    "id": "668_4_1322",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_53ntxume/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ytsvbqro/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.temp_alert_enable) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED\n"
  },
  {
    "id": "668_8_1334",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |=> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_jofztrqp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |=> sva_checker.temp_value > sva_checker.MIN_TEMP): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |=> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tpkakwcw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |=> sva_checker.temp_value > sva_checker.MIN_TEMP): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.power_good) |-> sva_checker.temp_value > sva_checker.MIN_TEMP): PROVED\n"
  },
  {
    "id": "673_10_1374",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_1gjaxr2d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "673_1_1341",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_ucb59c9b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "677_6_1400",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_0_st3l2s/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_0_st3l2s/sva_checker.sv\nfile /tmp/sva_check_0_st3l2s/sva_checker.sv line 7: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "677_8_1399",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_298p_xw7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1qmght7j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.inference_active == 1'b1 |-> $stable(sva_checker.batchnorm_param)): PROVED\n"
  },
  {
    "id": "688_6_1534",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v92jd82e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_obeo2tuo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(!sva_checker.bus_active) |-> (##1 sva_checker.data_bus === 1'bz)): PROVED\n"
  },
  {
    "id": "689_5_1492",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6a8tf_od/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5fxd_jl1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_state == 1'b1 |-> !$rose(sva_checker.can_tx_en)): PROVED\n"
  },
  {
    "id": "700_3_1601",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3qylpzyb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 $stable(sva_checker.thread_switch))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 sva_checker.thread_switch == $past(sva_checker.thread_switch))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 $stable(sva_checker.thread_switch))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w347k7ir/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 sva_checker.thread_switch == $past(sva_checker.thread_switch))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 $stable(sva_checker.thread_switch))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(|sva_checker.thread_switch) |-> (##1 sva_checker.thread_switch == $past(sva_checker.thread_switch))): PROVED\n"
  },
  {
    "id": "700_7_1595",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_ty2i924l/sva_checker.sv line 6: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_ty2i924l/sva_checker.sv\nfile /tmp/sva_check_ty2i924l/sva_checker.sv line 6: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "712_3_1698",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_o4numnuz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.channel_est <= sva_checker.CH_MAX)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.channel_est <= sva_checker.CH_MAX)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.channel_est <= sva_checker.CH_MAX)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c0covkzh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.channel_est <= sva_checker.CH_MAX)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.channel_est <= sva_checker.CH_MAX)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.reset_n) |-> (##[1:10] sva_checker.channel_est >= sva_checker.CH_MIN && sva_checker.cha"
  },
  {
    "id": "716_6_1726",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reram_cell_state != sva_checker.expected_state && sva_checker.reram_write_enable |-> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reram_write_enable && sva_checker.reram_cell_state != sva_checker.expected_state |=> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reram_cell_state != sva_checker.expected_state && sva_checker.reram_write_enable |-> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check__digjfi5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reram_cell_state != sva_checker.expected_state && sva_checker.reram_write_enable |-> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reram_write_enable && sva_checker.reram_cell_state != sva_checker.expected_state |=> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.reram_cell_state != sva_checker.expected_state && sva_checker.reram_write_enable |-> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_02l9licj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.reram_write_enable && sva_checker.reram_cell_state != sva_checker.expected_state |=> (##2 sva_checker.reram_cell_state == sva_checker.expected_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.reram_cell_state != sva_checker.expected_state && sva_checker.reram_write_enable |-> (##2 sva_checker.reram_cell_state == sva_checker"
  },
  {
    "id": "718_3_1738",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |=> sva_checker.all_modules_low_power_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> sva_checker.all_modules_low_power_state == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |=> sva_checker.all_modules_low_power_state): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check__whvsfau/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |=> sva_checker.all_modules_low_power_state): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> sva_checker.all_modules_low_power_state == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |=> sva_checker.all_modules_low_power_state): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yb0hq99i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> sva_checker.all_modules_low_power_state == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |=> sva_checker.all_modules_low_power_state): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> sva_checker.all_modules_low_power_state == 1): PROVED\n"
  },
  {
    "id": "718_7_1749",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u6lbgkdf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sbml7gx7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.thermal_protect_signal) |-> (##[0:1] sva_checker.all_modules_low_power_state)): PROVED\n"
  },
  {
    "id": "725_6_1794",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_lilur1rr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "726_8_1821",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_l1g60d16/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ && !sva_checker.bn_param_update_ |-> $stable(sva_checker.bn_param8_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ == 1 && sva_checker.bn_param_update_ == 0 |-> $stable(sva_checker.bn_param8_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ && !sva_checker.bn_param_update_ |-> $stable(sva_checker.bn_param8_)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s_98iyab/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ == 1 && sva_checker.bn_param_update_ == 0 |-> $stable(sva_checker.bn_param8_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ && !sva_checker.bn_param_update_ |-> $stable(sva_checker.bn_param8_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.inference_in_progress_ == 1 && sva_checker.bn_param_update_ == 0 |-> $stable(sva_checker.bn_param8_)): PROVED\n"
  },
  {
    "id": "755_4_2080",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done && $past(sva_checker.link_width_done) |-> sva_checker.lane_state == $past(sva_checker.lane_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done == 1 && $past(sva_checker.link_width_done) == 1 |-> (##1 sva_checker.lane_state == $past(sva_checker.lane_state))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_width_done && $past(sva_checker.link_width_done) |-> sva_checker.lane_state == $past(sva_checker.lane_state)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_kouywews/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done && $past(sva_checker.link_width_done) |-> sva_checker.lane_state == $past(sva_checker.lane_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done == 1 && $past(sva_checker.link_width_done) == 1 |-> (##1 sva_checker.lane_state == $past(sva_checker.lane_state))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_width_done && $past(sva_checker.link_width_done) |-> sva_checker.lane_state == $past(sva_checker.lane_state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p14a5ag1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done == 1 && $past(sva_checker.link_width_done) == 1 |-> (##1 sva_checker.lane_state == $past(sva_checker.lane_state))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_width_done && $past(sva_checker.link_width_done) |-> sva_checker.lane_state == $past(sva_checker.lane_state)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_width_done == 1 && $past(sva_checker.link_width_done) == 1 |-> (##1 sva_checker.lane_s"
  },
  {
    "id": "765_6_2185",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_sasrkdl4/sva_checker.sv line 6: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'",
    "log": "Parsing /tmp/sva_check_sasrkdl4/sva_checker.sv\nfile /tmp/sva_check_sasrkdl4/sva_checker.sv line 6: syntax error, unexpected until, expecting TOK_NON_TYPE_IDENTIFIER before 'until'\n"
  },
  {
    "id": "772_6_2206",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ayk6bd3l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0v3hc_go/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.relu_valid_out == 1'b1 |=> (##2 sva_checker.bn_valid_out == 1'b1)): PROVED\n"
  },
  {
    "id": "779_7_2319",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_f8n5fxsk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid_backup && sva_checker.frame_valid_backup && !sva_checker.signal_noise_backup): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid_backup == 1 && sva_checker.frame_valid_backup == 1 && sva_checker.signal_noise_backup == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid_backup && sva_checker.frame_valid_backup && !sva_checker.signal_noise_backup): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b5zxj7oo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid_backup == 1 && sva_checker.frame_valid_backup == 1 && sva_checker.signal_noise_backup == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid_backup && sva_checker.frame_valid_backup && !sva_checker.signal_noise_backup): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.crc_valid_primary) |-> sva_checker.crc_valid"
  },
  {
    "id": "780_4_2305",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault == 1 || sva_checker.sensor_2_fault == 1 || sva_checker.sensor_3_fault == 1 |-> (##[1:5] sva_checker.alarm_active == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault || sva_checker.sensor_2_fault || sva_checker.sensor_3_fault |=> (##[1:5] sva_checker.alarm_active)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_d_pd6bqo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault || sva_checker.sensor_2_fault || sva_checker.sensor_3_fault |=> (##[1:5] sva_checker.alarm_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault == 1 || sva_checker.sensor_2_fault == 1 || sva_checker.sensor_3_fault == 1 |-> (##[1:5] sva_checker.alarm_active == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault || sva_checker.sensor_2_fault || sva_checker.sensor_3_fault |=> (##[1:5] sva_checker.alarm_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s89jmlnz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault == 1 || sva_checker.sensor_2_fault == 1 || sva_checker.sensor_3_fault == 1 |-> (##[1:5] sva_checker.alarm_active == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault || sva_checker.sensor_2_fault || sva_checker.sensor_3_fault |=> (##[1:5] sva_checker.alarm_active)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_1_fault == 1 || sva_checker.sensor_2_fault == 1 || sva_checker.sensor_3_fault == 1 |-> (##[1:5] sva_checker.alarm_active == 1)): "
  },
  {
    "id": "789_3_2410",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_i9_lrv2p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && !sva_checker.crc_error |=> $rose(sva_checker.packet_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && sva_checker.crc_error == 0 |-> (##1 $rose(sva_checker.packet_ack))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && !sva_checker.crc_error |=> $rose(sva_checker.packet_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6o4x_21p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && sva_checker.crc_error == 0 |-> (##1 $rose(sva_checker.packet_ack))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && !sva_checker.crc_error |=> $rose(sva_checker.packet_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.packet_valid) && sva_checker.crc_error == 0 |-> (##1 $rose(sva_checker.packet_ack))): PROVED\n"
  },
  {
    "id": "790_3_2428",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |-> $stable(sva_checker.iq_swap)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |=> !$changed(sva_checker.iq_swap)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_miu63rha/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |=> !$changed(sva_checker.iq_swap)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |-> $stable(sva_checker.iq_swap)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |=> !$changed(sva_checker.iq_swap)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kjk6kl4a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |-> $stable(sva_checker.iq_swap)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |=> !$changed(sva_checker.iq_swap)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.iq_invert == 1'b0 |-> $stable(sva_checker.iq_swap)): PROVED\n"
  },
  {
    "id": "795_9_2499",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_gc_i_bji/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##0 !sva_checker.ack_mode_switch)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##1 !sva_checker.ack_mode_switch)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##0 !sva_checker.ack_mode_switch)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_or239mr3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##1 !sva_checker.ack_mode_switch)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##0 !sva_checker.ack_mode_switch)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ack_mode_switch) |-> ((sva_checker.ack_mode_switch [*1:2]) ##1 !sva_checker.ack_mode_switch)): PROVED\n"
  },
  {
    "id": "798_1_2530",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $changed, $countones. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_fc3yax3v/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: bitvector_types.h:42 function: to_bitvector_type\nCondition: can_cast_type<bitvector_typet>(type)\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x61e705]\n[0x670388]\n[0x672732]\n[0x6ab51d]\n[0x66fdad]\n[0x672732]\n[0x6781fa]\n[0x66fc3a]\n[0x672732]\n[0x6870f6]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6dac1e]\n[0x670c8e]\n[0x4b98f4]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "799_9_2545",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dkx778zs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rfhe1edd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sensor_enable == 1'b1 |-> (##[100:110] $rose(sva_checker.sensor_data_valid))): PROVED\n"
  },
  {
    "id": "812_1_2705",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $changed, $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_g1f15c15/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "816_13_2760",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t90jywli/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kfmcfrdb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.rank_switch_req_) |-> (##[1:2] $changed(sva_checker.odt_control_))): PROVED\n"
  },
  {
    "id": "834_2_2942",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |-> (##[1:3] $fell(sva_checker.camera_active_2))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |=> (##[1:3] $fell(sva_checker.camera_active_2))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_6o601jfj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |=> (##[1:3] $fell(sva_checker.camera_active_2))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |-> (##[1:3] $fell(sva_checker.camera_active_2))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |=> (##[1:3] $fell(sva_checker.camera_active_2))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_opk_dynw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |-> (##[1:3] $fell(sva_checker.camera_active_2))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |=> (##[1:3] $fell(sva_checker.camera_active_2))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.camera_power_2) |-> (##[1:3] $fell(sva_checker.camera_active_2))): PROVED\n"
  },
  {
    "id": "835_8_2968",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ifv_dikr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_807g_mcp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mipi_data_valid == 1'b1 |-> $stable(sva_checker.mipi_clock_freq)): PROVED\n"
  },
  {
    "id": "840_8_3058",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_o0elz893/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(!sva_checker.ddr_refresh_pending, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(sva_checker.ddr_refresh_pending) == 1'b0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(!sva_checker.ddr_refresh_pending, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xxmla0ko/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(sva_checker.ddr_refresh_pending) == 1'b0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(!sva_checker.ddr_refresh_pending, 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ddr_pwr_down) |-> $past(sva_checker.ddr_refresh_pending) == 1'b0): PROVED\n"
  },
  {
    "id": "843_1_3084",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nwb0i3zg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_39c7h23k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.master_reset_) |-> (##[0:3] sva_checker.awvalid_ && sva_checker.awready_)): PROVED\n"
  },
  {
    "id": "845_8_3108",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__m8zs901/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8mmzmsc8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.w_valid) && sva_checker.w_last |-> sva_checker.w_cnt == $past(sva_checker.w_len)): PROVED\n"
  },
  {
    "id": "846_3_3105",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0sukz6dm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sva_checker.lane_polarity_o == sva_checker.expected_polarity_i)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sva_checker.lane_polarity_o == sva_checker.expected_polarity_i)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sva_checker.lane_polarity_o == sva_checker.expected_polarity_i)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yn2ybxsq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sva_checker.lane_polarity_o == sva_checker.expected_polarity_i)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sva_checker.lane_polarity_o == sva_checker.expected_polarity_i)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lane_reversal_en_i && $rose(sva_checker.phy_ready_o) |-> (##[1:4] sv"
  },
  {
    "id": "852_10_3206",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bvqctbh5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qhnkz81k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.restore_state) |-> sva_checker.lane_config == sva_checker.saved_lane_config): PROVED\n"
  },
  {
    "id": "852_7_3229",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sqtmswee/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z1x4rwr9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.lane_sync_done) |-> (##[0:10] sva_checker.lane_skew < sva_checker.max_skew_threshold)): PROVED\n"
  },
  {
    "id": "857_6_3268",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_8uzp7z3l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "854_2_3237",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_fail == 1 && sva_checker.spectrum_switching_active == 0 |-> (##[1:16] sva_checker.retransmit_en == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_fail && !sva_checker.spectrum_switching_active |=> (##[1:16] sva_checker.retransmit_en)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check__v88chjj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_fail && !sva_checker.spectrum_switching_active |=> (##[1:16] sva_checker.retransmit_en)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_fail == 1 && sva_checker.spectrum_switching_active == 0 |-> (##[1:16] sva_checker.retransmit_en == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_fail && !sva_checker.spectrum_switching_active |=> (##[1:16] sva_checker.retransmit_en)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_p0zfs59n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_fail == 1 && sva_checker.spectrum_switching_active == 0 |-> (##[1:16] sva_checker.retransmit_en == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_fail && !sva_checker.spectrum_switching_active |=> (##[1:16] sva_checker.retransmit_en)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_fail == 1 && sva_checker.spectrum_switching_active == 0 |-> (##[1:16] sva_checker.retransmit_en == 1)): PROVED\n"
  },
  {
    "id": "858_15_3288",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ucsggjyz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] !sva_checker.intr_request)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] sva_checker.intr_request == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] !sva_checker.intr_request)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fuzz1u5r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] sva_checker.intr_request == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] !sva_checker.intr_request)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.intr_ack) |-> (##[1:3] sva_checker.intr_request == 0)): PROVED\n"
  },
  {
    "id": "863_2_3340",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_oz9ngmq4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w0_5ansk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_speed_change_req == 1'b1 |=> (##[1:5] sva_checker.usb_current_speed == sva_checker.usb_negotiated_speed)): PROVED\n"
  },
  {
    "id": "865_7_3378",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_g79zjf08/sva_checker.sv line 10: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_g79zjf08/sva_checker.sv\nfile /tmp/sva_check_g79zjf08/sva_checker.sv line 10: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "867_1_3388",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8yuh8h1i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |=> (##[1:10] $onehot0(sva_checker.can_tx_active))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |-> (##[1:10] (sva_checker.can_tx_active[0] == 1 || 0 == 1) && (sva_checker.can_tx_active[0] == 0 || 0 == 0))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |=> (##[1:10] $onehot0(sva_checker.can_tx_active))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ynsoc3r4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |-> (##[1:10] (sva_checker.can_tx_active[0] == 1 || 0 == 1) && (sva_checker.can_tx_active[0] == 0 || 0 == 0))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |=> (##[1:10] $onehot0(sva_checker.can_tx_active))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.can_tx_active[0]) && $rose(0) |-> (##[1:10] (sva_checker.can_tx_active[0] == 1 || 0 == 1) && (sva_checker.can_tx_active[0] == 0 || 0 == 0))): PROVED\n"
  },
  {
    "id": "870_3_3421",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_6lmyizx6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "872_7_3466",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid == 1 && sva_checker.eth_pkt_multicast == 1 && sva_checker.multicast_group_enabled == 0 |-> sva_checker.eth_pkt_dropped == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid && sva_checker.eth_pkt_multicast && !sva_checker.multicast_group_enabled |=> sva_checker.pkt_drop): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_rpdi6km2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid && sva_checker.eth_pkt_multicast && !sva_checker.multicast_group_enabled |=> sva_checker.pkt_drop): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid == 1 && sva_checker.eth_pkt_multicast == 1 && sva_checker.multicast_group_enabled == 0 |-> sva_checker.eth_pkt_dropped == 1): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid && sva_checker.eth_pkt_multicast && !sva_checker.multicast_group_enabled |=> sva_checker.pkt_drop): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qaftk8pz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid == 1 && sva_checker.eth_pkt_multicast == 1 && sva_checker.multicast_group_enabled == 0 |-> sva_checker.eth_pkt_dropped == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid && sva_checker.eth_pkt_multicast && !sva_checker.multicast_group_enabled |=> sva_checker.pkt_drop): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_pkt_valid == 1 && sva_checker.eth_pkt_multicast == 1 && sva_checker.multicast_group_enabled == 0 |-> sva_checker.eth_pkt_dropped ="
  },
  {
    "id": "877_3_3488",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z98hmx74/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active && $past(sva_checker.read_cmd_active, 3) |-> !sva_checker.write_cmd_active): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active == 1 && $past(sva_checker.read_cmd_active, 3) == 1 |-> sva_checker.write_cmd_active == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active && $past(sva_checker.read_cmd_active, 3) |-> !sva_checker.write_cmd_active): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xqde054f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active == 1 && $past(sva_checker.read_cmd_active, 3) == 1 |-> sva_checker.write_cmd_active == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active && $past(sva_checker.read_cmd_active, 3) |-> !sva_checker.write_cmd_active): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.read_cmd_active == 1 && $past(sva_checker.read_cmd_active, 3) == 1 |-> sva_checker.write_cmd_active == 0): PROVED\n"
  },
  {
    "id": "874_7_3496",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check__tuhqrzx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.express_traffic) && sva_checker.tx_packet_active |-> (##1 ($fell(sva_checker.tx_packet_active) [*1:8]) ##1 $rose(sva_checker.tx_packet_active))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.express_traffic) && sva_checker.tx_packet_active |-> (##[1:8] sva_checker.tx_packet_active == 1'b0 ##1 sva_checker.tx_packet_active == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.express_traffic) && sva_checker.tx_packet_active |-> (##1 ($fell(sva_checker.tx_packet_active) [*1:8]) ##1 $rose(sva_checker.tx_packet_active))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0twwkmv2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.express_traffic) && sva_checker.tx_packet_active |-> (##[1:8] sva_checker.tx_packet_active == 1'b0 ##1 sva_checker.tx_packet_active == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.express_traffic) && sva_checker.tx_packet_active |-> (##1 ($fell(sva_checker.tx_packet_active) [*1:8]) ##1 $rose(sva_checker.tx_packet_active))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_che"
  },
  {
    "id": "878_4_3523",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_uwo7nt4l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sxxmxn3b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_correction_active == 1'b1 |-> (sva_checker.ecc_parity_bits_valid throughout sva_checker.ecc_correction_cycle)): PROVED\n"
  },
  {
    "id": "882_10_3559",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && sva_checker.flash_write_retry_exhausted == 0 |-> (##1 sva_checker.flash_write_retry_attempt == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && !sva_checker.flash_write_retry_exhausted |=> (##1 sva_checker.flash_write_retry_attempt)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_4jseol_m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && !sva_checker.flash_write_retry_exhausted |=> (##1 sva_checker.flash_write_retry_attempt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && sva_checker.flash_write_retry_exhausted == 0 |-> (##1 sva_checker.flash_write_retry_attempt == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && !sva_checker.flash_write_retry_exhausted |=> (##1 sva_checker.flash_write_retry_attempt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9mgswin4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && sva_checker.flash_write_retry_exhausted == 0 |-> (##1 sva_checker.flash_write_retry_attempt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && !sva_checker.flash_write_retry_exhausted |=> (##1 sva_checker.flash_write_retry_attempt)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.flash_write_error) && sva_checker.flash_write_retry_exhausted == 0 |-> (##1 sva_checker.flash_write_retry_attempt == 1)): PROVED\n"
  },
  {
    "id": "883_9_3586",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_g4fnszme/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_role == sva_checker.SINK_ROLE && sva_checker.rx_packet == sva_checker.PD_CTRL_PR_SWAP |=> (##[1:50] sva_checker.pd_role == sva_checker.SOURCE_ROLE)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_role == sva_checker.SINK_ROLE && sva_checker.rx_packet == sva_checker.PD_CTRL_PR_SWAP |=> (##[1:50] sva_checker.pd_role == sva_checker.SOURCE_ROLE)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pd_role == sva_checker.SINK_ROLE && sva_checker.rx_packet == sva_checker.PD_CTRL_PR_SWAP |=> (##[1:50] sva_checker.pd_role == sva_checker.SOURCE_ROLE)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zrgvejym/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_role == sva_checker.SINK_ROLE && sva_checker.rx_packet == sva_checker.PD_CTRL_PR_SWAP |=> (##[1:50] sva_checker.pd_role == sva_checker.SOURCE_ROLE)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_role == sva_checker.SINK_ROLE && sva_checker.rx_packet == sva_checker.PD_CTRL_PR_SWAP |=> (##[1:50] sva_checker.pd_role == sva_checker.SOURCE_ROLE)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable "
  },
  {
    "id": "888_8_3663",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e_l4_7n2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 0 && sva_checker.wdr_active == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 1'b0 && sva_checker.wdr_active == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 0 && sva_checker.wdr_active == 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nbzc8noh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 1'b0 && sva_checker.wdr_active == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 0 && sva_checker.wdr_active == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.hdr_to_wdr_switch) |-> (##3 sva_checker.hdr_active == 1'b0 && sva_checker.wdr_active == 1'b1)): PROVED\n"
  },
  {
    "id": "885_4_3616",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_b5pax84l/sva_checker.sv line 5: syntax error, unexpected always, expecting TOK_NON_TYPE_IDENTIFIER before 'always'",
    "log": "Parsing /tmp/sva_check_b5pax84l/sva_checker.sv\nfile /tmp/sva_check_b5pax84l/sva_checker.sv line 5: syntax error, unexpected always, expecting TOK_NON_TYPE_IDENTIFIER before 'always'\n"
  },
  {
    "id": "889_1_3647",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ysidwppk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yetv3uy_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.frame_valid) |-> (sva_checker.frame_valid throughout (sva_checker.data_valid [->1]))): PROVED\n"
  },
  {
    "id": "890_2_3678",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_c9m8agkd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_param_) && $stable(sva_checker.sharpen_param_) && $stable(sva_checker.gamma_param_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_param_) && $stable(sva_checker.sharpen_param_) && $stable(sva_checker.gamma_param_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_param_) && $stable(sva_checker.sharpen_param_) && $stable(sva_checker.gamma_param_)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kptw2o6x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_param_) && $stable(sva_checker.sharpen_param_) && $stable(sva_checker.gamma_param_)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_param_) && $stable(sva_checker.sharpen_param_) && $stable(sva_checker.gamma_param_)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.isp_busy == 1'b1 |-> $stable(sva_checker.denoise_para"
  },
  {
    "id": "891_4_3701",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3_rx8501/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m_53r98i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.sensor_data_error) |-> (##[1:15] $fell(sva_checker.sensor_data_error) && sva_checker.image_stable)): PROVED\n"
  },
  {
    "id": "898_12_3805",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ac8v3y9p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fmq21kyl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.network_changed) |-> (##[1:100] $stable(sva_checker.stored_params) && $stable(sva_checker.current_params))): PROVED\n"
  },
  {
    "id": "10_22_0477",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__jfb0txs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transfer_done == 1'b1 |-> $past(sva_checker.spi_start, 1) && $past(sva_checker.spi_busy, 2) == 1'b1 && $past(sva_checker.spi_count, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transfer_done == 1'b1 |-> $past(sva_checker.spi_start, 1) == 1'b1 && $past(sva_checker.spi_busy, 2) == 1'b1 && $past(sva_checker.spi_count, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spi_transfer_done == 1'b1 |-> $past(sva_checker.spi_start, 1) && $past(sva_checker.spi_busy, 2) == 1'b1 && $past(sva_checker.spi_count, 3) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z_5j3tyg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transfer_done == 1'b1 |-> $past(sva_checker.spi_start, 1) == 1'b1 && $past(sva_checker.spi_busy, 2) == 1'b1 && $past(sva_checker.spi_count, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_transfer_done == 1'b1 |-> $past(sva_checker.spi_start, 1) && $past(sva_checker.spi_busy, 2) == 1'b1 && $past(sva_checker.spi_count, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.r"
  },
  {
    "id": "10_34_0491",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5tzeyxn8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_vsync) |-> $past(sva_checker.video_enable, 1) && $past(sva_checker.video_active, 2) && $past(sva_checker.video_line_count, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_vsync) |-> $past(sva_checker.video_enable, 1) == 1 && $past(sva_checker.video_active, 2) == 1 && $past(sva_checker.video_line_count, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_vsync) |-> $past(sva_checker.video_enable, 1) && $past(sva_checker.video_active, 2) && $past(sva_checker.video_line_count, 3) == 0): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e_uqjuzr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_vsync) |-> $past(sva_checker.video_enable, 1) == 1 && $past(sva_checker.video_active, 2) == 1 && $past(sva_checker.video_line_count, 3) == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.video_vsync) |-> $past(sva_checker.video_enable, 1) && $past(sva_checker.video_active, 2) && $past(sva_checker.video_line_count, 3) == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rs"
  },
  {
    "id": "10_42_0505",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_i795sodl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1'b1 |-> $past(sva_checker.rf_tx_start, 1) && $past(sva_checker.rf_busy, 2) && $past(sva_checker.rf_packet_valid, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1 |-> $past(sva_checker.rf_tx_start, 1) == 1 && $past(sva_checker.rf_busy, 2) == 1 && $past(sva_checker.rf_packet_valid, 3) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1'b1 |-> $past(sva_checker.rf_tx_start, 1) && $past(sva_checker.rf_busy, 2) && $past(sva_checker.rf_packet_valid, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5y3mcps_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1 |-> $past(sva_checker.rf_tx_start, 1) == 1 && $past(sva_checker.rf_busy, 2) == 1 && $past(sva_checker.rf_packet_valid, 3) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1'b1 |-> $past(sva_checker.rf_tx_start, 1) && $past(sva_checker.rf_busy, 2) && $past(sva_checker.rf_packet_valid, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_done == 1 |-> $past(sva_checker.r"
  },
  {
    "id": "10_6_0464",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jgaubz3i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_req, 1) && $past(sva_checker.mem_addr_valid, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_addr_valid, 2) && $past(sva_checker.mem_req, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_req, 1) && $past(sva_checker.mem_addr_valid, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kmd8f06c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_addr_valid, 2) && $past(sva_checker.mem_req, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_req, 1) && $past(sva_checker.mem_addr_valid, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.mem_write) |-> $past(sva_checker.mem_ready, 3) && $past(sva_checker.mem_addr_valid"
  },
  {
    "id": "11_45_0539",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d7ifiy5i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_active && sva_checker.buffer_full |-> (##0 $rose(sva_checker.overflow_flag))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_active == 1 && sva_checker.buffer_full == 1 |-> $rose(sva_checker.overflow_flag) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_active && sva_checker.buffer_full |-> (##0 $rose(sva_checker.overflow_flag))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yx2_cjz8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_active == 1 && sva_checker.buffer_full == 1 |-> $rose(sva_checker.overflow_flag) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_active && sva_checker.buffer_full |-> (##0 $rose(sva_checker.overflow_flag))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_active == 1 && sva_checker.buffer_full == 1 |-> $rose(sva_checker.overflow_flag) == 1): PROVED\n"
  },
  {
    "id": "12_14_0563",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ydnj_9ou/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request || sva_checker.sw_trigger |-> (##2 sva_checker.dma_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 || sva_checker.sw_trigger == 1 |-> (##2 sva_checker.dma_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request || sva_checker.sw_trigger |-> (##2 sva_checker.dma_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rvxvxm9y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 || sva_checker.sw_trigger == 1 |-> (##2 sva_checker.dma_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_request || sva_checker.sw_trigger |-> (##2 sva_checker.dma_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_request == 1 || sva_checker.sw_trigger == 1 |-> (##2 sva_checker.dma_ack == 1)): PROVED\n"
  },
  {
    "id": "15_8_0707",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected == 1 && sva_checker.error_passive == 0 && sva_checker.can_bus_off == 0 |-> (##[6:12] sva_checker.error_frame == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected && !sva_checker.error_passive |-> (##[6:12] sva_checker.error_frame_detected)): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_64ip3wb6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected && !sva_checker.error_passive |-> (##[6:12] sva_checker.error_frame_detected)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected == 1 && sva_checker.error_passive == 0 && sva_checker.can_bus_off == 0 |-> (##[6:12] sva_checker.error_frame == 1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected && !sva_checker.error_passive |-> (##[6:12] sva_checker.error_frame_detected)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__ud6yrsq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected == 1 && sva_checker.error_passive == 0 && sva_checker.can_bus_off == 0 |-> (##[6:12] sva_checker.error_frame == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected && !sva_checker.error_passive |-> (##[6:12] sva_checker.error_frame_detected)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_flag_detected == 1 && sva_checker.error_passive == 0 && sva_checker.can_bus_off == 0 |-> (##[6:12] sva_checker.error_frame "
  },
  {
    "id": "2_6_0072",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5g5zqzic/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy && $onehot(sva_checker.tx_byte))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy == 1'b1 && $onehot(sva_checker.tx_byte))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy && $onehot(sva_checker.tx_byte))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vf01fljr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy == 1'b1 && $onehot(sva_checker.tx_byte))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy && $onehot(sva_checker.tx_byte))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tx_start == 1'b1 |-> (##[2:7] sva_checker.tx_busy == 1'b1 && $onehot(sva_checker.tx_byte))): PROVED\n"
  },
  {
    "id": "3_19_0088",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1q482tdm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released && !sva_checker.bypass_mode |-> (##[10:20] sva_checker.pll_locked ##1 $stable(sva_checker.vco_freq))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released == 1 && sva_checker.bypass_mode == 0 |-> (##[10:20] sva_checker.pll_locked == 1 ##1 $stable(sva_checker.vco_freq))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released && !sva_checker.bypass_mode |-> (##[10:20] sva_checker.pll_locked ##1 $stable(sva_checker.vco_freq))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b2js35zv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released == 1 && sva_checker.bypass_mode == 0 |-> (##[10:20] sva_checker.pll_locked == 1 ##1 $stable(sva_checker.vco_freq))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released && !sva_checker.bypass_mode |-> (##[10:20] sva_checker.pll_locked ##1 $stable(sva_checker.vco_freq))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_released == 1 && sva_checker.bypass_mode == 0 |-> (##[10:20] sva_checker.pll_loc"
  },
  {
    "id": "8_27_0377",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mlduf3b2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done && !sva_checker.dram_zq_cal_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done == 1 && sva_checker.dram_zq_cal_error == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done && !sva_checker.dram_zq_cal_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_idyseugz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done == 1 && sva_checker.dram_zq_cal_error == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done && !sva_checker.dram_zq_cal_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dram_zq_cal_start) |-> (##[32'hs200:32'hs400] sva_checker.dram_zq_cal_done == 1 && sva_checker.dram_zq_cal_error ="
  },
  {
    "id": "8_31_0383",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gu1ig3sy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cyjlpsl_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.vid_hblank_n) |-> (##[40:44] $fell(sva_checker.vid_hsync_n) || sva_checker.vid_line_end == 1)): PROVED\n"
  },
  {
    "id": "8_49_0398",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fcxn51od/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_crl35a8n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.i2s_tdm_ws) |-> (##[32:64] sva_checker.i2s_tdm_sd == $past(sva_checker.i2s_tdm_ch0_data, 32))): PROVED\n"
  },
  {
    "id": "10_12_0470",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ws_5toqg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sample_ready == 1'b1 |-> $past(sva_checker.fifo_empty, 2) == 0 || $past(sva_checker.dma_enable, 4) && $past(sva_checker.irq_pending, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sample_ready == 1'b1 |-> $past(sva_checker.fifo_empty, 2) == 1'b0 || $past(sva_checker.dma_enable, 4) == 1'b1 && $past(sva_checker.irq_pending, 1) == 1'b1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sample_ready == 1'b1 |-> $past(sva_checker.fifo_empty, 2) == 0 || $past(sva_checker.dma_enable, 4) && $past(sva_checker.irq_pending, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_guwx3sr4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sample_ready == 1'b1 |-> $past(sva_checker.fifo_empty, 2) == 1'b0 || $past(sva_checker.dma_enable, 4) == 1'b1 && $past(sva_checker.irq_pending, 1) == 1'b1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sample_ready == 1'b1 |-> $past(sva_checker.fifo_empty, 2) == 0 || $past(sva_checker.dma_enable, 4) && $past(sva_checker.irq_pending, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker."
  },
  {
    "id": "10_29_0530",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_afgv68t9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.break_detected |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.break_detected == 1'b1 |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2) == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.break_detected |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yt2yp34j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.break_detected == 1'b1 |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2) == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.break_detected |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.break_detected == 1'b1 |-> (##[1:4] $past(sva_checker.line_status, 5) == 255 && $past(sva_checker.break_int_en, 2) == 1'b1)): PROVED\n"
  },
  {
    "id": "10_30_0487",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sq4edujr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phy_ready |-> $past(sva_checker.training_done, 3) && $past(sva_checker.power_good, 2) && $past(sva_checker.reset_deasserted, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phy_ready == 1 |-> $past(sva_checker.training_done, 3) == 1 && $past(sva_checker.power_good, 2) == 1 && $past(sva_checker.reset_deasserted, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phy_ready |-> $past(sva_checker.training_done, 3) && $past(sva_checker.power_good, 2) && $past(sva_checker.reset_deasserted, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c288rrlk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.phy_ready == 1 |-> $past(sva_checker.training_done, 3) == 1 && $past(sva_checker.power_good, 2) == 1 && $past(sva_checker.reset_deasserted, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.phy_ready |-> $past(sva_checker.training_done, 3) && $past(sva_checker.power_good, 2) && $past(sva_checker.reset_deasserted, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.phy_ready == 1 |-> $past(sva_checker.t"
  },
  {
    "id": "10_8_0471",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pql0ywp3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_fell |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_fell == 1 |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_fell |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pcxv4bq6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_fell == 1 |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_fell |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_fell == 1 |-> $past(sva_checker.sck_divider, 5) == sva_checker.current_divider || $past(sva_checker.config_valid, 1) == "
  },
  {
    "id": "12_30_0595",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_59ez9_8a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.force_reset |-> (##1 sva_checker.reset_issued)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.force_reset == 1 |-> (##1 sva_checker.reset_issued == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.force_reset |-> (##1 sva_checker.reset_issued)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j5ypm2xr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.force_reset == 1 |-> (##1 sva_checker.reset_issued == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.force_reset |-> (##1 sva_checker.reset_issued)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.force_reset == 1 |-> (##1 sva_checker.reset_issued == 1)): PROVED\n"
  },
  {
    "id": "13_13_0612",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ldzqe50y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.fault_detected |-> (##1 sva_checker.normal_op)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detected == 0 |-> (##1 sva_checker.normal_op == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.fault_detected |-> (##1 sva_checker.normal_op)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lgawokjv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fault_detected == 0 |-> (##1 sva_checker.normal_op == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.fault_detected |-> (##1 sva_checker.normal_op)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fault_detected == 0 |-> (##1 sva_checker.normal_op == 1)): PROVED\n"
  },
  {
    "id": "13_23_0638",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_er5f_75y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.collision_detected |-> (##[2:4] sva_checker.retry_attempt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.collision_detected == 0 |-> (##[2:4] sva_checker.retry_attempt == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.collision_detected |-> (##[2:4] sva_checker.retry_attempt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ovffy0br/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.collision_detected == 0 |-> (##[2:4] sva_checker.retry_attempt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.collision_detected |-> (##[2:4] sva_checker.retry_attempt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.collision_detected == 0 |-> (##[2:4] sva_checker.retry_attempt == 1)): PROVED\n"
  },
  {
    "id": "15_19_0728",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_wd7jj3no/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_over_threshold |-> (##[3:5] sva_checker.alarm_triggered ##1 !sva_checker.alarm_clear)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.temp_over_threshold == 1 |-> (##[3:5] sva_checker.alarm_triggered == 1 ##1 sva_checker.alarm_clear == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_over_threshold |-> (##[3:5] sva_checker.alarm_triggered ##1 !sva_checker.alarm_clear)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wfinpcpi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.temp_over_threshold == 1 |-> (##[3:5] sva_checker.alarm_triggered == 1 ##1 sva_checker.alarm_clear == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_over_threshold |-> (##[3:5] sva_checker.alarm_triggered ##1 !sva_checker.alarm_clear)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.test_mode == 0 && sva_checker.temp_over_threshold == 1 |-> (##[3:5] sva_checker.alarm_triggered == 1 ##1 sva_checker.alarm_clear == 0)): PROVED\n"
  },
  {
    "id": "15_20_0729",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xaroufi1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_refresh |-> (##[0:255] sva_checker.system_reset)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 0 && sva_checker.wdt_refresh == 0 |-> (##[0:255] sva_checker.system_reset == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.wdt_refresh |-> (##[0:255] sva_checker.system_reset)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zliim_bi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 0 && sva_checker.wdt_refresh == 0 |-> (##[0:255] sva_checker.system_reset == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.wdt_refresh |-> (##[0:255] sva_checker.system_reset)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.debug_halt == 0 && sva_checker.wdt_refresh == 0 |-> (##[0:255] sva_checker.system_reset == 1)): PROVED\n"
  },
  {
    "id": "15_29_0737",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_frlf68b3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trace_watermark == 1'b1 |-> (##[0:3] sva_checker.trigger_out ##1 !sva_checker.fifo_overflow)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trace_disabled == 0 && sva_checker.trace_watermark == 1 |-> (##[0:3] sva_checker.trigger_out == 1 ##1 sva_checker.fifo_overflow == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trace_watermark == 1'b1 |-> (##[0:3] sva_checker.trigger_out ##1 !sva_checker.fifo_overflow)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5y5wzxqy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.trace_disabled == 0 && sva_checker.trace_watermark == 1 |-> (##[0:3] sva_checker.trigger_out == 1 ##1 sva_checker.fifo_overflow == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.trace_watermark == 1'b1 |-> (##[0:3] sva_checker.trigger_out ##1 !sva_checker.fifo_overflow)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.trace_disabled == 0 && sva_checker.trace_watermark == 1 |-> (##[0:3] sva_checker.trigger_out == 1 ##1 sva_checker.fifo_overflow == 0)): PROVED\n"
  },
  {
    "id": "1_11_0038",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wswycj9m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled ##5 sva_checker.temperature_normal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled == 1'b1 ##5 sva_checker.temperature_normal == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled ##5 sva_checker.temperature_normal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3_na8gxb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled == 1'b1 ##5 sva_checker.temperature_normal == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled ##5 sva_checker.temperature_normal)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temperature_critical == 1'b1 |-> (##3 sva_checker.clock_throttled == 1'b1 ##5 sva_checker.temperature_normal == 1'b1)): PROVED\n"
  },
  {
    "id": "2_11_0026",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0y08m7x_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4d7o7fim/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[16:64] sva_checker.dma_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_19_0070",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4_bafec9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change |-> (##[16:64] sva_checker.voltage_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1 |-> (##[16:64] sva_checker.voltage_stable == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_change |-> (##[16:64] sva_checker.voltage_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rqqgk06_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1 |-> (##[16:64] sva_checker.voltage_stable == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.voltage_change |-> (##[16:64] sva_checker.voltage_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.voltage_change == 1 |-> (##[16:64] sva_checker.voltage_stable == 1)): PROVED\n"
  },
  {
    "id": "2_44_0089",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xph9psim/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fqv4g76s/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cfg_start == 1'b1 |-> (##[128:32'hs100] sva_checker.cfg_done == 1'b1)): PROVED\n"
  },
  {
    "id": "3_14_0136",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_t2vwemcp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert |-> (##1 sva_checker.voltage_adjust ##[3:6] sva_checker.vmon_normal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert == 1 |-> (##1 sva_checker.voltage_adjust == 1 ##[3:6] sva_checker.vmon_normal == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert |-> (##1 sva_checker.voltage_adjust ##[3:6] sva_checker.vmon_normal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jov9edr1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert == 1 |-> (##1 sva_checker.voltage_adjust == 1 ##[3:6] sva_checker.vmon_normal == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert |-> (##1 sva_checker.voltage_adjust ##[3:6] sva_checker.vmon_normal)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vmon_alert == 1 |-> (##1 sva_checker.voltage_adjust == 1 ##[3:6] sva_checker.vmon_normal == 1)): PROVED\n"
  },
  {
    "id": "7_40_0336",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jplplrqh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rn50mr90/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.plcp_header_detected) |-> (##1 sva_checker.data_unit_ready && $stable(sva_checker.rate_field))): PROVED\n"
  },
  {
    "id": "10_55_0532",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9atiadb_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_54twdne5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.pwr_ok, 5) |-> $past(sva_checker.core_ready, 4) && $past(sva_checker.pll_lock, 3)): PROVED\n"
  },
  {
    "id": "11_20_0528",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d6t3loyc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1 && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jibapxey/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1 && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1 && sva_checker.pwm_counter == sva_checker.period_reg |-> (##1 sva_checker.pwm_out == 1)): PROVED\n"
  },
  {
    "id": "11_17_0554",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_opal5o1a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start && !sva_checker.i2c_stop |-> (##[2:4] sva_checker.i2c_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start == 1 && sva_checker.i2c_stop == 0 |-> (##[2:4] sva_checker.i2c_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.i2c_start && !sva_checker.i2c_stop |-> (##[2:4] sva_checker.i2c_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0vlp5crz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start == 1 && sva_checker.i2c_stop == 0 |-> (##[2:4] sva_checker.i2c_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.i2c_start && !sva_checker.i2c_stop |-> (##[2:4] sva_checker.i2c_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.i2c_start == 1 && sva_checker.i2c_stop == 0 |-> (##[2:4] sva_checker.i2c_ack == 1)): PROVED\n"
  },
  {
    "id": "11_43_0558",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s86to005/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start && !sva_checker.rf_tx_busy |-> (##[16:32] sva_checker.rf_tx_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start == 1 && sva_checker.rf_tx_busy == 0 |-> (##[16:32] sva_checker.rf_tx_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start && !sva_checker.rf_tx_busy |-> (##[16:32] sva_checker.rf_tx_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yntyb50t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start == 1 && sva_checker.rf_tx_busy == 0 |-> (##[16:32] sva_checker.rf_tx_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start && !sva_checker.rf_tx_busy |-> (##[16:32] sva_checker.rf_tx_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rf_tx_start == 1 && sva_checker.rf_tx_busy == 0 |-> (##[16:32] sva_checker.rf_tx_done == 1)): PROVED\n"
  },
  {
    "id": "11_45_0562",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_b4h6ogcr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lock_start && !sva_checker.lock_busy |-> (##[128:32'hs100] sva_checker.lock_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lock_start == 1 && sva_checker.lock_busy == 0 |-> (##[128:32'hs100] sva_checker.lock_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lock_start && !sva_checker.lock_busy |-> (##[128:32'hs100] sva_checker.lock_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0e0j831t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lock_start == 1 && sva_checker.lock_busy == 0 |-> (##[128:32'hs100] sva_checker.lock_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lock_start && !sva_checker.lock_busy |-> (##[128:32'hs100] sva_checker.lock_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lock_start == 1 && sva_checker.lock_busy == 0 |-> (##[128:32'hs100] sva_checker.lock_done == 1)): PROVED\n"
  },
  {
    "id": "12_14_0580",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vuakphcl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse || sva_checker.sw_wd_trigger |-> (##0 sva_checker.system_reset)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse == 1 || sva_checker.sw_wd_trigger == 1 |-> sva_checker.system_reset == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse || sva_checker.sw_wd_trigger |-> (##0 sva_checker.system_reset)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rhrq1xxm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse == 1 || sva_checker.sw_wd_trigger == 1 |-> sva_checker.system_reset == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse || sva_checker.sw_wd_trigger |-> (##0 sva_checker.system_reset)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wdt_expire_pulse == 1 || sva_checker.sw_wd_trigger == 1 |-> sva_checker.system_reset == 1): PROVED\n"
  },
  {
    "id": "12_18_0579",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8zmzkzvc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag || sva_checker.force_alert_signal |-> (##2 sva_checker.interrupt_pending)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag == 1 || sva_checker.force_alert_signal == 1 |-> (##2 sva_checker.interrupt_pending == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag || sva_checker.force_alert_signal |-> (##2 sva_checker.interrupt_pending)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cu329_as/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag == 1 || sva_checker.force_alert_signal == 1 |-> (##2 sva_checker.interrupt_pending == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag || sva_checker.force_alert_signal |-> (##2 sva_checker.interrupt_pending)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pattern_match_flag == 1 || sva_checker.force_alert_signal == 1 |-> (##2 sva_checker.interrupt_pending == 1)): PROVED\n"
  },
  {
    "id": "12_30_0598",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p9wbute9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded || sva_checker.forced_alert_en |-> (##3 sva_checker.interrupt_assert)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded == 1 || sva_checker.forced_alert_en == 1 |-> (##3 sva_checker.interrupt_assert == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded || sva_checker.forced_alert_en |-> (##3 sva_checker.interrupt_assert)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2vveqt6o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded == 1 || sva_checker.forced_alert_en == 1 |-> (##3 sva_checker.interrupt_assert == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded || sva_checker.forced_alert_en |-> (##3 sva_checker.interrupt_assert)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.threshold_exceeded == 1 || sva_checker.forced_alert_en == 1 |-> (##3 sva_checker.interrupt_assert == 1)): PROVED\n"
  },
  {
    "id": "15_46_0767",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_b9u12arl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_on == 1'b1 |-> (##[5:10] sva_checker.pd_ready ##1 $stable(sva_checker.pd_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_rst == 0 && sva_checker.pd_on == 1 |-> (##[5:10] sva_checker.pd_ready == 1 ##1 $stable(sva_checker.pd_status))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pd_on == 1'b1 |-> (##[5:10] sva_checker.pd_ready ##1 $stable(sva_checker.pd_status))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y9ukiief/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pd_rst == 0 && sva_checker.pd_on == 1 |-> (##[5:10] sva_checker.pd_ready == 1 ##1 $stable(sva_checker.pd_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pd_on == 1'b1 |-> (##[5:10] sva_checker.pd_ready ##1 $stable(sva_checker.pd_status))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pd_rst == 0 && sva_checker.pd_on == 1 |-> (##[5:10] sva_checker.pd_ready == 1 ##1 $stable(sva_checker.pd_status))): PROVED\n"
  },
  {
    "id": "1_15_0058",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_34_6z548/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active && !sva_checker.over_temp)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active == 1'b1 && sva_checker.over_temp == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active && !sva_checker.over_temp)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_53wu4rns/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active == 1'b1 && sva_checker.over_temp == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active && !sva_checker.over_temp)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##5 sva_checker.clock_divider_active == 1'b1 && sva_checker.over_temp == 1'b0)): PROVED\n"
  },
  {
    "id": "1_5_0049",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3pplruzy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && !sva_checker.fifo_full |-> (##3 sva_checker.fifo_rd_en && !sva_checker.fifo_empty)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_full == 0 |-> (##3 sva_checker.fifo_rd_en == 1 && sva_checker.fifo_empty == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && !sva_checker.fifo_full |-> (##3 sva_checker.fifo_rd_en && !sva_checker.fifo_empty)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iay57isy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_full == 0 |-> (##3 sva_checker.fifo_rd_en == 1 && sva_checker.fifo_empty == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en && !sva_checker.fifo_full |-> (##3 sva_checker.fifo_rd_en && !sva_checker.fifo_empty)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_wr_en == 1 && sva_checker.fifo_full == 0 |-> (##3 sva_checker.fifo_rd_en == 1 && sva_checker.fifo_empty == 0)): PROVED\n"
  },
  {
    "id": "2_49_0103",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_iqkn3dby/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect ##1 $stable(sva_checker.proximity_distance))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect == 1'b1 ##1 $stable(sva_checker.proximity_distance))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect ##1 $stable(sva_checker.proximity_distance))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_q7q0fs19/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect == 1'b1 ##1 $stable(sva_checker.proximity_distance))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect ##1 $stable(sva_checker.proximity_distance))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##[1:3] sva_checker.proximity_detect == 1'b1 ##1 $stable(sva_checker.proximity_distance))): PROVED\n"
  },
  {
    "id": "5_15_0227",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_37t7ei1t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.init_start |-> ((sva_checker.init_cmd [*6]) ##1 sva_checker.init_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1 |-> ((sva_checker.init_cmd == 1 [*6]) ##1 sva_checker.init_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.init_start |-> ((sva_checker.init_cmd [*6]) ##1 sva_checker.init_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zftul10k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1 |-> ((sva_checker.init_cmd == 1 [*6]) ##1 sva_checker.init_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.init_start |-> ((sva_checker.init_cmd [*6]) ##1 sva_checker.init_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.init_start == 1 |-> ((sva_checker.init_cmd == 1 [*6]) ##1 sva_checker.init_done == 1)): PROVED\n"
  },
  {
    "id": "2_4_0043",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hbw1nhbm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req && !sva_checker.bus_lock |-> (##[8:16] sva_checker.cache_inv_done ##1 $stable(sva_checker.cache_tag_array))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 && sva_checker.bus_lock == 1'b0 |-> (##[8:16] sva_checker.cache_inv_done == 1'b1 ##1 $stable(sva_checker.cache_tag_array))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req && !sva_checker.bus_lock |-> (##[8:16] sva_checker.cache_inv_done ##1 $stable(sva_checker.cache_tag_array))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a0jlnzau/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 && sva_checker.bus_lock == 1'b0 |-> (##[8:16] sva_checker.cache_inv_done == 1'b1 ##1 $stable(sva_checker.cache_tag_array))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req && !sva_checker.bus_lock |-> (##[8:16] sva_checker.cache_inv_done ##1 $stable(sva_checker.cache_tag_array))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_inv_req == 1'b1 && sva_checker.bus_lock == 1'b0 |-> (##[8:16] sva_checker.cache_in"
  },
  {
    "id": "5_26_0234",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_j51ix55m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0d28tbmf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.high_pri [*2]) |-> (##1 (sva_checker.medium_pri [*2]))): PROVED\n"
  },
  {
    "id": "6_25_0269",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4uf9ht7c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tdaxxy3a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cmd_sent == 1'b1 |-> ((sva_checker.busy_response [*1:8]) ##1 (sva_checker.data_ready [*1:4]))): PROVED\n"
  },
  {
    "id": "6_44_0279",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dxlbsgv6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fade_start |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fade_start == 1 |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fade_start |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_88kwu67a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fade_start == 1 |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fade_start |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fade_start == 1 |-> ((sva_checker.brightness_up [*10:100]) ##1 (sva_checker.brightness_down [*10:100]))): PROVED\n"
  },
  {
    "id": "7_1_0307",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q405le8x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ctyepjqb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.data_valid) |-> (##[1:3] sva_checker.req_pending ##2 sva_checker.ack_received)): PROVED\n"
  },
  {
    "id": "7_40_0357",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3fg6nak5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9h2k85p4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.init_complete) |-> (##[3:6] sva_checker.clock_stable ##1 !sva_checker.reset_active)): PROVED\n"
  },
  {
    "id": "11_35_0522",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_5hoygi4y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pairing_req && !sva_checker.bonded |-> (##[5:10] $rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pairing_req == 1 && sva_checker.bonded == 0 |-> (##[5:10] ($rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pairing_req && !sva_checker.bonded |-> (##[5:10] $rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gwkdvj3r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pairing_req == 1 && sva_checker.bonded == 0 |-> (##[5:10] ($rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pairing_req && !sva_checker.bonded |-> (##[5:10] $rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pairing_req == 1 && sva_checker.bonded == 0 |-> (##[5:10] ($rose(sva_checker.link_key) ##2 $stable(sva_checker.device_addr)))): PROVED\n"
  },
  {
    "id": "12_15_0558",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_q5a4rhu_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start || sva_checker.force_frame |-> (##[4:8] sva_checker.vertical_sync)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 || sva_checker.force_frame == 1 |-> (##[4:8] sva_checker.vertical_sync == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start || sva_checker.force_frame |-> (##[4:8] sva_checker.vertical_sync)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__1n_eovv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 || sva_checker.force_frame == 1 |-> (##[4:8] sva_checker.vertical_sync == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start || sva_checker.force_frame |-> (##[4:8] sva_checker.vertical_sync)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 || sva_checker.force_frame == 1 |-> (##[4:8] sva_checker.vertical_sync == 1)): PROVED\n"
  },
  {
    "id": "12_38_0587",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__q3sxgfa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow || sva_checker.force_overflow |-> (##2 sva_checker.overflow_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1 || sva_checker.force_overflow == 1 |-> (##2 sva_checker.overflow_interrupt == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow || sva_checker.force_overflow |-> (##2 sva_checker.overflow_interrupt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ajun3ko1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1 || sva_checker.force_overflow == 1 |-> (##2 sva_checker.overflow_interrupt == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow || sva_checker.force_overflow |-> (##2 sva_checker.overflow_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 1 || sva_checker.force_overflow == 1 |-> (##2 sva_checker.overflow_interrupt == 1)): PROVED\n"
  },
  {
    "id": "12_40_0594",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lhcmylid/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.operation_complete || sva_checker.skip_operation |-> (##1 sva_checker.next_operation)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.operation_complete == 1 || sva_checker.skip_operation == 1 |-> (##1 sva_checker.next_operation == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operation_complete || sva_checker.skip_operation |-> (##1 sva_checker.next_operation)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_005ujiby/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.operation_complete == 1 || sva_checker.skip_operation == 1 |-> (##1 sva_checker.next_operation == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.operation_complete || sva_checker.skip_operation |-> (##1 sva_checker.next_operation)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.operation_complete == 1 || sva_checker.skip_operation == 1 |-> (##1 sva_checker.next_operation == 1)): PROVED\n"
  },
  {
    "id": "13_31_0641",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_se6l8n99/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b_upu99t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(!sva_checker.retention_mode) |-> (##3 sva_checker.normal_operation)): PROVED\n"
  },
  {
    "id": "13_36_0647",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1u12mrzl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.clock_stop_request |-> (##3 sva_checker.clock_running)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stop_request == 0 |-> (##3 sva_checker.clock_running == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.clock_stop_request |-> (##3 sva_checker.clock_running)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8jkb22cm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_stop_request == 0 |-> (##3 sva_checker.clock_running == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.clock_stop_request |-> (##3 sva_checker.clock_running)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_stop_request == 0 |-> (##3 sva_checker.clock_running == 1)): PROVED\n"
  },
  {
    "id": "2_19_0011",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_noik9iqt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start |-> (##[8:16] sva_checker.encrypt_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1 |-> (##[8:16] sva_checker.encrypt_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start |-> (##[8:16] sva_checker.encrypt_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yzcquxec/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1 |-> (##[8:16] sva_checker.encrypt_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start |-> (##[8:16] sva_checker.encrypt_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1 |-> (##[8:16] sva_checker.encrypt_done == 1)): PROVED\n"
  },
  {
    "id": "1_38_0003",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_5hnot74t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy ##50 sva_checker.sd_init_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy == 1'b1 ##50 sva_checker.sd_init_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy ##50 sva_checker.sd_init_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uq7qh2ax/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy == 1'b1 ##50 sva_checker.sd_init_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy ##50 sva_checker.sd_init_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sd_init_start == 1'b1 |-> (##5 sva_checker.sd_cmd_busy == 1'b1 ##50 sva_checker.sd_init_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_20_0004",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8w4pgk6x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start |-> (##[8:16] sva_checker.decrypt_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start == 1 |-> (##[8:16] sva_checker.decrypt_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start |-> (##[8:16] sva_checker.decrypt_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_g0u16kae/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start == 1 |-> (##[8:16] sva_checker.decrypt_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start |-> (##[8:16] sva_checker.decrypt_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.decrypt_start == 1 |-> (##[8:16] sva_checker.decrypt_done == 1)): PROVED\n"
  },
  {
    "id": "2_30_0080",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1ietvg3k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hzm__29h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_tx_start == 1'b1 |-> (##[8:16] sva_checker.eth_tx_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_5_0051",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lztboo71/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xi55b99t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_miss == 1'b1 |-> (##[4:12] sva_checker.mem_resp == 1'b1)): PROVED\n"
  },
  {
    "id": "3_20_0115",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k4xtwx5x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected |-> (##[5:8] sva_checker.recovery_sequence_started ##1 sva_checker.bus_ok_status)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1 |-> (##[5:8] sva_checker.recovery_sequence_started == 1 ##1 sva_checker.bus_ok_status == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected |-> (##[5:8] sva_checker.recovery_sequence_started ##1 sva_checker.bus_ok_status)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_908t9gpu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1 |-> (##[5:8] sva_checker.recovery_sequence_started == 1 ##1 sva_checker.bus_ok_status == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected |-> (##[5:8] sva_checker.recovery_sequence_started ##1 sva_checker.bus_ok_status)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1 |-> (##[5:8] sva_checker.recovery_sequence_started == 1 ##1 sva_checker.bus_ok_status == 1)): PROVED\n"
  },
  {
    "id": "3_21_0137",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fbhdgp5w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0s0ub9qv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conversion_started |-> (##[8:12] sva_checker.data_ready_flag ##1 sva_checker.result_valid)): PROVED\n"
  },
  {
    "id": "3_8_0092",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9mlrhqnu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled ##1 sva_checker.header_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled == 1'b1 ##1 sva_checker.header_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled ##1 sva_checker.header_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_327ye7eb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled == 1'b1 ##1 sva_checker.header_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled ##1 sva_checker.header_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.packet_start_indicator == 1'b1 |-> (##[2:5] sva_checker.crc_check_enabled == 1'b1 ##1 sva_checker.header_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "6_27_0284",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4fo9r6lt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed == 1 |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sec04bin/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed == 1 |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gpio_in_changed == 1 |-> ((sva_checker.gpio_in_stable [*10:50]) ##1 sva_checker.gpio_out_updated == 1)): PROVED\n"
  },
  {
    "id": "10_17_0482",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8vkva5vn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_up == 1 && $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3) == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_di9qz4ve/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_up == 1 && $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3) == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_up == 1 && $past(sva_checker.sync_header, 5) == 165 |-> (##2 $past(sva_checker.payload_start, 3) == 1)): PROVED\n"
  },
  {
    "id": "10_30_0477",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ur_jzryi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.filter_enable, 5) && $past(sva_checker.packet_type, 5) == 255 |-> (##1 $rose(sva_checker.drop_packet))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.filter_bypass == 0 && $past(sva_checker.filter_enable, 5) == 1 && $past(sva_checker.packet_type, 5) == 255 |-> (##1 $rose(sva_checker.drop_packet))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.filter_enable, 5) && $past(sva_checker.packet_type, 5) == 255 |-> (##1 $rose(sva_checker.drop_packet))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_a4gv4w2x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.filter_bypass == 0 && $past(sva_checker.filter_enable, 5) == 1 && $past(sva_checker.packet_type, 5) == 255 |-> (##1 $rose(sva_checker.drop_packet))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.filter_enable, 5) && $past(sva_checker.packet_type, 5) == 255 |-> (##1 $rose(sva_checker.drop_packet))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.filter_bypass == 0 && $past(sva_checker.filter_enable, 5) == 1 && $past(sva_checker.packet_type"
  },
  {
    "id": "12_42_0592",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $isunknown. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check_gdzvpt_c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: verilog_typecheck_expr.h:134 function: var_value\nCondition: false\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x8bca4a]\n[0x8dd6cd]\n[0x8dd96b]\n[0x8dcddf]\n[0x8af2fd]\n[0x8af9fb]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8af922]\n[0x8afe96]\n[0x8b4ad1]\n[0x8bbaae]\n[0x985d92]\n[0x8a65fd]\n[0x88a422]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "12_46_0607",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_el2xz8kc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_busy || sva_checker.flash_error |-> (##1 $rose(sva_checker.flash_reset))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_busy == 1 || sva_checker.flash_error == 1 |-> (##1 $rose(sva_checker.flash_reset))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_busy || sva_checker.flash_error |-> (##1 $rose(sva_checker.flash_reset))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vnbjfvvr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.flash_busy == 1 || sva_checker.flash_error == 1 |-> (##1 $rose(sva_checker.flash_reset))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.flash_busy || sva_checker.flash_error |-> (##1 $rose(sva_checker.flash_reset))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.flash_busy == 1 || sva_checker.flash_error == 1 |-> (##1 $rose(sva_checker.flash_reset))): PROVED\n"
  },
  {
    "id": "15_18_0731",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_bckrsy8g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.resume_detected |-> (##[2:5] sva_checker.host_wakeup)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_phy_reset_n == 1 && sva_checker.resume_detected == 1 |-> (##[2:5] sva_checker.host_wakeup == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.resume_detected |-> (##[2:5] sva_checker.host_wakeup)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fetpe4lw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_phy_reset_n == 1 && sva_checker.resume_detected == 1 |-> (##[2:5] sva_checker.host_wakeup == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.resume_detected |-> (##[2:5] sva_checker.host_wakeup)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_phy_reset_n == 1 && sva_checker.resume_detected == 1 |-> (##[2:5] sva_checker.host_wakeup == 1)): PROVED\n"
  },
  {
    "id": "1_33_0014",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bmod4mb8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8p7osd8b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.usb_pkt_start == 1'b1 |-> (##6 sva_checker.usb_pkt_end == 1'b1)): PROVED\n"
  },
  {
    "id": "1_41_0072",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ie9qb7oi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iqcvu_b7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_en == 1'b1 |-> (##6 sva_checker.timer_int == 1'b1)): PROVED\n"
  },
  {
    "id": "2_11_0053",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_m9t8z4s6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dtlnfx4c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ddr_init_start == 1'b1 |-> (##[16:128] sva_checker.ddr_init_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_12_0019",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dfpexcmh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_w7_nyio4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.link_training_start == 1'b1 |-> (##[8:32] sva_checker.link_training_complete == 1'b1)): PROVED\n"
  },
  {
    "id": "2_45_0093",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8qnv7fhf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start |-> (##[128:32'hs100] sva_checker.lock_achieved)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start == 1 |-> (##[128:32'hs100] sva_checker.lock_achieved == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start |-> (##[128:32'hs100] sva_checker.lock_achieved)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7hkan2im/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start == 1 |-> (##[128:32'hs100] sva_checker.lock_achieved == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start |-> (##[128:32'hs100] sva_checker.lock_achieved)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.acquisition_start == 1 |-> (##[128:32'hs100] sva_checker.lock_achieved == 1)): PROVED\n"
  },
  {
    "id": "3_33_0152",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vuhr_ka8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start && !sva_checker.reset_b |-> (##5 sva_checker.state_capture)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start == 1 && sva_checker.reset_b == 0 |-> (##5 sva_checker.state_capture == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start && !sva_checker.reset_b |-> (##5 sva_checker.state_capture)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_2qdv8ehj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start == 1 && sva_checker.reset_b == 0 |-> (##5 sva_checker.state_capture == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start && !sva_checker.reset_b |-> (##5 sva_checker.state_capture)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tms_sequence_start == 1 && sva_checker.reset_b == 0 |-> (##5 sva_checker.state_capture == 1)): PROVED\n"
  },
  {
    "id": "3_48_0144",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8uyn3u_0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected && !sva_checker.repeat_mode |-> (##[8:16] sva_checker.command_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected == 1 && sva_checker.repeat_mode == 0 |-> (##[8:16] sva_checker.command_complete == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected && !sva_checker.repeat_mode |-> (##[8:16] sva_checker.command_complete)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ax8rsw2d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected == 1 && sva_checker.repeat_mode == 0 |-> (##[8:16] sva_checker.command_complete == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected && !sva_checker.repeat_mode |-> (##[8:16] sva_checker.command_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.start_bit_detected == 1 && sva_checker.repeat_mode == 0 |-> (##[8:16] sva_checker.command_complete == 1)): PROVED\n"
  },
  {
    "id": "5_27_0231",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3osc5jt0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gj9rjpvw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.temp_rise [*4]) ##1 !sva_checker.fan_stuck) |-> (sva_checker.pwm_increase [*3])): PROVED\n"
  },
  {
    "id": "5_28_0227",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mchwdbtn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_blnhhhkv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.data_in_valid [*3]) ##1 !sva_checker.key_ready) |-> (sva_checker.cipher_text_valid [*2])): PROVED\n"
  },
  {
    "id": "5_32_0220",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zhz3_b89/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pkjlxhef/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.stall_condition [*4]) ##1 !sva_checker.flush) |-> (sva_checker.bubble_insert [*3])): PROVED\n"
  },
  {
    "id": "5_35_0232",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7_yot4z0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7wdjx_zo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.refresh_req [*5]) |-> (sva_checker.refresh_ack [*2])): PROVED\n"
  },
  {
    "id": "5_38_0238",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a9mjm8s0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zhewphob/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) ((sva_checker.power_up [*3]) ##1 !sva_checker.fault_detected) |-> (sva_checker.all_rails_good [*2])): PROVED\n"
  },
  {
    "id": "8_10_0362",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zj49ypr5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0evok0td/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.can_tx_enable) |-> (##[2:4] sva_checker.can_tx_ack && sva_checker.can_tx_id == $past(sva_checker.can_tx_id, 3))): PROVED\n"
  },
  {
    "id": "8_50_0418",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2282ijep/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_h4leped4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.tof_int) |-> (##3 sva_checker.tof_distance > $past(sva_checker.tof_threshold, 2) && sva_checker.tof_valid)): PROVED\n"
  },
  {
    "id": "10_39_0499",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3prz1sjx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6g9tb_07/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.frame_sent, 2) |-> $past(sva_checker.ack_received, 5) || $past(sva_checker.error_flag, 3)): PROVED\n"
  },
  {
    "id": "11_19_0555",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_x3tukpfs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_low && !sva_checker.vcc_bypass |-> (##1 sva_checker.power_warning)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_low == 1 && sva_checker.vcc_bypass == 0 |-> (##1 sva_checker.power_warning == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vcc_low && !sva_checker.vcc_bypass |-> (##1 sva_checker.power_warning)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cimise9q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_low == 1 && sva_checker.vcc_bypass == 0 |-> (##1 sva_checker.power_warning == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_low && !sva_checker.vcc_bypass |-> (##1 sva_checker.power_warning)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vcc_low == 1 && sva_checker.vcc_bypass == 0 |-> (##1 sva_checker.power_warning == 1)): PROVED\n"
  },
  {
    "id": "11_30_0546",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a_34nilu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid && !sva_checker.crc_error |-> (##1 sva_checker.crc_ok)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1 && sva_checker.crc_error == 0 |-> (##1 sva_checker.crc_ok == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_valid && !sva_checker.crc_error |-> (##1 sva_checker.crc_ok)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sf7ucbth/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1 && sva_checker.crc_error == 0 |-> (##1 sva_checker.crc_ok == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid && !sva_checker.crc_error |-> (##1 sva_checker.crc_ok)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1 && sva_checker.crc_error == 0 |-> (##1 sva_checker.crc_ok == 1)): PROVED\n"
  },
  {
    "id": "11_31_0540",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_1spuhdk9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_active && sva_checker.sck_rising |-> (##8 $stable(sva_checker.mosi_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_active == 1 && sva_checker.sck_rising == 1 |-> (##8 sva_checker.mosi_data == $past(sva_checker.mosi_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_active && sva_checker.sck_rising |-> (##8 $stable(sva_checker.mosi_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_84a42eqn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_active == 1 && sva_checker.sck_rising == 1 |-> (##8 sva_checker.mosi_data == $past(sva_checker.mosi_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_active && sva_checker.sck_rising |-> (##8 $stable(sva_checker.mosi_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_active == 1 && sva_checker.sck_rising == 1 |-> (##8 sva_checker.mosi_data == $past(sva_checker.mosi_data))): PROVED\n"
  },
  {
    "id": "11_34_0536",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jnlxh4lj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.duty_changed && !sva_checker.pwm_disabled |-> (##1 $changed(sva_checker.pwm_out))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.duty_changed == 1 && sva_checker.pwm_disabled == 0 |-> (##1 sva_checker.pwm_out != $past(sva_checker.pwm_out))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.duty_changed && !sva_checker.pwm_disabled |-> (##1 $changed(sva_checker.pwm_out))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vbd1_lkr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.duty_changed == 1 && sva_checker.pwm_disabled == 0 |-> (##1 sva_checker.pwm_out != $past(sva_checker.pwm_out))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.duty_changed && !sva_checker.pwm_disabled |-> (##1 $changed(sva_checker.pwm_out))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.duty_changed == 1 && sva_checker.pwm_disabled == 0 |-> (##1 sva_checker.pwm_out != $past(sva_checker.pwm_out))): PROVED\n"
  },
  {
    "id": "11_42_0542",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_m_6aj6jv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hash_start && !sva_checker.hash_busy |-> (##[16:32] sva_checker.hash_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hash_start == 1 && sva_checker.hash_busy == 0 |-> (##[16:32] sva_checker.hash_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hash_start && !sva_checker.hash_busy |-> (##[16:32] sva_checker.hash_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_d7aa86xr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hash_start == 1 && sva_checker.hash_busy == 0 |-> (##[16:32] sva_checker.hash_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hash_start && !sva_checker.hash_busy |-> (##[16:32] sva_checker.hash_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hash_start == 1 && sva_checker.hash_busy == 0 |-> (##[16:32] sva_checker.hash_done == 1)): PROVED\n"
  },
  {
    "id": "11_6_0525",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bj43tv3n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_n && sva_checker.we_n && sva_checker.oe_n |-> (##[1:3] $stable(sva_checker.mem_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_n == 1 && sva_checker.we_n == 1 && sva_checker.oe_n == 1 |-> (##[1:3] sva_checker.mem_data == $past(sva_checker.mem_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_n && sva_checker.we_n && sva_checker.oe_n |-> (##[1:3] $stable(sva_checker.mem_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_wweoqrzu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_n == 1 && sva_checker.we_n == 1 && sva_checker.oe_n == 1 |-> (##[1:3] sva_checker.mem_data == $past(sva_checker.mem_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_n && sva_checker.we_n && sva_checker.oe_n |-> (##[1:3] $stable(sva_checker.mem_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_n == 1 && sva_checker.we_n == 1 && sva_checker.oe_n == 1 |-> (##[1:3] sva_checker.mem_data == $past(sva_checker.mem_data))): PROVED\n"
  },
  {
    "id": "12_28_0599",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ed4vle0l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun || sva_checker.buffer_overrun |-> (##1 sva_checker.flow_control_activate)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun == 1 || sva_checker.buffer_overrun == 1 |-> (##1 sva_checker.flow_control_activate == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun || sva_checker.buffer_overrun |-> (##1 sva_checker.flow_control_activate)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5o_5sx1p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun == 1 || sva_checker.buffer_overrun == 1 |-> (##1 sva_checker.flow_control_activate == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun || sva_checker.buffer_overrun |-> (##1 sva_checker.flow_control_activate)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.buffer_underrun == 1 || sva_checker.buffer_overrun == 1 |-> (##1 sva_checker.flow_control_activate == 1)): PROVED\n"
  },
  {
    "id": "13_15_0629",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ssvte_o8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.crc_err |-> (##3 sva_checker.crc_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crc_err == 0 |-> (##3 sva_checker.crc_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.crc_err |-> (##3 sva_checker.crc_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__xvjgzwi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crc_err == 0 |-> (##3 sva_checker.crc_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.crc_err |-> (##3 sva_checker.crc_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crc_err == 0 |-> (##3 sva_checker.crc_valid == 1)): PROVED\n"
  },
  {
    "id": "12_45_0623",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__ln481fi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached || sva_checker.manual_flush_request |-> (##[0:2] sva_checker.flush_buffer)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached == 1 || sva_checker.manual_flush_request == 1 |-> (##[0:2] sva_checker.flush_buffer == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached || sva_checker.manual_flush_request |-> (##[0:2] sva_checker.flush_buffer)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_csuygfb9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached == 1 || sva_checker.manual_flush_request == 1 |-> (##[0:2] sva_checker.flush_buffer == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached || sva_checker.manual_flush_request |-> (##[0:2] sva_checker.flush_buffer)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.buffer_threshold_reached == 1 || sva_checker.manual_flush_request == 1 |-> (##[0:2] sva_checker.flush_buffer == 1)): PROVED\n"
  },
  {
    "id": "13_16_0642",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jpcbguxw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.overflow_flag |-> (##1 $stable(sva_checker.alu_result))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.overflow_flag == 0 |-> (##1 sva_checker.alu_result == $past(sva_checker.alu_result))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.overflow_flag |-> (##1 $stable(sva_checker.alu_result))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3cb_dulo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.overflow_flag == 0 |-> (##1 sva_checker.alu_result == $past(sva_checker.alu_result))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.overflow_flag |-> (##1 $stable(sva_checker.alu_result))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.overflow_flag == 0 |-> (##1 sva_checker.alu_result == $past(sva_checker.alu_result))): PROVED\n"
  },
  {
    "id": "13_32_0646",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_374s2a8z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.autoneg_complete |-> (##[2:4] sva_checker.autoneg_restart)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.autoneg_complete == 0 |-> (##[2:4] sva_checker.autoneg_restart == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.autoneg_complete |-> (##[2:4] sva_checker.autoneg_restart)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5xov31dd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.autoneg_complete == 0 |-> (##[2:4] sva_checker.autoneg_restart == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.autoneg_complete |-> (##[2:4] sva_checker.autoneg_restart)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.autoneg_complete == 0 |-> (##[2:4] sva_checker.autoneg_restart == 1)): PROVED\n"
  },
  {
    "id": "13_8_0628",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k9oexhcz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.cache_hit |-> (##[1:3] sva_checker.cache_miss)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 0 |-> (##[1:3] sva_checker.cache_miss == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.cache_hit |-> (##[1:3] sva_checker.cache_miss)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sch49x_n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 0 |-> (##[1:3] sva_checker.cache_miss == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.cache_hit |-> (##[1:3] sva_checker.cache_miss)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 0 |-> (##[1:3] sva_checker.cache_miss == 1)): PROVED\n"
  },
  {
    "id": "15_12_0704",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zfb4_vge/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_start == 1'b1 |-> (##[10:20] sva_checker.timer_expire)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_reset == 0 && sva_checker.timer_start == 1 |-> (##[10:20] sva_checker.timer_expire == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_start == 1'b1 |-> (##[10:20] sva_checker.timer_expire)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b8y35gat/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_reset == 0 && sva_checker.timer_start == 1 |-> (##[10:20] sva_checker.timer_expire == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_start == 1'b1 |-> (##[10:20] sva_checker.timer_expire)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_reset == 0 && sva_checker.timer_start == 1 |-> (##[10:20] sva_checker.timer_expire == 1)): PROVED\n"
  },
  {
    "id": "15_44_0762",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_jgrwryvg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bw_monitor |-> (##[5:10] sva_checker.bw_limit)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bw_reset == 0 && sva_checker.bw_monitor == 1 |-> (##[5:10] sva_checker.bw_limit == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bw_monitor |-> (##[5:10] sva_checker.bw_limit)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5cag0u25/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bw_reset == 0 && sva_checker.bw_monitor == 1 |-> (##[5:10] sva_checker.bw_limit == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bw_monitor |-> (##[5:10] sva_checker.bw_limit)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bw_reset == 0 && sva_checker.bw_monitor == 1 |-> (##[5:10] sva_checker.bw_limit == 1)): PROVED\n"
  },
  {
    "id": "15_49_0756",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ir91j8wr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.shake_reset == 0 && sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_nd5cyijw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.shake_reset == 0 && sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.shake_reset == 0 && sva_checker.shake_req == 1'b1 |-> (##[1:4] sva_checker.shake_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "1_23_0026",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wukb8pq1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m5z1b7ur/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_reset_release |-> (##[5:8] sva_checker.pll_locked ##1 !sva_checker.pll_unstable)): PROVED\n"
  },
  {
    "id": "15_8_0702",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_0lpvzuce/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack ##1 sva_checker.pwr_down_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_reset == 0 && sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack == 1'b1 ##1 sva_checker.pwr_down_ack == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack ##1 sva_checker.pwr_down_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zwkqc1s3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_reset == 0 && sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack == 1'b1 ##1 sva_checker.pwr_down_ack == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack ##1 sva_checker.pwr_down_ack)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwr_reset == 0 && sva_checker.pwr_down_req == 1'b1 |-> (##[2:5] sva_checker.pwr_ack == 1'b1 ##1 sva_checker.pwr_down_ack == 1'b1)): PROVED\n"
  },
  {
    "id": "1_39_0055",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_acoiolgx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7dmhojuc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.gpio_int) |-> (##[1:3] sva_checker.int_ack ##1 !sva_checker.gpio_int_pending)): PROVED\n"
  },
  {
    "id": "1_45_0042",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_7s8kb7_w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] sva_checker.tlb_hit ##1 !sva_checker.page_fault)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] (sva_checker.tlb_hit ##1 !sva_checker.page_fault))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] sva_checker.tlb_hit ##1 !sva_checker.page_fault)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sye8pudq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] (sva_checker.tlb_hit ##1 !sva_checker.page_fault))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] sva_checker.tlb_hit ##1 !sva_checker.page_fault)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.tlb_miss) |-> (##[3:6] (sva_checker.tlb_hit ##1 !sva_checker.page_fault))): PROVED\n"
  },
  {
    "id": "2_14_0004",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_yjd69u3j/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_aj7b29j2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_start == 1'b1 |-> (##[16:64] sva_checker.encrypt_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_15_0074",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_heegh666/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_x_qk207_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##[2:8] sva_checker.cooling_fan_on == 1'b1)): PROVED\n"
  },
  {
    "id": "2_30_0083",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_loyn8cyo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] $stable(sva_checker.hdmi_tmds))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] sva_checker.hdmi_tmds == $past(sva_checker.hdmi_tmds))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] $stable(sva_checker.hdmi_tmds))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yjaglqnv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] sva_checker.hdmi_tmds == $past(sva_checker.hdmi_tmds))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] $stable(sva_checker.hdmi_tmds))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.hdmi_pll_lock == 1'b1 |-> (##[16:64] sva_checker.hdmi_tmds == $past(sva_checker.hdmi_tmds))): PROVED\n"
  },
  {
    "id": "2_32_0095",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qa3cao0x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s80xgjpn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_dma_req == 1'b1 |-> (##[2:8] sva_checker.audio_data_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "2_34_0084",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_fhmymwio/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_twim22cl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.timer_load == 1'b1 |-> (##[16:64] sva_checker.timer_expire == 1'b1)): PROVED\n"
  },
  {
    "id": "2_45_0138",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gs0f_yne/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_05w2j_e1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_critical == 1'b1 |-> (##[1:4] sva_checker.power_off == 1'b1)): PROVED\n"
  },
  {
    "id": "2_5_0018",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wpnof52f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_s9xdh265/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_down_req == 1'b1 |-> (##[8:32] sva_checker.power_good == 1'b0)): PROVED\n"
  },
  {
    "id": "3_44_0150",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u6ic0871/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ifs1g9wi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_up_trigger |-> (##[5:8] sva_checker.vcore_stable ##1 sva_checker.pll_enable)): PROVED\n"
  },
  {
    "id": "11_28_0513",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pt2yj8uc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_active && sva_checker.tx_attempt |-> (##[1:3] sva_checker.collision_detected && !sva_checker.ack_received)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_active == 1 && sva_checker.tx_attempt == 1 |-> (##[1:3] sva_checker.collision_detected == 1 && sva_checker.ack_received == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_active && sva_checker.tx_attempt |-> (##[1:3] sva_checker.collision_detected && !sva_checker.ack_received)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_14_pkaij/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.rx_active == 1 && sva_checker.tx_attempt == 1 |-> (##[1:3] sva_checker.collision_detected == 1 && sva_checker.ack_received == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.rx_active && sva_checker.tx_attempt |-> (##[1:3] sva_checker.collision_detected && !sva_checker.ack_received)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.rx_active == 1 && sva_checker.tx_attempt == 1 |-> (##[1:3] sva_checker.collision_detected == 1 && sva_checker.ack_received == 0)): PROVED\n"
  },
  {
    "id": "12_21_0561",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zmqfx5dg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault || sva_checker.data_fault |-> (##[1:4] sva_checker.exception_handler)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault == 1 || sva_checker.data_fault == 1 |-> (##[1:4] sva_checker.exception_handler == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault || sva_checker.data_fault |-> (##[1:4] sva_checker.exception_handler)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_x8541jy_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault == 1 || sva_checker.data_fault == 1 |-> (##[1:4] sva_checker.exception_handler == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault || sva_checker.data_fault |-> (##[1:4] sva_checker.exception_handler)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.instruction_fault == 1 || sva_checker.data_fault == 1 |-> (##[1:4] sva_checker.exception_handler == 1)): PROVED\n"
  },
  {
    "id": "11_7_0505",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_aq6u5x3l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_en && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_en == 1 && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_en && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_zo3gp0o5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.burst_en == 1 && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.burst_en && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.burst_en == 1 && sva_checker.cmd[1:0] == 2'b01 |-> (##8 ($fell(sva_checker.burst_en) && sva_checker.data_strobe [->1]))): PROVED\n"
  },
  {
    "id": "1_12_0055",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w4h27nwz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted |-> (##[2:5] sva_checker.irq_acknowledged ##1 sva_checker.irq_serviced)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted == 1 |-> (##[2:5] sva_checker.irq_acknowledged == 1 ##1 sva_checker.irq_serviced == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted |-> (##[2:5] sva_checker.irq_acknowledged ##1 sva_checker.irq_serviced)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hf1gkk83/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted == 1 |-> (##[2:5] sva_checker.irq_acknowledged == 1 ##1 sva_checker.irq_serviced == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted |-> (##[2:5] sva_checker.irq_acknowledged ##1 sva_checker.irq_serviced)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.irq_asserted == 1 |-> (##[2:5] sva_checker.irq_acknowledged == 1 ##1 sva_checker.irq_serviced == 1)): PROVED\n"
  },
  {
    "id": "1_28_0004",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_d95gut2d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9jpvhv0w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scale_request |-> (##3 sva_checker.voltage_stable ##1 sva_checker.freq_update)): PROVED\n"
  },
  {
    "id": "1_36_0077",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6jv_1o36/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cdp9vs1e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.new_data |-> (##[1:3] sva_checker.data_processed ##1 sva_checker.output_updated)): PROVED\n"
  },
  {
    "id": "1_40_0023",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_m08ws55i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked ##1 sva_checker.data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked == 1'b1 ##1 sva_checker.data_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked ##1 sva_checker.data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qh2ye8vo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked == 1'b1 ##1 sva_checker.data_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked ##1 sva_checker.data_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lane_sync == 1'b1 |-> (##[2:5] sva_checker.all_lanes_locked == 1'b1 ##1 sva_checker.data_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "1_41_0002",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wtzlmod6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6wi0jeyx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.power_good |-> (##10 sva_checker.reset_deassert ##1 sva_checker.clock_stable)): PROVED\n"
  },
  {
    "id": "2_20_0032",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_co7innjo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change |-> (##[7:56] ($stable(sva_checker.pwm_period) [*3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change == 1 |-> (##[7:56] (sva_checker.pwm_period == $past(sva_checker.pwm_period) [*3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change |-> (##[7:56] ($stable(sva_checker.pwm_period) [*3]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check__y7dvjr0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change == 1 |-> (##[7:56] (sva_checker.pwm_period == $past(sva_checker.pwm_period) [*3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change |-> (##[7:56] ($stable(sva_checker.pwm_period) [*3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable_change == 1 |-> (##[7:56] (sva_checker.pwm_period == $past(sva_checker.pwm_period) [*3]))): PROVED\n"
  },
  {
    "id": "2_45_0146",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jh_o4lzp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tvalid && sva_checker.tready |-> (##[1:8] sva_checker.tlast || !sva_checker.tvalid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tvalid == 1 && sva_checker.tready == 1 |-> (##[1:8] sva_checker.tlast == 1 || sva_checker.tvalid == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tvalid && sva_checker.tready |-> (##[1:8] sva_checker.tlast || !sva_checker.tvalid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tfox3d43/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.tvalid == 1 && sva_checker.tready == 1 |-> (##[1:8] sva_checker.tlast == 1 || sva_checker.tvalid == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.tvalid && sva_checker.tready |-> (##[1:8] sva_checker.tlast || !sva_checker.tvalid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.tvalid == 1 && sva_checker.tready == 1 |-> (##[1:8] sva_checker.tlast == 1 || sva_checker.tvalid == 0)): PROVED\n"
  },
  {
    "id": "7_34_0338",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_m1ulw16b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9o3l0n48/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.motor_start) |-> (##[5:8] sva_checker.motor_phase_valid ##1 sva_checker.motor_running)): PROVED\n"
  },
  {
    "id": "3_43_0120",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6pxb7u6w/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_start && !sva_checker.read_active |-> (##[50:200] sva_checker.calibration_done && sva_checker.eye_optimal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_start == 1 && sva_checker.read_active == 0 |-> (##[50:200] sva_checker.calibration_done == 1 && sva_checker.eye_optimal == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calibration_start && !sva_checker.read_active |-> (##[50:200] sva_checker.calibration_done && sva_checker.eye_optimal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_1n4iblso/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_start == 1 && sva_checker.read_active == 0 |-> (##[50:200] sva_checker.calibration_done == 1 && sva_checker.eye_optimal == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.calibration_start && !sva_checker.read_active |-> (##[50:200] sva_checker.calibration_done && sva_checker.eye_optimal)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.calibration_start == 1 && sva_checker.read_active == 0 |-> (##[50:200] sva_checker.ca"
  },
  {
    "id": "7_8_0299",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9t6spnwn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_peros_rm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.uart_rx_break) |-> (##[1:2] sva_checker.uart_frame_error ##1 sva_checker.uart_break_interrupt)): PROVED\n"
  },
  {
    "id": "8_19_0351",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_op82go7t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] $fell(sva_checker.rx_active) ##1 sva_checker.break_condition)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] ($fell(sva_checker.rx_active) ##1 sva_checker.break_condition))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] $fell(sva_checker.rx_active) ##1 sva_checker.break_condition)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_crjlw5h2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] ($fell(sva_checker.rx_active) ##1 sva_checker.break_condition))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] $fell(sva_checker.rx_active) ##1 sva_checker.break_condition)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.rx_line) |-> (##[12:15] ($fell(sva_checker.rx_active) ##1 sva_checker.break_condition))): PROVED\n"
  },
  {
    "id": "8_32_0368",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_nqss29vh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] $fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] ($fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable == 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] $fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ydxt4x98/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] ($fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable == 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] $fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.pll_bypass) |-> (##[3:6] ($fell(sva_checker.pll_lock) ##1 sva_checker.clock_unstable == 1))): PROVED\n"
  },
  {
    "id": "11_28_0520",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7_0m9yyt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed && !sva_checker.sensor_off |-> (##[3:6] (sva_checker.alarm_trigger ##0 $stable(sva_checker.temp_code)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed == 1 && sva_checker.sensor_off == 0 |-> (##[3:6] sva_checker.alarm_trigger == 1 && sva_checker.temp_code == $past(sva_checker.temp_code))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed && !sva_checker.sensor_off |-> (##[3:6] (sva_checker.alarm_trigger ##0 $stable(sva_checker.temp_code)))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5z11la7n/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed == 1 && sva_checker.sensor_off == 0 |-> (##[3:6] sva_checker.alarm_trigger == 1 && sva_checker.temp_code == $past(sva_checker.temp_code))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed && !sva_checker.sensor_off |-> (##[3:6] (sva_checker.alarm_trigger ##0 $stable(sva_checker.temp_code)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_exceed == 1 && sva_checker.sensor_off == 0 |-> (##[3:6] sva_checker.alarm_trigger == 1 && s"
  },
  {
    "id": "11_31_0532",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_mf79w551/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max && !sva_checker.calibration_mode |-> (##1 sva_checker.second_tick ##0 $stable(sva_checker.rtc_regs))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max == 1 && sva_checker.calibration_mode == 0 |-> (##1 sva_checker.second_tick == 1 && $stable(sva_checker.rtc_regs))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_max && !sva_checker.calibration_mode |-> (##1 sva_checker.second_tick ##0 $stable(sva_checker.rtc_regs))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_oyid2gzp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max == 1 && sva_checker.calibration_mode == 0 |-> (##1 sva_checker.second_tick == 1 && $stable(sva_checker.rtc_regs))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_max && !sva_checker.calibration_mode |-> (##1 sva_checker.second_tick ##0 $stable(sva_checker.rtc_regs))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_max == 1 && sva_checker.calibration_mode == 0 |-> (##1 sva_checker.second_tick ="
  },
  {
    "id": "12_24_0582",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lbude144/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected || sva_checker.overcurrent_prot |-> (##2 sva_checker.shutdown_en)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected == 1 || sva_checker.overcurrent_prot == 1 |-> (##2 sva_checker.shutdown_en == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected || sva_checker.overcurrent_prot |-> (##2 sva_checker.shutdown_en)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pij04gam/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected == 1 || sva_checker.overcurrent_prot == 1 |-> (##2 sva_checker.shutdown_en == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected || sva_checker.overcurrent_prot |-> (##2 sva_checker.shutdown_en)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vdrop_detected == 1 || sva_checker.overcurrent_prot == 1 |-> (##2 sva_checker.shutdown_en == 1)): PROVED\n"
  },
  {
    "id": "12_30_0576",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0tshoa_g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.reset_received |-> (##0 !sva_checker.data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.reset_received == 1 |-> sva_checker.data_valid == 0): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.reset_received |-> (##0 !sva_checker.data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_k7qnxnp2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.reset_received == 1 |-> sva_checker.data_valid == 0): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sync_lost || sva_checker.reset_received |-> (##0 !sva_checker.data_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sync_lost == 1 || sva_checker.reset_received == 1 |-> sva_checker.data_valid == 0): PROVED\n"
  },
  {
    "id": "13_28_0624",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ybfddp5e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.counter_overflow |-> (##[2:4] sva_checker.monitor_triggered)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 0 |-> (##[2:4] sva_checker.monitor_triggered == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.counter_overflow |-> (##[2:4] sva_checker.monitor_triggered)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7bqur69t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 0 |-> (##[2:4] sva_checker.monitor_triggered == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.counter_overflow |-> (##[2:4] sva_checker.monitor_triggered)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.counter_overflow == 0 |-> (##[2:4] sva_checker.monitor_triggered == 1)): PROVED\n"
  },
  {
    "id": "13_34_0650",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0e8762y_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.excess_jitter |-> (##2 sva_checker.calibration_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.excess_jitter == 0 |-> (##2 sva_checker.calibration_done == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.excess_jitter |-> (##2 sva_checker.calibration_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_tebwnu0k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.excess_jitter == 0 |-> (##2 sva_checker.calibration_done == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.excess_jitter |-> (##2 sva_checker.calibration_done)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.excess_jitter == 0 |-> (##2 sva_checker.calibration_done == 1)): PROVED\n"
  },
  {
    "id": "13_37_0634",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_pjeqtc1d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.starvation_detected |-> (##1 sva_checker.arbiter_rotated)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.starvation_detected == 0 |-> (##1 sva_checker.arbiter_rotated == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.starvation_detected |-> (##1 sva_checker.arbiter_rotated)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r722dgc8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.starvation_detected == 0 |-> (##1 sva_checker.arbiter_rotated == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.starvation_detected |-> (##1 sva_checker.arbiter_rotated)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.starvation_detected == 0 |-> (##1 sva_checker.arbiter_rotated == 1)): PROVED\n"
  },
  {
    "id": "13_39_0640",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6yvied1e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.resource_contention |-> (##2 sva_checker.priority_resolved)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.resource_contention == 0 |-> (##2 sva_checker.priority_resolved == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.resource_contention |-> (##2 sva_checker.priority_resolved)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9qln21ai/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.resource_contention == 0 |-> (##2 sva_checker.priority_resolved == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.resource_contention |-> (##2 sva_checker.priority_resolved)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.resource_contention == 0 |-> (##2 sva_checker.priority_resolved == 1)): PROVED\n"
  },
  {
    "id": "13_40_0637",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0mbra62g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.protocol_violation |-> (##[1:4] sva_checker.protection_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.protocol_violation == 0 |-> (##[1:4] sva_checker.protection_active == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.protocol_violation |-> (##[1:4] sva_checker.protection_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_gg3baf0g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.protocol_violation == 0 |-> (##[1:4] sva_checker.protection_active == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.protocol_violation |-> (##[1:4] sva_checker.protection_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.protocol_violation == 0 |-> (##[1:4] sva_checker.protection_active == 1)): PROVED\n"
  },
  {
    "id": "13_44_0631",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jti3yjpb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5aqfd_1_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(!sva_checker.saturated_output) |-> (##2 sva_checker.limiter_active)): PROVED\n"
  },
  {
    "id": "15_17_0716",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_9s3nm3vl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.qspi_dual_mode_enable == 1'b1 |-> (##[2:4] sva_checker.qspi_io2_enable ##1 sva_checker.qspi_io3_enable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.qspi_reset == 0 && sva_checker.qspi_dual_mode_enable == 1 |-> (##[2:4] sva_checker.qspi_io2_enable == 1 ##1 sva_checker.qspi_io3_enable == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.qspi_dual_mode_enable == 1'b1 |-> (##[2:4] sva_checker.qspi_io2_enable ##1 sva_checker.qspi_io3_enable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_u2ag78vq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.qspi_reset == 0 && sva_checker.qspi_dual_mode_enable == 1 |-> (##[2:4] sva_checker.qspi_io2_enable == 1 ##1 sva_checker.qspi_io3_enable == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.qspi_dual_mode_enable == 1'b1 |-> (##[2:4] sva_checker.qspi_io2_enable ##1 sva_checker.qspi_io3_enable)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.qspi_reset == 0 && sva_checker.qspi_dual_mode_enable == 1 |-> (##[2:4] sva_checker.qspi_io2_enable == 1 ##1 sva_checker.qspi_io3_enable == 1)): PROVE"
  },
  {
    "id": "15_33_0732",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_o1as8kow/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scard_atr_request |-> (##[20:40] sva_checker.scard_atr_response_valid ##1 $onehot(sva_checker.scard_protocol_select))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scard_present == 1 && sva_checker.scard_atr_request == 1 |-> (##[20:40] sva_checker.scard_atr_response_valid == 1 ##1 $onehot(sva_checker.scard_protocol_select))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scard_atr_request |-> (##[20:40] sva_checker.scard_atr_response_valid ##1 $onehot(sva_checker.scard_protocol_select))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vaeiknx6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.scard_present == 1 && sva_checker.scard_atr_request == 1 |-> (##[20:40] sva_checker.scard_atr_response_valid == 1 ##1 $onehot(sva_checker.scard_protocol_select))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.scard_atr_request |-> (##[20:40] sva_checker.scard_atr_response_valid ##1 $onehot(sva_checker.scard_protocol_select))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.scard_present == 1 && sva_checker.scard_atr_request =="
  },
  {
    "id": "15_44_0752",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_lf1f9mdo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pause_frame_received |-> (##[1:2] sva_checker.eth_tx_pause_enable ##[16:32] sva_checker.eth_tx_resume_normal)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_mac_reset_n == 1 && sva_checker.eth_pause_frame_received == 1 |-> (##[1:2] sva_checker.eth_tx_pause_enable == 1 ##[16:32] sva_checker.eth_tx_resume_normal == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_pause_frame_received |-> (##[1:2] sva_checker.eth_tx_pause_enable ##[16:32] sva_checker.eth_tx_resume_normal)): PROVED\n\n\nBackward: Parsing /tmp/sva_check__txpme3_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_mac_reset_n == 1 && sva_checker.eth_pause_frame_received == 1 |-> (##[1:2] sva_checker.eth_tx_pause_enable == 1 ##[16:32] sva_checker.eth_tx_resume_normal == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_pause_frame_received |-> (##[1:2] sva_checker.eth_tx_pause_enable ##[16:32] sva_checker.eth_tx_resume_normal)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_mac_reset_n == 1 && sva_checker.eth_pause_frame_received"
  },
  {
    "id": "2_11_0003",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check__xl1yldy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_80qrtcir/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.wr_en) |-> (##[2:10] sva_checker.wr_ack ##[1:2] $stable(sva_checker.wr_data))): PROVED\n"
  },
  {
    "id": "2_27_0045",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zxgewzbk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_umddyvxw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.cs_n) |-> (##[8:32] $fell(sva_checker.cs_n) ##[1:3] $stable(sva_checker.spi_mode))): PROVED\n"
  },
  {
    "id": "2_43_0096",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ahl_a66y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9kd8xznn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.pkt_start) |-> (##[4:32] sva_checker.pkt_end ##[1:2] $stable(sva_checker.pkt_type))): PROVED\n"
  },
  {
    "id": "3_16_0111",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kvm9e9gg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert |-> (##1 sva_checker.frequency_reduced ##2 sva_checker.voltage_reduced)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert == 1 |-> (##1 sva_checker.frequency_reduced == 1 ##2 sva_checker.voltage_reduced == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert |-> (##1 sva_checker.frequency_reduced ##2 sva_checker.voltage_reduced)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pybgc5bc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert == 1 |-> (##1 sva_checker.frequency_reduced == 1 ##2 sva_checker.voltage_reduced == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert |-> (##1 sva_checker.frequency_reduced ##2 sva_checker.voltage_reduced)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.overtemp_alert == 1 |-> (##1 sva_checker.frequency_reduced == 1 ##2 sva_checker.voltage_reduced == 1)): PROVED\n"
  },
  {
    "id": "3_18_0126",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z2ywv0lt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.refresh_required |-> (##[7:9] sva_checker.refresh_active && !sva_checker.access_granted)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.refresh_required == 1 |-> (##[7:9] sva_checker.refresh_active == 1 && sva_checker.access_granted == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.refresh_required |-> (##[7:9] sva_checker.refresh_active && !sva_checker.access_granted)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b7bjauk9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.refresh_required == 1 |-> (##[7:9] sva_checker.refresh_active == 1 && sva_checker.access_granted == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.refresh_required |-> (##[7:9] sva_checker.refresh_active && !sva_checker.access_granted)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.refresh_required == 1 |-> (##[7:9] sva_checker.refresh_active == 1 && sva_checker.access_granted == 0)): PROVED\n"
  },
  {
    "id": "6_9_0239",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_lze0p2oj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full == 1 |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m6v0xhvg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full == 1 |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_not_full == 1 |-> ((sva_checker.data_in_valid [*1:4]) ##1 (sva_checker.fifo_write_enable [*2:3]))): PROVED\n"
  },
  {
    "id": "9_24_0437",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2u2vjwau/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cond_met |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cond_met == 1'b1 |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cond_met |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_apg_9s81/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cond_met == 1'b1 |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cond_met |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cond_met == 1'b1 |-> $stable(sva_checker.cond_data_a) || $stable(sva_checker.cond_data_b)): PROVED\n"
  },
  {
    "id": "9_46_0416",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jk_2ep0_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bkb156iu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.mux_select == 1'b1 |-> $stable(sva_checker.mux_data_a) || $stable(sva_checker.mux_data_b)): PROVED\n"
  },
  {
    "id": "10_3_0450",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_qhl78eg8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0], 3) == 2'b01): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0] == 2'b01, 3)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0], 3) == 2'b01): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jkah5kyd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0] == 2'b01, 3)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0], 3) == 2'b01): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.dma_start) |-> $past(sva_checker.dma_cfg_valid, 2) && $past(sva_checker.dma_mode[1:0] == 2'b01, 3)): PROVED\n"
  },
  {
    "id": "10_9_0463",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_esl94bxs/sva_checker.sv line 61: syntax error, unexpected ## before '##'",
    "log": "Parsing /tmp/sva_check_esl94bxs/sva_checker.sv\nfile /tmp/sva_check_esl94bxs/sva_checker.sv line 61: syntax error, unexpected ## before '##'\n"
  },
  {
    "id": "11_4_0496",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ii9jyk9u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit && sva_checker.tag_array == $past(sva_checker.tag_compare, 2) |-> (##2 sva_checker.valid_data && !sva_checker.cache_miss)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1 && sva_checker.tag_array == $past(sva_checker.tag_compare, 2) |-> (##2 sva_checker.valid_data == 1 && sva_checker.cache_miss == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit && sva_checker.tag_array == $past(sva_checker.tag_compare, 2) |-> (##2 sva_checker.valid_data && !sva_checker.cache_miss)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mknmry9g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1 && sva_checker.tag_array == $past(sva_checker.tag_compare, 2) |-> (##2 sva_checker.valid_data == 1 && sva_checker.cache_miss == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit && sva_checker.tag_array == $past(sva_checker.tag_compare, 2) |-> (##2 sva_checker.valid_data && !sva_checker.cache_miss)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit == 1 && sva_checker."
  },
  {
    "id": "12_17_0588",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_g2xwq456/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse || sva_checker.codec_reset |-> (##1 $fell(sva_checker.data_ready))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse == 1 || sva_checker.codec_reset == 1 |-> (##1 $fell(sva_checker.data_ready))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse || sva_checker.codec_reset |-> (##1 $fell(sva_checker.data_ready))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9qrkp3py/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse == 1 || sva_checker.codec_reset == 1 |-> (##1 $fell(sva_checker.data_ready))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse || sva_checker.codec_reset |-> (##1 $fell(sva_checker.data_ready))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_sync_pulse == 1 || sva_checker.codec_reset == 1 |-> (##1 $fell(sva_checker.data_ready))): PROVED\n"
  },
  {
    "id": "13_10_0619",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zh3l5433/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.clock_gate_enable |-> (##1 sva_checker.phase_alignment && !sva_checker.skew_detected)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_gate_enable == 0 |-> (##1 sva_checker.phase_alignment == 1 && sva_checker.skew_detected == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.clock_gate_enable |-> (##1 sva_checker.phase_alignment && !sva_checker.skew_detected)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vk37sey4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_gate_enable == 0 |-> (##1 sva_checker.phase_alignment == 1 && sva_checker.skew_detected == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.clock_gate_enable |-> (##1 sva_checker.phase_alignment && !sva_checker.skew_detected)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_gate_enable == 0 |-> (##1 sva_checker.phase_alignment == 1 && sva_checker.skew_detected == 0)): PROVED\n"
  },
  {
    "id": "13_44_0632",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_gef8suu9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.linearity_error_detected |-> (##2 sva_checker.correction_applied && !sva_checker.temperature_drift)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.linearity_error_detected == 0 |-> (##2 sva_checker.correction_applied == 1 && sva_checker.temperature_drift == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.linearity_error_detected |-> (##2 sva_checker.correction_applied && !sva_checker.temperature_drift)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xj23anyy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.linearity_error_detected == 0 |-> (##2 sva_checker.correction_applied == 1 && sva_checker.temperature_drift == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.linearity_error_detected |-> (##2 sva_checker.correction_applied && !sva_checker.temperature_drift)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.linearity_error_detected == 0 |-> (##2 sva_checker.correction_applied == 1 && sva_checker.temperature_drift == 0)): PROVED\n"
  },
  {
    "id": "15_11_0725",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_109qs_uc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_reset == 0 && sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bk6cy03g/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_reset == 0 && sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ecc_reset == 0 && sva_checker.ecc_trigger == 1'b1 |-> (##2 (sva_checker.ecc_corrected [*2]) ##1 sva_checker.ecc_clean)): PROVED\n"
  },
  {
    "id": "15_12_0697",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_8kxhaarm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active ##1 sva_checker.dma_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_reset == 0 && sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active == 1'b1 ##1 sva_checker.dma_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active ##1 sva_checker.dma_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_bjtt581z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_reset == 0 && sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active == 1'b1 ##1 sva_checker.dma_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active ##1 sva_checker.dma_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_reset == 0 && sva_checker.dma_start == 1'b1 |-> (##[3:7] sva_checker.dma_active == 1'b1 ##1 sva_checker.dma_done == 1'b1)): PROVED\n"
  },
  {
    "id": "15_27_0726",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_z250asr7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cs_assert |-> (##[4:6] sva_checker.data_valid ##1 sva_checker.cs_deassert)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.spi_reset == 0 && sva_checker.cs_assert == 1 |-> (##[4:6] sva_checker.data_valid == 1 ##1 sva_checker.cs_deassert == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cs_assert |-> (##[4:6] sva_checker.data_valid ##1 sva_checker.cs_deassert)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ass2dgaw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.spi_reset == 0 && sva_checker.cs_assert == 1 |-> (##[4:6] sva_checker.data_valid == 1 ##1 sva_checker.cs_deassert == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cs_assert |-> (##[4:6] sva_checker.data_valid ##1 sva_checker.cs_deassert)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.spi_reset == 0 && sva_checker.cs_assert == 1 |-> (##[4:6] sva_checker.data_valid == 1 ##1 sva_checker.cs_deassert == 1)): PROVED\n"
  },
  {
    "id": "15_29_0724",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_ixfp5q7o/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[6:9] sva_checker.ack_field ##1 sva_checker.frame_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 && sva_checker.can_reset == 0 |-> (##[6:9] sva_checker.ack_field == 1 ##1 sva_checker.frame_end == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[6:9] sva_checker.ack_field ##1 sva_checker.frame_end)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_jpwwu5g5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 && sva_checker.can_reset == 0 |-> (##[6:9] sva_checker.ack_field == 1 ##1 sva_checker.frame_end == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[6:9] sva_checker.ack_field ##1 sva_checker.frame_end)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 && sva_checker.can_reset == 0 |-> (##[6:9] sva_checker.ack_field == 1 ##1 sva_checker.frame_end == 1)): PROVED\n"
  },
  {
    "id": "15_32_0746",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_j14l06yz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check ##1 sva_checker.frame_done)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.eth_reset == 0 && sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check == 1'b1 ##1 sva_checker.frame_done == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check ##1 sva_checker.frame_done)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vsi4an82/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.eth_reset == 0 && sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check == 1'b1 ##1 sva_checker.frame_done == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check ##1 sva_checker.frame_done)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.eth_reset == 0 && sva_checker.frame_valid == 1'b1 |-> (##[12:16] sva_checker.crc_check == 1'b1 ##1 sva_checker.frame_done == 1'b1)): PROVED\n"
  },
  {
    "id": "2_35_0083",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_8maizr_k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full |-> (##[1:3] sva_checker.backpressure_asserted || sva_checker.overflow_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full == 1 |-> (##[1:3] sva_checker.backpressure_asserted == 1 || sva_checker.overflow_error == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full |-> (##[1:3] sva_checker.backpressure_asserted || sva_checker.overflow_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y0jfguby/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full == 1 |-> (##[1:3] sva_checker.backpressure_asserted == 1 || sva_checker.overflow_error == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full |-> (##[1:3] sva_checker.backpressure_asserted || sva_checker.overflow_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_almost_full == 1 |-> (##[1:3] sva_checker.backpressure_asserted == 1 || sva_checker.overflow_error == 1)): PROVED\n"
  },
  {
    "id": "3_13_0112",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_khcyt76m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt ##1 sva_checker.error_logged)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt == 1'b1 ##1 sva_checker.error_logged == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt ##1 sva_checker.error_logged)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_h1mt5b73/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt == 1'b1 ##1 sva_checker.error_logged == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt ##1 sva_checker.error_logged)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.uncorrectable_error == 1'b1 |-> (##[2:3] sva_checker.system_halt == 1'b1 ##1 sva_checker.error_logged == 1'b1)): PROVED\n"
  },
  {
    "id": "6_34_0279",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0c3c9oy_/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7nl3s2cf/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_rising [*2:4]) |-> (##[3:6] sva_checker.fan_speed_increase)): PROVED\n"
  },
  {
    "id": "7_46_0349",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v1zsucly/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack ##2 sva_checker.delseq_data_valid ##1 sva_checker.delseq_complete)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack == 1 ##2 sva_checker.delseq_data_valid == 1 ##1 sva_checker.delseq_complete == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack ##2 sva_checker.delseq_data_valid ##1 sva_checker.delseq_complete)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sbtvbg9d/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack == 1 ##2 sva_checker.delseq_data_valid == 1 ##1 sva_checker.delseq_complete == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack ##2 sva_checker.delseq_data_valid ##1 sva_checker.delseq_complete)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.delseq_trigger) |-> (##5 sva_checker.delseq_ack == 1 ##2 sva_checker.delseq_d"
  },
  {
    "id": "10_29_0486",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hs1r05jr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_lfikb84m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wdt_armed, 7) |-> $past(sva_checker.wdt_refreshed, 4) || $past(sva_checker.wdt_timeout, 2)): PROVED\n"
  },
  {
    "id": "10_49_0488",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_s1ztai3u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) || $past(sva_checker.degredation_mode, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) == 1 || $past(sva_checker.degredation_mode, 1) == 1): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) || $past(sva_checker.degredation_mode, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ezkaoulk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) == 1 || $past(sva_checker.degredation_mode, 1) == 1): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) || $past(sva_checker.degredation_mode, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.power_cycle, 8) > 32'hs3E8 |-> $past(sva_checker.eol_warning, 2) == 1 || $past(sva_checker.degredation_mode, 1) == 1): PROVED\n"
  },
  {
    "id": "10_50_0497",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vivahbzm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7d882ewa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.mem_test_start, 3) |-> (##1 $past(sva_checker.mem_test_done, 2) && $past(sva_checker.mem_test_pass, 1))): PROVED\n"
  },
  {
    "id": "10_6_0457",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_n9yan89f/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_credit, 7) < $past(sva_checker.tx_credit_thresh, 5) |-> (##1 $past(sva_checker.rx_credit_update, 3) || sva_checker.credit_overflow)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_credit, 7) < $past(sva_checker.tx_credit_thresh, 5) |-> (##1 $past(sva_checker.rx_credit_update, 3) || sva_checker.credit_overflow)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_credit, 7) < $past(sva_checker.tx_credit_thresh, 5) |-> (##1 $past(sva_checker.rx_credit_update, 3) || sva_checker.credit_overflow)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_m13sltoq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_credit, 7) < $past(sva_checker.tx_credit_thresh, 5) |-> (##1 $past(sva_checker.rx_credit_update, 3) || sva_checker.credit_overflow)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_credit, 7) < $past(sva_checker.tx_credit_thresh, 5) |-> (##1 $past(sva_checker.rx_credit_update, 3) || sva_checker.credit_overflow)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.tx_cred"
  },
  {
    "id": "11_37_0546",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_49jjgtpi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.compensation_start && !sva_checker.calibration_mode |-> (##[50:100] sva_checker.offset_adjusted)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.compensation_start == 1 && sva_checker.calibration_mode == 0 |-> (##[50:100] sva_checker.offset_adjusted == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.compensation_start && !sva_checker.calibration_mode |-> (##[50:100] sva_checker.offset_adjusted)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pdhk47id/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.compensation_start == 1 && sva_checker.calibration_mode == 0 |-> (##[50:100] sva_checker.offset_adjusted == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.compensation_start && !sva_checker.calibration_mode |-> (##[50:100] sva_checker.offset_adjusted)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.compensation_start == 1 && sva_checker.calibration_mode == 0 |-> (##[50:100] sva_checker.offset_adjusted == 1)): PROVED\n"
  },
  {
    "id": "11_43_0536",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_xoi42dhg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.location_update && !sva_checker.roaming_disabled |-> (##[5:10] sva_checker.registered_status)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.location_update == 1 && sva_checker.roaming_disabled == 0 |-> (##[5:10] sva_checker.registered_status == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.location_update && !sva_checker.roaming_disabled |-> (##[5:10] sva_checker.registered_status)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mvobmi8l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.location_update == 1 && sva_checker.roaming_disabled == 0 |-> (##[5:10] sva_checker.registered_status == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.location_update && !sva_checker.roaming_disabled |-> (##[5:10] sva_checker.registered_status)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.location_update == 1 && sva_checker.roaming_disabled == 0 |-> (##[5:10] sva_checker.registered_status == 1)): PROVED\n"
  },
  {
    "id": "11_44_0540",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_sdv4ggj5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock && !sva_checker.cold_start |-> (##[60:120] sva_checker.position_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock == 1 && sva_checker.cold_start == 0 |-> (##[60:120] sva_checker.position_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock && !sva_checker.cold_start |-> (##[60:120] sva_checker.position_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_6tpbzvhg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock == 1 && sva_checker.cold_start == 0 |-> (##[60:120] sva_checker.position_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock && !sva_checker.cold_start |-> (##[60:120] sva_checker.position_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.satellite_lock == 1 && sva_checker.cold_start == 0 |-> (##[60:120] sva_checker.position_valid == 1)): PROVED\n"
  },
  {
    "id": "12_42_0596",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_wx67g65p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crc_match || sva_checker.force_accept |-> (##1 sva_checker.packet_good && $fell(sva_checker.error_flag))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crc_match == 1 || sva_checker.force_accept == 1 |-> (##1 sva_checker.packet_good == 1 && $past(sva_checker.error_flag) == 1 && sva_checker.error_flag == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crc_match || sva_checker.force_accept |-> (##1 sva_checker.packet_good && $fell(sva_checker.error_flag))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kunhovwd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crc_match == 1 || sva_checker.force_accept == 1 |-> (##1 sva_checker.packet_good == 1 && $past(sva_checker.error_flag) == 1 && sva_checker.error_flag == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crc_match || sva_checker.force_accept |-> (##1 sva_checker.packet_good && $fell(sva_checker.error_flag))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crc_match == 1 || sva_checker.force_accept == 1 |-> (##1 sva_checker.packet_good == 1 && $p"
  },
  {
    "id": "1_21_0060",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_20cpvs_i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] (sva_checker.error_counter_inc ##1 !sva_checker.tx_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] sva_checker.error_counter_inc == 1'b1 ##1 sva_checker.tx_enable == 1'b0)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] (sva_checker.error_counter_inc ##1 !sva_checker.tx_enable))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_e5lk6qfc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] sva_checker.error_counter_inc == 1'b1 ##1 sva_checker.tx_enable == 1'b0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] (sva_checker.error_counter_inc ##1 !sva_checker.tx_enable))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_frame_detected == 1'b1 |-> (##[2:4] sva_checker.error_counter_inc == 1'b1 ##1 sva_checker.tx_enable == 1'b0)): PROVED\n"
  },
  {
    "id": "1_44_0069",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ig7ifz_3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] !sva_checker.pwm_low ##1 sva_checker.deadtime_elapsed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] sva_checker.pwm_low == 1'b0 ##1 sva_checker.deadtime_elapsed == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] !sva_checker.pwm_low ##1 sva_checker.deadtime_elapsed)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qyl5_y0p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] sva_checker.pwm_low == 1'b0 ##1 sva_checker.deadtime_elapsed == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] !sva_checker.pwm_low ##1 sva_checker.deadtime_elapsed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_high == 1'b1 |-> (##[1:3] sva_checker.pwm_low == 1'b0 ##1 sva_checker.deadtime_elapsed == 1'b1)): PROVED\n"
  },
  {
    "id": "2_12_0066",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_mvww3xsd/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uzvka9zq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert_high == 1'b1 |-> (##[2:5] sva_checker.cooling_fan_on == 1'b1 ##[3:8] sva_checker.temp_normal == 1'b1)): PROVED\n"
  },
  {
    "id": "2_31_0086",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a9x9oybu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate ##[2:4] $stable(sva_checker.memory_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate == 1'b1 ##[2:4] $stable(sva_checker.memory_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate ##[2:4] $stable(sva_checker.memory_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uws0vttu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate == 1'b1 ##[2:4] $stable(sva_checker.memory_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate ##[2:4] $stable(sva_checker.memory_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.snoop_hit == 1'b1 |-> (##[1:3] sva_checker.cache_invalidate == 1'b1 ##[2:4] $stable(sva_checker.memory_data))): PROVED\n"
  },
  {
    "id": "2_44_0110",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nf3vijad/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry ##[2:4] $stable(sva_checker.corrected_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry == 1'b1 ##[2:4] $stable(sva_checker.corrected_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry ##[2:4] $stable(sva_checker.corrected_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rqz4m2ik/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry == 1'b1 ##[2:4] $stable(sva_checker.corrected_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry ##[2:4] $stable(sva_checker.corrected_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.parity_error == 1'b1 |-> (##[1:3] sva_checker.data_retry == 1'b1 ##[2:4] $stable(sva_checker.corrected_data))): PROVED\n"
  },
  {
    "id": "2_51_0111",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3z1n9q41/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done ##[1:2] $stable(sva_checker.phase_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done == 1'b1 ##[1:2] $stable(sva_checker.phase_status))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done ##[1:2] $stable(sva_checker.phase_status))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_828r9nb6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done == 1'b1 ##[1:2] $stable(sva_checker.phase_status))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done ##[1:2] $stable(sva_checker.phase_status))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.align_request == 1'b1 |-> (##[8:16] sva_checker.align_done == 1'b1 ##[1:2] $stable(sva_checker.phase_status))): PROVED\n"
  },
  {
    "id": "3_23_0144",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_52m69qsg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] sva_checker.cam_href_high ##1 sva_checker.cam_data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] (sva_checker.cam_href_high ##1 sva_checker.cam_data_valid))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] sva_checker.cam_href_high ##1 sva_checker.cam_data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_atemfmg2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] (sva_checker.cam_href_high ##1 sva_checker.cam_data_valid))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] sva_checker.cam_href_high ##1 sva_checker.cam_data_valid)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cam_vsync_high |-> (##[32'hs500:32'hs514] (sva_checker.cam_href_high ##1 sva_checker.cam_data_valid))): PROVED\n"
  },
  {
    "id": "5_17_0193",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_wpjl3yad/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 ((sva_checker.fill_busy [*4]) ##1 sva_checker.fill_complete))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 (sva_checker.fill_busy == 1'b1 [*4]) ##1 sva_checker.fill_complete == 1'b1)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 ((sva_checker.fill_busy [*4]) ##1 sva_checker.fill_complete))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_r14epk3c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 (sva_checker.fill_busy == 1'b1 [*4]) ##1 sva_checker.fill_complete == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 ((sva_checker.fill_busy [*4]) ##1 sva_checker.fill_complete))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fill_request == 1'b1 |-> (##2 (sva_checker.fill_busy == 1'b1 [*4]) ##1 sva_checker.fill_complete == 1'b1)): PROVED\n"
  },
  {
    "id": "6_49_0291",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_z05705le/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (!sva_checker.missing_sof [*125:250]) ##1 sva_checker.frame_number_increment)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (sva_checker.missing_sof == 1'b0 [*125:250]) ##1 sva_checker.frame_number_increment == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (!sva_checker.missing_sof [*125:250]) ##1 sva_checker.frame_number_increment)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ad_9feqi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (sva_checker.missing_sof == 1'b0 [*125:250]) ##1 sva_checker.frame_number_increment == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (!sva_checker.missing_sof [*125:250]) ##1 sva_checker.frame_number_increment)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sof_packet == 1'b1 |-> (##[1:3] (sva_checker.missing_sof == 1'b0 [*125:250]) ##1 sva_checker.frame_number_increment == 1'b1)): PROVED\n"
  },
  {
    "id": "10_47_0495",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_p7ewa_ji/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hi020m84/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.div_valid) |-> $past(sva_checker.ref_count, 3) == $past(sva_checker.div_factor, 5)): PROVED\n"
  },
  {
    "id": "12_41_0596",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kvogv388/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req || sva_checker.dma_abort |-> (##1 $fell(sva_checker.dma_active))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req == 1 || sva_checker.dma_abort == 1 |-> (##1 $fell(sva_checker.dma_active))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req || sva_checker.dma_abort |-> (##1 $fell(sva_checker.dma_active))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kzxhuwv9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req == 1 || sva_checker.dma_abort == 1 |-> (##1 $fell(sva_checker.dma_active))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req || sva_checker.dma_abort |-> (##1 $fell(sva_checker.dma_active))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dma_pause_req == 1 || sva_checker.dma_abort == 1 |-> (##1 $fell(sva_checker.dma_active))): PROVED\n"
  },
  {
    "id": "1_35_0041",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_kzsda7vn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected ##1 $stable(sva_checker.proximity_distance))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected == 1'b1 ##1 $stable(sva_checker.proximity_distance))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected ##1 $stable(sva_checker.proximity_distance))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7pxu9vji/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected == 1'b1 ##1 $stable(sva_checker.proximity_distance))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected ##1 $stable(sva_checker.proximity_distance))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.proximity_enable == 1'b1 |-> (##3 sva_checker.proximity_detected == 1'b1 ##1 $stable(sva_checker.proximity_distance))): PROVED\n"
  },
  {
    "id": "1_8_0026",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jam1lab2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_active == 1'b1 |-> (##6 sva_checker.can_error_flag == 1'b1 ##2 sva_checker.can_error_passive == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_active |-> (##6 sva_checker.can_error_flag ##2 sva_checker.can_error_passive)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_active == 1'b1 |-> (##6 sva_checker.can_error_flag == 1'b1 ##2 sva_checker.can_error_passive == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_csezkrmj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_active |-> (##6 sva_checker.can_error_flag ##2 sva_checker.can_error_passive)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_active == 1'b1 |-> (##6 sva_checker.can_error_flag == 1'b1 ##2 sva_checker.can_error_passive == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_active |-> (##6 sva_checker.can_error_flag ##2 sva_checker.can_error_passive)): PROVED\n"
  },
  {
    "id": "3_14_0111",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_d0zfqrme/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown ##0 sva_checker.fan_speed == sva_checker.max_fan_speed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown == 1'b1 && sva_checker.fan_speed == sva_checker.max_fan_speed)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown ##0 sva_checker.fan_speed == sva_checker.max_fan_speed)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_87y8nh62/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown == 1'b1 && sva_checker.fan_speed == sva_checker.max_fan_speed)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown ##0 sva_checker.fan_speed == sva_checker.max_fan_speed)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_alert == 1'b1 |-> (##1 sva_checker.temp_shutdown == 1'b1 && sva_checker.fan_speed == sva_checker.max_fan_speed"
  },
  {
    "id": "3_15_0126",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4ee0d3cl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant ##1 sva_checker.bus_owner == sva_checker.requestor_id)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant == 1'b1 ##1 sva_checker.bus_owner == sva_checker.requestor_id)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant ##1 sva_checker.bus_owner == sva_checker.requestor_id)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_sxvu663q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant == 1'b1 ##1 sva_checker.bus_owner == sva_checker.requestor_id)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant ##1 sva_checker.bus_owner == sva_checker.requestor_id)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.bus_request == 1'b1 |-> (##[0:2] sva_checker.bus_grant == 1'b1 ##1 sva_checker.bus_owner == sva_checker.requestor_id)): PROVED\n"
  },
  {
    "id": "3_1_0101",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nql3vz5m/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> (sva_checker.grant_ack ##0 sva_checker.req_id == sva_checker.grant_id)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> sva_checker.grant_ack == 1'b1 && sva_checker.req_id == sva_checker.grant_id): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> (sva_checker.grant_ack ##0 sva_checker.req_id == sva_checker.grant_id)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_3k_4tm4p/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> sva_checker.grant_ack == 1'b1 && sva_checker.req_id == sva_checker.grant_id): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> (sva_checker.grant_ack ##0 sva_checker.req_id == sva_checker.grant_id)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.req_valid == 1'b1 |-> sva_checker.grant_ack == 1'b1 && sva_checker.req_id == sva_checker.grant_id): PROVED\n"
  },
  {
    "id": "3_2_0131",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_9zjyi1qx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vlqugoaq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.error_detected == 1'b1 |-> (##[1:3] sva_checker.abort_triggered == 1'b1)): PROVED\n"
  },
  {
    "id": "3_50_0149",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bt2ivdnz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed ##1 sva_checker.coordinates_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed == 1'b1 ##1 sva_checker.coordinates_valid == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed ##1 sva_checker.coordinates_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_chqkchih/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed == 1'b1 ##1 sva_checker.coordinates_valid == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed ##1 sva_checker.coordinates_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.touch_detected == 1'b1 |-> (##[1:3] sva_checker.touch_processed == 1'b1 ##1 sva_checker.coordinates_valid == 1'b1)): PROVED\n"
  },
  {
    "id": "10_43_0481",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_nl53q42h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) |-> ($past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) && $past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) |-> ($past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kzt_1ojk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) && $past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) |-> ($past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.stage1_valid, 3) && $past(sva_checker.stage2_valid, 2) |-> $past(sva_checker.stage3_valid, 1)): PROVED\n"
  },
  {
    "id": "10_42_0485",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_jtind6q5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !$past(sva_checker.fifo_full, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !$past(sva_checker.fifo_full, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !$past(sva_checker.fifo_full, 1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_z5s9ou32/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !$past(sva_checker.fifo_full, 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !$past(sva_checker.fifo_full, 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.wr_count, 2) - $past(sva_checker.rd_count, 2) == $past(sva_checker.fifo_level, 1) |-> !"
  },
  {
    "id": "11_44_0543",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_7nvsfzpe/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low ##0 !sva_checker.sda_high)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low && !sva_checker.sda_high)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low ##0 !sva_checker.sda_high)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qhi2r1qr/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low && !sva_checker.sda_high)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low ##0 !sva_checker.sda_high)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.start_cond) && $fell(sva_checker.sda_high) |-> (##1 sva_checker.scl_low && !sva_checker.sda_high)): PROVED\n"
  },
  {
    "id": "11_7_0490",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2ybgt0l8/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.fifo_almost_full && !sva_checker.fifo_reset |-> (##1 !sva_checker.wr_en || sva_checker.fifo_full)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.fifo_almost_full == 1 && sva_checker.fifo_reset == 0 |-> (##1 sva_checker.wr_en == 0 || sva_checker.fifo_full == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.fifo_almost_full && !sva_checker.fifo_reset |-> (##1 !sva_checker.wr_en || sva_checker.fifo_full)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_dnp5oyv4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.fifo_almost_full == 1 && sva_checker.fifo_reset == 0 |-> (##1 sva_checker.wr_en == 0 || sva_checker.fifo_full == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.wr_en && sva_checker.fifo_almost_full && !sva_checker.fifo_reset |-> (##1 !sva_checker.wr_en || sva_checker.fifo_full)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.wr_en == 1 && sva_checker.fifo_almost_full == 1 && sva_checker.fifo_reset == "
  },
  {
    "id": "12_19_0563",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_l5m5153u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning || sva_checker.charger_disconnected |-> (##1 $rose(sva_checker.power_save_mode))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning == 1 || sva_checker.charger_disconnected == 1 |-> (##1 $rose(sva_checker.power_save_mode))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning || sva_checker.charger_disconnected |-> (##1 $rose(sva_checker.power_save_mode))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fm7xq4u0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning == 1 || sva_checker.charger_disconnected == 1 |-> (##1 $rose(sva_checker.power_save_mode))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning || sva_checker.charger_disconnected |-> (##1 $rose(sva_checker.power_save_mode))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.battery_low_warning == 1 || sva_checker.charger_disconnected == 1 |-> (##1 $rose(sva_checker.power_save_mode))): PROVED\n"
  },
  {
    "id": "12_25_0574",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_imow976i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected || sva_checker.pll_unlock_event |-> (##1 $fell(sva_checker.tx_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected == 1 || sva_checker.pll_unlock_event == 1 |-> (##1 $fell(sva_checker.tx_enable))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected || sva_checker.pll_unlock_event |-> (##1 $fell(sva_checker.tx_enable))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vpr22hxa/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected == 1 || sva_checker.pll_unlock_event == 1 |-> (##1 $fell(sva_checker.tx_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected || sva_checker.pll_unlock_event |-> (##1 $fell(sva_checker.tx_enable))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.freq_error_detected == 1 || sva_checker.pll_unlock_event == 1 |-> (##1 $fell(sva_checker.tx_enable))): PROVED\n"
  },
  {
    "id": "13_38_0617",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_i_7yyld7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.crosstalk_detected |-> (##2 sva_checker.data_integrity_ok)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.crosstalk_detected == 0 |-> (##2 sva_checker.data_integrity_ok == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.crosstalk_detected |-> (##2 sva_checker.data_integrity_ok)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_62nxrf8k/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.crosstalk_detected == 0 |-> (##2 sva_checker.data_integrity_ok == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.crosstalk_detected |-> (##2 sva_checker.data_integrity_ok)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.crosstalk_detected == 0 |-> (##2 sva_checker.data_integrity_ok == 1)): PROVED\n"
  },
  {
    "id": "13_44_0641",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e4q0mtp0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) !sva_checker.esd_event |-> (##1 sva_checker.io_cell_ok)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.esd_event == 0 |-> (##1 sva_checker.io_cell_ok == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) !sva_checker.esd_event |-> (##1 sva_checker.io_cell_ok)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_yninbf4i/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.esd_event == 0 |-> (##1 sva_checker.io_cell_ok == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) !sva_checker.esd_event |-> (##1 sva_checker.io_cell_ok)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.esd_event == 0 |-> (##1 sva_checker.io_cell_ok == 1)): PROVED\n"
  },
  {
    "id": "15_24_0715",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent (neither direction holds)",
    "counterexample": "[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.monitor_enable == 1 && sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0 || $fell(sva_checker.monitor_enable))): PROVED\n",
    "log": "Forward: Parsing /tmp/sva_check_mz6c_118/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0 || $fell(sva_checker.monitor_enable))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.monitor_enable == 1 && sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0 || $fell(sva_checker.monitor_enable))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_kgwqzcc2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.monitor_enable == 1 && sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0 || $fell(sva_checker.monitor_enable))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.monitor_enable == 1 && sva_checker.vcc_value < sva_checker.min_voltage |-> (##1 sva_checker.power_good == 0)): PROVED\n"
  },
  {
    "id": "15_48_0747",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_e44xpxyo/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> ((##[1:10] sva_checker.irq_ack) or $fell(sva_checker.dsp_reset))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_reset == 1 && $rose(sva_checker.irq_line) |-> (##[1:10] sva_checker.irq_ack == 1 || sva_checker.dsp_reset == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> ((##[1:10] sva_checker.irq_ack) or $fell(sva_checker.dsp_reset))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ttvmi708/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.dsp_reset == 1 && $rose(sva_checker.irq_line) |-> (##[1:10] sva_checker.irq_ack == 1 || sva_checker.dsp_reset == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> ((##[1:10] sva_checker.irq_ack) or $fell(sva_checker.dsp_reset))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.dsp_reset == 1 && $rose(sva_checker.irq_line) |-> (##[1:10] sva_checker.irq_ack == 1 || sva_checker.dsp_reset == 0)): PROVED\n"
  },
  {
    "id": "1_24_0019",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_4x5oeugk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete ##3 sva_checker.ddr_ready)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete == 1'b1 ##3 sva_checker.ddr_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete ##3 sva_checker.ddr_ready)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_c2p_koga/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete == 1'b1 ##3 sva_checker.ddr_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete ##3 sva_checker.ddr_ready)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.training_start == 1'b1 |-> (##10 sva_checker.training_complete == 1'b1 ##3 sva_checker.ddr_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "1_32_0045",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_u11haxqw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active ##2 sva_checker.vsync_active)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active == 1'b1 ##2 sva_checker.vsync_active == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active ##2 sva_checker.vsync_active)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rv4lyy3a/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active == 1'b1 ##2 sva_checker.vsync_active == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active ##2 sva_checker.vsync_active)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1'b1 |-> (##4 sva_checker.hsync_active == 1'b1 ##2 sva_checker.vsync_active == 1'b1)): PROVED\n"
  },
  {
    "id": "1_33_0017",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ic21ve13/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready ##1 sva_checker.fifo_not_empty)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready == 1'b1 ##1 sva_checker.fifo_not_empty == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready ##1 sva_checker.fifo_not_empty)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_vx2ufccg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready == 1'b1 ##1 sva_checker.fifo_not_empty == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready ##1 sva_checker.fifo_not_empty)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sample_request == 1'b1 |-> (##5 sva_checker.data_ready == 1'b1 ##1 sva_checker.fifo_not_empty == 1'b1)): PROVED\n"
  },
  {
    "id": "1_39_0075",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_hg5kdiap/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset ##2 sva_checker.duty_cycle_set)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset == 1'b1 ##2 sva_checker.duty_cycle_set == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset ##2 sva_checker.duty_cycle_set)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t6k5wwsc/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset == 1'b1 ##2 sva_checker.duty_cycle_set == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset ##2 sva_checker.duty_cycle_set)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pwm_enable == 1'b1 |-> (##4 sva_checker.period_counter_reset == 1'b1 ##2 sva_checker.duty_cycle_set == 1'b1)): PROVED\n"
  },
  {
    "id": "1_8_0043",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_zso2s4us/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 !sva_checker.write_enable ##1 sva_checker.overflow_flag)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 sva_checker.write_enable == 1'b0 ##1 sva_checker.overflow_flag == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 !sva_checker.write_enable ##1 sva_checker.overflow_flag)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ph_xi910/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 sva_checker.write_enable == 1'b0 ##1 sva_checker.overflow_flag == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 !sva_checker.write_enable ##1 sva_checker.overflow_flag)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.fifo_full == 1'b1 |-> (##2 sva_checker.write_enable == 1'b0 ##1 sva_checker.overflow_flag == 1'b1)): PROVED\n"
  },
  {
    "id": "1_9_0048",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_addrgeuw/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable ##3 sva_checker.clk_primary_stopped)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable == 1'b1 ##3 sva_checker.clk_primary_stopped == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable ##3 sva_checker.clk_primary_stopped)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9kt6lha3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable == 1'b1 ##3 sva_checker.clk_primary_stopped == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable ##3 sva_checker.clk_primary_stopped)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.clock_switch_req == 1'b1 |-> (##9 sva_checker.clk_secondary_stable == 1'b1 ##3 sva_checker.clk_primary_stopped == 1'b1)): PROVED\n"
  },
  {
    "id": "2_12_0002",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tilqg29e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_t5zpz5sh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pkt_start == 1'b1 |-> (##[16:32'hs100] sva_checker.pkt_end == 1'b1)): PROVED\n"
  },
  {
    "id": "2_1_0062",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bduxaqzm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_9ywilngu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.data_valid) |-> (##[3:8] $stable(sva_checker.payload_data))): PROVED\n"
  },
  {
    "id": "2_31_0071",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2rh4h04u/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ccqyd7yt/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_start == 1'b1 |-> (##[4:32] sva_checker.audio_ready == 1'b1)): PROVED\n"
  },
  {
    "id": "2_30_0053",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_ng0j4yp6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[16:64] sva_checker.frame_end)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 |-> (##[16:64] sva_checker.frame_end == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[16:64] sva_checker.frame_end)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_or6551u3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 |-> (##[16:64] sva_checker.frame_end == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.frame_start |-> (##[16:64] sva_checker.frame_end)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.frame_start == 1 |-> (##[16:64] sva_checker.frame_end == 1)): PROVED\n"
  },
  {
    "id": "2_3_0056",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v74nj680/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.int_pend && !sva_checker.int_mask |-> (##[2:32] sva_checker.int_ack)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.int_pend == 1 && sva_checker.int_mask == 0 |-> (##[2:32] sva_checker.int_ack == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.int_pend && !sva_checker.int_mask |-> (##[2:32] sva_checker.int_ack)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_pluh5kj5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.int_pend == 1 && sva_checker.int_mask == 0 |-> (##[2:32] sva_checker.int_ack == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.int_pend && !sva_checker.int_mask |-> (##[2:32] sva_checker.int_ack)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.int_pend == 1 && sva_checker.int_mask == 0 |-> (##[2:32] sva_checker.int_ack == 1)): PROVED\n"
  },
  {
    "id": "2_43_0083",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_6s5z6a_z/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_5zrxmewz/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.gps_start == 1'b1 |-> (##[30:180] sva_checker.gps_fix == 1'b1)): PROVED\n"
  },
  {
    "id": "3_22_0120",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a7s8uusx/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change |-> (##[16:32] sva_checker.audio_data_valid)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change == 1 |-> (##[16:32] sva_checker.audio_data_valid == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change |-> (##[16:32] sva_checker.audio_data_valid)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_7j72vhks/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change == 1 |-> (##[16:32] sva_checker.audio_data_valid == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change |-> (##[16:32] sva_checker.audio_data_valid)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.audio_lrclk_change == 1 |-> (##[16:32] sva_checker.audio_data_valid == 1)): PROVED\n"
  },
  {
    "id": "3_3_0103",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Unsupported SVA functions detected: $countones. EBMC does not support these functions.",
    "log": "Parsing /tmp/sva_check__010ox_q/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\n--- begin invariant violation report ---\nInvariant check failed\nFile: bitvector_types.h:42 function: to_bitvector_type\nCondition: can_cast_type<bitvector_typet>(type)\nReason: Precondition\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x61e705]\n[0x670388]\n[0x672732]\n[0x6ab51d]\n[0x66fdad]\n[0x672732]\n[0x6870c3]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6db48d]\n[0x6dd76f]\n[0x6dac1e]\n[0x670c8e]\n[0x4b98f4]\n[0x4f8b08]\n[0x4fd72e]\n[0x4ca6f4]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "3_8_0127",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_e9o777_x/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hmn9uske/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.can_error_flag == 1'b1 |-> (##[6:7] sva_checker.can_error_counter > 127)): PROVED\n"
  },
  {
    "id": "10_7_0454",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_iypaigfp/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) ##[2:4] $past(sva_checker.intr_source, 3) == sva_checker.IRQ_TIMER)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) == 1'b1 ##[2:4] $past(sva_checker.intr_source, 3) == sva_checker.IRQ_TIMER)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) ##[2:4] $past(sva_checker.intr_source, 3) == sva_checker.IRQ_TIMER)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_y08aqtn9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) == 1'b1 ##[2:4] $past(sva_checker.intr_source, 3) == sva_checker.IRQ_TIMER)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) ##[2:4] $past(sva_checker.intr_source, 3) == sva_checker.IRQ_TIMER)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.intr_pending == 1'b1 |-> ($past(sva_checker.intr_enable, 5) =="
  },
  {
    "id": "11_13_0512",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_00xf_l5h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start && sva_checker.ref_volt_stable |-> (##8 sva_checker.data_ready && !sva_checker.conv_busy)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1 && sva_checker.ref_volt_stable == 1 |-> (##8 sva_checker.data_ready == 1 && sva_checker.conv_busy == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conv_start && sva_checker.ref_volt_stable |-> (##8 sva_checker.data_ready && !sva_checker.conv_busy)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_8r9k1fpy/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1 && sva_checker.ref_volt_stable == 1 |-> (##8 sva_checker.data_ready == 1 && sva_checker.conv_busy == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.conv_start && sva_checker.ref_volt_stable |-> (##8 sva_checker.data_ready && !sva_checker.conv_busy)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.conv_start == 1 && sva_checker.ref_volt_stable == 1 |-> (##8 sva_checker.data_ready == 1 && sva_checker.conv_busy == 0)): PROVED\n"
  },
  {
    "id": "11_21_0526",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_bffed9fb/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd && !sva_checker.wp_n |-> (##4 sva_checker.write_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1 && sva_checker.wp_n == 0 |-> (##4 sva_checker.write_error == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cmd && !sva_checker.wp_n |-> (##4 sva_checker.write_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4lm51vyq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1 && sva_checker.wp_n == 0 |-> (##4 sva_checker.write_error == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.write_cmd && !sva_checker.wp_n |-> (##4 sva_checker.write_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.write_cmd == 1 && sva_checker.wp_n == 0 |-> (##4 sva_checker.write_error == 1)): PROVED\n"
  },
  {
    "id": "11_24_0521",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vfb8sseq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high || sva_checker.vcc_low) && !sva_checker.test_mode |-> (##2 sva_checker.power_alert)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high == 1 || sva_checker.vcc_low == 1) && sva_checker.test_mode == 0 |-> (##2 sva_checker.power_alert == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high || sva_checker.vcc_low) && !sva_checker.test_mode |-> (##2 sva_checker.power_alert)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_or6qtn4y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high == 1 || sva_checker.vcc_low == 1) && sva_checker.test_mode == 0 |-> (##2 sva_checker.power_alert == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high || sva_checker.vcc_low) && !sva_checker.test_mode |-> (##2 sva_checker.power_alert)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.vcc_high == 1 || sva_checker.vcc_low == 1) && sva_checker.test_mode == 0 |-> (##2 sva_checker.power_alert == 1)): PROVED\n"
  },
  {
    "id": "11_30_0531",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_0im0m2c4/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_on && sva_checker.modulation_detected |-> (##[5:20] sva_checker.tag_present)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_on == 1 && sva_checker.modulation_detected == 1 |-> (##[5:20] sva_checker.tag_present == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.carrier_on && sva_checker.modulation_detected |-> (##[5:20] sva_checker.tag_present)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_hz2t8ohl/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_on == 1 && sva_checker.modulation_detected == 1 |-> (##[5:20] sva_checker.tag_present == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.carrier_on && sva_checker.modulation_detected |-> (##[5:20] sva_checker.tag_present)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.carrier_on == 1 && sva_checker.modulation_detected == 1 |-> (##[5:20] sva_checker.tag_present == 1)): PROVED\n"
  },
  {
    "id": "11_44_0537",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_w40t8poh/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_change && !sva_checker.manual_override |-> (##[3:6] sva_checker.pwm_duty_updated)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_change == 1 && sva_checker.manual_override == 0 |-> (##[3:6] sva_checker.pwm_duty_updated == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_change && !sva_checker.manual_override |-> (##[3:6] sva_checker.pwm_duty_updated)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_uexkatgs/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.temp_change == 1 && sva_checker.manual_override == 0 |-> (##[3:6] sva_checker.pwm_duty_updated == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.temp_change && !sva_checker.manual_override |-> (##[3:6] sva_checker.pwm_duty_updated)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.temp_change == 1 && sva_checker.manual_override == 0 |-> (##[3:6] sva_checker.pwm_duty_updated == 1)): PROVED\n"
  },
  {
    "id": "11_4_0497",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_a2t3ptec/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 && !0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 == 1 && 0 == 0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 && !0)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_rqrbrxyj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 == 1 && 0 == 0)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 && !0)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(0) && $rose(0) |-> (##1 0 == 1 && 0 == 0)): PROVED\n"
  },
  {
    "id": "12_4_0572",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_tuda5266/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_j2xcs4yi/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $fell(sva_checker.irq_mask_n) || $rose(sva_checker.wdog_timer_expire) |-> (##[2:5] $onehot(sva_checker.irq_vector))): PROVED\n"
  },
  {
    "id": "15_22_0727",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_7byaoqjj/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[5:20] sva_checker.pll_locked ##1 sva_checker.clock_output_stable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 && sva_checker.pll_reset_n == 1'b1 |-> (##[5:20] sva_checker.pll_locked == 1'b1 ##1 sva_checker.clock_output_stable == 1'b1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[5:20] sva_checker.pll_locked ##1 sva_checker.clock_output_stable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_iocd_6rk/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 && sva_checker.pll_reset_n == 1'b1 |-> (##[5:20] sva_checker.pll_locked == 1'b1 ##1 sva_checker.clock_output_stable == 1'b1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 |-> (##[5:20] sva_checker.pll_locked ##1 sva_checker.clock_output_stable)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.pll_enable == 1'b1 && sva_checker.pll_reset_n == 1'b1 |-> (##[5:20] sva_checker.pll_locked == 1'b1 ##1 sva_checker.clock_output_stable == 1'b1)): PROVED\n"
  },
  {
    "id": "15_50_0749",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva1 -> sva2",
    "log": "Forward: Parsing /tmp/sva_check_kqu2ey2e/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_checker.echo_detected ##1 sva_checker.time_diff == sva_checker.calculated_distance)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.sonar_reset == 0 && sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_checker.echo_detected == 1'b1 ##1 sva_checker.time_diff == sva_checker.calculated_distance)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_checker.echo_detected ##1 sva_checker.time_diff == sva_checker.calculated_distance)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_qrrwiju0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.sonar_reset == 0 && sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_checker.echo_detected == 1'b1 ##1 sva_checker.time_diff == sva_checker.calculated_distance)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_checker.echo_detected ##1 sva_checker.time_diff == sva_checker.calculated_distance)): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.sonar_reset == 0 && sva_checker.ping_sent == 1'b1 |-> (##[3:8] sva_che"
  },
  {
    "id": "2_39_0087",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_k0tb8mod/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_cna98trg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.ecc_start) |-> (##[8:32] $fell(sva_checker.ecc_done))): PROVED\n"
  },
  {
    "id": "3_5_0090",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_dumst6di/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_xacw30iu/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.irq_line) |-> (##[0:2] sva_checker.irq_ack ##1 sva_checker.irq_service)): PROVED\n"
  },
  {
    "id": "6_13_0248",
    "result": "not_implies",
    "equivalent": false,
    "message": "SVAs are not equivalent. Only holds: sva2 -> sva1",
    "log": "Forward: Parsing /tmp/sva_check_g0bq2kz0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] ((sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq)))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] (sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq))): REFUTED\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] ((sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq)))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_csqpbsk7/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] (sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] ((sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq)))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) (sva_checker.temp_high [*4:8]) |-> (##[2:4] (sva_checker.throttle_en [*3:6]) ##1 $fell(sva_checker.clock_freq))): PROVED\n"
  },
  {
    "id": "7_21_0305",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3xzaf66r/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_mzjikq9l/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.lcd_power_on) |-> (##3 sva_checker.lcd_init_start)): PROVED\n"
  },
  {
    "id": "7_25_0323",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_v22hiix9/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_ldh9je9y/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.jtag_tms) |-> (##[1:4] sva_checker.jtag_shift_state)): PROVED\n"
  },
  {
    "id": "8_16_0377",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_1kgcmfrv/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_1kgcmfrv/sva_checker.sv\nfile /tmp/sva_check_1kgcmfrv/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "8_31_0363",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_j4j_l5g6/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_j4j_l5g6/sva_checker.sv\nfile /tmp/sva_check_j4j_l5g6/sva_checker.sv line 5: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "10_18_0475",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_so1rk0d5/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_128cv5f3/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $past(sva_checker.packet_received, 2) |-> (##[1:4] $past(sva_checker.packet_length, 2) == sva_checker.bytes_remaining)): PROVED\n"
  },
  {
    "id": "10_42_0484",
    "result": "syntax_error",
    "equivalent": false,
    "message": "SVA Syntax Error: Syntax error in SVA: file /tmp/sva_check_r5vsmz1e/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'",
    "log": "Parsing /tmp/sva_check_r5vsmz1e/sva_checker.sv\nfile /tmp/sva_check_r5vsmz1e/sva_checker.sv line 6: syntax error, unexpected inside, expecting TOK_NON_TYPE_IDENTIFIER before 'inside'\n"
  },
  {
    "id": "10_8_0441",
    "result": "error",
    "equivalent": false,
    "message": "EBMC Error: Internal tool crash. The SVA may contain unsupported constructs.",
    "log": "Parsing /tmp/sva_check_j_c1s353/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\n--- begin invariant violation report ---\nInvariant check failed\nFile: ../../lib/cbmc/src/util/namespace.h:49 function: lookup\nCondition: !not_found\nReason: we are assuming that a name exists in the namespace when this function is called - identifier $past was not found\nBacktrace:\n[0x572f82]\n[0x573cfd]\n[0x4a6d22]\n[0x51b074]\n[0x580d6d]\n[0x580dcb]\n[0x580dcb]\n[0x8d0c40]\n[0x8e33fd]\n[0x8e43b8]\n[0x8e0618]\n[0x8e0ad9]\n[0x8e4a8a]\n[0x8e0618]\n[0x8e8fd0]\n[0x8e81cb]\n[0x8e8b07]\n[0x8e8166]\n[0x8e979f]\n[0x8e81cb]\n[0x8e928b]\n[0x8e81cb]\n[0x8c9d1f]\n[0x8cd137]\n[0x8c20f7]\n[0x985d92]\n[0x8c271b]\n[0x88a070]\n[0x65b204]\n[0x65be5f]\n[0x5158b1]\n[0x516d60]\n[0x4c9e94]\n[0x49883f]\n[0x496799]\n[0xa50c0a]\n[0xa524a7]\n[0x4a1c95]\n\n\n--- end invariant violation report ---\n"
  },
  {
    "id": "11_19_0524",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_rr11znr6/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready && sva_checker.plaintext_valid |-> (##3 sva_checker.ciphertext_out)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready == 1 && sva_checker.plaintext_valid == 1 |-> (##3 sva_checker.ciphertext_out == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready && sva_checker.plaintext_valid |-> (##3 sva_checker.ciphertext_out)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_0lathf2b/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready == 1 && sva_checker.plaintext_valid == 1 |-> (##3 sva_checker.ciphertext_out == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready && sva_checker.plaintext_valid |-> (##3 sva_checker.ciphertext_out)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.encrypt_ready == 1 && sva_checker.plaintext_valid == 1 |-> (##3 sva_checker.ciphertext_out == 1)): PROVED\n"
  },
  {
    "id": "11_1_0487",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vbjg17qn/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_4somxne2/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.req_main) && $fell(sva_checker.busy_arbiter) |-> (##[1:3] sva_checker.grant_controller)): PROVED\n"
  },
  {
    "id": "11_29_0527",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_2ubir7t0/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty && sva_checker.pixel_fetch |-> (##1 sva_checker.underflow_error)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty == 1 && sva_checker.pixel_fetch == 1 |-> (##1 sva_checker.underflow_error == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty && sva_checker.pixel_fetch |-> (##1 sva_checker.underflow_error)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_b7761t6t/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty == 1 && sva_checker.pixel_fetch == 1 |-> (##1 sva_checker.underflow_error == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty && sva_checker.pixel_fetch |-> (##1 sva_checker.underflow_error)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.lcd_fifo_empty == 1 && sva_checker.pixel_fetch == 1 |-> (##1 sva_checker.underflow_error == 1)): PROVED\n"
  },
  {
    "id": "11_32_0536",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_3k1p0zrq/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low && sva_checker.charger_connected |-> (##3 sva_checker.charge_enable)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low == 1 && sva_checker.charger_connected == 1 |-> (##3 sva_checker.charge_enable == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.battery_low && sva_checker.charger_connected |-> (##3 sva_checker.charge_enable)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_fbfiif75/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low == 1 && sva_checker.charger_connected == 1 |-> (##3 sva_checker.charge_enable == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.battery_low && sva_checker.charger_connected |-> (##3 sva_checker.charge_enable)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.battery_low == 1 && sva_checker.charger_connected == 1 |-> (##3 sva_checker.charge_enable == 1)): PROVED\n"
  },
  {
    "id": "11_4_0493",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_vsj44ipg/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag == 1 && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out == 1)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out)): PROVED\n\n\nBackward: Parsing /tmp/sva_check_szykrsrv/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag == 1 && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out == 1)): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out)): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.cache_hit_flag == 1 && sva_checker.current_tag == sva_checker.stored_tag |-> (##3 sva_checker.data_valid_out == 1)): PROVED\n"
  },
  {
    "id": "12_30_0585",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_b3aw7u4h/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern |-> (##2 $rose(sva_checker.match_flag))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern == 1 |-> (##2 $rose(sva_checker.match_flag))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern |-> (##2 $rose(sva_checker.match_flag))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_585u8jvm/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern == 1 |-> (##2 $rose(sva_checker.match_flag))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern |-> (##2 $rose(sva_checker.match_flag))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) sva_checker.data_in == 32'hDEADBEEF || sva_checker.force_pattern == 1 |-> (##2 $rose(sva_checker.match_flag))): PROVED\n"
  },
  {
    "id": "12_38_0577",
    "result": "equivalent",
    "equivalent": true,
    "message": "SVAs are equivalent (bidirectional implication holds)",
    "log": "Forward: Parsing /tmp/sva_check_waohxma1/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): PROVED\n\n\nBackward: Parsing /tmp/sva_check_au3qyp1c/sva_checker.sv\nConverting\nType-checking Verilog::sva_checker\nGenerating Decision Problem\nUsing MiniSAT 2.2.1 with simplifier\nProperties\nSolving with propositional reduction\nSAT checker: instance is SATISFIABLE\nSAT: path found\nSAT checker inconsistent: instance is UNSATISFIABLE\nUNSAT: No path found within bound\n\n** Results:\n[sva_checker.assume.1] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): ASSUMED\n[sva_checker.assert.2] always (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): PROVED up to bound 20\n[sva_checker.cover_antecedent] cover (disable iff (!sva_checker.rst_n) $rose(sva_checker.parity_ok) || sva_checker.force_parity_ok |-> (##[0:2] $fell(sva_checker.parity_err))): PROVED\n"
  }
]